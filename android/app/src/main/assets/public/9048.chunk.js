"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[9048],{1238:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uw\": () => (/* binding */ WebPlugin),\n/* harmony export */   \"fo\": () => (/* binding */ registerPlugin)\n/* harmony export */ });\n/* unused harmony exports Capacitor, CapacitorException, CapacitorPlatforms, ExceptionCode, Plugins, WebView, addPlatform, registerWebPlugin, setPlatform */\n/*! Capacitor: https://capacitorjs.com/ - MIT License */\nconst createCapacitorPlatforms = (win) => {\n    const defaultPlatformMap = new Map();\n    defaultPlatformMap.set('web', { name: 'web' });\n    const capPlatforms = win.CapacitorPlatforms || {\n        currentPlatform: { name: 'web' },\n        platforms: defaultPlatformMap,\n    };\n    const addPlatform = (name, platform) => {\n        capPlatforms.platforms.set(name, platform);\n    };\n    const setPlatform = (name) => {\n        if (capPlatforms.platforms.has(name)) {\n            capPlatforms.currentPlatform = capPlatforms.platforms.get(name);\n        }\n    };\n    capPlatforms.addPlatform = addPlatform;\n    capPlatforms.setPlatform = setPlatform;\n    return capPlatforms;\n};\nconst initPlatforms = (win) => (win.CapacitorPlatforms = createCapacitorPlatforms(win));\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst CapacitorPlatforms = /*#__PURE__*/ initPlatforms((typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof __webpack_require__.g !== 'undefined'\n                ? __webpack_require__.g\n                : {}));\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst addPlatform = CapacitorPlatforms.addPlatform;\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst setPlatform = CapacitorPlatforms.setPlatform;\n\nconst legacyRegisterWebPlugin = (cap, webPlugin) => {\n    var _a;\n    const config = webPlugin.config;\n    const Plugins = cap.Plugins;\n    if (!config || !config.name) {\n        // TODO: add link to upgrade guide\n        throw new Error(`Capacitor WebPlugin is using the deprecated \"registerWebPlugin()\" function, but without the config. Please use \"registerPlugin()\" instead to register this web plugin.\"`);\n    }\n    // TODO: add link to upgrade guide\n    console.warn(`Capacitor plugin \"${config.name}\" is using the deprecated \"registerWebPlugin()\" function`);\n    if (!Plugins[config.name] || ((_a = config === null || config === void 0 ? void 0 : config.platforms) === null || _a === void 0 ? void 0 : _a.includes(cap.getPlatform()))) {\n        // Add the web plugin into the plugins registry if there already isn't\n        // an existing one. If it doesn't already exist, that means\n        // there's no existing native implementation for it.\n        // - OR -\n        // If we already have a plugin registered (meaning it was defined in the native layer),\n        // then we should only overwrite it if the corresponding web plugin activates on\n        // a certain platform. For example: Geolocation uses the WebPlugin on Android but not iOS\n        Plugins[config.name] = webPlugin;\n    }\n};\n\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code) {\n        super(message);\n        this.message = message;\n        this.code = code;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    var _a, _b, _c, _d, _e;\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    /**\n     * @deprecated Use `capCustomPlatform` instead, default functions like registerPlugin will function with the new object.\n     */\n    const capPlatforms = win.CapacitorPlatforms;\n    const defaultGetPlatform = () => {\n        return capCustomPlatform !== null\n            ? capCustomPlatform.name\n            : getPlatformId(win);\n    };\n    const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;\n    const defaultIsNativePlatform = () => getPlatform() !== 'web';\n    const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;\n    const defaultIsPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) ||\n        defaultIsPluginAvailable;\n    const defaultGetPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find(h => h.name === pluginName); };\n    const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;\n    const handleError = (err) => win.console.error(err);\n    const pluginMethodNoop = (_target, prop, pluginName) => {\n        return Promise.reject(`${pluginName} does not have an implementation of \"${prop}\".`);\n    };\n    const registeredPlugins = new Map();\n    const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null &&\n                !jsImplementation &&\n                'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find(m => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then(impl => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair ✨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise(resolve => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([\n                ...Object.keys(jsImplementations),\n                ...(pluginHeader ? [platform] : []),\n            ]),\n        });\n        return proxy;\n    };\n    const registerPlugin = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = filePath => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.pluginMethodNoop = pluginMethodNoop;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    // Deprecated props\n    cap.platform = cap.getPlatform();\n    cap.isNative = cap.isNativePlatform();\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof __webpack_require__.g !== 'undefined'\n                ? __webpack_require__.g\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n/**\n * @deprecated Provided for backwards compatibility for Capacitor v2 plugins.\n * Capacitor v3 plugins should import the plugin directly. This \"Plugins\"\n * export is deprecated in v3, and will be removed in v4.\n */\nconst Plugins = Capacitor.Plugins;\n/**\n * Provided for backwards compatibility. Use the registerPlugin() API\n * instead, and provide the web plugin as the \"web\" implmenetation.\n * For example\n *\n * export const Example = registerPlugin('Example', {\n *   web: () => import('./web').then(m => new m.Example())\n * })\n *\n * @deprecated Deprecated in v3, will be removed from v4.\n */\nconst registerWebPlugin = (plugin) => legacyRegisterWebPlugin(Capacitor, plugin);\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor(config) {\n        this.listeners = {};\n        this.windowListeners = {};\n        if (config) {\n            // TODO: add link to upgrade guide\n            console.warn(`Capacitor WebPlugin \"${config.name}\" config object was deprecated in v3 and will be removed in v4.`);\n            this.config = config;\n        }\n    }\n    addListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        Object.defineProperty(p, 'remove', {\n            value: async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            },\n        });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data) {\n        const listeners = this.listeners[eventName];\n        if (listeners) {\n            listeners.forEach(listener => listener(data));\n        }\n    }\n    hasListeners(eventName) {\n        return !!this.listeners[eventName].length;\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: event => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n}\n\nconst WebView = /*#__PURE__*/ (/* unused pure expression or super */ null && (registerPlugin('WebView')));\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EscUJBQXFCLHFCQUFNO0FBQzNCLGtCQUFrQixxQkFBTTtBQUN4QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHlFQUF5Qjs7QUFFK0c7QUFDdEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3IvY29yZS9kaXN0L2luZGV4LmpzPzE1NDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIENhcGFjaXRvcjogaHR0cHM6Ly9jYXBhY2l0b3Jqcy5jb20vIC0gTUlUIExpY2Vuc2UgKi9cbmNvbnN0IGNyZWF0ZUNhcGFjaXRvclBsYXRmb3JtcyA9ICh3aW4pID0+IHtcbiAgICBjb25zdCBkZWZhdWx0UGxhdGZvcm1NYXAgPSBuZXcgTWFwKCk7XG4gICAgZGVmYXVsdFBsYXRmb3JtTWFwLnNldCgnd2ViJywgeyBuYW1lOiAnd2ViJyB9KTtcbiAgICBjb25zdCBjYXBQbGF0Zm9ybXMgPSB3aW4uQ2FwYWNpdG9yUGxhdGZvcm1zIHx8IHtcbiAgICAgICAgY3VycmVudFBsYXRmb3JtOiB7IG5hbWU6ICd3ZWInIH0sXG4gICAgICAgIHBsYXRmb3JtczogZGVmYXVsdFBsYXRmb3JtTWFwLFxuICAgIH07XG4gICAgY29uc3QgYWRkUGxhdGZvcm0gPSAobmFtZSwgcGxhdGZvcm0pID0+IHtcbiAgICAgICAgY2FwUGxhdGZvcm1zLnBsYXRmb3Jtcy5zZXQobmFtZSwgcGxhdGZvcm0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0UGxhdGZvcm0gPSAobmFtZSkgPT4ge1xuICAgICAgICBpZiAoY2FwUGxhdGZvcm1zLnBsYXRmb3Jtcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGNhcFBsYXRmb3Jtcy5jdXJyZW50UGxhdGZvcm0gPSBjYXBQbGF0Zm9ybXMucGxhdGZvcm1zLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY2FwUGxhdGZvcm1zLmFkZFBsYXRmb3JtID0gYWRkUGxhdGZvcm07XG4gICAgY2FwUGxhdGZvcm1zLnNldFBsYXRmb3JtID0gc2V0UGxhdGZvcm07XG4gICAgcmV0dXJuIGNhcFBsYXRmb3Jtcztcbn07XG5jb25zdCBpbml0UGxhdGZvcm1zID0gKHdpbikgPT4gKHdpbi5DYXBhY2l0b3JQbGF0Zm9ybXMgPSBjcmVhdGVDYXBhY2l0b3JQbGF0Zm9ybXMod2luKSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFNldCBgQ2FwYWNpdG9yQ3VzdG9tUGxhdGZvcm1gIG9uIHRoZSB3aW5kb3cgb2JqZWN0IHByaW9yIHRvIHJ1bnRpbWUgZXhlY3V0aW5nIGluIHRoZSB3ZWIgYXBwIGluc3RlYWRcbiAqL1xuY29uc3QgQ2FwYWNpdG9yUGxhdGZvcm1zID0gLyojX19QVVJFX18qLyBpbml0UGxhdGZvcm1zKCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFRoaXNcbiAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgICAgIDoge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2V0IGBDYXBhY2l0b3JDdXN0b21QbGF0Zm9ybWAgb24gdGhlIHdpbmRvdyBvYmplY3QgcHJpb3IgdG8gcnVudGltZSBleGVjdXRpbmcgaW4gdGhlIHdlYiBhcHAgaW5zdGVhZFxuICovXG5jb25zdCBhZGRQbGF0Zm9ybSA9IENhcGFjaXRvclBsYXRmb3Jtcy5hZGRQbGF0Zm9ybTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2V0IGBDYXBhY2l0b3JDdXN0b21QbGF0Zm9ybWAgb24gdGhlIHdpbmRvdyBvYmplY3QgcHJpb3IgdG8gcnVudGltZSBleGVjdXRpbmcgaW4gdGhlIHdlYiBhcHAgaW5zdGVhZFxuICovXG5jb25zdCBzZXRQbGF0Zm9ybSA9IENhcGFjaXRvclBsYXRmb3Jtcy5zZXRQbGF0Zm9ybTtcblxuY29uc3QgbGVnYWN5UmVnaXN0ZXJXZWJQbHVnaW4gPSAoY2FwLCB3ZWJQbHVnaW4pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY29uZmlnID0gd2ViUGx1Z2luLmNvbmZpZztcbiAgICBjb25zdCBQbHVnaW5zID0gY2FwLlBsdWdpbnM7XG4gICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5uYW1lKSB7XG4gICAgICAgIC8vIFRPRE86IGFkZCBsaW5rIHRvIHVwZ3JhZGUgZ3VpZGVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYXBhY2l0b3IgV2ViUGx1Z2luIGlzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFwicmVnaXN0ZXJXZWJQbHVnaW4oKVwiIGZ1bmN0aW9uLCBidXQgd2l0aG91dCB0aGUgY29uZmlnLiBQbGVhc2UgdXNlIFwicmVnaXN0ZXJQbHVnaW4oKVwiIGluc3RlYWQgdG8gcmVnaXN0ZXIgdGhpcyB3ZWIgcGx1Z2luLlwiYCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGFkZCBsaW5rIHRvIHVwZ3JhZGUgZ3VpZGVcbiAgICBjb25zb2xlLndhcm4oYENhcGFjaXRvciBwbHVnaW4gXCIke2NvbmZpZy5uYW1lfVwiIGlzIHVzaW5nIHRoZSBkZXByZWNhdGVkIFwicmVnaXN0ZXJXZWJQbHVnaW4oKVwiIGZ1bmN0aW9uYCk7XG4gICAgaWYgKCFQbHVnaW5zW2NvbmZpZy5uYW1lXSB8fCAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnBsYXRmb3JtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKGNhcC5nZXRQbGF0Zm9ybSgpKSkpIHtcbiAgICAgICAgLy8gQWRkIHRoZSB3ZWIgcGx1Z2luIGludG8gdGhlIHBsdWdpbnMgcmVnaXN0cnkgaWYgdGhlcmUgYWxyZWFkeSBpc24ndFxuICAgICAgICAvLyBhbiBleGlzdGluZyBvbmUuIElmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCwgdGhhdCBtZWFuc1xuICAgICAgICAvLyB0aGVyZSdzIG5vIGV4aXN0aW5nIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgaXQuXG4gICAgICAgIC8vIC0gT1IgLVxuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBwbHVnaW4gcmVnaXN0ZXJlZCAobWVhbmluZyBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgbmF0aXZlIGxheWVyKSxcbiAgICAgICAgLy8gdGhlbiB3ZSBzaG91bGQgb25seSBvdmVyd3JpdGUgaXQgaWYgdGhlIGNvcnJlc3BvbmRpbmcgd2ViIHBsdWdpbiBhY3RpdmF0ZXMgb25cbiAgICAgICAgLy8gYSBjZXJ0YWluIHBsYXRmb3JtLiBGb3IgZXhhbXBsZTogR2VvbG9jYXRpb24gdXNlcyB0aGUgV2ViUGx1Z2luIG9uIEFuZHJvaWQgYnV0IG5vdCBpT1NcbiAgICAgICAgUGx1Z2luc1tjb25maWcubmFtZV0gPSB3ZWJQbHVnaW47XG4gICAgfVxufTtcblxudmFyIEV4Y2VwdGlvbkNvZGU7XG4oZnVuY3Rpb24gKEV4Y2VwdGlvbkNvZGUpIHtcbiAgICAvKipcbiAgICAgKiBBUEkgaXMgbm90IGltcGxlbWVudGVkLlxuICAgICAqXG4gICAgICogVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSBBUEkgY2FuJ3QgYmUgdXNlZCBiZWNhdXNlIGl0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3JcbiAgICAgKiB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAgICAgKi9cbiAgICBFeGNlcHRpb25Db2RlW1wiVW5pbXBsZW1lbnRlZFwiXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIC8qKlxuICAgICAqIEFQSSBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBtZWFucyB0aGUgQVBJIGNhbid0IGJlIHVzZWQgcmlnaHQgbm93IGJlY2F1c2U6XG4gICAgICogICAtIGl0IGlzIGN1cnJlbnRseSBtaXNzaW5nIGEgcHJlcmVxdWlzaXRlLCBzdWNoIGFzIG5ldHdvcmsgY29ubmVjdGl2aXR5XG4gICAgICogICAtIGl0IHJlcXVpcmVzIGEgcGFydGljdWxhciBwbGF0Zm9ybSBvciBicm93c2VyIHZlcnNpb25cbiAgICAgKi9cbiAgICBFeGNlcHRpb25Db2RlW1wiVW5hdmFpbGFibGVcIl0gPSBcIlVOQVZBSUxBQkxFXCI7XG59KShFeGNlcHRpb25Db2RlIHx8IChFeGNlcHRpb25Db2RlID0ge30pKTtcbmNsYXNzIENhcGFjaXRvckV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmNvbnN0IGdldFBsYXRmb3JtSWQgPSAod2luKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAod2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLmFuZHJvaWRCcmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICB9XG4gICAgZWxzZSBpZiAoKF9iID0gKF9hID0gd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLndlYmtpdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2VIYW5kbGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyaWRnZSkge1xuICAgICAgICByZXR1cm4gJ2lvcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3dlYic7XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlQ2FwYWNpdG9yID0gKHdpbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgY2FwQ3VzdG9tUGxhdGZvcm0gPSB3aW4uQ2FwYWNpdG9yQ3VzdG9tUGxhdGZvcm0gfHwgbnVsbDtcbiAgICBjb25zdCBjYXAgPSB3aW4uQ2FwYWNpdG9yIHx8IHt9O1xuICAgIGNvbnN0IFBsdWdpbnMgPSAoY2FwLlBsdWdpbnMgPSBjYXAuUGx1Z2lucyB8fCB7fSk7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBjYXBDdXN0b21QbGF0Zm9ybWAgaW5zdGVhZCwgZGVmYXVsdCBmdW5jdGlvbnMgbGlrZSByZWdpc3RlclBsdWdpbiB3aWxsIGZ1bmN0aW9uIHdpdGggdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3QgY2FwUGxhdGZvcm1zID0gd2luLkNhcGFjaXRvclBsYXRmb3JtcztcbiAgICBjb25zdCBkZWZhdWx0R2V0UGxhdGZvcm0gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBjYXBDdXN0b21QbGF0Zm9ybS5uYW1lXG4gICAgICAgICAgICA6IGdldFBsYXRmb3JtSWQod2luKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFBsYXRmb3JtID0gKChfYSA9IGNhcFBsYXRmb3JtcyA9PT0gbnVsbCB8fCBjYXBQbGF0Zm9ybXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcFBsYXRmb3Jtcy5jdXJyZW50UGxhdGZvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQbGF0Zm9ybSkgfHwgZGVmYXVsdEdldFBsYXRmb3JtO1xuICAgIGNvbnN0IGRlZmF1bHRJc05hdGl2ZVBsYXRmb3JtID0gKCkgPT4gZ2V0UGxhdGZvcm0oKSAhPT0gJ3dlYic7XG4gICAgY29uc3QgaXNOYXRpdmVQbGF0Zm9ybSA9ICgoX2IgPSBjYXBQbGF0Zm9ybXMgPT09IG51bGwgfHwgY2FwUGxhdGZvcm1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBQbGF0Zm9ybXMuY3VycmVudFBsYXRmb3JtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNOYXRpdmVQbGF0Zm9ybSkgfHwgZGVmYXVsdElzTmF0aXZlUGxhdGZvcm07XG4gICAgY29uc3QgZGVmYXVsdElzUGx1Z2luQXZhaWxhYmxlID0gKHBsdWdpbk5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gcmVnaXN0ZXJlZFBsdWdpbnMuZ2V0KHBsdWdpbk5hbWUpO1xuICAgICAgICBpZiAocGx1Z2luID09PSBudWxsIHx8IHBsdWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGx1Z2luLnBsYXRmb3Jtcy5oYXMoZ2V0UGxhdGZvcm0oKSkpIHtcbiAgICAgICAgICAgIC8vIEpTIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGx1Z2luSGVhZGVyKHBsdWdpbk5hbWUpKSB7XG4gICAgICAgICAgICAvLyBOYXRpdmUgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgaXNQbHVnaW5BdmFpbGFibGUgPSAoKF9jID0gY2FwUGxhdGZvcm1zID09PSBudWxsIHx8IGNhcFBsYXRmb3JtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwUGxhdGZvcm1zLmN1cnJlbnRQbGF0Zm9ybSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlzUGx1Z2luQXZhaWxhYmxlKSB8fFxuICAgICAgICBkZWZhdWx0SXNQbHVnaW5BdmFpbGFibGU7XG4gICAgY29uc3QgZGVmYXVsdEdldFBsdWdpbkhlYWRlciA9IChwbHVnaW5OYW1lKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNhcC5QbHVnaW5IZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChoID0+IGgubmFtZSA9PT0gcGx1Z2luTmFtZSk7IH07XG4gICAgY29uc3QgZ2V0UGx1Z2luSGVhZGVyID0gKChfZCA9IGNhcFBsYXRmb3JtcyA9PT0gbnVsbCB8fCBjYXBQbGF0Zm9ybXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcFBsYXRmb3Jtcy5jdXJyZW50UGxhdGZvcm0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZXRQbHVnaW5IZWFkZXIpIHx8IGRlZmF1bHRHZXRQbHVnaW5IZWFkZXI7XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyKSA9PiB3aW4uY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnN0IHBsdWdpbk1ldGhvZE5vb3AgPSAoX3RhcmdldCwgcHJvcCwgcGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYCR7cGx1Z2luTmFtZX0gZG9lcyBub3QgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBcIiR7cHJvcH1cIi5gKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlZmF1bHRSZWdpc3RlclBsdWdpbiA9IChwbHVnaW5OYW1lLCBqc0ltcGxlbWVudGF0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRQbHVnaW4gPSByZWdpc3RlcmVkUGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkUGx1Z2luKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhcGFjaXRvciBwbHVnaW4gXCIke3BsdWdpbk5hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkLiBDYW5ub3QgcmVnaXN0ZXIgcGx1Z2lucyB0d2ljZS5gKTtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkUGx1Z2luLnByb3h5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gZ2V0UGxhdGZvcm0oKTtcbiAgICAgICAgY29uc3QgcGx1Z2luSGVhZGVyID0gZ2V0UGx1Z2luSGVhZGVyKHBsdWdpbk5hbWUpO1xuICAgICAgICBsZXQganNJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgY29uc3QgbG9hZFBsdWdpbkltcGxlbWVudGF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFqc0ltcGxlbWVudGF0aW9uICYmIHBsYXRmb3JtIGluIGpzSW1wbGVtZW50YXRpb25zKSB7XG4gICAgICAgICAgICAgICAganNJbXBsZW1lbnRhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBqc0ltcGxlbWVudGF0aW9uc1twbGF0Zm9ybV0gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGpzSW1wbGVtZW50YXRpb24gPSBhd2FpdCBqc0ltcGxlbWVudGF0aW9uc1twbGF0Zm9ybV0oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGpzSW1wbGVtZW50YXRpb24gPSBqc0ltcGxlbWVudGF0aW9uc1twbGF0Zm9ybV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2FwQ3VzdG9tUGxhdGZvcm0gIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhanNJbXBsZW1lbnRhdGlvbiAmJlxuICAgICAgICAgICAgICAgICd3ZWInIGluIGpzSW1wbGVtZW50YXRpb25zKSB7XG4gICAgICAgICAgICAgICAganNJbXBsZW1lbnRhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKGpzSW1wbGVtZW50YXRpb24gPSBhd2FpdCBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGpzSW1wbGVtZW50YXRpb24gPSBqc0ltcGxlbWVudGF0aW9uc1snd2ViJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzSW1wbGVtZW50YXRpb247XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBsdWdpbk1ldGhvZCA9IChpbXBsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHBsdWdpbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhlYWRlciA9IHBsdWdpbkhlYWRlciA9PT0gbnVsbCB8fCBwbHVnaW5IZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsdWdpbkhlYWRlci5tZXRob2RzLmZpbmQobSA9PiBwcm9wID09PSBtLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZEhlYWRlci5ydHlwZSA9PT0gJ3Byb21pc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMpID0+IGNhcC5uYXRpdmVQcm9taXNlKHBsdWdpbk5hbWUsIHByb3AudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiBjYXAubmF0aXZlQ2FsbGJhY2socGx1Z2luTmFtZSwgcHJvcC50b1N0cmluZygpLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gaW1wbFtwcm9wXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW1wbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSBpbXBsW3Byb3BdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmluZChpbXBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYXBhY2l0b3JFeGNlcHRpb24oYFwiJHtwbHVnaW5OYW1lfVwiIHBsdWdpbiBpcyBub3QgaW1wbGVtZW50ZWQgb24gJHtwbGF0Zm9ybX1gLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyID0gKHByb3ApID0+IHtcbiAgICAgICAgICAgIGxldCByZW1vdmU7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gbG9hZFBsdWdpbkltcGxlbWVudGF0aW9uKCkudGhlbihpbXBsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm4gPSBjcmVhdGVQbHVnaW5NZXRob2QoaW1wbCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gcCA9PT0gbnVsbCB8fCBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwLnJlbW92ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhcGFjaXRvckV4Y2VwdGlvbihgXCIke3BsdWdpbk5hbWV9LiR7cHJvcH0oKVwiIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiAke3BsYXRmb3JtfWAsIEV4Y2VwdGlvbkNvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2FkZExpc3RlbmVyJykge1xuICAgICAgICAgICAgICAgICAgICBwLnJlbW92ZSA9IGFzeW5jICgpID0+IHJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTb21lIGZsYWlyIOKcqFxuICAgICAgICAgICAgd3JhcHBlci50b1N0cmluZyA9ICgpID0+IGAke3Byb3AudG9TdHJpbmcoKX0oKSB7IFtjYXBhY2l0b3IgY29kZV0gfWA7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod3JhcHBlciwgJ25hbWUnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3AsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRMaXN0ZW5lciA9IGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIoJ2FkZExpc3RlbmVyJyk7XG4gICAgICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlUGx1Z2luTWV0aG9kV3JhcHBlcigncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgY29uc3QgYWRkTGlzdGVuZXJOYXRpdmUgPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IGFkZExpc3RlbmVyKHsgZXZlbnROYW1lIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gYXdhaXQgY2FsbDtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY2FsbC50aGVuKCgpID0+IHJlc29sdmUoeyByZW1vdmUgfSkpKTtcbiAgICAgICAgICAgIHAucmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNpbmcgYWRkTGlzdGVuZXIoKSB3aXRob3V0ICdhd2FpdCcgaXMgZGVwcmVjYXRlZC5gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAwMzBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCR0eXBlb2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9KU09OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiAoe30pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGRMaXN0ZW5lcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSGVhZGVyID8gYWRkTGlzdGVuZXJOYXRpdmUgOiBhZGRMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlTGlzdGVuZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIFBsdWdpbnNbcGx1Z2luTmFtZV0gPSBwcm94eTtcbiAgICAgICAgcmVnaXN0ZXJlZFBsdWdpbnMuc2V0KHBsdWdpbk5hbWUsIHtcbiAgICAgICAgICAgIG5hbWU6IHBsdWdpbk5hbWUsXG4gICAgICAgICAgICBwcm94eSxcbiAgICAgICAgICAgIHBsYXRmb3JtczogbmV3IFNldChbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoanNJbXBsZW1lbnRhdGlvbnMpLFxuICAgICAgICAgICAgICAgIC4uLihwbHVnaW5IZWFkZXIgPyBbcGxhdGZvcm1dIDogW10pLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgfTtcbiAgICBjb25zdCByZWdpc3RlclBsdWdpbiA9ICgoX2UgPSBjYXBQbGF0Zm9ybXMgPT09IG51bGwgfHwgY2FwUGxhdGZvcm1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBQbGF0Zm9ybXMuY3VycmVudFBsYXRmb3JtKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVnaXN0ZXJQbHVnaW4pIHx8IGRlZmF1bHRSZWdpc3RlclBsdWdpbjtcbiAgICAvLyBBZGQgaW4gY29udmVydEZpbGVTcmMgZm9yIHdlYiwgaXQgd2lsbCBhbHJlYWR5IGJlIGF2YWlsYWJsZSBpbiBuYXRpdmUgY29udGV4dFxuICAgIGlmICghY2FwLmNvbnZlcnRGaWxlU3JjKSB7XG4gICAgICAgIGNhcC5jb252ZXJ0RmlsZVNyYyA9IGZpbGVQYXRoID0+IGZpbGVQYXRoO1xuICAgIH1cbiAgICBjYXAuZ2V0UGxhdGZvcm0gPSBnZXRQbGF0Zm9ybTtcbiAgICBjYXAuaGFuZGxlRXJyb3IgPSBoYW5kbGVFcnJvcjtcbiAgICBjYXAuaXNOYXRpdmVQbGF0Zm9ybSA9IGlzTmF0aXZlUGxhdGZvcm07XG4gICAgY2FwLmlzUGx1Z2luQXZhaWxhYmxlID0gaXNQbHVnaW5BdmFpbGFibGU7XG4gICAgY2FwLnBsdWdpbk1ldGhvZE5vb3AgPSBwbHVnaW5NZXRob2ROb29wO1xuICAgIGNhcC5yZWdpc3RlclBsdWdpbiA9IHJlZ2lzdGVyUGx1Z2luO1xuICAgIGNhcC5FeGNlcHRpb24gPSBDYXBhY2l0b3JFeGNlcHRpb247XG4gICAgY2FwLkRFQlVHID0gISFjYXAuREVCVUc7XG4gICAgY2FwLmlzTG9nZ2luZ0VuYWJsZWQgPSAhIWNhcC5pc0xvZ2dpbmdFbmFibGVkO1xuICAgIC8vIERlcHJlY2F0ZWQgcHJvcHNcbiAgICBjYXAucGxhdGZvcm0gPSBjYXAuZ2V0UGxhdGZvcm0oKTtcbiAgICBjYXAuaXNOYXRpdmUgPSBjYXAuaXNOYXRpdmVQbGF0Zm9ybSgpO1xuICAgIHJldHVybiBjYXA7XG59O1xuY29uc3QgaW5pdENhcGFjaXRvckdsb2JhbCA9ICh3aW4pID0+ICh3aW4uQ2FwYWNpdG9yID0gY3JlYXRlQ2FwYWNpdG9yKHdpbikpO1xuXG5jb25zdCBDYXBhY2l0b3IgPSAvKiNfX1BVUkVfXyovIGluaXRDYXBhY2l0b3JHbG9iYWwodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxUaGlzXG4gICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICA6IHt9KTtcbmNvbnN0IHJlZ2lzdGVyUGx1Z2luID0gQ2FwYWNpdG9yLnJlZ2lzdGVyUGx1Z2luO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBQcm92aWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIENhcGFjaXRvciB2MiBwbHVnaW5zLlxuICogQ2FwYWNpdG9yIHYzIHBsdWdpbnMgc2hvdWxkIGltcG9ydCB0aGUgcGx1Z2luIGRpcmVjdGx5LiBUaGlzIFwiUGx1Z2luc1wiXG4gKiBleHBvcnQgaXMgZGVwcmVjYXRlZCBpbiB2MywgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NC5cbiAqL1xuY29uc3QgUGx1Z2lucyA9IENhcGFjaXRvci5QbHVnaW5zO1xuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFVzZSB0aGUgcmVnaXN0ZXJQbHVnaW4oKSBBUElcbiAqIGluc3RlYWQsIGFuZCBwcm92aWRlIHRoZSB3ZWIgcGx1Z2luIGFzIHRoZSBcIndlYlwiIGltcGxtZW5ldGF0aW9uLlxuICogRm9yIGV4YW1wbGVcbiAqXG4gKiBleHBvcnQgY29uc3QgRXhhbXBsZSA9IHJlZ2lzdGVyUGx1Z2luKCdFeGFtcGxlJywge1xuICogICB3ZWI6ICgpID0+IGltcG9ydCgnLi93ZWInKS50aGVuKG0gPT4gbmV3IG0uRXhhbXBsZSgpKVxuICogfSlcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIHYzLCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB2NC5cbiAqL1xuY29uc3QgcmVnaXN0ZXJXZWJQbHVnaW4gPSAocGx1Z2luKSA9PiBsZWdhY3lSZWdpc3RlcldlYlBsdWdpbihDYXBhY2l0b3IsIHBsdWdpbik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB3ZWIgcGx1Z2lucyBzaG91bGQgZXh0ZW5kLlxuICovXG5jbGFzcyBXZWJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgbGluayB0byB1cGdyYWRlIGd1aWRlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhcGFjaXRvciBXZWJQbHVnaW4gXCIke2NvbmZpZy5uYW1lfVwiIGNvbmZpZyBvYmplY3Qgd2FzIGRlcHJlY2F0ZWQgaW4gdjMgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NC5gKTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgYWRkZWQgYSB3aW5kb3cgbGlzdGVuZXIgZm9yIHRoaXMgZXZlbnQgYW5kIGl0IHJlcXVpcmVzIG9uZSxcbiAgICAgICAgLy8gZ28gYWhlYWQgYW5kIGFkZCBpdFxuICAgICAgICBjb25zdCB3aW5kb3dMaXN0ZW5lciA9IHRoaXMud2luZG93TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICh3aW5kb3dMaXN0ZW5lciAmJiAhd2luZG93TGlzdGVuZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcih3aW5kb3dMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoeyByZW1vdmUgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCAncmVtb3ZlJywge1xuICAgICAgICAgICAgdmFsdWU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVzaW5nIGFkZExpc3RlbmVyKCkgd2l0aG91dCAnYXdhaXQnIGlzIGRlcHJlY2F0ZWQuYCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBpbiB0aGlzLndpbmRvd0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcih0aGlzLndpbmRvd0xpc3RlbmVyc1tsaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIG5vdGlmeUxpc3RlbmVycyhldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZGF0YSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0xpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5sZW5ndGg7XG4gICAgfVxuICAgIHJlZ2lzdGVyV2luZG93TGlzdGVuZXIod2luZG93RXZlbnROYW1lLCBwbHVnaW5FdmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5lcnNbcGx1Z2luRXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd2luZG93RXZlbnROYW1lLFxuICAgICAgICAgICAgcGx1Z2luRXZlbnROYW1lLFxuICAgICAgICAgICAgaGFuZGxlcjogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKHBsdWdpbkV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdW5pbXBsZW1lbnRlZChtc2cgPSAnbm90IGltcGxlbWVudGVkJykge1xuICAgICAgICByZXR1cm4gbmV3IENhcGFjaXRvci5FeGNlcHRpb24obXNnLCBFeGNlcHRpb25Db2RlLlVuaW1wbGVtZW50ZWQpO1xuICAgIH1cbiAgICB1bmF2YWlsYWJsZShtc2cgPSAnbm90IGF2YWlsYWJsZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXBhY2l0b3IuRXhjZXB0aW9uKG1zZywgRXhjZXB0aW9uQ29kZS5VbmF2YWlsYWJsZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lckZ1bmMpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyBmb3IgdGhpcyB0eXBlIG9mIGV2ZW50LFxuICAgICAgICAvLyByZW1vdmUgdGhlIHdpbmRvdyBsaXN0ZW5lclxuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVyKHRoaXMud2luZG93TGlzdGVuZXJzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVyKGhhbmRsZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGUud2luZG93RXZlbnROYW1lLCBoYW5kbGUuaGFuZGxlcik7XG4gICAgICAgIGhhbmRsZS5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlV2luZG93TGlzdGVuZXIoaGFuZGxlKSB7XG4gICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlLndpbmRvd0V2ZW50TmFtZSwgaGFuZGxlLmhhbmRsZXIpO1xuICAgICAgICBoYW5kbGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuY29uc3QgV2ViVmlldyA9IC8qI19fUFVSRV9fKi8gcmVnaXN0ZXJQbHVnaW4oJ1dlYlZpZXcnKTtcblxuZXhwb3J0IHsgQ2FwYWNpdG9yLCBDYXBhY2l0b3JFeGNlcHRpb24sIENhcGFjaXRvclBsYXRmb3JtcywgRXhjZXB0aW9uQ29kZSwgUGx1Z2lucywgV2ViUGx1Z2luLCBXZWJWaWV3LCBhZGRQbGF0Zm9ybSwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdGVyV2ViUGx1Z2luLCBzZXRQbGF0Zm9ybSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1238\n")},773:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"V\": () => (/* binding */ PushNotifications)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1238);\n\nconst PushNotifications = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__/* .registerPlugin */ .fo)('PushNotifications', {});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzczLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBaUQ7QUFDakQsMEJBQTBCLHlFQUFjLHdCQUF3QjtBQUNsQztBQUNEO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL3B1c2gtbm90aWZpY2F0aW9ucy9kaXN0L2VzbS9pbmRleC5qcz82YWMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ2lzdGVyUGx1Z2luIH0gZnJvbSAnQGNhcGFjaXRvci9jb3JlJztcbmNvbnN0IFB1c2hOb3RpZmljYXRpb25zID0gcmVnaXN0ZXJQbHVnaW4oJ1B1c2hOb3RpZmljYXRpb25zJywge30pO1xuZXhwb3J0ICogZnJvbSAnLi9kZWZpbml0aW9ucyc7XG5leHBvcnQgeyBQdXNoTm90aWZpY2F0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///773\n")},2634:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"F\": () => (/* binding */ Toast)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1238);\n\nconst Toast = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__/* .registerPlugin */ .fo)('Toast', {\n    web: () => __webpack_require__.e(/* import() */ 5056).then(__webpack_require__.bind(__webpack_require__, 5056)).then(m => new m.ToastWeb()),\n});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYzNC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWlEO0FBQ2pELGNBQWMseUVBQWM7QUFDNUIsZUFBZSxvR0FBZTtBQUM5QixDQUFDO0FBQzZCO0FBQ2I7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3IvdG9hc3QvZGlzdC9lc20vaW5kZXguanM/YWY0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlclBsdWdpbiB9IGZyb20gJ0BjYXBhY2l0b3IvY29yZSc7XG5jb25zdCBUb2FzdCA9IHJlZ2lzdGVyUGx1Z2luKCdUb2FzdCcsIHtcbiAgICB3ZWI6ICgpID0+IGltcG9ydCgnLi93ZWInKS50aGVuKG0gPT4gbmV3IG0uVG9hc3RXZWIoKSksXG59KTtcbmV4cG9ydCAqIGZyb20gJy4vZGVmaW5pdGlvbnMnO1xuZXhwb3J0IHsgVG9hc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2634\n")},545:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"i\": () => (/* binding */ isRTL)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = (hostEl) => {\n  if (hostEl) {\n    if (hostEl.dir !== '') {\n      return hostEl.dir.toLowerCase() === 'rtl';\n    }\n  }\n  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ1LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9kaXIuanM/NDQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZG9jdW1lbnQgb3IgaG9zdCBlbGVtZW50XG4gKiBoYXMgYSBgZGlyYCBzZXQgdG8gYHJ0bGAuIFRoZSBob3N0IHZhbHVlIHdpbGwgYWx3YXlzXG4gKiB0YWtlIHByaW9yaXR5IG92ZXIgdGhlIHJvb3QgZG9jdW1lbnQgdmFsdWUuXG4gKi9cbmNvbnN0IGlzUlRMID0gKGhvc3RFbCkgPT4ge1xuICBpZiAoaG9zdEVsKSB7XG4gICAgaWYgKGhvc3RFbC5kaXIgIT09ICcnKSB7XG4gICAgICByZXR1cm4gaG9zdEVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQuZGlyLnRvTG93ZXJDYXNlKCkpID09PSAncnRsJztcbn07XG5cbmV4cG9ydCB7IGlzUlRMIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///545\n")},6587:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": () => (/* binding */ componentOnReady),\n/* harmony export */   \"h\": () => (/* binding */ hasShadowDom),\n/* harmony export */   \"i\": () => (/* binding */ inheritAttributes),\n/* harmony export */   \"j\": () => (/* binding */ clamp),\n/* harmony export */   \"r\": () => (/* binding */ raf),\n/* harmony export */   \"s\": () => (/* binding */ shallowEqualStringMap)\n/* harmony export */ });\n/* unused harmony exports a, b, d, e, f, g, k, l, m, n, o, p, q, t */\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst transitionEndAsync = (el, expectedDuration = 0) => {\n  return new Promise(resolve => {\n    transitionEnd(el, expectedDuration, resolve);\n  });\n};\n/**\n * Allows developer to wait for a transition\n * to finish and fallback to a timer if the\n * transition is cancelled or otherwise\n * never finishes. Also see transitionEndAsync\n * which is an await-able version of this.\n */\nconst transitionEnd = (el, expectedDuration = 0, callback) => {\n  let unRegTrans;\n  let animationTimeout;\n  const opts = { passive: true };\n  const ANIMATION_FALLBACK_TIMEOUT = 500;\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (ev === undefined || el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n    animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);\n    unRegTrans = () => {\n      if (animationTimeout) {\n        clearTimeout(animationTimeout);\n        animationTimeout = undefined;\n      }\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\n/**\n * Waits for a component to be ready for\n * both custom element and non-custom element builds.\n * If non-custom element build, el.componentOnReady\n * will be used.\n * For custom element builds, we wait a frame\n * so that the inner contents of the component\n * have a chance to render.\n *\n * Use this utility rather than calling\n * el.componentOnReady yourself.\n */\nconst componentOnReady = (el, callback) => {\n  if (el.componentOnReady) {\n    el.componentOnReady().then((resolvedEl) => callback(resolvedEl));\n  }\n  else {\n    raf(() => callback(el));\n  }\n};\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      }\n      else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.addEventListener(eventName, callback, opts);\n};\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      }\n      else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nconst hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\nconst findItemLabel = (componentEl) => {\n  const itemEl = componentEl.closest('ion-item');\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n  return null;\n};\nconst focusElement = (el) => {\n  el.focus();\n  /**\n   * When programmatically focusing an element,\n   * the focus-visible utility will not run because\n   * it is expecting a keyboard event to have triggered this;\n   * however, there are times when we need to manually control\n   * this behavior so we call the `setFocus` method on ion-app\n   * which will let us explicitly set the elements to focus.\n   */\n  if (el.classList.contains('ion-focusable')) {\n    const app = el.closest('ion-app');\n    if (app) {\n      app.setFocus([el]);\n    }\n  }\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText;\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.getElementById(labelledBy)\n    : findItemLabel(componentEl);\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n    // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  }\n  else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      }\n      else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n      labelText = label.textContent;\n    }\n  }\n  return { label, labelId, labelText };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n    throw new Error(message);\n  }\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\nconst pointerCoord = (ev) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return { x: touch.clientX, y: touch.clientY };\n    }\n    if (ev.pageX !== undefined) {\n      return { x: ev.pageX, y: ev.pageY };\n    }\n  }\n  return { x: 0, y: 0 };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\nconst isEndSide = (side) => {\n  const isRTL = document.dir === 'rtl';\n  switch (side) {\n    case 'start': return isRTL;\n    case 'end': return !isRTL;\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n/**\n * Check whether the two string maps are shallow equal.\n *\n * undefined is treated as an empty map.\n *\n * @returns whether the keys are the same and the values are shallow equal.\n */\nconst shallowEqualStringMap = (map1, map2) => {\n  map1 !== null && map1 !== void 0 ? map1 : (map1 = {});\n  map2 !== null && map2 !== void 0 ? map2 : (map2 = {});\n  if (map1 === map2) {\n    return true;\n  }\n  const keys1 = Object.keys(map1);\n  if (keys1.length !== Object.keys(map2).length) {\n    return false;\n  }\n  for (const k1 of keys1) {\n    if (!(k1 in map2)) {\n      return false;\n    }\n    if (map1[k1] !== map2[k1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2hlbHBlcnMuanM/ZWMwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgdHJhbnNpdGlvbkVuZEFzeW5jID0gKGVsLCBleHBlY3RlZER1cmF0aW9uID0gMCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgdHJhbnNpdGlvbkVuZChlbCwgZXhwZWN0ZWREdXJhdGlvbiwgcmVzb2x2ZSk7XG4gIH0pO1xufTtcbi8qKlxuICogQWxsb3dzIGRldmVsb3BlciB0byB3YWl0IGZvciBhIHRyYW5zaXRpb25cbiAqIHRvIGZpbmlzaCBhbmQgZmFsbGJhY2sgdG8gYSB0aW1lciBpZiB0aGVcbiAqIHRyYW5zaXRpb24gaXMgY2FuY2VsbGVkIG9yIG90aGVyd2lzZVxuICogbmV2ZXIgZmluaXNoZXMuIEFsc28gc2VlIHRyYW5zaXRpb25FbmRBc3luY1xuICogd2hpY2ggaXMgYW4gYXdhaXQtYWJsZSB2ZXJzaW9uIG9mIHRoaXMuXG4gKi9cbmNvbnN0IHRyYW5zaXRpb25FbmQgPSAoZWwsIGV4cGVjdGVkRHVyYXRpb24gPSAwLCBjYWxsYmFjaykgPT4ge1xuICBsZXQgdW5SZWdUcmFucztcbiAgbGV0IGFuaW1hdGlvblRpbWVvdXQ7XG4gIGNvbnN0IG9wdHMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgY29uc3QgQU5JTUFUSU9OX0ZBTExCQUNLX1RJTUVPVVQgPSA1MDA7XG4gIGNvbnN0IHVucmVnaXN0ZXIgPSAoKSA9PiB7XG4gICAgaWYgKHVuUmVnVHJhbnMpIHtcbiAgICAgIHVuUmVnVHJhbnMoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9IChldikgPT4ge1xuICAgIGlmIChldiA9PT0gdW5kZWZpbmVkIHx8IGVsID09PSBldi50YXJnZXQpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICAgIGNhbGxiYWNrKGV2KTtcbiAgICB9XG4gIH07XG4gIGlmIChlbCkge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBvblRyYW5zaXRpb25FbmQsIG9wdHMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBvblRyYW5zaXRpb25FbmQsIG9wdHMpO1xuICAgIGFuaW1hdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVHJhbnNpdGlvbkVuZCwgZXhwZWN0ZWREdXJhdGlvbiArIEFOSU1BVElPTl9GQUxMQkFDS19USU1FT1VUKTtcbiAgICB1blJlZ1RyYW5zID0gKCkgPT4ge1xuICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICBhbmltYXRpb25UaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB1bnJlZ2lzdGVyO1xufTtcbi8qKlxuICogV2FpdHMgZm9yIGEgY29tcG9uZW50IHRvIGJlIHJlYWR5IGZvclxuICogYm90aCBjdXN0b20gZWxlbWVudCBhbmQgbm9uLWN1c3RvbSBlbGVtZW50IGJ1aWxkcy5cbiAqIElmIG5vbi1jdXN0b20gZWxlbWVudCBidWlsZCwgZWwuY29tcG9uZW50T25SZWFkeVxuICogd2lsbCBiZSB1c2VkLlxuICogRm9yIGN1c3RvbSBlbGVtZW50IGJ1aWxkcywgd2Ugd2FpdCBhIGZyYW1lXG4gKiBzbyB0aGF0IHRoZSBpbm5lciBjb250ZW50cyBvZiB0aGUgY29tcG9uZW50XG4gKiBoYXZlIGEgY2hhbmNlIHRvIHJlbmRlci5cbiAqXG4gKiBVc2UgdGhpcyB1dGlsaXR5IHJhdGhlciB0aGFuIGNhbGxpbmdcbiAqIGVsLmNvbXBvbmVudE9uUmVhZHkgeW91cnNlbGYuXG4gKi9cbmNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoZWwsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChlbC5jb21wb25lbnRPblJlYWR5KSB7XG4gICAgZWwuY29tcG9uZW50T25SZWFkeSgpLnRoZW4oKHJlc29sdmVkRWwpID0+IGNhbGxiYWNrKHJlc29sdmVkRWwpKTtcbiAgfVxuICBlbHNlIHtcbiAgICByYWYoKCkgPT4gY2FsbGJhY2soZWwpKTtcbiAgfVxufTtcbi8qKlxuICogRWxlbWVudHMgaW5zaWRlIG9mIHdlYiBjb21wb25lbnRzIHNvbWV0aW1lcyBuZWVkIHRvIGluaGVyaXQgZ2xvYmFsIGF0dHJpYnV0ZXNcbiAqIHNldCBvbiB0aGUgaG9zdC4gRm9yIGV4YW1wbGUsIHRoZSBpbm5lciBpbnB1dCBpbiBgaW9uLWlucHV0YCBzaG91bGQgaW5oZXJpdFxuICogdGhlIGB0aXRsZWAgYXR0cmlidXRlIHRoYXQgZGV2ZWxvcGVycyBzZXQgZGlyZWN0bHkgb24gYGlvbi1pbnB1dGAuIFRoaXNcbiAqIGhlbHBlciBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGluIGNvbXBvbmVudFdpbGxMb2FkIGFuZCBhc3NpZ25lZCB0byBhIHZhcmlhYmxlXG4gKiB0aGF0IGlzIGxhdGVyIHVzZWQgaW4gdGhlIHJlbmRlciBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IG5lZWQgdG8gYmUgcmVhY3RpdmUgYXMgY2hhbmdpbmcgYXR0cmlidXRlcyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gKiBkb2VzIG5vdCB0cmlnZ2VyIGEgcmUtcmVuZGVyLlxuICovXG5jb25zdCBpbmhlcml0QXR0cmlidXRlcyA9IChlbCwgYXR0cmlidXRlcyA9IFtdKSA9PiB7XG4gIGNvbnN0IGF0dHJpYnV0ZU9iamVjdCA9IHt9O1xuICBhdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgYXR0cmlidXRlT2JqZWN0W2F0dHJdID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhdHRyaWJ1dGVPYmplY3Q7XG59O1xuY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gICAgY29uc3QgY29uZmlnID0gd2luICYmIHdpbi5Jb25pYyAmJiB3aW4uSW9uaWMuY29uZmlnO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGNvbnN0IGFlbCA9IGNvbmZpZy5nZXQoJ19hZWwnKTtcbiAgICAgIGlmIChhZWwpIHtcbiAgICAgICAgcmV0dXJuIGFlbChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb25maWcuX2FlbCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLl9hZWwoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbn07XG5jb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgICBjb25zdCBjb25maWcgPSB3aW4gJiYgd2luLklvbmljICYmIHdpbi5Jb25pYy5jb25maWc7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgY29uc3QgcmVsID0gY29uZmlnLmdldCgnX3JlbCcpO1xuICAgICAgaWYgKHJlbCkge1xuICAgICAgICByZXR1cm4gcmVsKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbmZpZy5fcmVsKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuX3JlbChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xufTtcbi8qKlxuICogR2V0cyB0aGUgcm9vdCBjb250ZXh0IG9mIGEgc2hhZG93IGRvbSBlbGVtZW50XG4gKiBPbiBuZXdlciBicm93c2VycyB0aGlzIHdpbGwgYmUgdGhlIHNoYWRvd1Jvb3QsXG4gKiBidXQgZm9yIG9sZGVyIGJyb3dzZXIgdGhpcyBtYXkganVzdCBiZSB0aGVcbiAqIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIFVzZWZ1bCBmb3Igd2hlbmV2ZXIgeW91IG5lZWQgdG8gZXhwbGljaXRseVxuICogZG8gXCJteUVsZW1lbnQuc2hhZG93Um9vdCEucXVlcnlTZWxlY3RvciguLi4pXCIuXG4gKi9cbmNvbnN0IGdldEVsZW1lbnRSb290ID0gKGVsLCBmYWxsYmFjayA9IGVsKSA9PiB7XG4gIHJldHVybiBlbC5zaGFkb3dSb290IHx8IGZhbGxiYWNrO1xufTtcbi8qKlxuICogUGF0Y2hlZCB2ZXJzaW9uIG9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0aGF0IGF2b2lkcyBuZ3pvbmVcbiAqIFVzZSBvbmx5IHdoZW4geW91IGtub3cgbmd6b25lIHNob3VsZCBub3QgcnVuXG4gKi9cbmNvbnN0IHJhZiA9IChoKSA9PiB7XG4gIGlmICh0eXBlb2YgX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9fem9uZV9zeW1ib2xfX3JlcXVlc3RBbmltYXRpb25GcmFtZShoKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCk7XG4gIH1cbiAgcmV0dXJuIHNldFRpbWVvdXQoaCk7XG59O1xuY29uc3QgaGFzU2hhZG93RG9tID0gKGVsKSA9PiB7XG4gIHJldHVybiAhIWVsLnNoYWRvd1Jvb3QgJiYgISFlbC5hdHRhY2hTaGFkb3c7XG59O1xuY29uc3QgZmluZEl0ZW1MYWJlbCA9IChjb21wb25lbnRFbCkgPT4ge1xuICBjb25zdCBpdGVtRWwgPSBjb21wb25lbnRFbC5jbG9zZXN0KCdpb24taXRlbScpO1xuICBpZiAoaXRlbUVsKSB7XG4gICAgcmV0dXJuIGl0ZW1FbC5xdWVyeVNlbGVjdG9yKCdpb24tbGFiZWwnKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBmb2N1c0VsZW1lbnQgPSAoZWwpID0+IHtcbiAgZWwuZm9jdXMoKTtcbiAgLyoqXG4gICAqIFdoZW4gcHJvZ3JhbW1hdGljYWxseSBmb2N1c2luZyBhbiBlbGVtZW50LFxuICAgKiB0aGUgZm9jdXMtdmlzaWJsZSB1dGlsaXR5IHdpbGwgbm90IHJ1biBiZWNhdXNlXG4gICAqIGl0IGlzIGV4cGVjdGluZyBhIGtleWJvYXJkIGV2ZW50IHRvIGhhdmUgdHJpZ2dlcmVkIHRoaXM7XG4gICAqIGhvd2V2ZXIsIHRoZXJlIGFyZSB0aW1lcyB3aGVuIHdlIG5lZWQgdG8gbWFudWFsbHkgY29udHJvbFxuICAgKiB0aGlzIGJlaGF2aW9yIHNvIHdlIGNhbGwgdGhlIGBzZXRGb2N1c2AgbWV0aG9kIG9uIGlvbi1hcHBcbiAgICogd2hpY2ggd2lsbCBsZXQgdXMgZXhwbGljaXRseSBzZXQgdGhlIGVsZW1lbnRzIHRvIGZvY3VzLlxuICAgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnaW9uLWZvY3VzYWJsZScpKSB7XG4gICAgY29uc3QgYXBwID0gZWwuY2xvc2VzdCgnaW9uLWFwcCcpO1xuICAgIGlmIChhcHApIHtcbiAgICAgIGFwcC5zZXRGb2N1cyhbZWxdKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIElvbmljJ3MgaW5wdXQgY29tcG9uZW50cyB0aGF0IHVzZSBTaGFkb3cgRE9NLiBJblxuICogb3JkZXIgdG8gcHJvcGVybHkgbGFiZWwgdGhlIGlucHV0cyB0byB3b3JrIHdpdGggc2NyZWVuIHJlYWRlcnMsIHdlIG5lZWRcbiAqIHRvIGdldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBsYWJlbCBvdXRzaWRlIG9mIHRoZSBzaGFkb3cgcm9vdCBhbmQgcGFzc1xuICogaXQgdG8gdGhlIGlucHV0IGluc2lkZSBvZiB0aGUgc2hhZG93IHJvb3QuXG4gKlxuICogUmVmZXJlbmNpbmcgbGFiZWwgZWxlbWVudHMgYnkgaWQgZnJvbSBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgaXNcbiAqIGltcG9zc2libGUgZHVlIHRvIHRoZSBzaGFkb3cgYm91bmRhcnksIHJlYWQgbW9yZSBoZXJlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIuc2FsZXNmb3JjZS5jb20vYmxvZ3MvMjAyMC8wMS9hY2Nlc3NpYmlsaXR5LWZvci13ZWItY29tcG9uZW50cy5odG1sXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudEVsIFRoZSBzaGFkb3cgZWxlbWVudCB0aGF0IG5lZWRzIHRoZSBhcmlhIGxhYmVsXG4gKiBAcGFyYW0gaW5wdXRJZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpbnB1dFxuICovXG5jb25zdCBnZXRBcmlhTGFiZWwgPSAoY29tcG9uZW50RWwsIGlucHV0SWQpID0+IHtcbiAgbGV0IGxhYmVsVGV4dDtcbiAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZXMgdGhlaXIgb3duIGxhYmVsIHZpYSB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJcbiAgLy8gd2Ugc2hvdWxkIHVzZSB0aGF0IGluc3RlYWQgb2YgbG9va2luZyBmb3IgYW4gaW9uLWxhYmVsXG4gIGNvbnN0IGxhYmVsbGVkQnkgPSBjb21wb25lbnRFbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAvLyBHcmFiIHRoZSBpZCBvZmYgb2YgdGhlIGNvbXBvbmVudCBpbiBjYXNlIHRoZXkgYXJlIHVzaW5nXG4gIC8vIGEgY3VzdG9tIGxhYmVsIHVzaW5nIHRoZSBsYWJlbCBlbGVtZW50XG4gIGNvbnN0IGNvbXBvbmVudElkID0gY29tcG9uZW50RWwuaWQ7XG4gIGxldCBsYWJlbElkID0gbGFiZWxsZWRCeSAhPT0gbnVsbCAmJiBsYWJlbGxlZEJ5LnRyaW0oKSAhPT0gJydcbiAgICA/IGxhYmVsbGVkQnlcbiAgICA6IGlucHV0SWQgKyAnLWxibCc7XG4gIGxldCBsYWJlbCA9IGxhYmVsbGVkQnkgIT09IG51bGwgJiYgbGFiZWxsZWRCeS50cmltKCkgIT09ICcnXG4gICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsYWJlbGxlZEJ5KVxuICAgIDogZmluZEl0ZW1MYWJlbChjb21wb25lbnRFbCk7XG4gIGlmIChsYWJlbCkge1xuICAgIGlmIChsYWJlbGxlZEJ5ID09PSBudWxsKSB7XG4gICAgICBsYWJlbC5pZCA9IGxhYmVsSWQ7XG4gICAgfVxuICAgIGxhYmVsVGV4dCA9IGxhYmVsLnRleHRDb250ZW50O1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGxhYmVsLCBjaGVjayB0byBzZWUgaWYgdGhlIHVzZXIgaGFzIHByb3ZpZGVkXG4gICAgLy8gb25lIGJ5IHNldHRpbmcgYW4gaWQgb24gdGhlIGNvbXBvbmVudCBhbmQgdXNpbmcgdGhlIGxhYmVsIGVsZW1lbnRcbiAgfVxuICBlbHNlIGlmIChjb21wb25lbnRJZC50cmltKCkgIT09ICcnKSB7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsYWJlbFtmb3I9XCIke2NvbXBvbmVudElkfVwiXWApO1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgaWYgKGxhYmVsLmlkICE9PSAnJykge1xuICAgICAgICBsYWJlbElkID0gbGFiZWwuaWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGFiZWwuaWQgPSBsYWJlbElkID0gYCR7Y29tcG9uZW50SWR9LWxibGA7XG4gICAgICB9XG4gICAgICBsYWJlbFRleHQgPSBsYWJlbC50ZXh0Q29udGVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbGFiZWwsIGxhYmVsSWQsIGxhYmVsVGV4dCB9O1xufTtcbi8qKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhZGQgYSBoaWRkZW4gaW5wdXQgdG8gYSBob3N0IGVsZW1lbnQgdGhhdCBjb250YWluc1xuICogYSBTaGFkb3cgRE9NLiBJdCBkb2VzIG5vdCBhZGQgdGhlIGlucHV0IGluc2lkZSBvZiB0aGUgU2hhZG93IHJvb3Qgd2hpY2hcbiAqIGFsbG93cyBpdCB0byBiZSBwaWNrZWQgdXAgaW5zaWRlIG9mIGZvcm1zLiBJdCBzaG91bGQgY29udGFpbiB0aGUgc2FtZVxuICogdmFsdWVzIGFzIHRoZSBob3N0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGFsd2F5cyBBZGQgYSBoaWRkZW4gaW5wdXQgZXZlbiBpZiB0aGUgY29udGFpbmVyIGRvZXMgbm90IHVzZSBTaGFkb3dcbiAqIEBwYXJhbSBjb250YWluZXIgVGhlIGVsZW1lbnQgd2hlcmUgdGhlIGlucHV0IHdpbGwgYmUgYWRkZWRcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSBkaXNhYmxlZCBJZiB0cnVlLCB0aGUgaW5wdXQgaXMgZGlzYWJsZWRcbiAqL1xuY29uc3QgcmVuZGVySGlkZGVuSW5wdXQgPSAoYWx3YXlzLCBjb250YWluZXIsIG5hbWUsIHZhbHVlLCBkaXNhYmxlZCkgPT4ge1xuICBpZiAoYWx3YXlzIHx8IGhhc1NoYWRvd0RvbShjb250YWluZXIpKSB7XG4gICAgbGV0IGlucHV0ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LmF1eC1pbnB1dCcpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIGlucHV0ID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgIGlucHV0LnR5cGUgPSAnaGlkZGVuJztcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2F1eC1pbnB1dCcpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICB9XG4gICAgaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICB9XG59O1xuY29uc3QgY2xhbXAgPSAobWluLCBuLCBtYXgpID0+IHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obiwgbWF4KSk7XG59O1xuY29uc3QgYXNzZXJ0ID0gKGFjdHVhbCwgcmVhc29uKSA9PiB7XG4gIGlmICghYWN0dWFsKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdBU1NFUlQ6ICcgKyByZWFzb247XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICBkZWJ1Z2dlcjsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcbmNvbnN0IG5vdyA9IChldikgPT4ge1xuICByZXR1cm4gZXYudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG59O1xuY29uc3QgcG9pbnRlckNvb3JkID0gKGV2KSA9PiB7XG4gIC8vIGdldCBYIGNvb3JkaW5hdGVzIGZvciBlaXRoZXIgYSBtb3VzZSBjbGlja1xuICAvLyBvciBhIHRvdWNoIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gZXZlbnRcbiAgaWYgKGV2KSB7XG4gICAgY29uc3QgY2hhbmdlZFRvdWNoZXMgPSBldi5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAoY2hhbmdlZFRvdWNoZXMgJiYgY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHJldHVybiB7IHg6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFkgfTtcbiAgICB9XG4gICAgaWYgKGV2LnBhZ2VYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7IHg6IGV2LnBhZ2VYLCB5OiBldi5wYWdlWSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBHaXZlbiBhIHNpZGUsIHJldHVybiBpZiBpdCBzaG91bGQgYmUgb24gdGhlIGVuZFxuICogYmFzZWQgb24gdGhlIHZhbHVlIG9mIGRpclxuICogQHBhcmFtIHNpZGUgdGhlIHNpZGVcbiAqIEBwYXJhbSBpc1JUTCB3aGV0aGVyIHRoZSBhcHBsaWNhdGlvbiBkaXIgaXMgcnRsXG4gKi9cbmNvbnN0IGlzRW5kU2lkZSA9IChzaWRlKSA9PiB7XG4gIGNvbnN0IGlzUlRMID0gZG9jdW1lbnQuZGlyID09PSAncnRsJztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAnc3RhcnQnOiByZXR1cm4gaXNSVEw7XG4gICAgY2FzZSAnZW5kJzogcmV0dXJuICFpc1JUTDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7c2lkZX1cIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgW3NpZGVdLiBVc2UgXCJzdGFydFwiIG9yIFwiZW5kXCIgaW5zdGVhZC5gKTtcbiAgfVxufTtcbmNvbnN0IGRlYm91bmNlRXZlbnQgPSAoZXZlbnQsIHdhaXQpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBldmVudC5fb3JpZ2luYWwgfHwgZXZlbnQ7XG4gIHJldHVybiB7XG4gICAgX29yaWdpbmFsOiBldmVudCxcbiAgICBlbWl0OiBkZWJvdW5jZShvcmlnaW5hbC5lbWl0LmJpbmQob3JpZ2luYWwpLCB3YWl0KVxuICB9O1xufTtcbmNvbnN0IGRlYm91bmNlID0gKGZ1bmMsIHdhaXQgPSAwKSA9PiB7XG4gIGxldCB0aW1lcjtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgd2FpdCwgLi4uYXJncyk7XG4gIH07XG59O1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB0d28gc3RyaW5nIG1hcHMgYXJlIHNoYWxsb3cgZXF1YWwuXG4gKlxuICogdW5kZWZpbmVkIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgbWFwLlxuICpcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGtleXMgYXJlIHRoZSBzYW1lIGFuZCB0aGUgdmFsdWVzIGFyZSBzaGFsbG93IGVxdWFsLlxuICovXG5jb25zdCBzaGFsbG93RXF1YWxTdHJpbmdNYXAgPSAobWFwMSwgbWFwMikgPT4ge1xuICBtYXAxICE9PSBudWxsICYmIG1hcDEgIT09IHZvaWQgMCA/IG1hcDEgOiAobWFwMSA9IHt9KTtcbiAgbWFwMiAhPT0gbnVsbCAmJiBtYXAyICE9PSB2b2lkIDAgPyBtYXAyIDogKG1hcDIgPSB7fSk7XG4gIGlmIChtYXAxID09PSBtYXAyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhtYXAxKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobWFwMikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgazEgb2Yga2V5czEpIHtcbiAgICBpZiAoIShrMSBpbiBtYXAyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWFwMVtrMV0gIT09IG1hcDJbazFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgYWRkRXZlbnRMaXN0ZW5lciBhcyBhLCByZW1vdmVFdmVudExpc3RlbmVyIGFzIGIsIGNvbXBvbmVudE9uUmVhZHkgYXMgYywgZ2V0QXJpYUxhYmVsIGFzIGQsIHJlbmRlckhpZGRlbklucHV0IGFzIGUsIGZvY3VzRWxlbWVudCBhcyBmLCBnZXRFbGVtZW50Um9vdCBhcyBnLCBoYXNTaGFkb3dEb20gYXMgaCwgaW5oZXJpdEF0dHJpYnV0ZXMgYXMgaSwgY2xhbXAgYXMgaiwgZGVib3VuY2VFdmVudCBhcyBrLCBmaW5kSXRlbUxhYmVsIGFzIGwsIGlzRW5kU2lkZSBhcyBtLCBhc3NlcnQgYXMgbiwgZGVib3VuY2UgYXMgbywgcG9pbnRlckNvb3JkIGFzIHAsIG5vdyBhcyBxLCByYWYgYXMgciwgc2hhbGxvd0VxdWFsU3RyaW5nTWFwIGFzIHMsIHRyYW5zaXRpb25FbmRBc3luYyBhcyB0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6587\n")},5026:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"g\": () => (/* binding */ getIonPageElement),\n/* harmony export */   \"t\": () => (/* binding */ transition)\n/* harmony export */ });\n/* unused harmony exports L, a, b, c, d, e, l, s */\n/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7210);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';\nconst LIFECYCLE_DID_ENTER = 'ionViewDidEnter';\nconst LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';\nconst LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';\nconst LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';\n\nconst iosTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(6338)]).then(__webpack_require__.bind(__webpack_require__, 6338));\nconst mdTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(4753)]).then(__webpack_require__.bind(__webpack_require__, 4753));\nconst transition = (opts) => {\n  return new Promise((resolve, reject) => {\n    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .writeTask */ .Iu)(() => {\n      beforeTransition(opts);\n      runTransition(opts).then(result => {\n        if (result.animation) {\n          result.animation.destroy();\n        }\n        afterTransition(opts);\n        resolve(result);\n      }, error => {\n        afterTransition(opts);\n        reject(error);\n      });\n    });\n  });\n};\nconst beforeTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  setZIndex(enteringEl, leavingEl, opts.direction);\n  if (opts.showGoBack) {\n    enteringEl.classList.add('can-go-back');\n  }\n  else {\n    enteringEl.classList.remove('can-go-back');\n  }\n  setPageHidden(enteringEl, false);\n  /**\n   * When transitioning, the page should not\n   * respond to click events. This resolves small\n   * issues like users double tapping the ion-back-button.\n   * These pointer events are removed in `afterTransition`.\n   */\n  enteringEl.style.setProperty('pointer-events', 'none');\n  if (leavingEl) {\n    setPageHidden(leavingEl, false);\n    leavingEl.style.setProperty('pointer-events', 'none');\n  }\n};\nconst runTransition = async (opts) => {\n  const animationBuilder = await getAnimationBuilder(opts);\n  const ani = (animationBuilder && _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .Build.isBrowser */ .Z5.isBrowser)\n    ? animation(animationBuilder, opts)\n    : noAnimation(opts); // fast path for no animation\n  return ani;\n};\nconst afterTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  enteringEl.classList.remove('ion-page-invisible');\n  enteringEl.style.removeProperty('pointer-events');\n  if (leavingEl !== undefined) {\n    leavingEl.classList.remove('ion-page-invisible');\n    leavingEl.style.removeProperty('pointer-events');\n  }\n};\nconst getAnimationBuilder = async (opts) => {\n  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {\n    return undefined;\n  }\n  if (opts.animationBuilder) {\n    return opts.animationBuilder;\n  }\n  const getAnimation = (opts.mode === 'ios')\n    ? (await iosTransitionAnimation()).iosTransitionAnimation\n    : (await mdTransitionAnimation()).mdTransitionAnimation;\n  return getAnimation;\n};\nconst animation = async (animationBuilder, opts) => {\n  await waitForReady(opts, true);\n  const trans = animationBuilder(opts.baseEl, opts);\n  fireWillEvents(opts.enteringEl, opts.leavingEl);\n  const didComplete = await playTransition(trans, opts);\n  if (opts.progressCallback) {\n    opts.progressCallback(undefined);\n  }\n  if (didComplete) {\n    fireDidEvents(opts.enteringEl, opts.leavingEl);\n  }\n  return {\n    hasCompleted: didComplete,\n    animation: trans\n  };\n};\nconst noAnimation = async (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  await waitForReady(opts, false);\n  fireWillEvents(enteringEl, leavingEl);\n  fireDidEvents(enteringEl, leavingEl);\n  return {\n    hasCompleted: true\n  };\n};\nconst waitForReady = async (opts, defaultDeep) => {\n  const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;\n  const promises = deep ? [\n    deepReady(opts.enteringEl),\n    deepReady(opts.leavingEl),\n  ] : [\n    shallowReady(opts.enteringEl),\n    shallowReady(opts.leavingEl),\n  ];\n  await Promise.all(promises);\n  await notifyViewReady(opts.viewIsReady, opts.enteringEl);\n};\nconst notifyViewReady = async (viewIsReady, enteringEl) => {\n  if (viewIsReady) {\n    await viewIsReady(enteringEl);\n  }\n};\nconst playTransition = (trans, opts) => {\n  const progressCallback = opts.progressCallback;\n  const promise = new Promise(resolve => {\n    trans.onFinish((currentStep) => resolve(currentStep === 1));\n  });\n  // cool, let's do this, start the transition\n  if (progressCallback) {\n    // this is a swipe to go back, just get the transition progress ready\n    // kick off the swipe animation start\n    trans.progressStart(true);\n    progressCallback(trans);\n  }\n  else {\n    // only the top level transition should actually start \"play\"\n    // kick it off and let it play through\n    // ******** DOM WRITE ****************\n    trans.play();\n  }\n  // create a callback for when the animation is done\n  return promise;\n};\nconst fireWillEvents = (enteringEl, leavingEl) => {\n  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);\n  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);\n};\nconst fireDidEvents = (enteringEl, leavingEl) => {\n  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);\n  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);\n};\nconst lifecycle = (el, eventName) => {\n  if (el) {\n    const ev = new CustomEvent(eventName, {\n      bubbles: false,\n      cancelable: false,\n    });\n    el.dispatchEvent(ev);\n  }\n};\nconst shallowReady = (el) => {\n  if (el) {\n    return new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, resolve));\n  }\n  return Promise.resolve();\n};\nconst deepReady = async (el) => {\n  const element = el;\n  if (element) {\n    if (element.componentOnReady != null) {\n      const stencilEl = await element.componentOnReady();\n      if (stencilEl != null) {\n        return;\n      }\n      /**\n       * Custom elements in Stencil will have __registerHost.\n       */\n    }\n    else if (element.__registerHost != null) {\n      /**\n       * Non-lazy loaded custom elements need to wait\n       * one frame for component to be loaded.\n       */\n      const waitForCustomElement = new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.r)(resolve));\n      await waitForCustomElement;\n      return;\n    }\n    await Promise.all(Array.from(element.children).map(deepReady));\n  }\n};\nconst setPageHidden = (el, hidden) => {\n  if (hidden) {\n    el.setAttribute('aria-hidden', 'true');\n    el.classList.add('ion-page-hidden');\n  }\n  else {\n    el.hidden = false;\n    el.removeAttribute('aria-hidden');\n    el.classList.remove('ion-page-hidden');\n  }\n};\nconst setZIndex = (enteringEl, leavingEl, direction) => {\n  if (enteringEl !== undefined) {\n    enteringEl.style.zIndex = (direction === 'back')\n      ? '99'\n      : '101';\n  }\n  if (leavingEl !== undefined) {\n    leavingEl.style.zIndex = '100';\n  }\n};\nconst getIonPageElement = (element) => {\n  if (element.classList.contains('ion-page')) {\n    return element;\n  }\n  const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');\n  if (ionPage) {\n    return ionPage;\n  }\n  // idk, return the original element so at least something animates and we don't have a null pointer\n  return element;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAyNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2lFO0FBQ0Y7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLCtJQUE2QjtBQUNsRSxvQ0FBb0MsK0lBQTRCO0FBQ2hFO0FBQ0E7QUFDQSxJQUFJLGtGQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEZBQWU7QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOENBQUc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNk8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW5kZXg0LmpzPzY3OWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHdyaXRlVGFzaywgQnVpbGQgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudE9uUmVhZHksIHIgYXMgcmFmIH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcblxuY29uc3QgTElGRUNZQ0xFX1dJTExfRU5URVIgPSAnaW9uVmlld1dpbGxFbnRlcic7XG5jb25zdCBMSUZFQ1lDTEVfRElEX0VOVEVSID0gJ2lvblZpZXdEaWRFbnRlcic7XG5jb25zdCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSA9ICdpb25WaWV3V2lsbExlYXZlJztcbmNvbnN0IExJRkVDWUNMRV9ESURfTEVBVkUgPSAnaW9uVmlld0RpZExlYXZlJztcbmNvbnN0IExJRkVDWUNMRV9XSUxMX1VOTE9BRCA9ICdpb25WaWV3V2lsbFVubG9hZCc7XG5cbmNvbnN0IGlvc1RyYW5zaXRpb25BbmltYXRpb24gPSAoKSA9PiBpbXBvcnQoJy4vaW9zLnRyYW5zaXRpb24uanMnKTtcbmNvbnN0IG1kVHJhbnNpdGlvbkFuaW1hdGlvbiA9ICgpID0+IGltcG9ydCgnLi9tZC50cmFuc2l0aW9uLmpzJyk7XG5jb25zdCB0cmFuc2l0aW9uID0gKG9wdHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZVRhc2soKCkgPT4ge1xuICAgICAgYmVmb3JlVHJhbnNpdGlvbihvcHRzKTtcbiAgICAgIHJ1blRyYW5zaXRpb24ob3B0cykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmFuaW1hdGlvbikge1xuICAgICAgICAgIHJlc3VsdC5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGFmdGVyVHJhbnNpdGlvbihvcHRzKTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICBhZnRlclRyYW5zaXRpb24ob3B0cyk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuY29uc3QgYmVmb3JlVHJhbnNpdGlvbiA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IGVudGVyaW5nRWwgPSBvcHRzLmVudGVyaW5nRWw7XG4gIGNvbnN0IGxlYXZpbmdFbCA9IG9wdHMubGVhdmluZ0VsO1xuICBzZXRaSW5kZXgoZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzLmRpcmVjdGlvbik7XG4gIGlmIChvcHRzLnNob3dHb0JhY2spIHtcbiAgICBlbnRlcmluZ0VsLmNsYXNzTGlzdC5hZGQoJ2Nhbi1nby1iYWNrJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZW50ZXJpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdjYW4tZ28tYmFjaycpO1xuICB9XG4gIHNldFBhZ2VIaWRkZW4oZW50ZXJpbmdFbCwgZmFsc2UpO1xuICAvKipcbiAgICogV2hlbiB0cmFuc2l0aW9uaW5nLCB0aGUgcGFnZSBzaG91bGQgbm90XG4gICAqIHJlc3BvbmQgdG8gY2xpY2sgZXZlbnRzLiBUaGlzIHJlc29sdmVzIHNtYWxsXG4gICAqIGlzc3VlcyBsaWtlIHVzZXJzIGRvdWJsZSB0YXBwaW5nIHRoZSBpb24tYmFjay1idXR0b24uXG4gICAqIFRoZXNlIHBvaW50ZXIgZXZlbnRzIGFyZSByZW1vdmVkIGluIGBhZnRlclRyYW5zaXRpb25gLlxuICAgKi9cbiAgZW50ZXJpbmdFbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICBpZiAobGVhdmluZ0VsKSB7XG4gICAgc2V0UGFnZUhpZGRlbihsZWF2aW5nRWwsIGZhbHNlKTtcbiAgICBsZWF2aW5nRWwuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgfVxufTtcbmNvbnN0IHJ1blRyYW5zaXRpb24gPSBhc3luYyAob3B0cykgPT4ge1xuICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gYXdhaXQgZ2V0QW5pbWF0aW9uQnVpbGRlcihvcHRzKTtcbiAgY29uc3QgYW5pID0gKGFuaW1hdGlvbkJ1aWxkZXIgJiYgQnVpbGQuaXNCcm93c2VyKVxuICAgID8gYW5pbWF0aW9uKGFuaW1hdGlvbkJ1aWxkZXIsIG9wdHMpXG4gICAgOiBub0FuaW1hdGlvbihvcHRzKTsgLy8gZmFzdCBwYXRoIGZvciBubyBhbmltYXRpb25cbiAgcmV0dXJuIGFuaTtcbn07XG5jb25zdCBhZnRlclRyYW5zaXRpb24gPSAob3B0cykgPT4ge1xuICBjb25zdCBlbnRlcmluZ0VsID0gb3B0cy5lbnRlcmluZ0VsO1xuICBjb25zdCBsZWF2aW5nRWwgPSBvcHRzLmxlYXZpbmdFbDtcbiAgZW50ZXJpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdpb24tcGFnZS1pbnZpc2libGUnKTtcbiAgZW50ZXJpbmdFbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgaWYgKGxlYXZpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGVhdmluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2lvbi1wYWdlLWludmlzaWJsZScpO1xuICAgIGxlYXZpbmdFbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgfVxufTtcbmNvbnN0IGdldEFuaW1hdGlvbkJ1aWxkZXIgPSBhc3luYyAob3B0cykgPT4ge1xuICBpZiAoIW9wdHMubGVhdmluZ0VsIHx8ICFvcHRzLmFuaW1hdGVkIHx8IG9wdHMuZHVyYXRpb24gPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChvcHRzLmFuaW1hdGlvbkJ1aWxkZXIpIHtcbiAgICByZXR1cm4gb3B0cy5hbmltYXRpb25CdWlsZGVyO1xuICB9XG4gIGNvbnN0IGdldEFuaW1hdGlvbiA9IChvcHRzLm1vZGUgPT09ICdpb3MnKVxuICAgID8gKGF3YWl0IGlvc1RyYW5zaXRpb25BbmltYXRpb24oKSkuaW9zVHJhbnNpdGlvbkFuaW1hdGlvblxuICAgIDogKGF3YWl0IG1kVHJhbnNpdGlvbkFuaW1hdGlvbigpKS5tZFRyYW5zaXRpb25BbmltYXRpb247XG4gIHJldHVybiBnZXRBbmltYXRpb247XG59O1xuY29uc3QgYW5pbWF0aW9uID0gYXN5bmMgKGFuaW1hdGlvbkJ1aWxkZXIsIG9wdHMpID0+IHtcbiAgYXdhaXQgd2FpdEZvclJlYWR5KG9wdHMsIHRydWUpO1xuICBjb25zdCB0cmFucyA9IGFuaW1hdGlvbkJ1aWxkZXIob3B0cy5iYXNlRWwsIG9wdHMpO1xuICBmaXJlV2lsbEV2ZW50cyhvcHRzLmVudGVyaW5nRWwsIG9wdHMubGVhdmluZ0VsKTtcbiAgY29uc3QgZGlkQ29tcGxldGUgPSBhd2FpdCBwbGF5VHJhbnNpdGlvbih0cmFucywgb3B0cyk7XG4gIGlmIChvcHRzLnByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICBvcHRzLnByb2dyZXNzQ2FsbGJhY2sodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoZGlkQ29tcGxldGUpIHtcbiAgICBmaXJlRGlkRXZlbnRzKG9wdHMuZW50ZXJpbmdFbCwgb3B0cy5sZWF2aW5nRWwpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFzQ29tcGxldGVkOiBkaWRDb21wbGV0ZSxcbiAgICBhbmltYXRpb246IHRyYW5zXG4gIH07XG59O1xuY29uc3Qgbm9BbmltYXRpb24gPSBhc3luYyAob3B0cykgPT4ge1xuICBjb25zdCBlbnRlcmluZ0VsID0gb3B0cy5lbnRlcmluZ0VsO1xuICBjb25zdCBsZWF2aW5nRWwgPSBvcHRzLmxlYXZpbmdFbDtcbiAgYXdhaXQgd2FpdEZvclJlYWR5KG9wdHMsIGZhbHNlKTtcbiAgZmlyZVdpbGxFdmVudHMoZW50ZXJpbmdFbCwgbGVhdmluZ0VsKTtcbiAgZmlyZURpZEV2ZW50cyhlbnRlcmluZ0VsLCBsZWF2aW5nRWwpO1xuICByZXR1cm4ge1xuICAgIGhhc0NvbXBsZXRlZDogdHJ1ZVxuICB9O1xufTtcbmNvbnN0IHdhaXRGb3JSZWFkeSA9IGFzeW5jIChvcHRzLCBkZWZhdWx0RGVlcCkgPT4ge1xuICBjb25zdCBkZWVwID0gb3B0cy5kZWVwV2FpdCAhPT0gdW5kZWZpbmVkID8gb3B0cy5kZWVwV2FpdCA6IGRlZmF1bHREZWVwO1xuICBjb25zdCBwcm9taXNlcyA9IGRlZXAgPyBbXG4gICAgZGVlcFJlYWR5KG9wdHMuZW50ZXJpbmdFbCksXG4gICAgZGVlcFJlYWR5KG9wdHMubGVhdmluZ0VsKSxcbiAgXSA6IFtcbiAgICBzaGFsbG93UmVhZHkob3B0cy5lbnRlcmluZ0VsKSxcbiAgICBzaGFsbG93UmVhZHkob3B0cy5sZWF2aW5nRWwpLFxuICBdO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGF3YWl0IG5vdGlmeVZpZXdSZWFkeShvcHRzLnZpZXdJc1JlYWR5LCBvcHRzLmVudGVyaW5nRWwpO1xufTtcbmNvbnN0IG5vdGlmeVZpZXdSZWFkeSA9IGFzeW5jICh2aWV3SXNSZWFkeSwgZW50ZXJpbmdFbCkgPT4ge1xuICBpZiAodmlld0lzUmVhZHkpIHtcbiAgICBhd2FpdCB2aWV3SXNSZWFkeShlbnRlcmluZ0VsKTtcbiAgfVxufTtcbmNvbnN0IHBsYXlUcmFuc2l0aW9uID0gKHRyYW5zLCBvcHRzKSA9PiB7XG4gIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2s7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB0cmFucy5vbkZpbmlzaCgoY3VycmVudFN0ZXApID0+IHJlc29sdmUoY3VycmVudFN0ZXAgPT09IDEpKTtcbiAgfSk7XG4gIC8vIGNvb2wsIGxldCdzIGRvIHRoaXMsIHN0YXJ0IHRoZSB0cmFuc2l0aW9uXG4gIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgLy8gdGhpcyBpcyBhIHN3aXBlIHRvIGdvIGJhY2ssIGp1c3QgZ2V0IHRoZSB0cmFuc2l0aW9uIHByb2dyZXNzIHJlYWR5XG4gICAgLy8ga2ljayBvZmYgdGhlIHN3aXBlIGFuaW1hdGlvbiBzdGFydFxuICAgIHRyYW5zLnByb2dyZXNzU3RhcnQodHJ1ZSk7XG4gICAgcHJvZ3Jlc3NDYWxsYmFjayh0cmFucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gb25seSB0aGUgdG9wIGxldmVsIHRyYW5zaXRpb24gc2hvdWxkIGFjdHVhbGx5IHN0YXJ0IFwicGxheVwiXG4gICAgLy8ga2ljayBpdCBvZmYgYW5kIGxldCBpdCBwbGF5IHRocm91Z2hcbiAgICAvLyAqKioqKioqKiBET00gV1JJVEUgKioqKioqKioqKioqKioqKlxuICAgIHRyYW5zLnBsYXkoKTtcbiAgfVxuICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGRvbmVcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuY29uc3QgZmlyZVdpbGxFdmVudHMgPSAoZW50ZXJpbmdFbCwgbGVhdmluZ0VsKSA9PiB7XG4gIGxpZmVjeWNsZShsZWF2aW5nRWwsIExJRkVDWUNMRV9XSUxMX0xFQVZFKTtcbiAgbGlmZWN5Y2xlKGVudGVyaW5nRWwsIExJRkVDWUNMRV9XSUxMX0VOVEVSKTtcbn07XG5jb25zdCBmaXJlRGlkRXZlbnRzID0gKGVudGVyaW5nRWwsIGxlYXZpbmdFbCkgPT4ge1xuICBsaWZlY3ljbGUoZW50ZXJpbmdFbCwgTElGRUNZQ0xFX0RJRF9FTlRFUik7XG4gIGxpZmVjeWNsZShsZWF2aW5nRWwsIExJRkVDWUNMRV9ESURfTEVBVkUpO1xufTtcbmNvbnN0IGxpZmVjeWNsZSA9IChlbCwgZXZlbnROYW1lKSA9PiB7XG4gIGlmIChlbCkge1xuICAgIGNvbnN0IGV2ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgfVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkeSA9IChlbCkgPT4ge1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjb21wb25lbnRPblJlYWR5KGVsLCByZXNvbHZlKSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcbmNvbnN0IGRlZXBSZWFkeSA9IGFzeW5jIChlbCkgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gZWw7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuY29tcG9uZW50T25SZWFkeSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzdGVuY2lsRWwgPSBhd2FpdCBlbGVtZW50LmNvbXBvbmVudE9uUmVhZHkoKTtcbiAgICAgIGlmIChzdGVuY2lsRWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEN1c3RvbSBlbGVtZW50cyBpbiBTdGVuY2lsIHdpbGwgaGF2ZSBfX3JlZ2lzdGVySG9zdC5cbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50Ll9fcmVnaXN0ZXJIb3N0ICE9IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm9uLWxhenkgbG9hZGVkIGN1c3RvbSBlbGVtZW50cyBuZWVkIHRvIHdhaXRcbiAgICAgICAqIG9uZSBmcmFtZSBmb3IgY29tcG9uZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgd2FpdEZvckN1c3RvbUVsZW1lbnQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJhZihyZXNvbHZlKSk7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ3VzdG9tRWxlbWVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkcmVuKS5tYXAoZGVlcFJlYWR5KSk7XG4gIH1cbn07XG5jb25zdCBzZXRQYWdlSGlkZGVuID0gKGVsLCBoaWRkZW4pID0+IHtcbiAgaWYgKGhpZGRlbikge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2lvbi1wYWdlLWhpZGRlbicpO1xuICB9XG4gIGVsc2Uge1xuICAgIGVsLmhpZGRlbiA9IGZhbHNlO1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdpb24tcGFnZS1oaWRkZW4nKTtcbiAgfVxufTtcbmNvbnN0IHNldFpJbmRleCA9IChlbnRlcmluZ0VsLCBsZWF2aW5nRWwsIGRpcmVjdGlvbikgPT4ge1xuICBpZiAoZW50ZXJpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW50ZXJpbmdFbC5zdHlsZS56SW5kZXggPSAoZGlyZWN0aW9uID09PSAnYmFjaycpXG4gICAgICA/ICc5OSdcbiAgICAgIDogJzEwMSc7XG4gIH1cbiAgaWYgKGxlYXZpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGVhdmluZ0VsLnN0eWxlLnpJbmRleCA9ICcxMDAnO1xuICB9XG59O1xuY29uc3QgZ2V0SW9uUGFnZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2lvbi1wYWdlJykpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBjb25zdCBpb25QYWdlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiAuaW9uLXBhZ2UsIDpzY29wZSA+IGlvbi1uYXYsIDpzY29wZSA+IGlvbi10YWJzJyk7XG4gIGlmIChpb25QYWdlKSB7XG4gICAgcmV0dXJuIGlvblBhZ2U7XG4gIH1cbiAgLy8gaWRrLCByZXR1cm4gdGhlIG9yaWdpbmFsIGVsZW1lbnQgc28gYXQgbGVhc3Qgc29tZXRoaW5nIGFuaW1hdGVzIGFuZCB3ZSBkb24ndCBoYXZlIGEgbnVsbCBwb2ludGVyXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZXhwb3J0IHsgTElGRUNZQ0xFX1dJTExfRU5URVIgYXMgTCwgTElGRUNZQ0xFX0RJRF9FTlRFUiBhcyBhLCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSBhcyBiLCBMSUZFQ1lDTEVfRElEX0xFQVZFIGFzIGMsIExJRkVDWUNMRV9XSUxMX1VOTE9BRCBhcyBkLCBkZWVwUmVhZHkgYXMgZSwgZ2V0SW9uUGFnZUVsZW1lbnQgYXMgZywgbGlmZWN5Y2xlIGFzIGwsIHNldFBhZ2VIaWRkZW4gYXMgcywgdHJhbnNpdGlvbiBhcyB0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5026\n")},7434:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ createAnimation)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var animationPrefix;var processKeyframes=function(e){e.forEach((function(e){for(var n in e){if(e.hasOwnProperty(n)){var r=e[n];if(n==="easing"){var t="animation-timing-function";e[t]=r;delete e[n]}else{var t=convertCamelCaseToHypen(n);if(t!==n){e[t]=r;delete e[n]}}}}}));return e};var convertCamelCaseToHypen=function(e){return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()};var getAnimationPrefix=function(e){if(animationPrefix===undefined){var n=e.style.animationName!==undefined;var r=e.style.webkitAnimationName!==undefined;animationPrefix=!n&&r?"-webkit-":""}return animationPrefix};var setStyleProperty=function(e,n,r){var t=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.setProperty(t+n,r)};var removeStyleProperty=function(e,n){var r=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.removeProperty(r+n)};var animationEnd=function(e,n){var r;var t={passive:true};var a=function(){if(r){r()}};var i=function(r){if(e===r.target){a();n(r)}};if(e){e.addEventListener("webkitAnimationEnd",i,t);e.addEventListener("animationend",i,t);r=function(){e.removeEventListener("webkitAnimationEnd",i,t);e.removeEventListener("animationend",i,t)}}return a};var generateKeyframeRules=function(e){if(e===void 0){e=[]}return e.map((function(e){var n=e.offset;var r=[];for(var t in e){if(e.hasOwnProperty(t)&&t!=="offset"){r.push("".concat(t,": ").concat(e[t],";"))}}return"".concat(n*100,"% { ").concat(r.join(" ")," }")})).join(" ")};var keyframeIds=[];var generateKeyframeName=function(e){var n=keyframeIds.indexOf(e);if(n<0){n=keyframeIds.push(e)-1}return"ion-animation-".concat(n)};var getStyleContainer=function(e){var n=e.getRootNode();return n.head||n};var createKeyframeStylesheet=function(e,n,r){var t=getStyleContainer(r);var a=getAnimationPrefix(r);var i=t.querySelector("#"+e);if(i){return i}var o=(r.ownerDocument||document).createElement("style");o.id=e;o.textContent="@".concat(a,"keyframes ").concat(e," { ").concat(n," } @").concat(a,"keyframes ").concat(e,"-alt { ").concat(n," }");t.appendChild(o);return o};var addClassToArray=function(e,n){if(e===void 0){e=[]}if(n!==undefined){var r=Array.isArray(n)?n:[n];return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e,true),r,true)}return e};var createAnimation=function(e){var n;var r;var t;var a;var i;var o;var f=[];var u=[];var c=[];var s=false;var v;var l={};var d=[];var y=[];var m={};var p=0;var h=false;var g=false;var E;var P;var S;var A;var C=true;var T=false;var b=true;var k;var w;var x=e;var K=[];var _=[];var I=[];var D=[];var L=[];var N=[];var R=[];var F=[];var O=[];var W=[];var j=typeof AnimationEffect==="function"||typeof window.AnimationEffect==="function";var H=typeof Element==="function"&&typeof Element.prototype.animate==="function"&&j;var M=100;var $=function(){return W};var q=function(e){D.forEach((function(n){n.destroy(e)}));z(e);I.length=0;D.length=0;f.length=0;G();s=false;b=true;return w};var z=function(e){J();if(e){Q()}};var Z=function(){h=false;g=false;b=true;P=undefined;S=undefined;A=undefined;p=0;T=false;C=true};var B=function(e,n){var r=n&&n.oneTimeCallback?_:K;r.push({c:e,o:n});return w};var G=function(){K.length=0;_.length=0;return w};var J=function(){if(H){W.forEach((function(e){e.cancel()}));W.length=0}else{var e=I.slice();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){e.forEach((function(e){removeStyleProperty(e,"animation-name");removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-timing-function");removeStyleProperty(e,"animation-iteration-count");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state");removeStyleProperty(e,"animation-fill-mode");removeStyleProperty(e,"animation-direction")}))}))}};var Q=function(){L.forEach((function(e){if(e&&e.parentNode){e.parentNode.removeChild(e)}}));L.length=0};var U=function(e){N.push(e);return w};var V=function(e){R.push(e);return w};var X=function(e){F.push(e);return w};var Y=function(e){O.push(e);return w};var ee=function(e){u=addClassToArray(u,e);return w};var ne=function(e){c=addClassToArray(c,e);return w};var re=function(e){if(e===void 0){e={}}l=e;return w};var te=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];l[t]=""}return w};var ae=function(e){d=addClassToArray(d,e);return w};var ie=function(e){y=addClassToArray(y,e);return w};var oe=function(e){if(e===void 0){e={}}m=e;return w};var fe=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];m[t]=""}return w};var ue=function(){if(i!==undefined){return i}if(v){return v.getFill()}return"both"};var ce=function(){if(P!==undefined){return P}if(o!==undefined){return o}if(v){return v.getDirection()}return"normal"};var se=function(){if(h){return"linear"}if(t!==undefined){return t}if(v){return v.getEasing()}return"linear"};var ve=function(){if(g){return 0}if(S!==undefined){return S}if(r!==undefined){return r}if(v){return v.getDuration()}return 0};var le=function(){if(a!==undefined){return a}if(v){return v.getIterations()}return 1};var de=function(){if(A!==undefined){return A}if(n!==undefined){return n}if(v){return v.getDelay()}return 0};var ye=function(){return f};var me=function(e){o=e;Re(true);return w};var pe=function(e){i=e;Re(true);return w};var he=function(e){n=e;Re(true);return w};var ge=function(e){t=e;Re(true);return w};var Ee=function(e){if(!H&&e===0){e=1}r=e;Re(true);return w};var Pe=function(e){a=e;Re(true);return w};var Se=function(e){v=e;return w};var Ae=function(e){if(e!=null){if(e.nodeType===1){I.push(e)}else if(e.length>=0){for(var n=0;n<e.length;n++){I.push(e[n])}}else{console.error("Invalid addElement value")}}return w};var Ce=function(e){if(e!=null){if(Array.isArray(e)){for(var n=0,r=e;n<r.length;n++){var t=r[n];t.parent(w);D.push(t)}}else{e.parent(w);D.push(e)}}return w};var Te=function(e){var n=f!==e;f=e;if(n){be(f)}return w};var be=function(e){if(H){$().forEach((function(n){if(n.effect.setKeyframes){n.effect.setKeyframes(e)}else{var r=new KeyframeEffect(n.effect.target,e,n.effect.getTiming());n.effect=r}}))}else{Ke()}};var ke=function(){N.forEach((function(e){return e()}));R.forEach((function(e){return e()}));var e=u;var n=c;var r=l;I.forEach((function(t){var a=t.classList;e.forEach((function(e){return a.add(e)}));n.forEach((function(e){return a.remove(e)}));for(var i in r){if(r.hasOwnProperty(i)){setStyleProperty(t,i,r[i])}}}))};var we=function(){$e();F.forEach((function(e){return e()}));O.forEach((function(e){return e()}));var e=C?1:0;var n=d;var r=y;var t=m;I.forEach((function(e){var a=e.classList;n.forEach((function(e){return a.add(e)}));r.forEach((function(e){return a.remove(e)}));for(var i in t){if(t.hasOwnProperty(i)){setStyleProperty(e,i,t[i])}}}));K.forEach((function(n){return n.c(e,w)}));_.forEach((function(n){return n.c(e,w)}));_.length=0;b=true;if(C){T=true}C=true};var xe=function(){if(p===0){return}p--;if(p===0){we();if(v){v.animationFinish()}}};var Ke=function(n){if(n===void 0){n=true}Q();var r=processKeyframes(f);I.forEach((function(t){if(r.length>0){var a=generateKeyframeRules(r);k=e!==undefined?e:generateKeyframeName(a);var i=createKeyframeStylesheet(k,a,t);L.push(i);setStyleProperty(t,"animation-duration","".concat(ve(),"ms"));setStyleProperty(t,"animation-timing-function",se());setStyleProperty(t,"animation-delay","".concat(de(),"ms"));setStyleProperty(t,"animation-fill-mode",ue());setStyleProperty(t,"animation-direction",ce());var o=le()===Infinity?"infinite":le().toString();setStyleProperty(t,"animation-iteration-count",o);setStyleProperty(t,"animation-play-state","paused");if(n){setStyleProperty(t,"animation-name","".concat(i.id,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(t,"animation-name",i.id||null)}))}}))};var _e=function(){I.forEach((function(e){var n=e.animate(f,{id:x,delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()});n.pause();W.push(n)}));if(W.length>0){W[0].onfinish=function(){xe()}}};var Ie=function(e){if(e===void 0){e=true}ke();if(f.length>0){if(H){_e()}else{Ke(e)}}s=true};var De=function(e){e=Math.min(Math.max(e,0),.9999);if(H){W.forEach((function(n){n.currentTime=n.effect.getComputedTiming().delay+ve()*e;n.pause()}))}else{var n="-".concat(ve()*e,"ms");I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-delay",n);setStyleProperty(e,"animation-play-state","paused")}}))}};var Le=function(e){W.forEach((function(e){e.effect.updateTiming({delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()})}));if(e!==undefined){De(e)}};var Ne=function(e,n){if(e===void 0){e=true}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(r){setStyleProperty(r,"animation-name",k||null);setStyleProperty(r,"animation-duration","".concat(ve(),"ms"));setStyleProperty(r,"animation-timing-function",se());setStyleProperty(r,"animation-delay",n!==undefined?"-".concat(n*ve(),"ms"):"".concat(de(),"ms"));setStyleProperty(r,"animation-fill-mode",ue()||null);setStyleProperty(r,"animation-direction",ce()||null);var t=le()===Infinity?"infinite":le().toString();setStyleProperty(r,"animation-iteration-count",t);if(e){setStyleProperty(r,"animation-name","".concat(k,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(r,"animation-name",k||null)}))}))}))};var Re=function(e,n,r){if(e===void 0){e=false}if(n===void 0){n=true}if(e){D.forEach((function(t){t.update(e,n,r)}))}if(H){Le(r)}else{Ne(n,r)}return w};var Fe=function(e,n){if(e===void 0){e=false}D.forEach((function(r){r.progressStart(e,n)}));je();h=e;if(!s){Ie()}Re(false,true,n);return w};var Oe=function(e){D.forEach((function(n){n.progressStep(e)}));De(e);return w};var We=function(e,n,r){h=false;D.forEach((function(t){t.progressEnd(e,n,r)}));if(r!==undefined){S=r}T=false;C=true;if(e===0){P=ce()==="reverse"?"normal":"reverse";if(P==="reverse"){C=false}if(H){Re();De(1-n)}else{A=(1-n)*ve()*-1;Re(false,false)}}else if(e===1){if(H){Re();De(n)}else{A=n*ve()*-1;Re(false,false)}}if(e!==undefined){B((function(){S=undefined;P=undefined;A=undefined}),{oneTimeCallback:true});if(!v){Ge()}}return w};var je=function(){if(s){if(H){W.forEach((function(e){e.pause()}))}else{I.forEach((function(e){setStyleProperty(e,"animation-play-state","paused")}))}}};var He=function(){D.forEach((function(e){e.pause()}));je();return w};var Me=function(){E=undefined;xe()};var $e=function(){if(E){clearTimeout(E)}};var qe=function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-play-state","running")}}))}));if(f.length===0||I.length===0){xe()}else{var e=de()||0;var n=ve()||0;var r=le()||1;if(isFinite(r)){E=setTimeout(Me,e+n*r+M)}animationEnd(I[0],(function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){ze();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)(xe)}))}))}};var ze=function(){I.forEach((function(e){removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state")}))};var Ze=function(){W.forEach((function(e){e.play()}));if(f.length===0||I.length===0){xe()}};var Be=function(){if(H){De(0);Le()}else{Ne()}};var Ge=function(e){return new Promise((function(n){if(e&&e.sync){g=true;B((function(){return g=false}),{oneTimeCallback:true})}if(!s){Ie()}if(T){Be();T=false}if(b){p=D.length+1;b=false}B((function(){return n()}),{oneTimeCallback:true});D.forEach((function(e){e.play()}));if(H){Ze()}else{qe()}}))};var Je=function(){D.forEach((function(e){e.stop()}));if(s){J();s=false}Z()};var Qe=function(e,n){var r;var t=f[0];if(t!==undefined&&(t.offset===undefined||t.offset===0)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([(r={offset:0},r[e]=n,r)],f,true)}return w};var Ue=function(e,n){var r;var t=f[f.length-1];if(t!==undefined&&(t.offset===undefined||t.offset===1)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],f,true),[(r={offset:1},r[e]=n,r)],false)}return w};var Ve=function(e,n,r){return Qe(e,n).to(e,r)};return w={parentAnimation:v,elements:I,childAnimations:D,id:x,animationFinish:xe,from:Qe,to:Ue,fromTo:Ve,parent:Se,play:Ge,pause:He,stop:Je,destroy:q,keyframes:Te,addAnimation:Ce,addElement:Ae,update:Re,fill:pe,direction:me,iterations:Pe,duration:Ee,easing:ge,delay:he,getWebAnimations:$,getKeyframes:ye,getFill:ue,getDirection:ce,getDelay:de,getIterations:le,getEasing:se,getDuration:ve,afterAddRead:X,afterAddWrite:Y,afterClearStyles:fe,afterStyles:oe,afterRemoveClass:ie,afterAddClass:ae,beforeAddRead:U,beforeAddWrite:V,beforeClearStyles:te,beforeStyles:re,beforeRemoveClass:ne,beforeAddClass:ee,onFinish:B,progressStart:Fe,progressStep:Oe,progressEnd:We}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dUIsVUFBVSxHQUFHLEtBQUssdUJBQXVCLG9EQUFvRCxNQUFNLGtCQUFrQix1QkFBdUIsVUFBVSxHQUFHLEtBQUssVUFBVSxrQkFBa0IsWUFBWSxNQUFNLGtCQUFrQixNQUFNLGtCQUFrQixrQkFBa0IsS0FBSyx1REFBRyxhQUFhLHVCQUF1QixlQUFlLHNEQUFzRCxHQUFHLEdBQUcsK0JBQStCLEtBQUssS0FBSyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IseUJBQXlCLDhCQUE4QixLQUFLLHVEQUFHLGFBQWEsS0FBSyx1REFBRyxLQUFLLEdBQUcsS0FBSyxrQkFBa0IsdUJBQXVCLDRDQUE0Qyx5Q0FBeUMsOENBQThDLElBQUksa0JBQWtCLHVCQUF1QixTQUFTLEdBQUcsK0JBQStCLE9BQU8sa0JBQWtCLE1BQU0sTUFBTSxLQUFLLEtBQUssT0FBTyxtQkFBbUIsZ0NBQWdDLGNBQWMsT0FBTyxjQUFjLGVBQWUsR0FBRyxxQkFBcUIsRUFBRSxPQUFPLEtBQUssTUFBTSxLQUFLLFFBQVEsTUFBTSxhQUFhLFFBQVEsY0FBYyxXQUFXLEdBQUcscUJBQXFCLEVBQUUsdUJBQXVCLFNBQVMsR0FBRyxNQUFNLEtBQUssS0FBSyxNQUFNLElBQUksa0JBQWtCLHVCQUF1QixTQUFTLEdBQUcsTUFBTSxJQUFJLFFBQVEsS0FBSyxxQkFBcUIsTUFBTSxXQUFXLHdEQUF3RCxPQUFPLEtBQUssRUFBRSw4REFBYSxNQUFNLFNBQVMsb0JBQW9CLFVBQVUscUJBQXFCLE1BQU0sb0JBQW9CLHdEQUF3RCxPQUFPLEtBQUssRUFBRSw4REFBYSxDQUFDLDhEQUFhLGlCQUFpQixTQUFTLG1CQUFtQixVQUFVLHVCQUF1Qix3QkFBd0IsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2FuaW1hdGlvbi0xOWRiZjliZi5qcz83ZTBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtyIGFzIHJhZn1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjt2YXIgYW5pbWF0aW9uUHJlZml4O3ZhciBwcm9jZXNzS2V5ZnJhbWVzPWZ1bmN0aW9uKGUpe2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Zm9yKHZhciBuIGluIGUpe2lmKGUuaGFzT3duUHJvcGVydHkobikpe3ZhciByPWVbbl07aWYobj09PVwiZWFzaW5nXCIpe3ZhciB0PVwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiO2VbdF09cjtkZWxldGUgZVtuXX1lbHNle3ZhciB0PWNvbnZlcnRDYW1lbENhc2VUb0h5cGVuKG4pO2lmKHQhPT1uKXtlW3RdPXI7ZGVsZXRlIGVbbl19fX19fSkpO3JldHVybiBlfTt2YXIgY29udmVydENhbWVsQ2FzZVRvSHlwZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZyxcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCl9O3ZhciBnZXRBbmltYXRpb25QcmVmaXg9ZnVuY3Rpb24oZSl7aWYoYW5pbWF0aW9uUHJlZml4PT09dW5kZWZpbmVkKXt2YXIgbj1lLnN0eWxlLmFuaW1hdGlvbk5hbWUhPT11bmRlZmluZWQ7dmFyIHI9ZS5zdHlsZS53ZWJraXRBbmltYXRpb25OYW1lIT09dW5kZWZpbmVkO2FuaW1hdGlvblByZWZpeD0hbiYmcj9cIi13ZWJraXQtXCI6XCJcIn1yZXR1cm4gYW5pbWF0aW9uUHJlZml4fTt2YXIgc2V0U3R5bGVQcm9wZXJ0eT1mdW5jdGlvbihlLG4scil7dmFyIHQ9bi5zdGFydHNXaXRoKFwiYW5pbWF0aW9uXCIpP2dldEFuaW1hdGlvblByZWZpeChlKTpcIlwiO2Uuc3R5bGUuc2V0UHJvcGVydHkodCtuLHIpfTt2YXIgcmVtb3ZlU3R5bGVQcm9wZXJ0eT1mdW5jdGlvbihlLG4pe3ZhciByPW4uc3RhcnRzV2l0aChcImFuaW1hdGlvblwiKT9nZXRBbmltYXRpb25QcmVmaXgoZSk6XCJcIjtlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHIrbil9O3ZhciBhbmltYXRpb25FbmQ9ZnVuY3Rpb24oZSxuKXt2YXIgcjt2YXIgdD17cGFzc2l2ZTp0cnVlfTt2YXIgYT1mdW5jdGlvbigpe2lmKHIpe3IoKX19O3ZhciBpPWZ1bmN0aW9uKHIpe2lmKGU9PT1yLnRhcmdldCl7YSgpO24ocil9fTtpZihlKXtlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRBbmltYXRpb25FbmRcIixpLHQpO2UuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLGksdCk7cj1mdW5jdGlvbigpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdEFuaW1hdGlvbkVuZFwiLGksdCk7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsaSx0KX19cmV0dXJuIGF9O3ZhciBnZW5lcmF0ZUtleWZyYW1lUnVsZXM9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1bXX1yZXR1cm4gZS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciBuPWUub2Zmc2V0O3ZhciByPVtdO2Zvcih2YXIgdCBpbiBlKXtpZihlLmhhc093blByb3BlcnR5KHQpJiZ0IT09XCJvZmZzZXRcIil7ci5wdXNoKFwiXCIuY29uY2F0KHQsXCI6IFwiKS5jb25jYXQoZVt0XSxcIjtcIikpfX1yZXR1cm5cIlwiLmNvbmNhdChuKjEwMCxcIiUgeyBcIikuY29uY2F0KHIuam9pbihcIiBcIiksXCIgfVwiKX0pKS5qb2luKFwiIFwiKX07dmFyIGtleWZyYW1lSWRzPVtdO3ZhciBnZW5lcmF0ZUtleWZyYW1lTmFtZT1mdW5jdGlvbihlKXt2YXIgbj1rZXlmcmFtZUlkcy5pbmRleE9mKGUpO2lmKG48MCl7bj1rZXlmcmFtZUlkcy5wdXNoKGUpLTF9cmV0dXJuXCJpb24tYW5pbWF0aW9uLVwiLmNvbmNhdChuKX07dmFyIGdldFN0eWxlQ29udGFpbmVyPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZ2V0Um9vdE5vZGUoKTtyZXR1cm4gbi5oZWFkfHxufTt2YXIgY3JlYXRlS2V5ZnJhbWVTdHlsZXNoZWV0PWZ1bmN0aW9uKGUsbixyKXt2YXIgdD1nZXRTdHlsZUNvbnRhaW5lcihyKTt2YXIgYT1nZXRBbmltYXRpb25QcmVmaXgocik7dmFyIGk9dC5xdWVyeVNlbGVjdG9yKFwiI1wiK2UpO2lmKGkpe3JldHVybiBpfXZhciBvPShyLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50KS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by5pZD1lO28udGV4dENvbnRlbnQ9XCJAXCIuY29uY2F0KGEsXCJrZXlmcmFtZXMgXCIpLmNvbmNhdChlLFwiIHsgXCIpLmNvbmNhdChuLFwiIH0gQFwiKS5jb25jYXQoYSxcImtleWZyYW1lcyBcIikuY29uY2F0KGUsXCItYWx0IHsgXCIpLmNvbmNhdChuLFwiIH1cIik7dC5hcHBlbmRDaGlsZChvKTtyZXR1cm4gb307dmFyIGFkZENsYXNzVG9BcnJheT1mdW5jdGlvbihlLG4pe2lmKGU9PT12b2lkIDApe2U9W119aWYobiE9PXVuZGVmaW5lZCl7dmFyIHI9QXJyYXkuaXNBcnJheShuKT9uOltuXTtyZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLGUsdHJ1ZSkscix0cnVlKX1yZXR1cm4gZX07dmFyIGNyZWF0ZUFuaW1hdGlvbj1mdW5jdGlvbihlKXt2YXIgbjt2YXIgcjt2YXIgdDt2YXIgYTt2YXIgaTt2YXIgbzt2YXIgZj1bXTt2YXIgdT1bXTt2YXIgYz1bXTt2YXIgcz1mYWxzZTt2YXIgdjt2YXIgbD17fTt2YXIgZD1bXTt2YXIgeT1bXTt2YXIgbT17fTt2YXIgcD0wO3ZhciBoPWZhbHNlO3ZhciBnPWZhbHNlO3ZhciBFO3ZhciBQO3ZhciBTO3ZhciBBO3ZhciBDPXRydWU7dmFyIFQ9ZmFsc2U7dmFyIGI9dHJ1ZTt2YXIgazt2YXIgdzt2YXIgeD1lO3ZhciBLPVtdO3ZhciBfPVtdO3ZhciBJPVtdO3ZhciBEPVtdO3ZhciBMPVtdO3ZhciBOPVtdO3ZhciBSPVtdO3ZhciBGPVtdO3ZhciBPPVtdO3ZhciBXPVtdO3ZhciBqPXR5cGVvZiBBbmltYXRpb25FZmZlY3Q9PT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiB3aW5kb3cuQW5pbWF0aW9uRWZmZWN0PT09XCJmdW5jdGlvblwiO3ZhciBIPXR5cGVvZiBFbGVtZW50PT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT09PVwiZnVuY3Rpb25cIiYmajt2YXIgTT0xMDA7dmFyICQ9ZnVuY3Rpb24oKXtyZXR1cm4gV307dmFyIHE9ZnVuY3Rpb24oZSl7RC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmRlc3Ryb3koZSl9KSk7eihlKTtJLmxlbmd0aD0wO0QubGVuZ3RoPTA7Zi5sZW5ndGg9MDtHKCk7cz1mYWxzZTtiPXRydWU7cmV0dXJuIHd9O3ZhciB6PWZ1bmN0aW9uKGUpe0ooKTtpZihlKXtRKCl9fTt2YXIgWj1mdW5jdGlvbigpe2g9ZmFsc2U7Zz1mYWxzZTtiPXRydWU7UD11bmRlZmluZWQ7Uz11bmRlZmluZWQ7QT11bmRlZmluZWQ7cD0wO1Q9ZmFsc2U7Qz10cnVlfTt2YXIgQj1mdW5jdGlvbihlLG4pe3ZhciByPW4mJm4ub25lVGltZUNhbGxiYWNrP186SztyLnB1c2goe2M6ZSxvOm59KTtyZXR1cm4gd307dmFyIEc9ZnVuY3Rpb24oKXtLLmxlbmd0aD0wO18ubGVuZ3RoPTA7cmV0dXJuIHd9O3ZhciBKPWZ1bmN0aW9uKCl7aWYoSCl7Vy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmNhbmNlbCgpfSkpO1cubGVuZ3RoPTB9ZWxzZXt2YXIgZT1JLnNsaWNlKCk7cmFmKChmdW5jdGlvbigpe2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLW5hbWVcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZGVsYXlcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZGlyZWN0aW9uXCIpfSkpfSkpfX07dmFyIFE9ZnVuY3Rpb24oKXtMLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGUmJmUucGFyZW50Tm9kZSl7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfX0pKTtMLmxlbmd0aD0wfTt2YXIgVT1mdW5jdGlvbihlKXtOLnB1c2goZSk7cmV0dXJuIHd9O3ZhciBWPWZ1bmN0aW9uKGUpe1IucHVzaChlKTtyZXR1cm4gd307dmFyIFg9ZnVuY3Rpb24oZSl7Ri5wdXNoKGUpO3JldHVybiB3fTt2YXIgWT1mdW5jdGlvbihlKXtPLnB1c2goZSk7cmV0dXJuIHd9O3ZhciBlZT1mdW5jdGlvbihlKXt1PWFkZENsYXNzVG9BcnJheSh1LGUpO3JldHVybiB3fTt2YXIgbmU9ZnVuY3Rpb24oZSl7Yz1hZGRDbGFzc1RvQXJyYXkoYyxlKTtyZXR1cm4gd307dmFyIHJlPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9e319bD1lO3JldHVybiB3fTt2YXIgdGU9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1bXX1mb3IodmFyIG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciB0PXJbbl07bFt0XT1cIlwifXJldHVybiB3fTt2YXIgYWU9ZnVuY3Rpb24oZSl7ZD1hZGRDbGFzc1RvQXJyYXkoZCxlKTtyZXR1cm4gd307dmFyIGllPWZ1bmN0aW9uKGUpe3k9YWRkQ2xhc3NUb0FycmF5KHksZSk7cmV0dXJuIHd9O3ZhciBvZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXt9fW09ZTtyZXR1cm4gd307dmFyIGZlPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9W119Zm9yKHZhciBuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgdD1yW25dO21bdF09XCJcIn1yZXR1cm4gd307dmFyIHVlPWZ1bmN0aW9uKCl7aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGl9aWYodil7cmV0dXJuIHYuZ2V0RmlsbCgpfXJldHVyblwiYm90aFwifTt2YXIgY2U9ZnVuY3Rpb24oKXtpZihQIT09dW5kZWZpbmVkKXtyZXR1cm4gUH1pZihvIT09dW5kZWZpbmVkKXtyZXR1cm4gb31pZih2KXtyZXR1cm4gdi5nZXREaXJlY3Rpb24oKX1yZXR1cm5cIm5vcm1hbFwifTt2YXIgc2U9ZnVuY3Rpb24oKXtpZihoKXtyZXR1cm5cImxpbmVhclwifWlmKHQhPT11bmRlZmluZWQpe3JldHVybiB0fWlmKHYpe3JldHVybiB2LmdldEVhc2luZygpfXJldHVyblwibGluZWFyXCJ9O3ZhciB2ZT1mdW5jdGlvbigpe2lmKGcpe3JldHVybiAwfWlmKFMhPT11bmRlZmluZWQpe3JldHVybiBTfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiByfWlmKHYpe3JldHVybiB2LmdldER1cmF0aW9uKCl9cmV0dXJuIDB9O3ZhciBsZT1mdW5jdGlvbigpe2lmKGEhPT11bmRlZmluZWQpe3JldHVybiBhfWlmKHYpe3JldHVybiB2LmdldEl0ZXJhdGlvbnMoKX1yZXR1cm4gMX07dmFyIGRlPWZ1bmN0aW9uKCl7aWYoQSE9PXVuZGVmaW5lZCl7cmV0dXJuIEF9aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG59aWYodil7cmV0dXJuIHYuZ2V0RGVsYXkoKX1yZXR1cm4gMH07dmFyIHllPWZ1bmN0aW9uKCl7cmV0dXJuIGZ9O3ZhciBtZT1mdW5jdGlvbihlKXtvPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBwZT1mdW5jdGlvbihlKXtpPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBoZT1mdW5jdGlvbihlKXtuPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBnZT1mdW5jdGlvbihlKXt0PWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBFZT1mdW5jdGlvbihlKXtpZighSCYmZT09PTApe2U9MX1yPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBQZT1mdW5jdGlvbihlKXthPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBTZT1mdW5jdGlvbihlKXt2PWU7cmV0dXJuIHd9O3ZhciBBZT1mdW5jdGlvbihlKXtpZihlIT1udWxsKXtpZihlLm5vZGVUeXBlPT09MSl7SS5wdXNoKGUpfWVsc2UgaWYoZS5sZW5ndGg+PTApe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXtJLnB1c2goZVtuXSl9fWVsc2V7Y29uc29sZS5lcnJvcihcIkludmFsaWQgYWRkRWxlbWVudCB2YWx1ZVwiKX19cmV0dXJuIHd9O3ZhciBDZT1mdW5jdGlvbihlKXtpZihlIT1udWxsKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciB0PXJbbl07dC5wYXJlbnQodyk7RC5wdXNoKHQpfX1lbHNle2UucGFyZW50KHcpO0QucHVzaChlKX19cmV0dXJuIHd9O3ZhciBUZT1mdW5jdGlvbihlKXt2YXIgbj1mIT09ZTtmPWU7aWYobil7YmUoZil9cmV0dXJuIHd9O3ZhciBiZT1mdW5jdGlvbihlKXtpZihIKXskKCkuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYobi5lZmZlY3Quc2V0S2V5ZnJhbWVzKXtuLmVmZmVjdC5zZXRLZXlmcmFtZXMoZSl9ZWxzZXt2YXIgcj1uZXcgS2V5ZnJhbWVFZmZlY3Qobi5lZmZlY3QudGFyZ2V0LGUsbi5lZmZlY3QuZ2V0VGltaW5nKCkpO24uZWZmZWN0PXJ9fSkpfWVsc2V7S2UoKX19O3ZhciBrZT1mdW5jdGlvbigpe04uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKTtSLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7dmFyIGU9dTt2YXIgbj1jO3ZhciByPWw7SS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT10LmNsYXNzTGlzdDtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFkZChlKX0pKTtuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBhLnJlbW92ZShlKX0pKTtmb3IodmFyIGkgaW4gcil7aWYoci5oYXNPd25Qcm9wZXJ0eShpKSl7c2V0U3R5bGVQcm9wZXJ0eSh0LGkscltpXSl9fX0pKX07dmFyIHdlPWZ1bmN0aW9uKCl7JGUoKTtGLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7Ty5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpO3ZhciBlPUM/MTowO3ZhciBuPWQ7dmFyIHI9eTt2YXIgdD1tO0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIGE9ZS5jbGFzc0xpc3Q7bi5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5hZGQoZSl9KSk7ci5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5yZW1vdmUoZSl9KSk7Zm9yKHZhciBpIGluIHQpe2lmKHQuaGFzT3duUHJvcGVydHkoaSkpe3NldFN0eWxlUHJvcGVydHkoZSxpLHRbaV0pfX19KSk7Sy5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbi5jKGUsdyl9KSk7Xy5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbi5jKGUsdyl9KSk7Xy5sZW5ndGg9MDtiPXRydWU7aWYoQyl7VD10cnVlfUM9dHJ1ZX07dmFyIHhlPWZ1bmN0aW9uKCl7aWYocD09PTApe3JldHVybn1wLS07aWYocD09PTApe3dlKCk7aWYodil7di5hbmltYXRpb25GaW5pc2goKX19fTt2YXIgS2U9ZnVuY3Rpb24obil7aWYobj09PXZvaWQgMCl7bj10cnVlfVEoKTt2YXIgcj1wcm9jZXNzS2V5ZnJhbWVzKGYpO0kuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoci5sZW5ndGg+MCl7dmFyIGE9Z2VuZXJhdGVLZXlmcmFtZVJ1bGVzKHIpO2s9ZSE9PXVuZGVmaW5lZD9lOmdlbmVyYXRlS2V5ZnJhbWVOYW1lKGEpO3ZhciBpPWNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldChrLGEsdCk7TC5wdXNoKGkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kdXJhdGlvblwiLFwiXCIuY29uY2F0KHZlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLHNlKCkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kZWxheVwiLFwiXCIuY29uY2F0KGRlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiLHVlKCkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kaXJlY3Rpb25cIixjZSgpKTt2YXIgbz1sZSgpPT09SW5maW5pdHk/XCJpbmZpbml0ZVwiOmxlKCkudG9TdHJpbmcoKTtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIsbyk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcInBhdXNlZFwiKTtpZihuKXtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24tbmFtZVwiLFwiXCIuY29uY2F0KGkuaWQsXCItYWx0XCIpKX1yYWYoKGZ1bmN0aW9uKCl7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLW5hbWVcIixpLmlkfHxudWxsKX0pKX19KSl9O3ZhciBfZT1mdW5jdGlvbigpe0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5hbmltYXRlKGYse2lkOngsZGVsYXk6ZGUoKSxkdXJhdGlvbjp2ZSgpLGVhc2luZzpzZSgpLGl0ZXJhdGlvbnM6bGUoKSxmaWxsOnVlKCksZGlyZWN0aW9uOmNlKCl9KTtuLnBhdXNlKCk7Vy5wdXNoKG4pfSkpO2lmKFcubGVuZ3RoPjApe1dbMF0ub25maW5pc2g9ZnVuY3Rpb24oKXt4ZSgpfX19O3ZhciBJZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXRydWV9a2UoKTtpZihmLmxlbmd0aD4wKXtpZihIKXtfZSgpfWVsc2V7S2UoZSl9fXM9dHJ1ZX07dmFyIERlPWZ1bmN0aW9uKGUpe2U9TWF0aC5taW4oTWF0aC5tYXgoZSwwKSwuOTk5OSk7aWYoSCl7Vy5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmN1cnJlbnRUaW1lPW4uZWZmZWN0LmdldENvbXB1dGVkVGltaW5nKCkuZGVsYXkrdmUoKSplO24ucGF1c2UoKX0pKX1lbHNle3ZhciBuPVwiLVwiLmNvbmNhdCh2ZSgpKmUsXCJtc1wiKTtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGYubGVuZ3RoPjApe3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1kZWxheVwiLG4pO3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJwYXVzZWRcIil9fSkpfX07dmFyIExlPWZ1bmN0aW9uKGUpe1cuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5lZmZlY3QudXBkYXRlVGltaW5nKHtkZWxheTpkZSgpLGR1cmF0aW9uOnZlKCksZWFzaW5nOnNlKCksaXRlcmF0aW9uczpsZSgpLGZpbGw6dWUoKSxkaXJlY3Rpb246Y2UoKX0pfSkpO2lmKGUhPT11bmRlZmluZWQpe0RlKGUpfX07dmFyIE5lPWZ1bmN0aW9uKGUsbil7aWYoZT09PXZvaWQgMCl7ZT10cnVlfXJhZigoZnVuY3Rpb24oKXtJLmZvckVhY2goKGZ1bmN0aW9uKHIpe3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1uYW1lXCIsa3x8bnVsbCk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIsXCJcIi5jb25jYXQodmUoKSxcIm1zXCIpKTtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsc2UoKSk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWRlbGF5XCIsbiE9PXVuZGVmaW5lZD9cIi1cIi5jb25jYXQobip2ZSgpLFwibXNcIik6XCJcIi5jb25jYXQoZGUoKSxcIm1zXCIpKTtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tZmlsbC1tb2RlXCIsdWUoKXx8bnVsbCk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWRpcmVjdGlvblwiLGNlKCl8fG51bGwpO3ZhciB0PWxlKCk9PT1JbmZpbml0eT9cImluZmluaXRlXCI6bGUoKS50b1N0cmluZygpO3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIix0KTtpZihlKXtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tbmFtZVwiLFwiXCIuY29uY2F0KGssXCItYWx0XCIpKX1yYWYoKGZ1bmN0aW9uKCl7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLW5hbWVcIixrfHxudWxsKX0pKX0pKX0pKX07dmFyIFJlPWZ1bmN0aW9uKGUsbixyKXtpZihlPT09dm9pZCAwKXtlPWZhbHNlfWlmKG49PT12b2lkIDApe249dHJ1ZX1pZihlKXtELmZvckVhY2goKGZ1bmN0aW9uKHQpe3QudXBkYXRlKGUsbixyKX0pKX1pZihIKXtMZShyKX1lbHNle05lKG4scil9cmV0dXJuIHd9O3ZhciBGZT1mdW5jdGlvbihlLG4pe2lmKGU9PT12b2lkIDApe2U9ZmFsc2V9RC5mb3JFYWNoKChmdW5jdGlvbihyKXtyLnByb2dyZXNzU3RhcnQoZSxuKX0pKTtqZSgpO2g9ZTtpZighcyl7SWUoKX1SZShmYWxzZSx0cnVlLG4pO3JldHVybiB3fTt2YXIgT2U9ZnVuY3Rpb24oZSl7RC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLnByb2dyZXNzU3RlcChlKX0pKTtEZShlKTtyZXR1cm4gd307dmFyIFdlPWZ1bmN0aW9uKGUsbixyKXtoPWZhbHNlO0QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wcm9ncmVzc0VuZChlLG4scil9KSk7aWYociE9PXVuZGVmaW5lZCl7Uz1yfVQ9ZmFsc2U7Qz10cnVlO2lmKGU9PT0wKXtQPWNlKCk9PT1cInJldmVyc2VcIj9cIm5vcm1hbFwiOlwicmV2ZXJzZVwiO2lmKFA9PT1cInJldmVyc2VcIil7Qz1mYWxzZX1pZihIKXtSZSgpO0RlKDEtbil9ZWxzZXtBPSgxLW4pKnZlKCkqLTE7UmUoZmFsc2UsZmFsc2UpfX1lbHNlIGlmKGU9PT0xKXtpZihIKXtSZSgpO0RlKG4pfWVsc2V7QT1uKnZlKCkqLTE7UmUoZmFsc2UsZmFsc2UpfX1pZihlIT09dW5kZWZpbmVkKXtCKChmdW5jdGlvbigpe1M9dW5kZWZpbmVkO1A9dW5kZWZpbmVkO0E9dW5kZWZpbmVkfSkse29uZVRpbWVDYWxsYmFjazp0cnVlfSk7aWYoIXYpe0dlKCl9fXJldHVybiB3fTt2YXIgamU9ZnVuY3Rpb24oKXtpZihzKXtpZihIKXtXLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGF1c2UoKX0pKX1lbHNle0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7c2V0U3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcInBhdXNlZFwiKX0pKX19fTt2YXIgSGU9ZnVuY3Rpb24oKXtELmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGF1c2UoKX0pKTtqZSgpO3JldHVybiB3fTt2YXIgTWU9ZnVuY3Rpb24oKXtFPXVuZGVmaW5lZDt4ZSgpfTt2YXIgJGU9ZnVuY3Rpb24oKXtpZihFKXtjbGVhclRpbWVvdXQoRSl9fTt2YXIgcWU9ZnVuY3Rpb24oKXskZSgpO3JhZigoZnVuY3Rpb24oKXtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGYubGVuZ3RoPjApe3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJydW5uaW5nXCIpfX0pKX0pKTtpZihmLmxlbmd0aD09PTB8fEkubGVuZ3RoPT09MCl7eGUoKX1lbHNle3ZhciBlPWRlKCl8fDA7dmFyIG49dmUoKXx8MDt2YXIgcj1sZSgpfHwxO2lmKGlzRmluaXRlKHIpKXtFPXNldFRpbWVvdXQoTWUsZStuKnIrTSl9YW5pbWF0aW9uRW5kKElbMF0sKGZ1bmN0aW9uKCl7JGUoKTtyYWYoKGZ1bmN0aW9uKCl7emUoKTtyYWYoeGUpfSkpfSkpfX07dmFyIHplPWZ1bmN0aW9uKCl7SS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZHVyYXRpb25cIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWRlbGF5XCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIpfSkpfTt2YXIgWmU9ZnVuY3Rpb24oKXtXLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGxheSgpfSkpO2lmKGYubGVuZ3RoPT09MHx8SS5sZW5ndGg9PT0wKXt4ZSgpfX07dmFyIEJlPWZ1bmN0aW9uKCl7aWYoSCl7RGUoMCk7TGUoKX1lbHNle05lKCl9fTt2YXIgR2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtpZihlJiZlLnN5bmMpe2c9dHJ1ZTtCKChmdW5jdGlvbigpe3JldHVybiBnPWZhbHNlfSkse29uZVRpbWVDYWxsYmFjazp0cnVlfSl9aWYoIXMpe0llKCl9aWYoVCl7QmUoKTtUPWZhbHNlfWlmKGIpe3A9RC5sZW5ndGgrMTtiPWZhbHNlfUIoKGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pLHtvbmVUaW1lQ2FsbGJhY2s6dHJ1ZX0pO0QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5wbGF5KCl9KSk7aWYoSCl7WmUoKX1lbHNle3FlKCl9fSkpfTt2YXIgSmU9ZnVuY3Rpb24oKXtELmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uuc3RvcCgpfSkpO2lmKHMpe0ooKTtzPWZhbHNlfVooKX07dmFyIFFlPWZ1bmN0aW9uKGUsbil7dmFyIHI7dmFyIHQ9ZlswXTtpZih0IT09dW5kZWZpbmVkJiYodC5vZmZzZXQ9PT11bmRlZmluZWR8fHQub2Zmc2V0PT09MCkpe3RbZV09bn1lbHNle2Y9X19zcHJlYWRBcnJheShbKHI9e29mZnNldDowfSxyW2VdPW4scildLGYsdHJ1ZSl9cmV0dXJuIHd9O3ZhciBVZT1mdW5jdGlvbihlLG4pe3ZhciByO3ZhciB0PWZbZi5sZW5ndGgtMV07aWYodCE9PXVuZGVmaW5lZCYmKHQub2Zmc2V0PT09dW5kZWZpbmVkfHx0Lm9mZnNldD09PTEpKXt0W2VdPW59ZWxzZXtmPV9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxmLHRydWUpLFsocj17b2Zmc2V0OjF9LHJbZV09bixyKV0sZmFsc2UpfXJldHVybiB3fTt2YXIgVmU9ZnVuY3Rpb24oZSxuLHIpe3JldHVybiBRZShlLG4pLnRvKGUscil9O3JldHVybiB3PXtwYXJlbnRBbmltYXRpb246dixlbGVtZW50czpJLGNoaWxkQW5pbWF0aW9uczpELGlkOngsYW5pbWF0aW9uRmluaXNoOnhlLGZyb206UWUsdG86VWUsZnJvbVRvOlZlLHBhcmVudDpTZSxwbGF5OkdlLHBhdXNlOkhlLHN0b3A6SmUsZGVzdHJveTpxLGtleWZyYW1lczpUZSxhZGRBbmltYXRpb246Q2UsYWRkRWxlbWVudDpBZSx1cGRhdGU6UmUsZmlsbDpwZSxkaXJlY3Rpb246bWUsaXRlcmF0aW9uczpQZSxkdXJhdGlvbjpFZSxlYXNpbmc6Z2UsZGVsYXk6aGUsZ2V0V2ViQW5pbWF0aW9uczokLGdldEtleWZyYW1lczp5ZSxnZXRGaWxsOnVlLGdldERpcmVjdGlvbjpjZSxnZXREZWxheTpkZSxnZXRJdGVyYXRpb25zOmxlLGdldEVhc2luZzpzZSxnZXREdXJhdGlvbjp2ZSxhZnRlckFkZFJlYWQ6WCxhZnRlckFkZFdyaXRlOlksYWZ0ZXJDbGVhclN0eWxlczpmZSxhZnRlclN0eWxlczpvZSxhZnRlclJlbW92ZUNsYXNzOmllLGFmdGVyQWRkQ2xhc3M6YWUsYmVmb3JlQWRkUmVhZDpVLGJlZm9yZUFkZFdyaXRlOlYsYmVmb3JlQ2xlYXJTdHlsZXM6dGUsYmVmb3JlU3R5bGVzOnJlLGJlZm9yZVJlbW92ZUNsYXNzOm5lLGJlZm9yZUFkZENsYXNzOmVlLG9uRmluaXNoOkIscHJvZ3Jlc3NTdGFydDpGZSxwcm9ncmVzc1N0ZXA6T2UscHJvZ3Jlc3NFbmQ6V2V9fTtleHBvcnR7Y3JlYXRlQW5pbWF0aW9uIGFzIGN9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7434\n')},3544:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "g": () => (/* binding */ getTimeGivenProgression)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar getTimeGivenProgression=function(t,r,a,e,o){return solveCubicBezier(t[1],r[1],a[1],e[1],o).map((function(o){return solveCubicParametricEquation(t[0],r[0],a[0],e[0],o)}))};var solveCubicParametricEquation=function(t,r,a,e,o){var i=3*r*Math.pow(o-1,2);var n=-3*a*o+3*a+e*o;var u=t*Math.pow(o-1,3);return o*(i+o*n)-u};var solveCubicBezier=function(t,r,a,e,o){t-=o;r-=o;a-=o;e-=o;var i=solveCubicEquation(e-3*a+3*r-t,3*a-6*r+3*t,3*r-3*t,t);return i.filter((function(t){return t>=0&&t<=1}))};var solveQuadraticEquation=function(t,r,a){var e=r*r-4*t*a;if(e<0){return[]}else{return[(-r+Math.sqrt(e))/(2*t),(-r-Math.sqrt(e))/(2*t)]}};var solveCubicEquation=function(t,r,a,e){if(t===0){return solveQuadraticEquation(r,a,e)}r/=t;a/=t;e/=t;var o=(3*a-r*r)/3;var i=(2*r*r*r-9*r*a+27*e)/27;if(o===0){return[Math.pow(-i,1/3)]}else if(i===0){return[Math.sqrt(-o),-Math.sqrt(-o)]}var n=Math.pow(i/2,2)+Math.pow(o/3,3);if(n===0){return[Math.pow(i/2,1/2)-r/3]}else if(n>0){return[Math.pow(-(i/2)+Math.sqrt(n),1/3)-Math.pow(i/2+Math.sqrt(n),1/3)-r/3]}var u=Math.sqrt(Math.pow(-(o/3),3));var s=Math.acos(-(i/(2*Math.sqrt(Math.pow(-(o/3),3)))));var v=2*Math.pow(u,1/3);return[v*Math.cos(s/3)-r/3,v*Math.cos((s+2*Math.PI)/3)-r/3,v*Math.cos((s+4*Math.PI)/3)-r/3]};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdFQUFnRSwyREFBMkQsSUFBSSxxREFBcUQsMEJBQTBCLHFCQUFxQix3QkFBd0Isb0JBQW9CLHlDQUF5QyxLQUFLLEtBQUssS0FBSyxLQUFLLDREQUE0RCw2QkFBNkIsa0JBQWtCLElBQUksMkNBQTJDLGdCQUFnQixRQUFRLFNBQVMsS0FBSywwREFBMEQseUNBQXlDLFVBQVUscUNBQXFDLEtBQUssS0FBSyxLQUFLLGtCQUFrQiw4QkFBOEIsVUFBVSx5QkFBeUIsZUFBZSxxQ0FBcUMsc0NBQXNDLFVBQVUsOEJBQThCLGFBQWEsNkVBQTZFLG9DQUFvQyx3REFBd0Qsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvY3ViaWMtYmV6aWVyLTE1NGE1M2E1LmpzPzA0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbnZhciBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbj1mdW5jdGlvbih0LHIsYSxlLG8pe3JldHVybiBzb2x2ZUN1YmljQmV6aWVyKHRbMV0sclsxXSxhWzFdLGVbMV0sbykubWFwKChmdW5jdGlvbihvKXtyZXR1cm4gc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbih0WzBdLHJbMF0sYVswXSxlWzBdLG8pfSkpfTt2YXIgc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbj1mdW5jdGlvbih0LHIsYSxlLG8pe3ZhciBpPTMqcipNYXRoLnBvdyhvLTEsMik7dmFyIG49LTMqYSpvKzMqYStlKm87dmFyIHU9dCpNYXRoLnBvdyhvLTEsMyk7cmV0dXJuIG8qKGkrbypuKS11fTt2YXIgc29sdmVDdWJpY0Jlemllcj1mdW5jdGlvbih0LHIsYSxlLG8pe3QtPW87ci09bzthLT1vO2UtPW87dmFyIGk9c29sdmVDdWJpY0VxdWF0aW9uKGUtMyphKzMqci10LDMqYS02KnIrMyp0LDMqci0zKnQsdCk7cmV0dXJuIGkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdD49MCYmdDw9MX0pKX07dmFyIHNvbHZlUXVhZHJhdGljRXF1YXRpb249ZnVuY3Rpb24odCxyLGEpe3ZhciBlPXIqci00KnQqYTtpZihlPDApe3JldHVybltdfWVsc2V7cmV0dXJuWygtcitNYXRoLnNxcnQoZSkpLygyKnQpLCgtci1NYXRoLnNxcnQoZSkpLygyKnQpXX19O3ZhciBzb2x2ZUN1YmljRXF1YXRpb249ZnVuY3Rpb24odCxyLGEsZSl7aWYodD09PTApe3JldHVybiBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uKHIsYSxlKX1yLz10O2EvPXQ7ZS89dDt2YXIgbz0oMyphLXIqcikvMzt2YXIgaT0oMipyKnIqci05KnIqYSsyNyplKS8yNztpZihvPT09MCl7cmV0dXJuW01hdGgucG93KC1pLDEvMyldfWVsc2UgaWYoaT09PTApe3JldHVybltNYXRoLnNxcnQoLW8pLC1NYXRoLnNxcnQoLW8pXX12YXIgbj1NYXRoLnBvdyhpLzIsMikrTWF0aC5wb3coby8zLDMpO2lmKG49PT0wKXtyZXR1cm5bTWF0aC5wb3coaS8yLDEvMiktci8zXX1lbHNlIGlmKG4+MCl7cmV0dXJuW01hdGgucG93KC0oaS8yKStNYXRoLnNxcnQobiksMS8zKS1NYXRoLnBvdyhpLzIrTWF0aC5zcXJ0KG4pLDEvMyktci8zXX12YXIgdT1NYXRoLnNxcnQoTWF0aC5wb3coLShvLzMpLDMpKTt2YXIgcz1NYXRoLmFjb3MoLShpLygyKk1hdGguc3FydChNYXRoLnBvdygtKG8vMyksMykpKSkpO3ZhciB2PTIqTWF0aC5wb3codSwxLzMpO3JldHVyblt2Kk1hdGguY29zKHMvMyktci8zLHYqTWF0aC5jb3MoKHMrMipNYXRoLlBJKS8zKS1yLzMsdipNYXRoLmNvcygocys0Kk1hdGguUEkpLzMpLXIvM119O2V4cG9ydHtnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbiBhcyBnfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3544\n')},4988:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "G": () => (/* binding */ GESTURE_CONTROLLER)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar GestureController=function(){function t(){this.gestureId=0;this.requestedStart=new Map;this.disabledGestures=new Map;this.disabledScroll=new Set}t.prototype.createGesture=function(t){return new GestureDelegate(this,this.newID(),t.name,t.priority||0,!!t.disableScroll)};t.prototype.createBlocker=function(t){if(t===void 0){t={}}return new BlockerDelegate(this,this.newID(),t.disable,!!t.disableScroll)};t.prototype.start=function(t,e,r){if(!this.canStart(t)){this.requestedStart.delete(e);return false}this.requestedStart.set(e,r);return true};t.prototype.capture=function(t,e,r){if(!this.start(t,e,r)){return false}var i=this.requestedStart;var s=-1e4;i.forEach((function(t){s=Math.max(s,t)}));if(s===r){this.capturedId=e;i.clear();var l=new CustomEvent("ionGestureCaptured",{detail:{gestureName:t}});document.dispatchEvent(l);return true}i.delete(e);return false};t.prototype.release=function(t){this.requestedStart.delete(t);if(this.capturedId===t){this.capturedId=undefined}};t.prototype.disableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r===undefined){r=new Set;this.disabledGestures.set(t,r)}r.add(e)};t.prototype.enableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r!==undefined){r.delete(e)}};t.prototype.disableScroll=function(t){this.disabledScroll.add(t);if(this.disabledScroll.size===1){document.body.classList.add(BACKDROP_NO_SCROLL)}};t.prototype.enableScroll=function(t){this.disabledScroll.delete(t);if(this.disabledScroll.size===0){document.body.classList.remove(BACKDROP_NO_SCROLL)}};t.prototype.canStart=function(t){if(this.capturedId!==undefined){return false}if(this.isDisabled(t)){return false}return true};t.prototype.isCaptured=function(){return this.capturedId!==undefined};t.prototype.isScrollDisabled=function(){return this.disabledScroll.size>0};t.prototype.isDisabled=function(t){var e=this.disabledGestures.get(t);if(e&&e.size>0){return true}return false};t.prototype.newID=function(){this.gestureId++;return this.gestureId};return t}();var GestureDelegate=function(){function t(t,e,r,i,s){this.id=e;this.name=r;this.disableScroll=s;this.priority=i*1e6+e;this.ctrl=t}t.prototype.canStart=function(){if(!this.ctrl){return false}return this.ctrl.canStart(this.name)};t.prototype.start=function(){if(!this.ctrl){return false}return this.ctrl.start(this.name,this.id,this.priority)};t.prototype.capture=function(){if(!this.ctrl){return false}var t=this.ctrl.capture(this.name,this.id,this.priority);if(t&&this.disableScroll){this.ctrl.disableScroll(this.id)}return t};t.prototype.release=function(){if(this.ctrl){this.ctrl.release(this.id);if(this.disableScroll){this.ctrl.enableScroll(this.id)}}};t.prototype.destroy=function(){this.release();this.ctrl=undefined};return t}();var BlockerDelegate=function(){function t(t,e,r,i){this.id=e;this.disable=r;this.disableScroll=i;this.ctrl=t}t.prototype.block=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.disableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.disableScroll(this.id)}};t.prototype.unblock=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.enableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.enableScroll(this.id)}};t.prototype.destroy=function(){this.unblock();this.ctrl=undefined};return t}();var BACKDROP_NO_SCROLL="backdrop-no-scroll";var GESTURE_CONTROLLER=new GestureController;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk4OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsaUJBQWlCLDRCQUE0Qiw4QkFBOEIsNEJBQTRCLHNDQUFzQyxzRkFBc0Ysc0NBQXNDLGVBQWUsS0FBSywyRUFBMkUsa0NBQWtDLHNCQUFzQiw4QkFBOEIsYUFBYSw2QkFBNkIsYUFBYSxvQ0FBb0MsdUJBQXVCLGFBQWEsMEJBQTBCLFdBQVcsdUJBQXVCLGdCQUFnQixHQUFHLFVBQVUsa0JBQWtCLFVBQVUsNENBQTRDLFFBQVEsZUFBZSxFQUFFLDBCQUEwQixZQUFZLFlBQVksY0FBYyxnQ0FBZ0MsOEJBQThCLHdCQUF3Qiw0QkFBNEIseUNBQXlDLG1DQUFtQyxrQkFBa0IsVUFBVSwrQkFBK0IsVUFBVSx3Q0FBd0MsbUNBQW1DLGtCQUFrQixjQUFjLHNDQUFzQywyQkFBMkIsaUNBQWlDLGtEQUFrRCxxQ0FBcUMsOEJBQThCLGlDQUFpQyxxREFBcUQsaUNBQWlDLGdDQUFnQyxhQUFhLHVCQUF1QixhQUFhLGFBQWEsa0NBQWtDLG9DQUFvQyx3Q0FBd0MsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsZ0JBQWdCLFlBQVksY0FBYyw2QkFBNkIsaUJBQWlCLHVCQUF1QixTQUFTLEdBQUcsK0JBQStCLHNCQUFzQixVQUFVLFlBQVkscUJBQXFCLHNCQUFzQixZQUFZLGdDQUFnQyxlQUFlLGFBQWEsc0NBQXNDLDZCQUE2QixlQUFlLGFBQWEseURBQXlELCtCQUErQixlQUFlLGFBQWEseURBQXlELDBCQUEwQixpQ0FBaUMsVUFBVSwrQkFBK0IsY0FBYywyQkFBMkIsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxxQkFBcUIsU0FBUyxHQUFHLCtCQUErQixvQkFBb0IsVUFBVSxlQUFlLHFCQUFxQixZQUFZLDZCQUE2QixlQUFlLE9BQU8saUJBQWlCLDJCQUEyQixXQUFXLEtBQUssV0FBVyxxQ0FBcUMsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxPQUFPLGlCQUFpQiwyQkFBMkIsV0FBVyxLQUFLLFdBQVcsb0NBQW9DLHVCQUF1QixrQ0FBa0MsK0JBQStCLGVBQWUscUJBQXFCLFNBQVMsR0FBRyw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9nZXN0dXJlLWNvbnRyb2xsZXItNjhjMDIzYTQuanM/NGFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xudmFyIEdlc3R1cmVDb250cm9sbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuZ2VzdHVyZUlkPTA7dGhpcy5yZXF1ZXN0ZWRTdGFydD1uZXcgTWFwO3RoaXMuZGlzYWJsZWRHZXN0dXJlcz1uZXcgTWFwO3RoaXMuZGlzYWJsZWRTY3JvbGw9bmV3IFNldH10LnByb3RvdHlwZS5jcmVhdGVHZXN0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgR2VzdHVyZURlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQubmFtZSx0LnByaW9yaXR5fHwwLCEhdC5kaXNhYmxlU2Nyb2xsKX07dC5wcm90b3R5cGUuY3JlYXRlQmxvY2tlcj1mdW5jdGlvbih0KXtpZih0PT09dm9pZCAwKXt0PXt9fXJldHVybiBuZXcgQmxvY2tlckRlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQuZGlzYWJsZSwhIXQuZGlzYWJsZVNjcm9sbCl9O3QucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHQsZSxyKXtpZighdGhpcy5jYW5TdGFydCh0KSl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUoZSk7cmV0dXJuIGZhbHNlfXRoaXMucmVxdWVzdGVkU3RhcnQuc2V0KGUscik7cmV0dXJuIHRydWV9O3QucHJvdG90eXBlLmNhcHR1cmU9ZnVuY3Rpb24odCxlLHIpe2lmKCF0aGlzLnN0YXJ0KHQsZSxyKSl7cmV0dXJuIGZhbHNlfXZhciBpPXRoaXMucmVxdWVzdGVkU3RhcnQ7dmFyIHM9LTFlNDtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3M9TWF0aC5tYXgocyx0KX0pKTtpZihzPT09cil7dGhpcy5jYXB0dXJlZElkPWU7aS5jbGVhcigpO3ZhciBsPW5ldyBDdXN0b21FdmVudChcImlvbkdlc3R1cmVDYXB0dXJlZFwiLHtkZXRhaWw6e2dlc3R1cmVOYW1lOnR9fSk7ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChsKTtyZXR1cm4gdHJ1ZX1pLmRlbGV0ZShlKTtyZXR1cm4gZmFsc2V9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24odCl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUodCk7aWYodGhpcy5jYXB0dXJlZElkPT09dCl7dGhpcy5jYXB0dXJlZElkPXVuZGVmaW5lZH19O3QucHJvdG90eXBlLmRpc2FibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyPT09dW5kZWZpbmVkKXtyPW5ldyBTZXQ7dGhpcy5kaXNhYmxlZEdlc3R1cmVzLnNldCh0LHIpfXIuYWRkKGUpfTt0LnByb3RvdHlwZS5lbmFibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyIT09dW5kZWZpbmVkKXtyLmRlbGV0ZShlKX19O3QucHJvdG90eXBlLmRpc2FibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5hZGQodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MSl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5lbmFibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5kZWxldGUodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MCl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5jYW5TdGFydD1mdW5jdGlvbih0KXtpZih0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1pZih0aGlzLmlzRGlzYWJsZWQodCkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX07dC5wcm90b3R5cGUuaXNDYXB0dXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWR9O3QucHJvdG90eXBlLmlzU2Nyb2xsRGlzYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPjB9O3QucHJvdG90eXBlLmlzRGlzYWJsZWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihlJiZlLnNpemU+MCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LnByb3RvdHlwZS5uZXdJRD1mdW5jdGlvbigpe3RoaXMuZ2VzdHVyZUlkKys7cmV0dXJuIHRoaXMuZ2VzdHVyZUlkfTtyZXR1cm4gdH0oKTt2YXIgR2VzdHVyZURlbGVnYXRlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpLHMpe3RoaXMuaWQ9ZTt0aGlzLm5hbWU9cjt0aGlzLmRpc2FibGVTY3JvbGw9czt0aGlzLnByaW9yaXR5PWkqMWU2K2U7dGhpcy5jdHJsPXR9dC5wcm90b3R5cGUuY2FuU3RhcnQ9ZnVuY3Rpb24oKXtpZighdGhpcy5jdHJsKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRoaXMuY3RybC5jYW5TdGFydCh0aGlzLm5hbWUpfTt0LnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe2lmKCF0aGlzLmN0cmwpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5jdHJsLnN0YXJ0KHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpfTt0LnByb3RvdHlwZS5jYXB0dXJlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJuIGZhbHNlfXZhciB0PXRoaXMuY3RybC5jYXB0dXJlKHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpO2lmKHQmJnRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9cmV0dXJuIHR9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24oKXtpZih0aGlzLmN0cmwpe3RoaXMuY3RybC5yZWxlYXNlKHRoaXMuaWQpO2lmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmVuYWJsZVNjcm9sbCh0aGlzLmlkKX19fTt0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5yZWxlYXNlKCk7dGhpcy5jdHJsPXVuZGVmaW5lZH07cmV0dXJuIHR9KCk7dmFyIEJsb2NrZXJEZWxlZ2F0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsaSl7dGhpcy5pZD1lO3RoaXMuZGlzYWJsZT1yO3RoaXMuZGlzYWJsZVNjcm9sbD1pO3RoaXMuY3RybD10fXQucHJvdG90eXBlLmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmRpc2FibGVHZXN0dXJlKHIsdGhpcy5pZCl9fWlmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9fTt0LnByb3RvdHlwZS51bmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmVuYWJsZUdlc3R1cmUocix0aGlzLmlkKX19aWYodGhpcy5kaXNhYmxlU2Nyb2xsKXt0aGlzLmN0cmwuZW5hYmxlU2Nyb2xsKHRoaXMuaWQpfX07dC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5ibG9jaygpO3RoaXMuY3RybD11bmRlZmluZWR9O3JldHVybiB0fSgpO3ZhciBCQUNLRFJPUF9OT19TQ1JPTEw9XCJiYWNrZHJvcC1uby1zY3JvbGxcIjt2YXIgR0VTVFVSRV9DT05UUk9MTEVSPW5ldyBHZXN0dXJlQ29udHJvbGxlcjtleHBvcnR7R0VTVFVSRV9DT05UUk9MTEVSIGFzIEd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4988\n')},7292:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MENU_BACK_BUTTON_PRIORITY": () => (/* binding */ MENU_BACK_BUTTON_PRIORITY),\n/* harmony export */   "OVERLAY_BACK_BUTTON_PRIORITY": () => (/* binding */ OVERLAY_BACK_BUTTON_PRIORITY),\n/* harmony export */   "blockHardwareBackButton": () => (/* binding */ blockHardwareBackButton),\n/* harmony export */   "startHardwareBackButton": () => (/* binding */ startHardwareBackButton)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var blockHardwareBackButton=function(){document.addEventListener("backbutton",(function(){}))};var startHardwareBackButton=function(){var r=document;var t=false;r.addEventListener("backbutton",(function(){if(t){return}var n=0;var e=[];var a=new CustomEvent("ionBackButton",{bubbles:false,detail:{register:function(r,t){e.push({priority:r,handler:t,id:n++})}}});r.dispatchEvent(a);var i=function(r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(e){switch(e.label){case 0:e.trys.push([0,3,,4]);if(!(r&&r.handler))return[3,2];t=r.handler(o);if(!(t!=null))return[3,2];return[4,t];case 1:e.sent();e.label=2;case 2:return[3,4];case 3:n=e.sent();console.error(n);return[3,4];case 4:return[2]}}))}))};var o=function(){if(e.length>0){var r={priority:Number.MIN_SAFE_INTEGER,handler:function(){return undefined},id:-1};e.forEach((function(t){if(t.priority>=r.priority){r=t}}));t=true;e=e.filter((function(t){return t.id!==r.id}));i(r).then((function(){return t=false}))}};o()}))};var OVERLAY_BACK_BUTTON_PRIORITY=100;var MENU_BACK_BUTTON_PRIORITY=99;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0EsMENBQTBDLG9EQUFvRCxJQUFJLHVDQUF1QyxlQUFlLFlBQVksNENBQTRDLE1BQU0sT0FBTyxRQUFRLFNBQVMsdUNBQXVDLHNCQUFzQix1QkFBdUIsUUFBUSw0QkFBNEIsSUFBSSxFQUFFLG1CQUFtQixrQkFBa0IsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0IsNkJBQTZCLCtCQUErQixlQUFlLDBCQUEwQixZQUFZLGdCQUFnQixVQUFVLG1CQUFtQixrQkFBa0IsaUJBQWlCLFlBQVksa0JBQWtCLEdBQUcsSUFBSSxpQkFBaUIsZUFBZSxPQUFPLG9EQUFvRCxpQkFBaUIsUUFBUSx1QkFBdUIsMkJBQTJCLEtBQUssR0FBRyxPQUFPLHdCQUF3QixtQkFBbUIsR0FBRyxzQkFBc0IsZUFBZSxLQUFLLElBQUksSUFBSSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9oYXJkd2FyZS1iYWNrLWJ1dHRvbi1hY2U2YTcxYi5qcz85NWRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtfX2F3YWl0ZXIsX19nZW5lcmF0b3J9ZnJvbVwidHNsaWJcIjtcbi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovdmFyIGJsb2NrSGFyZHdhcmVCYWNrQnV0dG9uPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJhY2tidXR0b25cIiwoZnVuY3Rpb24oKXt9KSl9O3ZhciBzdGFydEhhcmR3YXJlQmFja0J1dHRvbj1mdW5jdGlvbigpe3ZhciByPWRvY3VtZW50O3ZhciB0PWZhbHNlO3IuYWRkRXZlbnRMaXN0ZW5lcihcImJhY2tidXR0b25cIiwoZnVuY3Rpb24oKXtpZih0KXtyZXR1cm59dmFyIG49MDt2YXIgZT1bXTt2YXIgYT1uZXcgQ3VzdG9tRXZlbnQoXCJpb25CYWNrQnV0dG9uXCIse2J1YmJsZXM6ZmFsc2UsZGV0YWlsOntyZWdpc3RlcjpmdW5jdGlvbihyLHQpe2UucHVzaCh7cHJpb3JpdHk6cixoYW5kbGVyOnQsaWQ6bisrfSl9fX0pO3IuZGlzcGF0Y2hFdmVudChhKTt2YXIgaT1mdW5jdGlvbihyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6ZS50cnlzLnB1c2goWzAsMywsNF0pO2lmKCEociYmci5oYW5kbGVyKSlyZXR1cm5bMywyXTt0PXIuaGFuZGxlcihvKTtpZighKHQhPW51bGwpKXJldHVyblszLDJdO3JldHVybls0LHRdO2Nhc2UgMTplLnNlbnQoKTtlLmxhYmVsPTI7Y2FzZSAyOnJldHVyblszLDRdO2Nhc2UgMzpuPWUuc2VudCgpO2NvbnNvbGUuZXJyb3Iobik7cmV0dXJuWzMsNF07Y2FzZSA0OnJldHVyblsyXX19KSl9KSl9O3ZhciBvPWZ1bmN0aW9uKCl7aWYoZS5sZW5ndGg+MCl7dmFyIHI9e3ByaW9yaXR5Ok51bWJlci5NSU5fU0FGRV9JTlRFR0VSLGhhbmRsZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdW5kZWZpbmVkfSxpZDotMX07ZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZih0LnByaW9yaXR5Pj1yLnByaW9yaXR5KXtyPXR9fSkpO3Q9dHJ1ZTtlPWUuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZCE9PXIuaWR9KSk7aShyKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0PWZhbHNlfSkpfX07bygpfSkpfTt2YXIgT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWT0xMDA7dmFyIE1FTlVfQkFDS19CVVRUT05fUFJJT1JJVFk9OTk7ZXhwb3J0e01FTlVfQkFDS19CVVRUT05fUFJJT1JJVFksT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWSxibG9ja0hhcmR3YXJlQmFja0J1dHRvbixzdGFydEhhcmR3YXJlQmFja0J1dHRvbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7292\n')},7504:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ addEventListener),\n/* harmony export */   "b": () => (/* binding */ removeEventListener),\n/* harmony export */   "c": () => (/* binding */ componentOnReady),\n/* harmony export */   "d": () => (/* binding */ getAriaLabel),\n/* harmony export */   "e": () => (/* binding */ renderHiddenInput),\n/* harmony export */   "f": () => (/* binding */ focusElement),\n/* harmony export */   "g": () => (/* binding */ getElementRoot),\n/* harmony export */   "h": () => (/* binding */ debounceEvent),\n/* harmony export */   "i": () => (/* binding */ inheritAttributes),\n/* harmony export */   "j": () => (/* binding */ findItemLabel),\n/* harmony export */   "k": () => (/* binding */ clamp),\n/* harmony export */   "l": () => (/* binding */ hasShadowDom),\n/* harmony export */   "m": () => (/* binding */ assert),\n/* harmony export */   "n": () => (/* binding */ isEndSide),\n/* harmony export */   "o": () => (/* binding */ debounce),\n/* harmony export */   "p": () => (/* binding */ pointerCoord),\n/* harmony export */   "q": () => (/* binding */ now),\n/* harmony export */   "r": () => (/* binding */ raf),\n/* harmony export */   "s": () => (/* binding */ shallowEqualStringMap),\n/* harmony export */   "t": () => (/* binding */ transitionEndAsync)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var transitionEndAsync=function(e,n){if(n===void 0){n=0}return new Promise((function(t){transitionEnd(e,n,t)}))};var transitionEnd=function(e,n,t){if(n===void 0){n=0}var r;var i;var a={passive:true};var o=500;var u=function(){if(r){r()}};var s=function(n){if(n===undefined||e===n.target){u();t(n)}};if(e){e.addEventListener("webkitTransitionEnd",s,a);e.addEventListener("transitionend",s,a);i=setTimeout(s,n+o);r=function(){if(i){clearTimeout(i);i=undefined}e.removeEventListener("webkitTransitionEnd",s,a);e.removeEventListener("transitionend",s,a)}}return u};var componentOnReady=function(e,n){if(e.componentOnReady){e.componentOnReady().then((function(e){return n(e)}))}else{raf((function(){return n(e)}))}};var inheritAttributes=function(e,n){if(n===void 0){n=[]}var t={};n.forEach((function(n){if(e.hasAttribute(n)){var r=e.getAttribute(n);if(r!==null){t[n]=e.getAttribute(n)}e.removeAttribute(n)}}));return t};var addEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_ael");if(o){return o(e,n,t,r)}else if(a._ael){return a._ael(e,n,t,r)}}}return e.addEventListener(n,t,r)};var removeEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_rel");if(o){return o(e,n,t,r)}else if(a._rel){return a._rel(e,n,t,r)}}}return e.removeEventListener(n,t,r)};var getElementRoot=function(e,n){if(n===void 0){n=e}return e.shadowRoot||n};var raf=function(e){if(typeof __zone_symbol__requestAnimationFrame==="function"){return __zone_symbol__requestAnimationFrame(e)}if(typeof requestAnimationFrame==="function"){return requestAnimationFrame(e)}return setTimeout(e)};var hasShadowDom=function(e){return!!e.shadowRoot&&!!e.attachShadow};var findItemLabel=function(e){var n=e.closest("ion-item");if(n){return n.querySelector("ion-label")}return null};var focusElement=function(e){e.focus();if(e.classList.contains("ion-focusable")){var n=e.closest("ion-app");if(n){n.setFocus([e])}}};var getAriaLabel=function(e,n){var t;var r=e.getAttribute("aria-labelledby");var i=e.id;var a=r!==null&&r.trim()!==""?r:n+"-lbl";var o=r!==null&&r.trim()!==""?document.getElementById(r):findItemLabel(e);if(o){if(r===null){o.id=a}t=o.textContent;o.setAttribute("aria-hidden","true")}else if(i.trim()!==""){o=document.querySelector(\'label[for="\'.concat(i,\'"]\'));if(o){if(o.id!==""){a=o.id}else{o.id=a="".concat(i,"-lbl")}t=o.textContent}}return{label:o,labelId:a,labelText:t}};var renderHiddenInput=function(e,n,t,r,i){if(e||hasShadowDom(n)){var a=n.querySelector("input.aux-input");if(!a){a=n.ownerDocument.createElement("input");a.type="hidden";a.classList.add("aux-input");n.appendChild(a)}a.disabled=i;a.name=t;a.value=r||""}};var clamp=function(e,n,t){return Math.max(e,Math.min(n,t))};var assert=function(e,n){if(!e){var t="ASSERT: "+n;console.error(t);debugger;throw new Error(t)}};var now=function(e){return e.timeStamp||Date.now()};var pointerCoord=function(e){if(e){var n=e.changedTouches;if(n&&n.length>0){var t=n[0];return{x:t.clientX,y:t.clientY}}if(e.pageX!==undefined){return{x:e.pageX,y:e.pageY}}}return{x:0,y:0}};var isEndSide=function(e){var n=document.dir==="rtl";switch(e){case"start":return n;case"end":return!n;default:throw new Error(\'"\'.concat(e,\'" is not a valid value for [side]. Use "start" or "end" instead.\'))}};var debounceEvent=function(e,n){var t=e._original||e;return{_original:e,emit:debounce(t.emit.bind(t),n)}};var debounce=function(e,n){if(n===void 0){n=0}var t;return function(){var r=[];for(var i=0;i<arguments.length;i++){r[i]=arguments[i]}clearTimeout(t);t=setTimeout.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e,n],r,false))}};var shallowEqualStringMap=function(e,n){e!==null&&e!==void 0?e:e={};n!==null&&n!==void 0?n:n={};if(e===n){return true}var t=Object.keys(e);if(t.length!==Object.keys(n).length){return false}for(var r=0,i=t;r<i.length;r++){var a=i[r];if(!(a in n)){return false}if(e[a]!==n[a]){return false}}return true};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUwNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxlQUFlLElBQUksZ0NBQWdDLHFCQUFxQixJQUFJLGtDQUFrQyxlQUFlLElBQUksTUFBTSxNQUFNLE9BQU8sY0FBYyxVQUFVLGlCQUFpQixNQUFNLE1BQU0sa0JBQWtCLGdDQUFnQyxJQUFJLE9BQU8sTUFBTSw4Q0FBOEMsd0NBQXdDLG9CQUFvQixhQUFhLE1BQU0sZ0JBQWdCLFlBQVksaURBQWlELDRDQUE0QyxVQUFVLG1DQUFtQyx1QkFBdUIsdUNBQXVDLFlBQVksR0FBRyxLQUFLLGdCQUFnQixZQUFZLEtBQUssb0NBQW9DLGVBQWUsS0FBSyxTQUFTLHVCQUF1QixzQkFBc0Isd0JBQXdCLGFBQWEsdUJBQXVCLHNCQUFzQixHQUFHLFVBQVUsdUNBQXVDLGdDQUFnQyxhQUFhLGlDQUFpQyxNQUFNLG9CQUFvQixNQUFNLGtCQUFrQixnQkFBZ0IseUJBQXlCLGtDQUFrQywwQ0FBMEMsZ0NBQWdDLGFBQWEsaUNBQWlDLE1BQU0sb0JBQW9CLE1BQU0sa0JBQWtCLGdCQUFnQix5QkFBeUIscUNBQXFDLGlDQUFpQyxlQUFlLElBQUksd0JBQXdCLG9CQUFvQiw2REFBNkQsK0NBQStDLDhDQUE4QyxnQ0FBZ0Msc0JBQXNCLDZCQUE2Qix3Q0FBd0MsOEJBQThCLDRCQUE0QixNQUFNLG9DQUFvQyxhQUFhLDZCQUE2QixVQUFVLDBDQUEwQywyQkFBMkIsTUFBTSxtQkFBbUIsK0JBQStCLE1BQU0sd0NBQXdDLFdBQVcseUNBQXlDLDBFQUEwRSxNQUFNLGFBQWEsT0FBTyxnQkFBZ0IscUNBQXFDLHVCQUF1Qix1REFBdUQsTUFBTSxjQUFjLE9BQU8sS0FBSywyQkFBMkIsaUJBQWlCLE9BQU8sZ0NBQWdDLDBDQUEwQyx1QkFBdUIseUNBQXlDLE9BQU8seUNBQXlDLGdCQUFnQiw2QkFBNkIsaUJBQWlCLGFBQWEsU0FBUyxnQkFBZ0IsMEJBQTBCLGtDQUFrQyx5QkFBeUIsT0FBTyxtQkFBbUIsaUJBQWlCLFNBQVMscUJBQXFCLG9CQUFvQixnQ0FBZ0MsNkJBQTZCLE1BQU0sdUJBQXVCLGtCQUFrQixXQUFXLE9BQU8seUJBQXlCLHdCQUF3QixPQUFPLHNCQUFzQixPQUFPLFVBQVUsMEJBQTBCLDJCQUEyQixVQUFVLHFCQUFxQixtQkFBbUIsNEdBQTRHLGdDQUFnQyxxQkFBcUIsT0FBTyw4Q0FBOEMsMkJBQTJCLGVBQWUsSUFBSSxNQUFNLGtCQUFrQixTQUFTLFlBQVksbUJBQW1CLEtBQUssa0JBQWtCLGdCQUFnQiwwQkFBMEIsOERBQWEsbUJBQW1CLHdDQUF3Qyw0QkFBNEIsNEJBQTRCLFVBQVUsWUFBWSxxQkFBcUIscUNBQXFDLGFBQWEsZ0JBQWdCLFdBQVcsS0FBSyxXQUFXLGNBQWMsYUFBYSxnQkFBZ0IsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2hlbHBlcnMtNmUxZTViNjUuanM/YThlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19zcHJlYWRBcnJheX1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi92YXIgdHJhbnNpdGlvbkVuZEFzeW5jPWZ1bmN0aW9uKGUsbil7aWYobj09PXZvaWQgMCl7bj0wfXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dHJhbnNpdGlvbkVuZChlLG4sdCl9KSl9O3ZhciB0cmFuc2l0aW9uRW5kPWZ1bmN0aW9uKGUsbix0KXtpZihuPT09dm9pZCAwKXtuPTB9dmFyIHI7dmFyIGk7dmFyIGE9e3Bhc3NpdmU6dHJ1ZX07dmFyIG89NTAwO3ZhciB1PWZ1bmN0aW9uKCl7aWYocil7cigpfX07dmFyIHM9ZnVuY3Rpb24obil7aWYobj09PXVuZGVmaW5lZHx8ZT09PW4udGFyZ2V0KXt1KCk7dChuKX19O2lmKGUpe2UuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIixzLGEpO2UuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIixzLGEpO2k9c2V0VGltZW91dChzLG4rbyk7cj1mdW5jdGlvbigpe2lmKGkpe2NsZWFyVGltZW91dChpKTtpPXVuZGVmaW5lZH1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIscyxhKTtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIscyxhKX19cmV0dXJuIHV9O3ZhciBjb21wb25lbnRPblJlYWR5PWZ1bmN0aW9uKGUsbil7aWYoZS5jb21wb25lbnRPblJlYWR5KXtlLmNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gbihlKX0pKX1lbHNle3JhZigoZnVuY3Rpb24oKXtyZXR1cm4gbihlKX0pKX19O3ZhciBpbmhlcml0QXR0cmlidXRlcz1mdW5jdGlvbihlLG4pe2lmKG49PT12b2lkIDApe249W119dmFyIHQ9e307bi5mb3JFYWNoKChmdW5jdGlvbihuKXtpZihlLmhhc0F0dHJpYnV0ZShuKSl7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUobik7aWYociE9PW51bGwpe3Rbbl09ZS5nZXRBdHRyaWJ1dGUobil9ZS5yZW1vdmVBdHRyaWJ1dGUobil9fSkpO3JldHVybiB0fTt2YXIgYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLG4sdCxyKXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7dmFyIGk9d2luZG93O3ZhciBhPWkmJmkuSW9uaWMmJmkuSW9uaWMuY29uZmlnO2lmKGEpe3ZhciBvPWEuZ2V0KFwiX2FlbFwiKTtpZihvKXtyZXR1cm4gbyhlLG4sdCxyKX1lbHNlIGlmKGEuX2FlbCl7cmV0dXJuIGEuX2FlbChlLG4sdCxyKX19fXJldHVybiBlLmFkZEV2ZW50TGlzdGVuZXIobix0LHIpfTt2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLG4sdCxyKXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7dmFyIGk9d2luZG93O3ZhciBhPWkmJmkuSW9uaWMmJmkuSW9uaWMuY29uZmlnO2lmKGEpe3ZhciBvPWEuZ2V0KFwiX3JlbFwiKTtpZihvKXtyZXR1cm4gbyhlLG4sdCxyKX1lbHNlIGlmKGEuX3JlbCl7cmV0dXJuIGEuX3JlbChlLG4sdCxyKX19fXJldHVybiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIobix0LHIpfTt2YXIgZ2V0RWxlbWVudFJvb3Q9ZnVuY3Rpb24oZSxuKXtpZihuPT09dm9pZCAwKXtuPWV9cmV0dXJuIGUuc2hhZG93Um9vdHx8bn07dmFyIHJhZj1mdW5jdGlvbihlKXtpZih0eXBlb2YgX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpfWlmKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PT1cImZ1bmN0aW9uXCIpe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSl9cmV0dXJuIHNldFRpbWVvdXQoZSl9O3ZhciBoYXNTaGFkb3dEb209ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnNoYWRvd1Jvb3QmJiEhZS5hdHRhY2hTaGFkb3d9O3ZhciBmaW5kSXRlbUxhYmVsPWZ1bmN0aW9uKGUpe3ZhciBuPWUuY2xvc2VzdChcImlvbi1pdGVtXCIpO2lmKG4pe3JldHVybiBuLnF1ZXJ5U2VsZWN0b3IoXCJpb24tbGFiZWxcIil9cmV0dXJuIG51bGx9O3ZhciBmb2N1c0VsZW1lbnQ9ZnVuY3Rpb24oZSl7ZS5mb2N1cygpO2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaW9uLWZvY3VzYWJsZVwiKSl7dmFyIG49ZS5jbG9zZXN0KFwiaW9uLWFwcFwiKTtpZihuKXtuLnNldEZvY3VzKFtlXSl9fX07dmFyIGdldEFyaWFMYWJlbD1mdW5jdGlvbihlLG4pe3ZhciB0O3ZhciByPWUuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIpO3ZhciBpPWUuaWQ7dmFyIGE9ciE9PW51bGwmJnIudHJpbSgpIT09XCJcIj9yOm4rXCItbGJsXCI7dmFyIG89ciE9PW51bGwmJnIudHJpbSgpIT09XCJcIj9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKTpmaW5kSXRlbUxhYmVsKGUpO2lmKG8pe2lmKHI9PT1udWxsKXtvLmlkPWF9dD1vLnRleHRDb250ZW50O28uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIil9ZWxzZSBpZihpLnRyaW0oKSE9PVwiXCIpe289ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPVwiJy5jb25jYXQoaSwnXCJdJykpO2lmKG8pe2lmKG8uaWQhPT1cIlwiKXthPW8uaWR9ZWxzZXtvLmlkPWE9XCJcIi5jb25jYXQoaSxcIi1sYmxcIil9dD1vLnRleHRDb250ZW50fX1yZXR1cm57bGFiZWw6byxsYWJlbElkOmEsbGFiZWxUZXh0OnR9fTt2YXIgcmVuZGVySGlkZGVuSW5wdXQ9ZnVuY3Rpb24oZSxuLHQscixpKXtpZihlfHxoYXNTaGFkb3dEb20obikpe3ZhciBhPW4ucXVlcnlTZWxlY3RvcihcImlucHV0LmF1eC1pbnB1dFwiKTtpZighYSl7YT1uLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2EudHlwZT1cImhpZGRlblwiO2EuY2xhc3NMaXN0LmFkZChcImF1eC1pbnB1dFwiKTtuLmFwcGVuZENoaWxkKGEpfWEuZGlzYWJsZWQ9aTthLm5hbWU9dDthLnZhbHVlPXJ8fFwiXCJ9fTt2YXIgY2xhbXA9ZnVuY3Rpb24oZSxuLHQpe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKG4sdCkpfTt2YXIgYXNzZXJ0PWZ1bmN0aW9uKGUsbil7aWYoIWUpe3ZhciB0PVwiQVNTRVJUOiBcIituO2NvbnNvbGUuZXJyb3IodCk7ZGVidWdnZXI7dGhyb3cgbmV3IEVycm9yKHQpfX07dmFyIG5vdz1mdW5jdGlvbihlKXtyZXR1cm4gZS50aW1lU3RhbXB8fERhdGUubm93KCl9O3ZhciBwb2ludGVyQ29vcmQ9ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIG49ZS5jaGFuZ2VkVG91Y2hlcztpZihuJiZuLmxlbmd0aD4wKXt2YXIgdD1uWzBdO3JldHVybnt4OnQuY2xpZW50WCx5OnQuY2xpZW50WX19aWYoZS5wYWdlWCE9PXVuZGVmaW5lZCl7cmV0dXJue3g6ZS5wYWdlWCx5OmUucGFnZVl9fX1yZXR1cm57eDowLHk6MH19O3ZhciBpc0VuZFNpZGU9ZnVuY3Rpb24oZSl7dmFyIG49ZG9jdW1lbnQuZGlyPT09XCJydGxcIjtzd2l0Y2goZSl7Y2FzZVwic3RhcnRcIjpyZXR1cm4gbjtjYXNlXCJlbmRcIjpyZXR1cm4hbjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcignXCInLmNvbmNhdChlLCdcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgW3NpZGVdLiBVc2UgXCJzdGFydFwiIG9yIFwiZW5kXCIgaW5zdGVhZC4nKSl9fTt2YXIgZGVib3VuY2VFdmVudD1mdW5jdGlvbihlLG4pe3ZhciB0PWUuX29yaWdpbmFsfHxlO3JldHVybntfb3JpZ2luYWw6ZSxlbWl0OmRlYm91bmNlKHQuZW1pdC5iaW5kKHQpLG4pfX07dmFyIGRlYm91bmNlPWZ1bmN0aW9uKGUsbil7aWYobj09PXZvaWQgMCl7bj0wfXZhciB0O3JldHVybiBmdW5jdGlvbigpe3ZhciByPVtdO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe3JbaV09YXJndW1lbnRzW2ldfWNsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQuYXBwbHkodm9pZCAwLF9fc3ByZWFkQXJyYXkoW2Usbl0scixmYWxzZSkpfX07dmFyIHNoYWxsb3dFcXVhbFN0cmluZ01hcD1mdW5jdGlvbihlLG4pe2UhPT1udWxsJiZlIT09dm9pZCAwP2U6ZT17fTtuIT09bnVsbCYmbiE9PXZvaWQgMD9uOm49e307aWYoZT09PW4pe3JldHVybiB0cnVlfXZhciB0PU9iamVjdC5rZXlzKGUpO2lmKHQubGVuZ3RoIT09T2JqZWN0LmtleXMobikubGVuZ3RoKXtyZXR1cm4gZmFsc2V9Zm9yKHZhciByPTAsaT10O3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pW3JdO2lmKCEoYSBpbiBuKSl7cmV0dXJuIGZhbHNlfWlmKGVbYV0hPT1uW2FdKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfTtleHBvcnR7YWRkRXZlbnRMaXN0ZW5lciBhcyBhLHJlbW92ZUV2ZW50TGlzdGVuZXIgYXMgYixjb21wb25lbnRPblJlYWR5IGFzIGMsZ2V0QXJpYUxhYmVsIGFzIGQscmVuZGVySGlkZGVuSW5wdXQgYXMgZSxmb2N1c0VsZW1lbnQgYXMgZixnZXRFbGVtZW50Um9vdCBhcyBnLGRlYm91bmNlRXZlbnQgYXMgaCxpbmhlcml0QXR0cmlidXRlcyBhcyBpLGZpbmRJdGVtTGFiZWwgYXMgaixjbGFtcCBhcyBrLGhhc1NoYWRvd0RvbSBhcyBsLGFzc2VydCBhcyBtLGlzRW5kU2lkZSBhcyBuLGRlYm91bmNlIGFzIG8scG9pbnRlckNvb3JkIGFzIHAsbm93IGFzIHEscmFmIGFzIHIsc2hhbGxvd0VxdWFsU3RyaW5nTWFwIGFzIHMsdHJhbnNpdGlvbkVuZEFzeW5jIGFzIHR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7504\n')},3876:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "GESTURE_CONTROLLER": () => (/* reexport safe */ _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   "createGesture": () => (/* binding */ createGesture)\n/* harmony export */ });\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4988);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar addEventListener=function(e,r,t,a){var n=supportsPassive(e)?{capture:!!a.capture,passive:!!a.passive}:!!a.capture;var i;var u;if(e["__zone_symbol__addEventListener"]){i="__zone_symbol__addEventListener";u="__zone_symbol__removeEventListener"}else{i="addEventListener";u="removeEventListener"}e[i](r,t,n);return function(){e[u](r,t,n)}};var supportsPassive=function(e){if(_sPassive===undefined){try{var r=Object.defineProperty({},"passive",{get:function(){_sPassive=true}});e.addEventListener("optsTest",(function(){return}),r)}catch(e){_sPassive=false}}return!!_sPassive};var _sPassive;var MOUSE_WAIT=2e3;var createPointerEvents=function(e,r,t,a,n){var i;var u;var s;var v;var f;var o;var c;var l=0;var d=function(a){l=Date.now()+MOUSE_WAIT;if(!r(a)){return}if(!u&&t){u=addEventListener(e,"touchmove",t,n)}if(!s){s=addEventListener(a.target,"touchend",p,n)}if(!v){v=addEventListener(a.target,"touchcancel",p,n)}};var m=function(a){if(l>Date.now()){return}if(!r(a)){return}if(!o&&t){o=addEventListener(getDocument(e),"mousemove",t,n)}if(!c){c=addEventListener(getDocument(e),"mouseup",E,n)}};var p=function(e){_();if(a){a(e)}};var E=function(e){g();if(a){a(e)}};var _=function(){if(u){u()}if(s){s()}if(v){v()}u=s=v=undefined};var g=function(){if(o){o()}if(c){c()}o=c=undefined};var y=function(){_();g()};var X=function(r){if(r===void 0){r=true}if(!r){if(i){i()}if(f){f()}i=f=undefined;y()}else{if(!i){i=addEventListener(e,"touchstart",d,n)}if(!f){f=addEventListener(e,"mousedown",m,n)}}};var Y=function(){X(false);a=t=r=undefined};return{enable:X,stop:y,destroy:Y}};var getDocument=function(e){return e instanceof Document?e:e.ownerDocument};var createPanRecognizer=function(e,r,t){var a=t*(Math.PI/180);var n=e==="x";var i=Math.cos(a);var u=r*r;var s=0;var v=0;var f=false;var o=0;return{start:function(e,r){s=e;v=r;o=0;f=true},detect:function(e,r){if(!f){return false}var t=e-s;var a=r-v;var c=t*t+a*a;if(c<u){return false}var l=Math.sqrt(c);var d=(n?t:a)/l;if(d>i){o=1}else if(d<-i){o=-1}else{o=0}f=false;return true},isGesture:function(){return o!==0},getDirection:function(){return o}}};var createGesture=function(e){var r=false;var t=false;var a=true;var n=false;var i=Object.assign({disableScroll:false,direction:"x",gesturePriority:0,passive:true,maxAngle:40,threshold:10},e);var u=i.canStart;var s=i.onWillStart;var v=i.onStart;var f=i.onEnd;var o=i.notCaptured;var c=i.onMove;var l=i.threshold;var d=i.passive;var m=i.blurOnStart;var p={type:"pan",startX:0,startY:0,startTime:0,currentX:0,currentY:0,velocityX:0,velocityY:0,deltaX:0,deltaY:0,currentTime:0,event:undefined,data:undefined};var E=createPanRecognizer(i.direction,i.threshold,i.maxAngle);var _=_gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G.createGesture({name:e.gestureName,priority:e.gesturePriority,disableScroll:e.disableScroll});var g=function(e){var r=now(e);if(t||!a){return false}updateDetail(e,p);p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime=r;p.velocityX=p.velocityY=p.deltaX=p.deltaY=0;p.event=e;if(u&&u(p)===false){return false}_.release();if(!_.start()){return false}t=true;if(l===0){return Y()}E.start(p.startX,p.startY);return true};var y=function(e){if(r){if(!n&&a){n=true;calcGestureData(p,e);requestAnimationFrame(X)}return}calcGestureData(p,e);if(E.detect(p.currentX,p.currentY)){if(!E.isGesture()||!Y()){b()}}};var X=function(){if(!r){return}n=false;if(c){c(p)}};var Y=function(){if(_&&!_.capture()){return false}r=true;a=false;p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime;if(s){s(p).then(h)}else{h()}return true};var L=function(){if(typeof document!=="undefined"){var e=document.activeElement;if(e!==null&&e.blur){e.blur()}}};var h=function(){if(m){L()}if(v){v(p)}a=true};var T=function(){r=false;t=false;n=false;a=true;_.release()};var D=function(e){var t=r;var n=a;T();if(!n){return}calcGestureData(p,e);if(t){if(f){f(p)}return}if(o){o(p)}};var P=createPointerEvents(i.el,g,y,D,{capture:false,passive:d});var b=function(){T();P.stop();if(o){o(p)}};return{enable:function(e){if(e===void 0){e=true}if(!e){if(r){D(undefined)}T()}P.enable(e)},destroy:function(){_.destroy();P.destroy()}}};var calcGestureData=function(e,r){if(!r){return}var t=e.currentX;var a=e.currentY;var n=e.currentTime;updateDetail(r,e);var i=e.currentX;var u=e.currentY;var s=e.currentTime=now(r);var v=s-n;if(v>0&&v<100){var f=(i-t)/v;var o=(u-a)/v;e.velocityX=f*.7+e.velocityX*.3;e.velocityY=o*.7+e.velocityY*.3}e.deltaX=i-e.startX;e.deltaY=u-e.startY;e.event=r};var updateDetail=function(e,r){var t=0;var a=0;if(e){var n=e.changedTouches;if(n&&n.length>0){var i=n[0];t=i.clientX;a=i.clientY}else if(e.pageX!==undefined){t=e.pageX;a=e.pageY}}r.currentX=t;r.currentY=a};var now=function(e){return e.timeStamp||Date.now()};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtNDFiZjQxZjIuanM/YzhiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0e0cgYXMgR0VTVFVSRV9DT05UUk9MTEVSfWZyb21cIi4vZ2VzdHVyZS1jb250cm9sbGVyLTY4YzAyM2E0LmpzXCI7ZXhwb3J0e0cgYXMgR0VTVFVSRV9DT05UUk9MTEVSfWZyb21cIi4vZ2VzdHVyZS1jb250cm9sbGVyLTY4YzAyM2E0LmpzXCI7dmFyIGFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZSxyLHQsYSl7dmFyIG49c3VwcG9ydHNQYXNzaXZlKGUpP3tjYXB0dXJlOiEhYS5jYXB0dXJlLHBhc3NpdmU6ISFhLnBhc3NpdmV9OiEhYS5jYXB0dXJlO3ZhciBpO3ZhciB1O2lmKGVbXCJfX3pvbmVfc3ltYm9sX19hZGRFdmVudExpc3RlbmVyXCJdKXtpPVwiX196b25lX3N5bWJvbF9fYWRkRXZlbnRMaXN0ZW5lclwiO3U9XCJfX3pvbmVfc3ltYm9sX19yZW1vdmVFdmVudExpc3RlbmVyXCJ9ZWxzZXtpPVwiYWRkRXZlbnRMaXN0ZW5lclwiO3U9XCJyZW1vdmVFdmVudExpc3RlbmVyXCJ9ZVtpXShyLHQsbik7cmV0dXJuIGZ1bmN0aW9uKCl7ZVt1XShyLHQsbil9fTt2YXIgc3VwcG9ydHNQYXNzaXZlPWZ1bmN0aW9uKGUpe2lmKF9zUGFzc2l2ZT09PXVuZGVmaW5lZCl7dHJ5e3ZhciByPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7X3NQYXNzaXZlPXRydWV9fSk7ZS5hZGRFdmVudExpc3RlbmVyKFwib3B0c1Rlc3RcIiwoZnVuY3Rpb24oKXtyZXR1cm59KSxyKX1jYXRjaChlKXtfc1Bhc3NpdmU9ZmFsc2V9fXJldHVybiEhX3NQYXNzaXZlfTt2YXIgX3NQYXNzaXZlO3ZhciBNT1VTRV9XQUlUPTJlMzt2YXIgY3JlYXRlUG9pbnRlckV2ZW50cz1mdW5jdGlvbihlLHIsdCxhLG4pe3ZhciBpO3ZhciB1O3ZhciBzO3ZhciB2O3ZhciBmO3ZhciBvO3ZhciBjO3ZhciBsPTA7dmFyIGQ9ZnVuY3Rpb24oYSl7bD1EYXRlLm5vdygpK01PVVNFX1dBSVQ7aWYoIXIoYSkpe3JldHVybn1pZighdSYmdCl7dT1hZGRFdmVudExpc3RlbmVyKGUsXCJ0b3VjaG1vdmVcIix0LG4pfWlmKCFzKXtzPWFkZEV2ZW50TGlzdGVuZXIoYS50YXJnZXQsXCJ0b3VjaGVuZFwiLHAsbil9aWYoIXYpe3Y9YWRkRXZlbnRMaXN0ZW5lcihhLnRhcmdldCxcInRvdWNoY2FuY2VsXCIscCxuKX19O3ZhciBtPWZ1bmN0aW9uKGEpe2lmKGw+RGF0ZS5ub3coKSl7cmV0dXJufWlmKCFyKGEpKXtyZXR1cm59aWYoIW8mJnQpe289YWRkRXZlbnRMaXN0ZW5lcihnZXREb2N1bWVudChlKSxcIm1vdXNlbW92ZVwiLHQsbil9aWYoIWMpe2M9YWRkRXZlbnRMaXN0ZW5lcihnZXREb2N1bWVudChlKSxcIm1vdXNldXBcIixFLG4pfX07dmFyIHA9ZnVuY3Rpb24oZSl7XygpO2lmKGEpe2EoZSl9fTt2YXIgRT1mdW5jdGlvbihlKXtnKCk7aWYoYSl7YShlKX19O3ZhciBfPWZ1bmN0aW9uKCl7aWYodSl7dSgpfWlmKHMpe3MoKX1pZih2KXt2KCl9dT1zPXY9dW5kZWZpbmVkfTt2YXIgZz1mdW5jdGlvbigpe2lmKG8pe28oKX1pZihjKXtjKCl9bz1jPXVuZGVmaW5lZH07dmFyIHk9ZnVuY3Rpb24oKXtfKCk7ZygpfTt2YXIgWD1mdW5jdGlvbihyKXtpZihyPT09dm9pZCAwKXtyPXRydWV9aWYoIXIpe2lmKGkpe2koKX1pZihmKXtmKCl9aT1mPXVuZGVmaW5lZDt5KCl9ZWxzZXtpZighaSl7aT1hZGRFdmVudExpc3RlbmVyKGUsXCJ0b3VjaHN0YXJ0XCIsZCxuKX1pZighZil7Zj1hZGRFdmVudExpc3RlbmVyKGUsXCJtb3VzZWRvd25cIixtLG4pfX19O3ZhciBZPWZ1bmN0aW9uKCl7WChmYWxzZSk7YT10PXI9dW5kZWZpbmVkfTtyZXR1cm57ZW5hYmxlOlgsc3RvcDp5LGRlc3Ryb3k6WX19O3ZhciBnZXREb2N1bWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERvY3VtZW50P2U6ZS5vd25lckRvY3VtZW50fTt2YXIgY3JlYXRlUGFuUmVjb2duaXplcj1mdW5jdGlvbihlLHIsdCl7dmFyIGE9dCooTWF0aC5QSS8xODApO3ZhciBuPWU9PT1cInhcIjt2YXIgaT1NYXRoLmNvcyhhKTt2YXIgdT1yKnI7dmFyIHM9MDt2YXIgdj0wO3ZhciBmPWZhbHNlO3ZhciBvPTA7cmV0dXJue3N0YXJ0OmZ1bmN0aW9uKGUscil7cz1lO3Y9cjtvPTA7Zj10cnVlfSxkZXRlY3Q6ZnVuY3Rpb24oZSxyKXtpZighZil7cmV0dXJuIGZhbHNlfXZhciB0PWUtczt2YXIgYT1yLXY7dmFyIGM9dCp0K2EqYTtpZihjPHUpe3JldHVybiBmYWxzZX12YXIgbD1NYXRoLnNxcnQoYyk7dmFyIGQ9KG4/dDphKS9sO2lmKGQ+aSl7bz0xfWVsc2UgaWYoZDwtaSl7bz0tMX1lbHNle289MH1mPWZhbHNlO3JldHVybiB0cnVlfSxpc0dlc3R1cmU6ZnVuY3Rpb24oKXtyZXR1cm4gbyE9PTB9LGdldERpcmVjdGlvbjpmdW5jdGlvbigpe3JldHVybiBvfX19O3ZhciBjcmVhdGVHZXN0dXJlPWZ1bmN0aW9uKGUpe3ZhciByPWZhbHNlO3ZhciB0PWZhbHNlO3ZhciBhPXRydWU7dmFyIG49ZmFsc2U7dmFyIGk9T2JqZWN0LmFzc2lnbih7ZGlzYWJsZVNjcm9sbDpmYWxzZSxkaXJlY3Rpb246XCJ4XCIsZ2VzdHVyZVByaW9yaXR5OjAscGFzc2l2ZTp0cnVlLG1heEFuZ2xlOjQwLHRocmVzaG9sZDoxMH0sZSk7dmFyIHU9aS5jYW5TdGFydDt2YXIgcz1pLm9uV2lsbFN0YXJ0O3ZhciB2PWkub25TdGFydDt2YXIgZj1pLm9uRW5kO3ZhciBvPWkubm90Q2FwdHVyZWQ7dmFyIGM9aS5vbk1vdmU7dmFyIGw9aS50aHJlc2hvbGQ7dmFyIGQ9aS5wYXNzaXZlO3ZhciBtPWkuYmx1ck9uU3RhcnQ7dmFyIHA9e3R5cGU6XCJwYW5cIixzdGFydFg6MCxzdGFydFk6MCxzdGFydFRpbWU6MCxjdXJyZW50WDowLGN1cnJlbnRZOjAsdmVsb2NpdHlYOjAsdmVsb2NpdHlZOjAsZGVsdGFYOjAsZGVsdGFZOjAsY3VycmVudFRpbWU6MCxldmVudDp1bmRlZmluZWQsZGF0YTp1bmRlZmluZWR9O3ZhciBFPWNyZWF0ZVBhblJlY29nbml6ZXIoaS5kaXJlY3Rpb24saS50aHJlc2hvbGQsaS5tYXhBbmdsZSk7dmFyIF89R0VTVFVSRV9DT05UUk9MTEVSLmNyZWF0ZUdlc3R1cmUoe25hbWU6ZS5nZXN0dXJlTmFtZSxwcmlvcml0eTplLmdlc3R1cmVQcmlvcml0eSxkaXNhYmxlU2Nyb2xsOmUuZGlzYWJsZVNjcm9sbH0pO3ZhciBnPWZ1bmN0aW9uKGUpe3ZhciByPW5vdyhlKTtpZih0fHwhYSl7cmV0dXJuIGZhbHNlfXVwZGF0ZURldGFpbChlLHApO3Auc3RhcnRYPXAuY3VycmVudFg7cC5zdGFydFk9cC5jdXJyZW50WTtwLnN0YXJ0VGltZT1wLmN1cnJlbnRUaW1lPXI7cC52ZWxvY2l0eVg9cC52ZWxvY2l0eVk9cC5kZWx0YVg9cC5kZWx0YVk9MDtwLmV2ZW50PWU7aWYodSYmdShwKT09PWZhbHNlKXtyZXR1cm4gZmFsc2V9Xy5yZWxlYXNlKCk7aWYoIV8uc3RhcnQoKSl7cmV0dXJuIGZhbHNlfXQ9dHJ1ZTtpZihsPT09MCl7cmV0dXJuIFkoKX1FLnN0YXJ0KHAuc3RhcnRYLHAuc3RhcnRZKTtyZXR1cm4gdHJ1ZX07dmFyIHk9ZnVuY3Rpb24oZSl7aWYocil7aWYoIW4mJmEpe249dHJ1ZTtjYWxjR2VzdHVyZURhdGEocCxlKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoWCl9cmV0dXJufWNhbGNHZXN0dXJlRGF0YShwLGUpO2lmKEUuZGV0ZWN0KHAuY3VycmVudFgscC5jdXJyZW50WSkpe2lmKCFFLmlzR2VzdHVyZSgpfHwhWSgpKXtiKCl9fX07dmFyIFg9ZnVuY3Rpb24oKXtpZighcil7cmV0dXJufW49ZmFsc2U7aWYoYyl7YyhwKX19O3ZhciBZPWZ1bmN0aW9uKCl7aWYoXyYmIV8uY2FwdHVyZSgpKXtyZXR1cm4gZmFsc2V9cj10cnVlO2E9ZmFsc2U7cC5zdGFydFg9cC5jdXJyZW50WDtwLnN0YXJ0WT1wLmN1cnJlbnRZO3Auc3RhcnRUaW1lPXAuY3VycmVudFRpbWU7aWYocyl7cyhwKS50aGVuKGgpfWVsc2V7aCgpfXJldHVybiB0cnVlfTt2YXIgTD1mdW5jdGlvbigpe2lmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCIpe3ZhciBlPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoZSE9PW51bGwmJmUuYmx1cil7ZS5ibHVyKCl9fX07dmFyIGg9ZnVuY3Rpb24oKXtpZihtKXtMKCl9aWYodil7dihwKX1hPXRydWV9O3ZhciBUPWZ1bmN0aW9uKCl7cj1mYWxzZTt0PWZhbHNlO249ZmFsc2U7YT10cnVlO18ucmVsZWFzZSgpfTt2YXIgRD1mdW5jdGlvbihlKXt2YXIgdD1yO3ZhciBuPWE7VCgpO2lmKCFuKXtyZXR1cm59Y2FsY0dlc3R1cmVEYXRhKHAsZSk7aWYodCl7aWYoZil7ZihwKX1yZXR1cm59aWYobyl7byhwKX19O3ZhciBQPWNyZWF0ZVBvaW50ZXJFdmVudHMoaS5lbCxnLHksRCx7Y2FwdHVyZTpmYWxzZSxwYXNzaXZlOmR9KTt2YXIgYj1mdW5jdGlvbigpe1QoKTtQLnN0b3AoKTtpZihvKXtvKHApfX07cmV0dXJue2VuYWJsZTpmdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXRydWV9aWYoIWUpe2lmKHIpe0QodW5kZWZpbmVkKX1UKCl9UC5lbmFibGUoZSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtfLmRlc3Ryb3koKTtQLmRlc3Ryb3koKX19fTt2YXIgY2FsY0dlc3R1cmVEYXRhPWZ1bmN0aW9uKGUscil7aWYoIXIpe3JldHVybn12YXIgdD1lLmN1cnJlbnRYO3ZhciBhPWUuY3VycmVudFk7dmFyIG49ZS5jdXJyZW50VGltZTt1cGRhdGVEZXRhaWwocixlKTt2YXIgaT1lLmN1cnJlbnRYO3ZhciB1PWUuY3VycmVudFk7dmFyIHM9ZS5jdXJyZW50VGltZT1ub3cocik7dmFyIHY9cy1uO2lmKHY+MCYmdjwxMDApe3ZhciBmPShpLXQpL3Y7dmFyIG89KHUtYSkvdjtlLnZlbG9jaXR5WD1mKi43K2UudmVsb2NpdHlYKi4zO2UudmVsb2NpdHlZPW8qLjcrZS52ZWxvY2l0eVkqLjN9ZS5kZWx0YVg9aS1lLnN0YXJ0WDtlLmRlbHRhWT11LWUuc3RhcnRZO2UuZXZlbnQ9cn07dmFyIHVwZGF0ZURldGFpbD1mdW5jdGlvbihlLHIpe3ZhciB0PTA7dmFyIGE9MDtpZihlKXt2YXIgbj1lLmNoYW5nZWRUb3VjaGVzO2lmKG4mJm4ubGVuZ3RoPjApe3ZhciBpPW5bMF07dD1pLmNsaWVudFg7YT1pLmNsaWVudFl9ZWxzZSBpZihlLnBhZ2VYIT09dW5kZWZpbmVkKXt0PWUucGFnZVg7YT1lLnBhZ2VZfX1yLmN1cnJlbnRYPXQ7ci5jdXJyZW50WT1hfTt2YXIgbm93PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX07ZXhwb3J0e2NyZWF0ZUdlc3R1cmV9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3876\n')},2896:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ Build),\n/* harmony export */   "H": () => (/* binding */ Host),\n/* harmony export */   "N": () => (/* binding */ NAMESPACE),\n/* harmony export */   "a": () => (/* binding */ setMode),\n/* harmony export */   "b": () => (/* binding */ bootstrapLazy),\n/* harmony export */   "c": () => (/* binding */ writeTask),\n/* harmony export */   "d": () => (/* binding */ doc),\n/* harmony export */   "e": () => (/* binding */ createEvent),\n/* harmony export */   "f": () => (/* binding */ readTask),\n/* harmony export */   "g": () => (/* binding */ getMode),\n/* harmony export */   "h": () => (/* binding */ h),\n/* harmony export */   "i": () => (/* binding */ getElement),\n/* harmony export */   "j": () => (/* binding */ forceUpdate),\n/* harmony export */   "k": () => (/* binding */ getAssetPath),\n/* harmony export */   "p": () => (/* binding */ promiseResolve),\n/* harmony export */   "r": () => (/* binding */ registerInstance),\n/* harmony export */   "s": () => (/* binding */ setPlatformHelpers),\n/* harmony export */   "w": () => (/* binding */ win)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var NAMESPACE="ionic";var scopeId;var contentRef;var hostTagName;var useNativeShadowDom=false;var checkSlotFallbackVisibility=false;var checkSlotRelocate=false;var isSvgMode=false;var queuePending=false;var win=typeof window!=="undefined"?window:{};var doc=win.document||{head:{}};var plt={$flags$:0,$resourcesUrl$:"",jmp:function(e){return e()},raf:function(e){return requestAnimationFrame(e)},ael:function(e,t,r,n){return e.addEventListener(t,r,n)},rel:function(e,t,r,n){return e.removeEventListener(t,r,n)},ce:function(e,t){return new CustomEvent(e,t)}};var setPlatformHelpers=function(e){Object.assign(plt,e)};var supportsShadow=true;var promiseResolve=function(e){return Promise.resolve(e)};var supportsConstructibleStylesheets=function(){try{new CSSStyleSheet;return typeof(new CSSStyleSheet).replace==="function"}catch(e){}return false}();var addHostEventListeners=function(e,t,r,n){if(r){r.map((function(r){var n=r[0],a=r[1],o=r[2];var s=getHostListenerTarget(e,n);var i=hostListenerProxy(t,o);var l=hostListenerOpts(n);plt.ael(s,a,i,l);(t.$rmListeners$=t.$rmListeners$||[]).push((function(){return plt.rel(s,a,i,l)}))}))}};var hostListenerProxy=function(e,t){return function(r){try{{if(e.$flags$&256){e.$lazyInstance$[t](r)}else{(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,r])}}}catch(e){consoleError(e)}}};var getHostListenerTarget=function(e,t){if(t&4)return doc;if(t&8)return win;if(t&16)return doc.body;return e};var hostListenerOpts=function(e){return(e&2)!==0};var CONTENT_REF_ID="r";var ORG_LOCATION_ID="o";var SLOT_NODE_ID="s";var TEXT_NODE_ID="t";var HYDRATE_ID="s-id";var HYDRATED_STYLE_ID="sty-id";var HYDRATE_CHILD_ID="c-id";var HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}";var XLINK_NS="http://www.w3.org/1999/xlink";var createTime=function(e,t){if(t===void 0){t=""}{return function(){return}}};var uniqueTime=function(e,t){{return function(){return}}};var rootAppliedStyles=new WeakMap;var registerStyle=function(e,t,r){var n=styles.get(e);if(supportsConstructibleStylesheets&&r){n=n||new CSSStyleSheet;n.replace(t)}else{n=t}styles.set(e,n)};var addStyle=function(e,t,r,n){var a=getScopeId(t,r);var o=styles.get(a);e=e.nodeType===11?e:doc;if(o){if(typeof o==="string"){e=e.head||e;var s=rootAppliedStyles.get(e);var i=void 0;if(!s){rootAppliedStyles.set(e,s=new Set)}if(!s.has(a)){if(e.host&&(i=e.querySelector("[".concat(HYDRATED_STYLE_ID,\'="\').concat(a,\'"]\')))){i.innerHTML=o}else{{i=doc.createElement("style");i.innerHTML=o}e.insertBefore(i,e.querySelector("link"))}if(s){s.add(a)}}}else if(!e.adoptedStyleSheets.includes(o)){e.adoptedStyleSheets=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e.adoptedStyleSheets,true),[o],false)}}return a};var attachStyles=function(e){var t=e.$cmpMeta$;var r=e.$hostElement$;var n=t.$flags$;var a=createTime("attachStyles",t.$tagName$);var o=addStyle(r.shadowRoot?r.shadowRoot:r.getRootNode(),t,e.$modeName$);if(n&10){r["s-sc"]=o;r.classList.add(o+"-h");if(n&2){r.classList.add(o+"-s")}}a()};var getScopeId=function(e,t){return"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$)};var convertScopedToShadow=function(e){return e.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g,"$1{")};var computeMode=function(e){return modeResolutionChain.map((function(t){return t(e)})).find((function(e){return!!e}))};var setMode=function(e){return modeResolutionChain.push(e)};var getMode=function(e){return getHostRef(e).$modeName$};var EMPTY_OBJ={};var SVG_NS="http://www.w3.org/2000/svg";var HTML_NS="http://www.w3.org/1999/xhtml";var isDef=function(e){return e!=null};var isComplexType=function(e){e=typeof e;return e==="object"||e==="function"};var h=function(e,t){var r=[];for(var n=2;n<arguments.length;n++){r[n-2]=arguments[n]}var a=null;var o=null;var s=null;var i=false;var l=false;var $=[];var c=function(t){for(var r=0;r<t.length;r++){a=t[r];if(Array.isArray(a)){c(a)}else if(a!=null&&typeof a!=="boolean"){if(i=typeof e!=="function"&&!isComplexType(a)){a=String(a)}if(i&&l){$[$.length-1].$text$+=a}else{$.push(i?newVNode(null,a):a)}l=i}}};c(r);if(t){if(t.key){o=t.key}if(t.name){s=t.name}{var f=t.className||t.class;if(f){t.class=typeof f!=="object"?f:Object.keys(f).filter((function(e){return f[e]})).join(" ")}}}if(typeof e==="function"){return e(t===null?{}:t,$,vdomFnUtils)}var u=newVNode(e,null);u.$attrs$=t;if($.length>0){u.$children$=$}{u.$key$=o}{u.$name$=s}return u};var newVNode=function(e,t){var r={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};{r.$attrs$=null}{r.$key$=null}{r.$name$=null}return r};var Host={};var isHost=function(e){return e&&e.$tag$===Host};var vdomFnUtils={forEach:function(e,t){return e.map(convertToPublic).forEach(t)},map:function(e,t){return e.map(convertToPublic).map(t).map(convertToPrivate)}};var convertToPublic=function(e){return{vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}};var convertToPrivate=function(e){if(typeof e.vtag==="function"){var t=Object.assign({},e.vattrs);if(e.vkey){t.key=e.vkey}if(e.vname){t.name=e.vname}return h.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e.vtag,t],e.vchildren||[],false))}var r=newVNode(e.vtag,e.vtext);r.$attrs$=e.vattrs;r.$children$=e.vchildren;r.$key$=e.vkey;r.$name$=e.vname;return r};var setAccessor=function(e,t,r,n,a,o){if(r!==n){var s=isMemberInElement(e,t);var i=t.toLowerCase();if(t==="class"){var l=e.classList;var $=parseClassList(r);var c=parseClassList(n);l.remove.apply(l,$.filter((function(e){return e&&!c.includes(e)})));l.add.apply(l,c.filter((function(e){return e&&!$.includes(e)})))}else if(t==="style"){{for(var f in r){if(!n||n[f]==null){if(f.includes("-")){e.style.removeProperty(f)}else{e.style[f]=""}}}}for(var f in n){if(!r||n[f]!==r[f]){if(f.includes("-")){e.style.setProperty(f,n[f])}else{e.style[f]=n[f]}}}}else if(t==="key");else if(t==="ref"){if(n){n(e)}}else if(!s&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"){t=t.slice(3)}else if(isMemberInElement(win,i)){t=i.slice(2)}else{t=i[2]+t.slice(3)}if(r){plt.rel(e,t,r,false)}if(n){plt.ael(e,t,n,false)}}else{var u=isComplexType(n);if((s||u&&n!==null)&&!a){try{if(!e.tagName.includes("-")){var d=n==null?"":n;if(t==="list"){s=false}else if(r==null||e[t]!=d){e[t]=d}}else{e[t]=n}}catch(e){}}var v=false;{if(i!==(i=i.replace(/^xlink\\:?/,""))){t=i;v=true}}if(n==null||n===false){if(n!==false||e.getAttribute(t)===""){if(v){e.removeAttributeNS(XLINK_NS,t)}else{e.removeAttribute(t)}}}else if((!s||o&4||a)&&!u){n=n===true?"":n;if(v){e.setAttributeNS(XLINK_NS,t,n)}else{e.setAttribute(t,n)}}}}};var parseClassListRegex=/\\s/;var parseClassList=function(e){return!e?[]:e.split(parseClassListRegex)};var updateElement=function(e,t,r,n){var a=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$;var o=e&&e.$attrs$||EMPTY_OBJ;var s=t.$attrs$||EMPTY_OBJ;{for(n in o){if(!(n in s)){setAccessor(a,n,o[n],undefined,r,t.$flags$)}}}for(n in s){setAccessor(a,n,o[n],s[n],r,t.$flags$)}};var createElm=function(e,t,r,n){var a=t.$children$[r];var o=0;var s;var i;var l;if(!useNativeShadowDom){checkSlotRelocate=true;if(a.$tag$==="slot"){if(scopeId){n.classList.add(scopeId+"-s")}a.$flags$|=a.$children$?2:1}}if(a.$text$!==null){s=a.$elm$=doc.createTextNode(a.$text$)}else if(a.$flags$&1){s=a.$elm$=doc.createTextNode("")}else{if(!isSvgMode){isSvgMode=a.$tag$==="svg"}s=a.$elm$=doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,a.$flags$&2?"slot-fb":a.$tag$);if(isSvgMode&&a.$tag$==="foreignObject"){isSvgMode=false}{updateElement(null,a,isSvgMode)}if(isDef(scopeId)&&s["s-si"]!==scopeId){s.classList.add(s["s-si"]=scopeId)}if(a.$children$){for(o=0;o<a.$children$.length;++o){i=createElm(e,a,o,s);if(i){s.appendChild(i)}}}{if(a.$tag$==="svg"){isSvgMode=false}else if(s.tagName==="foreignObject"){isSvgMode=true}}}{s["s-hn"]=hostTagName;if(a.$flags$&(2|1)){s["s-sr"]=true;s["s-cr"]=contentRef;s["s-sn"]=a.$name$||"";l=e&&e.$children$&&e.$children$[r];if(l&&l.$tag$===a.$tag$&&e.$elm$){putBackInOriginalLocation(e.$elm$,false)}}}return s};var putBackInOriginalLocation=function(e,t){plt.$flags$|=1;var r=e.childNodes;for(var n=r.length-1;n>=0;n--){var a=r[n];if(a["s-hn"]!==hostTagName&&a["s-ol"]){parentReferenceNode(a).insertBefore(a,referenceNode(a));a["s-ol"].remove();a["s-ol"]=undefined;checkSlotRelocate=true}if(t){putBackInOriginalLocation(a,t)}}plt.$flags$&=~1};var addVnodes=function(e,t,r,n,a,o){var s=e["s-cr"]&&e["s-cr"].parentNode||e;var i;if(s.shadowRoot&&s.tagName===hostTagName){s=s.shadowRoot}for(;a<=o;++a){if(n[a]){i=createElm(null,r,a,e);if(i){n[a].$elm$=i;s.insertBefore(i,referenceNode(t))}}}};var removeVnodes=function(e,t,r,n,a){for(;t<=r;++t){if(n=e[t]){a=n.$elm$;callNodeRefs(n);{checkSlotFallbackVisibility=true;if(a["s-ol"]){a["s-ol"].remove()}else{putBackInOriginalLocation(a,true)}}a.remove()}}};var updateChildren=function(e,t,r,n){var a=0;var o=0;var s=0;var i=0;var l=t.length-1;var $=t[0];var c=t[l];var f=n.length-1;var u=n[0];var d=n[f];var v;var p;while(a<=l&&o<=f){if($==null){$=t[++a]}else if(c==null){c=t[--l]}else if(u==null){u=n[++o]}else if(d==null){d=n[--f]}else if(isSameVnode($,u)){patch($,u);$=t[++a];u=n[++o]}else if(isSameVnode(c,d)){patch(c,d);c=t[--l];d=n[--f]}else if(isSameVnode($,d)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation($.$elm$.parentNode,false)}patch($,d);e.insertBefore($.$elm$,c.$elm$.nextSibling);$=t[++a];d=n[--f]}else if(isSameVnode(c,u)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation(c.$elm$.parentNode,false)}patch(c,u);e.insertBefore(c.$elm$,$.$elm$);c=t[--l];u=n[++o]}else{s=-1;{for(i=a;i<=l;++i){if(t[i]&&t[i].$key$!==null&&t[i].$key$===u.$key$){s=i;break}}}if(s>=0){p=t[s];if(p.$tag$!==u.$tag$){v=createElm(t&&t[o],r,s,e)}else{patch(p,u);t[s]=undefined;v=p.$elm$}u=n[++o]}else{v=createElm(t&&t[o],r,o,e);u=n[++o]}if(v){{parentReferenceNode($.$elm$).insertBefore(v,referenceNode($.$elm$))}}}}if(a>l){addVnodes(e,n[f+1]==null?null:n[f+1].$elm$,r,n,o,f)}else if(o>f){removeVnodes(t,a,l)}};var isSameVnode=function(e,t){if(e.$tag$===t.$tag$){if(e.$tag$==="slot"){return e.$name$===t.$name$}{return e.$key$===t.$key$}}return false};var referenceNode=function(e){return e&&e["s-ol"]||e};var parentReferenceNode=function(e){return(e["s-ol"]?e["s-ol"]:e).parentNode};var patch=function(e,t){var r=t.$elm$=e.$elm$;var n=e.$children$;var a=t.$children$;var o=t.$tag$;var s=t.$text$;var i;if(s===null){{isSvgMode=o==="svg"?true:o==="foreignObject"?false:isSvgMode}{if(o==="slot");else{updateElement(e,t,isSvgMode)}}if(n!==null&&a!==null){updateChildren(r,n,t,a)}else if(a!==null){if(e.$text$!==null){r.textContent=""}addVnodes(r,null,t,a,0,a.length-1)}else if(n!==null){removeVnodes(n,0,n.length-1)}if(isSvgMode&&o==="svg"){isSvgMode=false}}else if(i=r["s-cr"]){i.parentNode.textContent=s}else if(e.$text$!==s){r.data=s}};var updateFallbackSlotVisibility=function(e){var t=e.childNodes;var r;var n;var a;var o;var s;var i;for(n=0,a=t.length;n<a;n++){r=t[n];if(r.nodeType===1){if(r["s-sr"]){s=r["s-sn"];r.hidden=false;for(o=0;o<a;o++){i=t[o].nodeType;if(t[o]["s-hn"]!==r["s-hn"]||s!==""){if(i===1&&s===t[o].getAttribute("slot")){r.hidden=true;break}}else{if(i===1||i===3&&t[o].textContent.trim()!==""){r.hidden=true;break}}}}updateFallbackSlotVisibility(r)}}};var relocateNodes=[];var relocateSlotContent=function(e){var t;var r;var n;var a;var o;var s;var i=0;var l=e.childNodes;var $=l.length;for(;i<$;i++){t=l[i];if(t["s-sr"]&&(r=t["s-cr"])&&r.parentNode){n=r.parentNode.childNodes;a=t["s-sn"];for(s=n.length-1;s>=0;s--){r=n[s];if(!r["s-cn"]&&!r["s-nr"]&&r["s-hn"]!==t["s-hn"]){if(isNodeLocatedInSlot(r,a)){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));checkSlotFallbackVisibility=true;r["s-sn"]=r["s-sn"]||a;if(o){o.$slotRefNode$=t}else{relocateNodes.push({$slotRefNode$:t,$nodeToRelocate$:r})}if(r["s-sr"]){relocateNodes.map((function(e){if(isNodeLocatedInSlot(e.$nodeToRelocate$,r["s-sn"])){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));if(o&&!e.$slotRefNode$){e.$slotRefNode$=o.$slotRefNode$}}}))}}else if(!relocateNodes.some((function(e){return e.$nodeToRelocate$===r}))){relocateNodes.push({$nodeToRelocate$:r})}}}}if(t.nodeType===1){relocateSlotContent(t)}}};var isNodeLocatedInSlot=function(e,t){if(e.nodeType===1){if(e.getAttribute("slot")===null&&t===""){return true}if(e.getAttribute("slot")===t){return true}return false}if(e["s-sn"]===t){return true}return t===""};var callNodeRefs=function(e){{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null);e.$children$&&e.$children$.map(callNodeRefs)}};var renderVdom=function(e,t){var r=e.$hostElement$;var n=e.$cmpMeta$;var a=e.$vnode$||newVNode(null,null);var o=isHost(t)?t:h(null,null,t);hostTagName=r.tagName;if(n.$attrsToReflect$){o.$attrs$=o.$attrs$||{};n.$attrsToReflect$.map((function(e){var t=e[0],n=e[1];return o.$attrs$[n]=r[t]}))}o.$tag$=null;o.$flags$|=4;e.$vnode$=o;o.$elm$=a.$elm$=r.shadowRoot||r;{scopeId=r["s-sc"]}{contentRef=r["s-cr"];useNativeShadowDom=(n.$flags$&1)!==0;checkSlotFallbackVisibility=false}patch(a,o);{plt.$flags$|=1;if(checkSlotRelocate){relocateSlotContent(o.$elm$);var s=void 0;var i=void 0;var l=void 0;var $=void 0;var c=void 0;var f=void 0;var u=0;for(;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(!i["s-ol"]){l=doc.createTextNode("");l["s-nr"]=i;i.parentNode.insertBefore(i["s-ol"]=l,i)}}for(u=0;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(s.$slotRefNode$){$=s.$slotRefNode$.parentNode;c=s.$slotRefNode$.nextSibling;l=i["s-ol"];while(l=l.previousSibling){f=l["s-nr"];if(f&&f["s-sn"]===i["s-sn"]&&$===f.parentNode){f=f.nextSibling;if(!f||!f["s-nr"]){c=f;break}}}if(!c&&$!==i.parentNode||i.nextSibling!==c){if(i!==c){if(!i["s-hn"]&&i["s-ol"]){i["s-hn"]=i["s-ol"].parentNode.nodeName}$.insertBefore(i,c)}}}else{if(i.nodeType===1){i.hidden=true}}}}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(o.$elm$)}plt.$flags$&=~1;relocateNodes.length=0}};var getElement=function(e){return getHostRef(e).$hostElement$};var createEvent=function(e,t,r){var n=getElement(e);return{emit:function(e){return emitEvent(n,t,{bubbles:!!(r&4),composed:!!(r&2),cancelable:!!(r&1),detail:e})}}};var emitEvent=function(e,t,r){var n=plt.ce(t,r);e.dispatchEvent(n);return n};var attachToAncestor=function(e,t){if(t&&!e.$onRenderResolve$&&t["s-p"]){t["s-p"].push(new Promise((function(t){return e.$onRenderResolve$=t})))}};var scheduleUpdate=function(e,t){{e.$flags$|=16}if(e.$flags$&4){e.$flags$|=512;return}attachToAncestor(e,e.$ancestorComponent$);var r=function(){return dispatchHooks(e,t)};return writeTask(r)};var dispatchHooks=function(e,t){var r=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$);var n=e.$lazyInstance$;var a;if(t){{e.$flags$|=256;if(e.$queuedListeners$){e.$queuedListeners$.map((function(e){var t=e[0],r=e[1];return safeCall(n,t,r)}));e.$queuedListeners$=null}}{a=safeCall(n,"componentWillLoad")}}{a=then(a,(function(){return safeCall(n,"componentWillRender")}))}r();return then(a,(function(){return updateComponent(e,n,t)}))};var updateComponent=function(e,t,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,a,o,s,i,l;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function($){n=e.$hostElement$;a=createTime("update",e.$cmpMeta$.$tagName$);o=n["s-rc"];if(r){attachStyles(e)}s=createTime("render",e.$cmpMeta$.$tagName$);{callRender(e,t)}if(o){o.map((function(e){return e()}));n["s-rc"]=undefined}s();a();{i=n["s-p"];l=function(){return postUpdateComponent(e)};if(i.length===0){l()}else{Promise.all(i).then(l);e.$flags$|=4;i.length=0}}return[2]}))}))};var callRender=function(e,t,r){try{t=t.render&&t.render();{e.$flags$&=~16}{e.$flags$|=2}{{{renderVdom(e,t)}}}}catch(t){consoleError(t,e.$hostElement$)}return null};var postUpdateComponent=function(e){var t=e.$cmpMeta$.$tagName$;var r=e.$hostElement$;var n=createTime("postUpdate",t);var a=e.$lazyInstance$;var o=e.$ancestorComponent$;{safeCall(a,"componentDidRender")}if(!(e.$flags$&64)){e.$flags$|=64;{addHydratedFlag(r)}{safeCall(a,"componentDidLoad")}n();{e.$onReadyResolve$(r);if(!o){appDidLoad()}}}else{{safeCall(a,"componentDidUpdate")}n()}{e.$onInstanceResolve$(r)}{if(e.$onRenderResolve$){e.$onRenderResolve$();e.$onRenderResolve$=undefined}if(e.$flags$&512){nextTick((function(){return scheduleUpdate(e,false)}))}e.$flags$&=~(4|512)}};var forceUpdate=function(e){{var t=getHostRef(e);var r=t.$hostElement$.isConnected;if(r&&(t.$flags$&(2|16))===2){scheduleUpdate(t,false)}return r}};var appDidLoad=function(e){{addHydratedFlag(doc.documentElement)}nextTick((function(){return emitEvent(win,"appload",{detail:{namespace:NAMESPACE}})}))};var safeCall=function(e,t,r){if(e&&e[t]){try{return e[t](r)}catch(e){consoleError(e)}}return undefined};var then=function(e,t){return e&&e.then?e.then(t):t()};var addHydratedFlag=function(e){return e.classList.add("hydrated")};var initializeClientHydrate=function(e,t,r,n){var a=createTime("hydrateClient",t);var o=e.shadowRoot;var s=[];var i=[];var l=o?[]:null;var $=n.$vnode$=newVNode(t,null);if(!plt.$orgLocNodes$){initializeDocumentHydrate(doc.body,plt.$orgLocNodes$=new Map)}e[HYDRATE_ID]=r;e.removeAttribute(HYDRATE_ID);clientHydrate($,s,i,l,e,e,r);s.map((function(e){var r=e.$hostId$+"."+e.$nodeId$;var n=plt.$orgLocNodes$.get(r);var a=e.$elm$;if(n&&supportsShadow&&n["s-en"]===""){n.parentNode.insertBefore(a,n.nextSibling)}if(!o){a["s-hn"]=t;if(n){a["s-ol"]=n;a["s-ol"]["s-nr"]=a}}plt.$orgLocNodes$.delete(r)}));if(o){l.map((function(e){if(e){o.appendChild(e)}}))}a()};var clientHydrate=function(e,t,r,n,a,o,s){var i;var l;var $;var c;if(o.nodeType===1){i=o.getAttribute(HYDRATE_CHILD_ID);if(i){l=i.split(".");if(l[0]===s||l[0]==="0"){$={$flags$:0,$hostId$:l[0],$nodeId$:l[1],$depth$:l[2],$index$:l[3],$tag$:o.tagName.toLowerCase(),$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null};t.push($);o.removeAttribute(HYDRATE_CHILD_ID);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;e=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}for(c=o.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.childNodes[c],s)}if(o.shadowRoot){for(c=o.shadowRoot.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.shadowRoot.childNodes[c],s)}}}else if(o.nodeType===8){l=o.nodeValue.split(".");if(l[1]===s||l[1]==="0"){i=l[0];$={$flags$:0,$hostId$:l[1],$nodeId$:l[2],$depth$:l[3],$index$:l[4],$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null};if(i===TEXT_NODE_ID){$.$elm$=o.nextSibling;if($.$elm$&&$.$elm$.nodeType===3){$.$text$=$.$elm$.textContent;t.push($);o.remove();if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}else if($.$hostId$===s){if(i===SLOT_NODE_ID){$.$tag$="slot";if(l[5]){o["s-sn"]=$.$name$=l[5]}else{o["s-sn"]=""}o["s-sr"]=true;if(n){$.$elm$=doc.createElement($.$tag$);if($.$name$){$.$elm$.setAttribute("name",$.$name$)}o.parentNode.insertBefore($.$elm$,o);o.remove();if($.$depth$==="0"){n[$.$index$]=$.$elm$}}r.push($);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$}else if(i===CONTENT_REF_ID){if(n){o.remove()}else{a["s-cr"]=o;o["s-cn"]=true}}}}}else if(e&&e.$tag$==="style"){var f=newVNode(null,o.textContent);f.$elm$=o;f.$index$="0";e.$children$=[f]}};var initializeDocumentHydrate=function(e,t){if(e.nodeType===1){var r=0;for(;r<e.childNodes.length;r++){initializeDocumentHydrate(e.childNodes[r],t)}if(e.shadowRoot){for(r=0;r<e.shadowRoot.childNodes.length;r++){initializeDocumentHydrate(e.shadowRoot.childNodes[r],t)}}}else if(e.nodeType===8){var n=e.nodeValue.split(".");if(n[0]===ORG_LOCATION_ID){t.set(n[1]+"."+n[2],e);e.nodeValue="";e["s-en"]=n[3]}}};var parsePropertyValue=function(e,t){if(e!=null&&!isComplexType(e)){if(t&4){return e==="false"?false:e===""||!!e}if(t&2){return parseFloat(e)}if(t&1){return String(e)}return e}return e};var getValue=function(e,t){return getHostRef(e).$instanceValues$.get(t)};var setValue=function(e,t,r,n){var a=getHostRef(e);var o=a.$hostElement$;var s=a.$instanceValues$.get(t);var i=a.$flags$;var l=a.$lazyInstance$;r=parsePropertyValue(r,n.$members$[t][0]);var $=Number.isNaN(s)&&Number.isNaN(r);var c=r!==s&&!$;if((!(i&8)||s===undefined)&&c){a.$instanceValues$.set(t,r);if(l){if(n.$watchers$&&i&128){var f=n.$watchers$[t];if(f){f.map((function(e){try{l[e](r,s,t)}catch(e){consoleError(e,o)}}))}}if((i&(2|16))===2){scheduleUpdate(a,false)}}}};var proxyComponent=function(e,t,r){if(t.$members$){if(e.watchers){t.$watchers$=e.watchers}var n=Object.entries(t.$members$);var a=e.prototype;n.map((function(e){var n=e[0],o=e[1][0];if(o&31||r&2&&o&32){Object.defineProperty(a,n,{get:function(){return getValue(this,n)},set:function(e){setValue(this,n,e,t)},configurable:true,enumerable:true})}else if(r&1&&o&64){Object.defineProperty(a,n,{value:function(){var e=[];for(var t=0;t<arguments.length;t++){e[t]=arguments[t]}var r=getHostRef(this);return r.$onInstancePromise$.then((function(){var t;return(t=r.$lazyInstance$)[n].apply(t,e)}))}})}}));if(r&1){var o=new Map;a.attributeChangedCallback=function(e,t,r){var n=this;plt.jmp((function(){var t=o.get(e);if(n.hasOwnProperty(t)){r=n[t];delete n[t]}else if(a.hasOwnProperty(t)&&typeof n[t]==="number"&&n[t]==r){return}n[t]=r===null&&typeof n[t]==="boolean"?false:r}))};e.observedAttributes=n.filter((function(e){var t=e[0],r=e[1];return r[0]&15})).map((function(e){var r=e[0],n=e[1];var a=n[1]||r;o.set(a,r);if(n[0]&512){t.$attrsToReflect$.push([r,a])}return a}))}}return e};var initializeComponent=function(e,t,r,n,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,o,s,i,l,$,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(f){switch(f.label){case 0:if(!((t.$flags$&32)===0))return[3,3];t.$flags$|=32;a=loadModule(r);if(!a.then)return[3,2];n=uniqueTime();return[4,a];case 1:a=f.sent();n();f.label=2;case 2:if(!a.isProxied){{r.$watchers$=a.watchers}proxyComponent(a,r,2);a.isProxied=true}o=createTime("createInstance",r.$tagName$);{t.$flags$|=8}try{new a(t)}catch(e){consoleError(e)}{t.$flags$&=~8}{t.$flags$|=128}o();fireConnectedCallback(t.$lazyInstance$);if(a.style){s=a.style;if(typeof s!=="string"){s=s[t.$modeName$=computeMode(e)]}i=getScopeId(r,t.$modeName$);if(!styles.has(i)){l=createTime("registerStyles",r.$tagName$);registerStyle(i,s,!!(r.$flags$&1));l()}}f.label=3;case 3:$=t.$ancestorComponent$;c=function(){return scheduleUpdate(t,true)};if($&&$["s-rc"]){$["s-rc"].push(c)}else{c()}return[2]}}))}))};var fireConnectedCallback=function(e){{safeCall(e,"connectedCallback")}};var connectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$cmpMeta$;var n=createTime("connectedCallback",r.$tagName$);if(!(t.$flags$&1)){t.$flags$|=1;var a=void 0;{a=e.getAttribute(HYDRATE_ID);if(a){if(r.$flags$&1){var o=addStyle(e.shadowRoot,r,e.getAttribute("s-mode"));e.classList.remove(o+"-h",o+"-s")}initializeClientHydrate(e,r.$tagName$,a,t)}}if(!a){if(r.$flags$&(4|8)){setContentReference(e)}}{var s=e;while(s=s.parentNode||s.host){if(s.nodeType===1&&s.hasAttribute("s-id")&&s["s-p"]||s["s-p"]){attachToAncestor(t,t.$ancestorComponent$=s);break}}}if(r.$members$){Object.entries(r.$members$).map((function(t){var r=t[0],n=t[1][0];if(n&31&&e.hasOwnProperty(r)){var a=e[r];delete e[r];e[r]=a}}))}{nextTick((function(){return initializeComponent(e,t,r)}))}}else{addHostEventListeners(e,t,r.$listeners$);fireConnectedCallback(t.$lazyInstance$)}n()}};var setContentReference=function(e){var t=e["s-cr"]=doc.createComment("");t["s-cn"]=true;e.insertBefore(t,e.firstChild)};var disconnectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$lazyInstance$;{if(t.$rmListeners$){t.$rmListeners$.map((function(e){return e()}));t.$rmListeners$=undefined}}{safeCall(r,"disconnectedCallback")}}};var bootstrapLazy=function(e,t){if(t===void 0){t={}}var r=createTime();var n=[];var a=t.exclude||[];var o=win.customElements;var s=doc.head;var i=s.querySelector("meta[charset]");var l=doc.createElement("style");var $=[];var c=doc.querySelectorAll("[".concat(HYDRATED_STYLE_ID,"]"));var f;var u=true;var d=0;Object.assign(plt,t);plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href;{plt.$flags$|=2}{for(;d<c.length;d++){registerStyle(c[d].getAttribute(HYDRATED_STYLE_ID),convertScopedToShadow(c[d].innerHTML),true)}}e.map((function(e){e[1].map((function(t){var r={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};{r.$members$=t[2]}{r.$listeners$=t[3]}{r.$attrsToReflect$=[]}{r.$watchers$={}}var s=r.$tagName$;var i=function(e){(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT)(t,e);function t(t){var n=e.call(this,t)||this;t=n;registerHost(t,r);if(r.$flags$&1){{{t.attachShadow({mode:"open",delegatesFocus:!!(r.$flags$&16)})}}}return n}t.prototype.connectedCallback=function(){var e=this;if(f){clearTimeout(f);f=null}if(u){$.push(this)}else{plt.jmp((function(){return connectedCallback(e)}))}};t.prototype.disconnectedCallback=function(){var e=this;plt.jmp((function(){return disconnectedCallback(e)}))};t.prototype.componentOnReady=function(){return getHostRef(this).$onReadyPromise$};return t}(HTMLElement);r.$lazyBundleId$=e[0];if(!a.includes(s)&&!o.get(s)){n.push(s);o.define(s,proxyComponent(i,r,1))}}))}));{l.innerHTML=n+HYDRATED_CSS;l.setAttribute("data-styles","");s.insertBefore(l,i?i.nextSibling:s.firstChild)}u=false;if($.length){$.map((function(e){return e.connectedCallback()}))}else{{plt.jmp((function(){return f=setTimeout(appDidLoad,30)}))}}r()};var getAssetPath=function(e){var t=new URL(e,plt.$resourcesUrl$);return t.origin!==win.location.origin?t.href:t.pathname};var hostRefs=new WeakMap;var getHostRef=function(e){return hostRefs.get(e)};var registerInstance=function(e,t){return hostRefs.set(t.$lazyInstance$=e,t)};var registerHost=function(e,t){var r={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};{r.$onInstancePromise$=new Promise((function(e){return r.$onInstanceResolve$=e}))}{r.$onReadyPromise$=new Promise((function(e){return r.$onReadyResolve$=e}));e["s-p"]=[];e["s-rc"]=[]}addHostEventListeners(e,r,t.$listeners$);return hostRefs.set(e,r)};var isMemberInElement=function(e,t){return t in e};var consoleError=function(e,t){return(0,console.error)(e,t)};var cmpModules=new Map;var loadModule=function(e,t,r){var n=e.$tagName$.replace(/-/g,"_");var a=e.$lazyBundleId$;var o=cmpModules.get(a);if(o){return o[n]}return __webpack_require__(3076)("./".concat(a,".entry.js").concat("")).then((function(e){{cmpModules.set(a,e)}return e[n]}),consoleError)};var styles=new Map;var modeResolutionChain=[];var queueDomReads=[];var queueDomWrites=[];var queueTask=function(e,t){return function(r){e.push(r);if(!queuePending){queuePending=true;if(t&&plt.$flags$&4){nextTick(flush)}else{plt.raf(flush)}}}};var consume=function(e){for(var t=0;t<e.length;t++){try{e[t](performance.now())}catch(e){consoleError(e)}}e.length=0};var flush=function(){consume(queueDomReads);{consume(queueDomWrites);if(queuePending=queueDomReads.length>0){plt.raf(flush)}}};var nextTick=function(e){return promiseResolve().then(e)};var readTask=queueTask(queueDomReads,false);var writeTask=queueTask(queueDomWrites,true);var Build={isDev:false,isBrowser:true,isServer:false,isTesting:false};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NENBQTRDLDZDQUE2QyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtYjNlZWNiMTQuanM/YjNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZXh0ZW5kcyxfX2dlbmVyYXRvcixfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL3ZhciBOQU1FU1BBQ0U9XCJpb25pY1wiO3ZhciBzY29wZUlkO3ZhciBjb250ZW50UmVmO3ZhciBob3N0VGFnTmFtZTt2YXIgdXNlTmF0aXZlU2hhZG93RG9tPWZhbHNlO3ZhciBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHk9ZmFsc2U7dmFyIGNoZWNrU2xvdFJlbG9jYXRlPWZhbHNlO3ZhciBpc1N2Z01vZGU9ZmFsc2U7dmFyIHF1ZXVlUGVuZGluZz1mYWxzZTt2YXIgd2luPXR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fTt2YXIgZG9jPXdpbi5kb2N1bWVudHx8e2hlYWQ6e319O3ZhciBwbHQ9eyRmbGFncyQ6MCwkcmVzb3VyY2VzVXJsJDpcIlwiLGptcDpmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSxyYWY6ZnVuY3Rpb24oZSl7cmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShlKX0sYWVsOmZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBlLmFkZEV2ZW50TGlzdGVuZXIodCxyLG4pfSxyZWw6ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LHIsbil9LGNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBDdXN0b21FdmVudChlLHQpfX07dmFyIHNldFBsYXRmb3JtSGVscGVycz1mdW5jdGlvbihlKXtPYmplY3QuYXNzaWduKHBsdCxlKX07dmFyIHN1cHBvcnRzU2hhZG93PXRydWU7dmFyIHByb21pc2VSZXNvbHZlPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoZSl9O3ZhciBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cz1mdW5jdGlvbigpe3RyeXtuZXcgQ1NTU3R5bGVTaGVldDtyZXR1cm4gdHlwZW9mKG5ldyBDU1NTdHlsZVNoZWV0KS5yZXBsYWNlPT09XCJmdW5jdGlvblwifWNhdGNoKGUpe31yZXR1cm4gZmFsc2V9KCk7dmFyIGFkZEhvc3RFdmVudExpc3RlbmVycz1mdW5jdGlvbihlLHQscixuKXtpZihyKXtyLm1hcCgoZnVuY3Rpb24ocil7dmFyIG49clswXSxhPXJbMV0sbz1yWzJdO3ZhciBzPWdldEhvc3RMaXN0ZW5lclRhcmdldChlLG4pO3ZhciBpPWhvc3RMaXN0ZW5lclByb3h5KHQsbyk7dmFyIGw9aG9zdExpc3RlbmVyT3B0cyhuKTtwbHQuYWVsKHMsYSxpLGwpOyh0LiRybUxpc3RlbmVycyQ9dC4kcm1MaXN0ZW5lcnMkfHxbXSkucHVzaCgoZnVuY3Rpb24oKXtyZXR1cm4gcGx0LnJlbChzLGEsaSxsKX0pKX0pKX19O3ZhciBob3N0TGlzdGVuZXJQcm94eT1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihyKXt0cnl7e2lmKGUuJGZsYWdzJCYyNTYpe2UuJGxhenlJbnN0YW5jZSRbdF0ocil9ZWxzZXsoZS4kcXVldWVkTGlzdGVuZXJzJD1lLiRxdWV1ZWRMaXN0ZW5lcnMkfHxbXSkucHVzaChbdCxyXSl9fX1jYXRjaChlKXtjb25zb2xlRXJyb3IoZSl9fX07dmFyIGdldEhvc3RMaXN0ZW5lclRhcmdldD1mdW5jdGlvbihlLHQpe2lmKHQmNClyZXR1cm4gZG9jO2lmKHQmOClyZXR1cm4gd2luO2lmKHQmMTYpcmV0dXJuIGRvYy5ib2R5O3JldHVybiBlfTt2YXIgaG9zdExpc3RlbmVyT3B0cz1mdW5jdGlvbihlKXtyZXR1cm4oZSYyKSE9PTB9O3ZhciBDT05URU5UX1JFRl9JRD1cInJcIjt2YXIgT1JHX0xPQ0FUSU9OX0lEPVwib1wiO3ZhciBTTE9UX05PREVfSUQ9XCJzXCI7dmFyIFRFWFRfTk9ERV9JRD1cInRcIjt2YXIgSFlEUkFURV9JRD1cInMtaWRcIjt2YXIgSFlEUkFURURfU1RZTEVfSUQ9XCJzdHktaWRcIjt2YXIgSFlEUkFURV9DSElMRF9JRD1cImMtaWRcIjt2YXIgSFlEUkFURURfQ1NTPVwie3Zpc2liaWxpdHk6aGlkZGVufS5oeWRyYXRlZHt2aXNpYmlsaXR5OmluaGVyaXR9XCI7dmFyIFhMSU5LX05TPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO3ZhciBjcmVhdGVUaW1lPWZ1bmN0aW9uKGUsdCl7aWYodD09PXZvaWQgMCl7dD1cIlwifXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm59fX07dmFyIHVuaXF1ZVRpbWU9ZnVuY3Rpb24oZSx0KXt7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJufX19O3ZhciByb290QXBwbGllZFN0eWxlcz1uZXcgV2Vha01hcDt2YXIgcmVnaXN0ZXJTdHlsZT1mdW5jdGlvbihlLHQscil7dmFyIG49c3R5bGVzLmdldChlKTtpZihzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cyYmcil7bj1ufHxuZXcgQ1NTU3R5bGVTaGVldDtuLnJlcGxhY2UodCl9ZWxzZXtuPXR9c3R5bGVzLnNldChlLG4pfTt2YXIgYWRkU3R5bGU9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9Z2V0U2NvcGVJZCh0LHIpO3ZhciBvPXN0eWxlcy5nZXQoYSk7ZT1lLm5vZGVUeXBlPT09MTE/ZTpkb2M7aWYobyl7aWYodHlwZW9mIG89PT1cInN0cmluZ1wiKXtlPWUuaGVhZHx8ZTt2YXIgcz1yb290QXBwbGllZFN0eWxlcy5nZXQoZSk7dmFyIGk9dm9pZCAwO2lmKCFzKXtyb290QXBwbGllZFN0eWxlcy5zZXQoZSxzPW5ldyBTZXQpfWlmKCFzLmhhcyhhKSl7aWYoZS5ob3N0JiYoaT1lLnF1ZXJ5U2VsZWN0b3IoXCJbXCIuY29uY2F0KEhZRFJBVEVEX1NUWUxFX0lELCc9XCInKS5jb25jYXQoYSwnXCJdJykpKSl7aS5pbm5lckhUTUw9b31lbHNle3tpPWRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aS5pbm5lckhUTUw9b31lLmluc2VydEJlZm9yZShpLGUucXVlcnlTZWxlY3RvcihcImxpbmtcIikpfWlmKHMpe3MuYWRkKGEpfX19ZWxzZSBpZighZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMobykpe2UuYWRvcHRlZFN0eWxlU2hlZXRzPV9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxlLmFkb3B0ZWRTdHlsZVNoZWV0cyx0cnVlKSxbb10sZmFsc2UpfX1yZXR1cm4gYX07dmFyIGF0dGFjaFN0eWxlcz1mdW5jdGlvbihlKXt2YXIgdD1lLiRjbXBNZXRhJDt2YXIgcj1lLiRob3N0RWxlbWVudCQ7dmFyIG49dC4kZmxhZ3MkO3ZhciBhPWNyZWF0ZVRpbWUoXCJhdHRhY2hTdHlsZXNcIix0LiR0YWdOYW1lJCk7dmFyIG89YWRkU3R5bGUoci5zaGFkb3dSb290P3Iuc2hhZG93Um9vdDpyLmdldFJvb3ROb2RlKCksdCxlLiRtb2RlTmFtZSQpO2lmKG4mMTApe3JbXCJzLXNjXCJdPW87ci5jbGFzc0xpc3QuYWRkKG8rXCItaFwiKTtpZihuJjIpe3IuY2xhc3NMaXN0LmFkZChvK1wiLXNcIil9fWEoKX07dmFyIGdldFNjb3BlSWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInNjLVwiKyh0JiZlLiRmbGFncyQmMzI/ZS4kdGFnTmFtZSQrXCItXCIrdDplLiR0YWdOYW1lJCl9O3ZhciBjb252ZXJ0U2NvcGVkVG9TaGFkb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csXCIkMXtcIil9O3ZhciBjb21wdXRlTW9kZT1mdW5jdGlvbihlKXtyZXR1cm4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0KGUpfSkpLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKX07dmFyIHNldE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG1vZGVSZXNvbHV0aW9uQ2hhaW4ucHVzaChlKX07dmFyIGdldE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGdldEhvc3RSZWYoZSkuJG1vZGVOYW1lJH07dmFyIEVNUFRZX09CSj17fTt2YXIgU1ZHX05TPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjt2YXIgSFRNTF9OUz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjt2YXIgaXNEZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPW51bGx9O3ZhciBpc0NvbXBsZXhUeXBlPWZ1bmN0aW9uKGUpe2U9dHlwZW9mIGU7cmV0dXJuIGU9PT1cIm9iamVjdFwifHxlPT09XCJmdW5jdGlvblwifTt2YXIgaD1mdW5jdGlvbihlLHQpe3ZhciByPVtdO2Zvcih2YXIgbj0yO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3Jbbi0yXT1hcmd1bWVudHNbbl19dmFyIGE9bnVsbDt2YXIgbz1udWxsO3ZhciBzPW51bGw7dmFyIGk9ZmFsc2U7dmFyIGw9ZmFsc2U7dmFyICQ9W107dmFyIGM9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe2E9dFtyXTtpZihBcnJheS5pc0FycmF5KGEpKXtjKGEpfWVsc2UgaWYoYSE9bnVsbCYmdHlwZW9mIGEhPT1cImJvb2xlYW5cIil7aWYoaT10eXBlb2YgZSE9PVwiZnVuY3Rpb25cIiYmIWlzQ29tcGxleFR5cGUoYSkpe2E9U3RyaW5nKGEpfWlmKGkmJmwpeyRbJC5sZW5ndGgtMV0uJHRleHQkKz1hfWVsc2V7JC5wdXNoKGk/bmV3Vk5vZGUobnVsbCxhKTphKX1sPWl9fX07YyhyKTtpZih0KXtpZih0LmtleSl7bz10LmtleX1pZih0Lm5hbWUpe3M9dC5uYW1lfXt2YXIgZj10LmNsYXNzTmFtZXx8dC5jbGFzcztpZihmKXt0LmNsYXNzPXR5cGVvZiBmIT09XCJvYmplY3RcIj9mOk9iamVjdC5rZXlzKGYpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGZbZV19KSkuam9pbihcIiBcIil9fX1pZih0eXBlb2YgZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGUodD09PW51bGw/e306dCwkLHZkb21GblV0aWxzKX12YXIgdT1uZXdWTm9kZShlLG51bGwpO3UuJGF0dHJzJD10O2lmKCQubGVuZ3RoPjApe3UuJGNoaWxkcmVuJD0kfXt1LiRrZXkkPW99e3UuJG5hbWUkPXN9cmV0dXJuIHV9O3ZhciBuZXdWTm9kZT1mdW5jdGlvbihlLHQpe3ZhciByPXskZmxhZ3MkOjAsJHRhZyQ6ZSwkdGV4dCQ6dCwkZWxtJDpudWxsLCRjaGlsZHJlbiQ6bnVsbH07e3IuJGF0dHJzJD1udWxsfXtyLiRrZXkkPW51bGx9e3IuJG5hbWUkPW51bGx9cmV0dXJuIHJ9O3ZhciBIb3N0PXt9O3ZhciBpc0hvc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuJHRhZyQ9PT1Ib3N0fTt2YXIgdmRvbUZuVXRpbHM9e2ZvckVhY2g6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXAoY29udmVydFRvUHVibGljKS5mb3JFYWNoKHQpfSxtYXA6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXAoY29udmVydFRvUHVibGljKS5tYXAodCkubWFwKGNvbnZlcnRUb1ByaXZhdGUpfX07dmFyIGNvbnZlcnRUb1B1YmxpYz1mdW5jdGlvbihlKXtyZXR1cm57dmF0dHJzOmUuJGF0dHJzJCx2Y2hpbGRyZW46ZS4kY2hpbGRyZW4kLHZrZXk6ZS4ka2V5JCx2bmFtZTplLiRuYW1lJCx2dGFnOmUuJHRhZyQsdnRleHQ6ZS4kdGV4dCR9fTt2YXIgY29udmVydFRvUHJpdmF0ZT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZS52dGFnPT09XCJmdW5jdGlvblwiKXt2YXIgdD1PYmplY3QuYXNzaWduKHt9LGUudmF0dHJzKTtpZihlLnZrZXkpe3Qua2V5PWUudmtleX1pZihlLnZuYW1lKXt0Lm5hbWU9ZS52bmFtZX1yZXR1cm4gaC5hcHBseSh2b2lkIDAsX19zcHJlYWRBcnJheShbZS52dGFnLHRdLGUudmNoaWxkcmVufHxbXSxmYWxzZSkpfXZhciByPW5ld1ZOb2RlKGUudnRhZyxlLnZ0ZXh0KTtyLiRhdHRycyQ9ZS52YXR0cnM7ci4kY2hpbGRyZW4kPWUudmNoaWxkcmVuO3IuJGtleSQ9ZS52a2V5O3IuJG5hbWUkPWUudm5hbWU7cmV0dXJuIHJ9O3ZhciBzZXRBY2Nlc3Nvcj1mdW5jdGlvbihlLHQscixuLGEsbyl7aWYociE9PW4pe3ZhciBzPWlzTWVtYmVySW5FbGVtZW50KGUsdCk7dmFyIGk9dC50b0xvd2VyQ2FzZSgpO2lmKHQ9PT1cImNsYXNzXCIpe3ZhciBsPWUuY2xhc3NMaXN0O3ZhciAkPXBhcnNlQ2xhc3NMaXN0KHIpO3ZhciBjPXBhcnNlQ2xhc3NMaXN0KG4pO2wucmVtb3ZlLmFwcGx5KGwsJC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiYhYy5pbmNsdWRlcyhlKX0pKSk7bC5hZGQuYXBwbHkobCxjLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiEkLmluY2x1ZGVzKGUpfSkpKX1lbHNlIGlmKHQ9PT1cInN0eWxlXCIpe3tmb3IodmFyIGYgaW4gcil7aWYoIW58fG5bZl09PW51bGwpe2lmKGYuaW5jbHVkZXMoXCItXCIpKXtlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGYpfWVsc2V7ZS5zdHlsZVtmXT1cIlwifX19fWZvcih2YXIgZiBpbiBuKXtpZighcnx8bltmXSE9PXJbZl0pe2lmKGYuaW5jbHVkZXMoXCItXCIpKXtlLnN0eWxlLnNldFByb3BlcnR5KGYsbltmXSl9ZWxzZXtlLnN0eWxlW2ZdPW5bZl19fX19ZWxzZSBpZih0PT09XCJrZXlcIik7ZWxzZSBpZih0PT09XCJyZWZcIil7aWYobil7bihlKX19ZWxzZSBpZighcyYmdFswXT09PVwib1wiJiZ0WzFdPT09XCJuXCIpe2lmKHRbMl09PT1cIi1cIil7dD10LnNsaWNlKDMpfWVsc2UgaWYoaXNNZW1iZXJJbkVsZW1lbnQod2luLGkpKXt0PWkuc2xpY2UoMil9ZWxzZXt0PWlbMl0rdC5zbGljZSgzKX1pZihyKXtwbHQucmVsKGUsdCxyLGZhbHNlKX1pZihuKXtwbHQuYWVsKGUsdCxuLGZhbHNlKX19ZWxzZXt2YXIgdT1pc0NvbXBsZXhUeXBlKG4pO2lmKChzfHx1JiZuIT09bnVsbCkmJiFhKXt0cnl7aWYoIWUudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikpe3ZhciBkPW49PW51bGw/XCJcIjpuO2lmKHQ9PT1cImxpc3RcIil7cz1mYWxzZX1lbHNlIGlmKHI9PW51bGx8fGVbdF0hPWQpe2VbdF09ZH19ZWxzZXtlW3RdPW59fWNhdGNoKGUpe319dmFyIHY9ZmFsc2U7e2lmKGkhPT0oaT1pLnJlcGxhY2UoL154bGlua1xcOj8vLFwiXCIpKSl7dD1pO3Y9dHJ1ZX19aWYobj09bnVsbHx8bj09PWZhbHNlKXtpZihuIT09ZmFsc2V8fGUuZ2V0QXR0cmlidXRlKHQpPT09XCJcIil7aWYodil7ZS5yZW1vdmVBdHRyaWJ1dGVOUyhYTElOS19OUyx0KX1lbHNle2UucmVtb3ZlQXR0cmlidXRlKHQpfX19ZWxzZSBpZigoIXN8fG8mNHx8YSkmJiF1KXtuPW49PT10cnVlP1wiXCI6bjtpZih2KXtlLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLHQsbil9ZWxzZXtlLnNldEF0dHJpYnV0ZSh0LG4pfX19fX07dmFyIHBhcnNlQ2xhc3NMaXN0UmVnZXg9L1xccy87dmFyIHBhcnNlQ2xhc3NMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiFlP1tdOmUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCl9O3ZhciB1cGRhdGVFbGVtZW50PWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPXQuJGVsbSQubm9kZVR5cGU9PT0xMSYmdC4kZWxtJC5ob3N0P3QuJGVsbSQuaG9zdDp0LiRlbG0kO3ZhciBvPWUmJmUuJGF0dHJzJHx8RU1QVFlfT0JKO3ZhciBzPXQuJGF0dHJzJHx8RU1QVFlfT0JKO3tmb3IobiBpbiBvKXtpZighKG4gaW4gcykpe3NldEFjY2Vzc29yKGEsbixvW25dLHVuZGVmaW5lZCxyLHQuJGZsYWdzJCl9fX1mb3IobiBpbiBzKXtzZXRBY2Nlc3NvcihhLG4sb1tuXSxzW25dLHIsdC4kZmxhZ3MkKX19O3ZhciBjcmVhdGVFbG09ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9dC4kY2hpbGRyZW4kW3JdO3ZhciBvPTA7dmFyIHM7dmFyIGk7dmFyIGw7aWYoIXVzZU5hdGl2ZVNoYWRvd0RvbSl7Y2hlY2tTbG90UmVsb2NhdGU9dHJ1ZTtpZihhLiR0YWckPT09XCJzbG90XCIpe2lmKHNjb3BlSWQpe24uY2xhc3NMaXN0LmFkZChzY29wZUlkK1wiLXNcIil9YS4kZmxhZ3MkfD1hLiRjaGlsZHJlbiQ/MjoxfX1pZihhLiR0ZXh0JCE9PW51bGwpe3M9YS4kZWxtJD1kb2MuY3JlYXRlVGV4dE5vZGUoYS4kdGV4dCQpfWVsc2UgaWYoYS4kZmxhZ3MkJjEpe3M9YS4kZWxtJD1kb2MuY3JlYXRlVGV4dE5vZGUoXCJcIil9ZWxzZXtpZighaXNTdmdNb2RlKXtpc1N2Z01vZGU9YS4kdGFnJD09PVwic3ZnXCJ9cz1hLiRlbG0kPWRvYy5jcmVhdGVFbGVtZW50TlMoaXNTdmdNb2RlP1NWR19OUzpIVE1MX05TLGEuJGZsYWdzJCYyP1wic2xvdC1mYlwiOmEuJHRhZyQpO2lmKGlzU3ZnTW9kZSYmYS4kdGFnJD09PVwiZm9yZWlnbk9iamVjdFwiKXtpc1N2Z01vZGU9ZmFsc2V9e3VwZGF0ZUVsZW1lbnQobnVsbCxhLGlzU3ZnTW9kZSl9aWYoaXNEZWYoc2NvcGVJZCkmJnNbXCJzLXNpXCJdIT09c2NvcGVJZCl7cy5jbGFzc0xpc3QuYWRkKHNbXCJzLXNpXCJdPXNjb3BlSWQpfWlmKGEuJGNoaWxkcmVuJCl7Zm9yKG89MDtvPGEuJGNoaWxkcmVuJC5sZW5ndGg7KytvKXtpPWNyZWF0ZUVsbShlLGEsbyxzKTtpZihpKXtzLmFwcGVuZENoaWxkKGkpfX19e2lmKGEuJHRhZyQ9PT1cInN2Z1wiKXtpc1N2Z01vZGU9ZmFsc2V9ZWxzZSBpZihzLnRhZ05hbWU9PT1cImZvcmVpZ25PYmplY3RcIil7aXNTdmdNb2RlPXRydWV9fX17c1tcInMtaG5cIl09aG9zdFRhZ05hbWU7aWYoYS4kZmxhZ3MkJigyfDEpKXtzW1wicy1zclwiXT10cnVlO3NbXCJzLWNyXCJdPWNvbnRlbnRSZWY7c1tcInMtc25cIl09YS4kbmFtZSR8fFwiXCI7bD1lJiZlLiRjaGlsZHJlbiQmJmUuJGNoaWxkcmVuJFtyXTtpZihsJiZsLiR0YWckPT09YS4kdGFnJCYmZS4kZWxtJCl7cHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihlLiRlbG0kLGZhbHNlKX19fXJldHVybiBzfTt2YXIgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbj1mdW5jdGlvbihlLHQpe3BsdC4kZmxhZ3MkfD0xO3ZhciByPWUuY2hpbGROb2Rlcztmb3IodmFyIG49ci5sZW5ndGgtMTtuPj0wO24tLSl7dmFyIGE9cltuXTtpZihhW1wicy1oblwiXSE9PWhvc3RUYWdOYW1lJiZhW1wicy1vbFwiXSl7cGFyZW50UmVmZXJlbmNlTm9kZShhKS5pbnNlcnRCZWZvcmUoYSxyZWZlcmVuY2VOb2RlKGEpKTthW1wicy1vbFwiXS5yZW1vdmUoKTthW1wicy1vbFwiXT11bmRlZmluZWQ7Y2hlY2tTbG90UmVsb2NhdGU9dHJ1ZX1pZih0KXtwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGEsdCl9fXBsdC4kZmxhZ3MkJj1+MX07dmFyIGFkZFZub2Rlcz1mdW5jdGlvbihlLHQscixuLGEsbyl7dmFyIHM9ZVtcInMtY3JcIl0mJmVbXCJzLWNyXCJdLnBhcmVudE5vZGV8fGU7dmFyIGk7aWYocy5zaGFkb3dSb290JiZzLnRhZ05hbWU9PT1ob3N0VGFnTmFtZSl7cz1zLnNoYWRvd1Jvb3R9Zm9yKDthPD1vOysrYSl7aWYoblthXSl7aT1jcmVhdGVFbG0obnVsbCxyLGEsZSk7aWYoaSl7blthXS4kZWxtJD1pO3MuaW5zZXJ0QmVmb3JlKGkscmVmZXJlbmNlTm9kZSh0KSl9fX19O3ZhciByZW1vdmVWbm9kZXM9ZnVuY3Rpb24oZSx0LHIsbixhKXtmb3IoO3Q8PXI7Kyt0KXtpZihuPWVbdF0pe2E9bi4kZWxtJDtjYWxsTm9kZVJlZnMobik7e2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT10cnVlO2lmKGFbXCJzLW9sXCJdKXthW1wicy1vbFwiXS5yZW1vdmUoKX1lbHNle3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oYSx0cnVlKX19YS5yZW1vdmUoKX19fTt2YXIgdXBkYXRlQ2hpbGRyZW49ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9MDt2YXIgbz0wO3ZhciBzPTA7dmFyIGk9MDt2YXIgbD10Lmxlbmd0aC0xO3ZhciAkPXRbMF07dmFyIGM9dFtsXTt2YXIgZj1uLmxlbmd0aC0xO3ZhciB1PW5bMF07dmFyIGQ9bltmXTt2YXIgdjt2YXIgcDt3aGlsZShhPD1sJiZvPD1mKXtpZigkPT1udWxsKXskPXRbKythXX1lbHNlIGlmKGM9PW51bGwpe2M9dFstLWxdfWVsc2UgaWYodT09bnVsbCl7dT1uWysrb119ZWxzZSBpZihkPT1udWxsKXtkPW5bLS1mXX1lbHNlIGlmKGlzU2FtZVZub2RlKCQsdSkpe3BhdGNoKCQsdSk7JD10WysrYV07dT1uWysrb119ZWxzZSBpZihpc1NhbWVWbm9kZShjLGQpKXtwYXRjaChjLGQpO2M9dFstLWxdO2Q9blstLWZdfWVsc2UgaWYoaXNTYW1lVm5vZGUoJCxkKSl7aWYoJC4kdGFnJD09PVwic2xvdFwifHxkLiR0YWckPT09XCJzbG90XCIpe3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oJC4kZWxtJC5wYXJlbnROb2RlLGZhbHNlKX1wYXRjaCgkLGQpO2UuaW5zZXJ0QmVmb3JlKCQuJGVsbSQsYy4kZWxtJC5uZXh0U2libGluZyk7JD10WysrYV07ZD1uWy0tZl19ZWxzZSBpZihpc1NhbWVWbm9kZShjLHUpKXtpZigkLiR0YWckPT09XCJzbG90XCJ8fGQuJHRhZyQ9PT1cInNsb3RcIil7cHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihjLiRlbG0kLnBhcmVudE5vZGUsZmFsc2UpfXBhdGNoKGMsdSk7ZS5pbnNlcnRCZWZvcmUoYy4kZWxtJCwkLiRlbG0kKTtjPXRbLS1sXTt1PW5bKytvXX1lbHNle3M9LTE7e2ZvcihpPWE7aTw9bDsrK2kpe2lmKHRbaV0mJnRbaV0uJGtleSQhPT1udWxsJiZ0W2ldLiRrZXkkPT09dS4ka2V5JCl7cz1pO2JyZWFrfX19aWYocz49MCl7cD10W3NdO2lmKHAuJHRhZyQhPT11LiR0YWckKXt2PWNyZWF0ZUVsbSh0JiZ0W29dLHIscyxlKX1lbHNle3BhdGNoKHAsdSk7dFtzXT11bmRlZmluZWQ7dj1wLiRlbG0kfXU9blsrK29dfWVsc2V7dj1jcmVhdGVFbG0odCYmdFtvXSxyLG8sZSk7dT1uWysrb119aWYodil7e3BhcmVudFJlZmVyZW5jZU5vZGUoJC4kZWxtJCkuaW5zZXJ0QmVmb3JlKHYscmVmZXJlbmNlTm9kZSgkLiRlbG0kKSl9fX19aWYoYT5sKXthZGRWbm9kZXMoZSxuW2YrMV09PW51bGw/bnVsbDpuW2YrMV0uJGVsbSQscixuLG8sZil9ZWxzZSBpZihvPmYpe3JlbW92ZVZub2Rlcyh0LGEsbCl9fTt2YXIgaXNTYW1lVm5vZGU9ZnVuY3Rpb24oZSx0KXtpZihlLiR0YWckPT09dC4kdGFnJCl7aWYoZS4kdGFnJD09PVwic2xvdFwiKXtyZXR1cm4gZS4kbmFtZSQ9PT10LiRuYW1lJH17cmV0dXJuIGUuJGtleSQ9PT10LiRrZXkkfX1yZXR1cm4gZmFsc2V9O3ZhciByZWZlcmVuY2VOb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlW1wicy1vbFwiXXx8ZX07dmFyIHBhcmVudFJlZmVyZW5jZU5vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuKGVbXCJzLW9sXCJdP2VbXCJzLW9sXCJdOmUpLnBhcmVudE5vZGV9O3ZhciBwYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQuJGVsbSQ9ZS4kZWxtJDt2YXIgbj1lLiRjaGlsZHJlbiQ7dmFyIGE9dC4kY2hpbGRyZW4kO3ZhciBvPXQuJHRhZyQ7dmFyIHM9dC4kdGV4dCQ7dmFyIGk7aWYocz09PW51bGwpe3tpc1N2Z01vZGU9bz09PVwic3ZnXCI/dHJ1ZTpvPT09XCJmb3JlaWduT2JqZWN0XCI/ZmFsc2U6aXNTdmdNb2RlfXtpZihvPT09XCJzbG90XCIpO2Vsc2V7dXBkYXRlRWxlbWVudChlLHQsaXNTdmdNb2RlKX19aWYobiE9PW51bGwmJmEhPT1udWxsKXt1cGRhdGVDaGlsZHJlbihyLG4sdCxhKX1lbHNlIGlmKGEhPT1udWxsKXtpZihlLiR0ZXh0JCE9PW51bGwpe3IudGV4dENvbnRlbnQ9XCJcIn1hZGRWbm9kZXMocixudWxsLHQsYSwwLGEubGVuZ3RoLTEpfWVsc2UgaWYobiE9PW51bGwpe3JlbW92ZVZub2RlcyhuLDAsbi5sZW5ndGgtMSl9aWYoaXNTdmdNb2RlJiZvPT09XCJzdmdcIil7aXNTdmdNb2RlPWZhbHNlfX1lbHNlIGlmKGk9cltcInMtY3JcIl0pe2kucGFyZW50Tm9kZS50ZXh0Q29udGVudD1zfWVsc2UgaWYoZS4kdGV4dCQhPT1zKXtyLmRhdGE9c319O3ZhciB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5PWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2hpbGROb2Rlczt2YXIgcjt2YXIgbjt2YXIgYTt2YXIgbzt2YXIgczt2YXIgaTtmb3Iobj0wLGE9dC5sZW5ndGg7bjxhO24rKyl7cj10W25dO2lmKHIubm9kZVR5cGU9PT0xKXtpZihyW1wicy1zclwiXSl7cz1yW1wicy1zblwiXTtyLmhpZGRlbj1mYWxzZTtmb3Iobz0wO288YTtvKyspe2k9dFtvXS5ub2RlVHlwZTtpZih0W29dW1wicy1oblwiXSE9PXJbXCJzLWhuXCJdfHxzIT09XCJcIil7aWYoaT09PTEmJnM9PT10W29dLmdldEF0dHJpYnV0ZShcInNsb3RcIikpe3IuaGlkZGVuPXRydWU7YnJlYWt9fWVsc2V7aWYoaT09PTF8fGk9PT0zJiZ0W29dLnRleHRDb250ZW50LnRyaW0oKSE9PVwiXCIpe3IuaGlkZGVuPXRydWU7YnJlYWt9fX19dXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eShyKX19fTt2YXIgcmVsb2NhdGVOb2Rlcz1bXTt2YXIgcmVsb2NhdGVTbG90Q29udGVudD1mdW5jdGlvbihlKXt2YXIgdDt2YXIgcjt2YXIgbjt2YXIgYTt2YXIgbzt2YXIgczt2YXIgaT0wO3ZhciBsPWUuY2hpbGROb2Rlczt2YXIgJD1sLmxlbmd0aDtmb3IoO2k8JDtpKyspe3Q9bFtpXTtpZih0W1wicy1zclwiXSYmKHI9dFtcInMtY3JcIl0pJiZyLnBhcmVudE5vZGUpe249ci5wYXJlbnROb2RlLmNoaWxkTm9kZXM7YT10W1wicy1zblwiXTtmb3Iocz1uLmxlbmd0aC0xO3M+PTA7cy0tKXtyPW5bc107aWYoIXJbXCJzLWNuXCJdJiYhcltcInMtbnJcIl0mJnJbXCJzLWhuXCJdIT09dFtcInMtaG5cIl0pe2lmKGlzTm9kZUxvY2F0ZWRJblNsb3QocixhKSl7bz1yZWxvY2F0ZU5vZGVzLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiBlLiRub2RlVG9SZWxvY2F0ZSQ9PT1yfSkpO2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT10cnVlO3JbXCJzLXNuXCJdPXJbXCJzLXNuXCJdfHxhO2lmKG8pe28uJHNsb3RSZWZOb2RlJD10fWVsc2V7cmVsb2NhdGVOb2Rlcy5wdXNoKHskc2xvdFJlZk5vZGUkOnQsJG5vZGVUb1JlbG9jYXRlJDpyfSl9aWYocltcInMtc3JcIl0pe3JlbG9jYXRlTm9kZXMubWFwKChmdW5jdGlvbihlKXtpZihpc05vZGVMb2NhdGVkSW5TbG90KGUuJG5vZGVUb1JlbG9jYXRlJCxyW1wicy1zblwiXSkpe289cmVsb2NhdGVOb2Rlcy5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gZS4kbm9kZVRvUmVsb2NhdGUkPT09cn0pKTtpZihvJiYhZS4kc2xvdFJlZk5vZGUkKXtlLiRzbG90UmVmTm9kZSQ9by4kc2xvdFJlZk5vZGUkfX19KSl9fWVsc2UgaWYoIXJlbG9jYXRlTm9kZXMuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuJG5vZGVUb1JlbG9jYXRlJD09PXJ9KSkpe3JlbG9jYXRlTm9kZXMucHVzaCh7JG5vZGVUb1JlbG9jYXRlJDpyfSl9fX19aWYodC5ub2RlVHlwZT09PTEpe3JlbG9jYXRlU2xvdENvbnRlbnQodCl9fX07dmFyIGlzTm9kZUxvY2F0ZWRJblNsb3Q9ZnVuY3Rpb24oZSx0KXtpZihlLm5vZGVUeXBlPT09MSl7aWYoZS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpPT09bnVsbCYmdD09PVwiXCIpe3JldHVybiB0cnVlfWlmKGUuZ2V0QXR0cmlidXRlKFwic2xvdFwiKT09PXQpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1pZihlW1wicy1zblwiXT09PXQpe3JldHVybiB0cnVlfXJldHVybiB0PT09XCJcIn07dmFyIGNhbGxOb2RlUmVmcz1mdW5jdGlvbihlKXt7ZS4kYXR0cnMkJiZlLiRhdHRycyQucmVmJiZlLiRhdHRycyQucmVmKG51bGwpO2UuJGNoaWxkcmVuJCYmZS4kY2hpbGRyZW4kLm1hcChjYWxsTm9kZVJlZnMpfX07dmFyIHJlbmRlclZkb209ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLiRob3N0RWxlbWVudCQ7dmFyIG49ZS4kY21wTWV0YSQ7dmFyIGE9ZS4kdm5vZGUkfHxuZXdWTm9kZShudWxsLG51bGwpO3ZhciBvPWlzSG9zdCh0KT90OmgobnVsbCxudWxsLHQpO2hvc3RUYWdOYW1lPXIudGFnTmFtZTtpZihuLiRhdHRyc1RvUmVmbGVjdCQpe28uJGF0dHJzJD1vLiRhdHRycyR8fHt9O24uJGF0dHJzVG9SZWZsZWN0JC5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVybiBvLiRhdHRycyRbbl09clt0XX0pKX1vLiR0YWckPW51bGw7by4kZmxhZ3MkfD00O2UuJHZub2RlJD1vO28uJGVsbSQ9YS4kZWxtJD1yLnNoYWRvd1Jvb3R8fHI7e3Njb3BlSWQ9cltcInMtc2NcIl19e2NvbnRlbnRSZWY9cltcInMtY3JcIl07dXNlTmF0aXZlU2hhZG93RG9tPShuLiRmbGFncyQmMSkhPT0wO2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT1mYWxzZX1wYXRjaChhLG8pO3twbHQuJGZsYWdzJHw9MTtpZihjaGVja1Nsb3RSZWxvY2F0ZSl7cmVsb2NhdGVTbG90Q29udGVudChvLiRlbG0kKTt2YXIgcz12b2lkIDA7dmFyIGk9dm9pZCAwO3ZhciBsPXZvaWQgMDt2YXIgJD12b2lkIDA7dmFyIGM9dm9pZCAwO3ZhciBmPXZvaWQgMDt2YXIgdT0wO2Zvcig7dTxyZWxvY2F0ZU5vZGVzLmxlbmd0aDt1Kyspe3M9cmVsb2NhdGVOb2Rlc1t1XTtpPXMuJG5vZGVUb1JlbG9jYXRlJDtpZighaVtcInMtb2xcIl0pe2w9ZG9jLmNyZWF0ZVRleHROb2RlKFwiXCIpO2xbXCJzLW5yXCJdPWk7aS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpW1wicy1vbFwiXT1sLGkpfX1mb3IodT0wO3U8cmVsb2NhdGVOb2Rlcy5sZW5ndGg7dSsrKXtzPXJlbG9jYXRlTm9kZXNbdV07aT1zLiRub2RlVG9SZWxvY2F0ZSQ7aWYocy4kc2xvdFJlZk5vZGUkKXskPXMuJHNsb3RSZWZOb2RlJC5wYXJlbnROb2RlO2M9cy4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO2w9aVtcInMtb2xcIl07d2hpbGUobD1sLnByZXZpb3VzU2libGluZyl7Zj1sW1wicy1uclwiXTtpZihmJiZmW1wicy1zblwiXT09PWlbXCJzLXNuXCJdJiYkPT09Zi5wYXJlbnROb2RlKXtmPWYubmV4dFNpYmxpbmc7aWYoIWZ8fCFmW1wicy1uclwiXSl7Yz1mO2JyZWFrfX19aWYoIWMmJiQhPT1pLnBhcmVudE5vZGV8fGkubmV4dFNpYmxpbmchPT1jKXtpZihpIT09Yyl7aWYoIWlbXCJzLWhuXCJdJiZpW1wicy1vbFwiXSl7aVtcInMtaG5cIl09aVtcInMtb2xcIl0ucGFyZW50Tm9kZS5ub2RlTmFtZX0kLmluc2VydEJlZm9yZShpLGMpfX19ZWxzZXtpZihpLm5vZGVUeXBlPT09MSl7aS5oaWRkZW49dHJ1ZX19fX1pZihjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpe3VwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkoby4kZWxtJCl9cGx0LiRmbGFncyQmPX4xO3JlbG9jYXRlTm9kZXMubGVuZ3RoPTB9fTt2YXIgZ2V0RWxlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZ2V0SG9zdFJlZihlKS4kaG9zdEVsZW1lbnQkfTt2YXIgY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWdldEVsZW1lbnQoZSk7cmV0dXJue2VtaXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVtaXRFdmVudChuLHQse2J1YmJsZXM6ISEociY0KSxjb21wb3NlZDohIShyJjIpLGNhbmNlbGFibGU6ISEociYxKSxkZXRhaWw6ZX0pfX19O3ZhciBlbWl0RXZlbnQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXBsdC5jZSh0LHIpO2UuZGlzcGF0Y2hFdmVudChuKTtyZXR1cm4gbn07dmFyIGF0dGFjaFRvQW5jZXN0b3I9ZnVuY3Rpb24oZSx0KXtpZih0JiYhZS4kb25SZW5kZXJSZXNvbHZlJCYmdFtcInMtcFwiXSl7dFtcInMtcFwiXS5wdXNoKG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gZS4kb25SZW5kZXJSZXNvbHZlJD10fSkpKX19O3ZhciBzY2hlZHVsZVVwZGF0ZT1mdW5jdGlvbihlLHQpe3tlLiRmbGFncyR8PTE2fWlmKGUuJGZsYWdzJCY0KXtlLiRmbGFncyR8PTUxMjtyZXR1cm59YXR0YWNoVG9BbmNlc3RvcihlLGUuJGFuY2VzdG9yQ29tcG9uZW50JCk7dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4gZGlzcGF0Y2hIb29rcyhlLHQpfTtyZXR1cm4gd3JpdGVUYXNrKHIpfTt2YXIgZGlzcGF0Y2hIb29rcz1mdW5jdGlvbihlLHQpe3ZhciByPWNyZWF0ZVRpbWUoXCJzY2hlZHVsZVVwZGF0ZVwiLGUuJGNtcE1ldGEkLiR0YWdOYW1lJCk7dmFyIG49ZS4kbGF6eUluc3RhbmNlJDt2YXIgYTtpZih0KXt7ZS4kZmxhZ3MkfD0yNTY7aWYoZS4kcXVldWVkTGlzdGVuZXJzJCl7ZS4kcXVldWVkTGlzdGVuZXJzJC5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0scj1lWzFdO3JldHVybiBzYWZlQ2FsbChuLHQscil9KSk7ZS4kcXVldWVkTGlzdGVuZXJzJD1udWxsfX17YT1zYWZlQ2FsbChuLFwiY29tcG9uZW50V2lsbExvYWRcIil9fXthPXRoZW4oYSwoZnVuY3Rpb24oKXtyZXR1cm4gc2FmZUNhbGwobixcImNvbXBvbmVudFdpbGxSZW5kZXJcIil9KSl9cigpO3JldHVybiB0aGVuKGEsKGZ1bmN0aW9uKCl7cmV0dXJuIHVwZGF0ZUNvbXBvbmVudChlLG4sdCl9KSl9O3ZhciB1cGRhdGVDb21wb25lbnQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sYSxvLHMsaSxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbigkKXtuPWUuJGhvc3RFbGVtZW50JDthPWNyZWF0ZVRpbWUoXCJ1cGRhdGVcIixlLiRjbXBNZXRhJC4kdGFnTmFtZSQpO289bltcInMtcmNcIl07aWYocil7YXR0YWNoU3R5bGVzKGUpfXM9Y3JlYXRlVGltZShcInJlbmRlclwiLGUuJGNtcE1ldGEkLiR0YWdOYW1lJCk7e2NhbGxSZW5kZXIoZSx0KX1pZihvKXtvLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKTtuW1wicy1yY1wiXT11bmRlZmluZWR9cygpO2EoKTt7aT1uW1wicy1wXCJdO2w9ZnVuY3Rpb24oKXtyZXR1cm4gcG9zdFVwZGF0ZUNvbXBvbmVudChlKX07aWYoaS5sZW5ndGg9PT0wKXtsKCl9ZWxzZXtQcm9taXNlLmFsbChpKS50aGVuKGwpO2UuJGZsYWdzJHw9NDtpLmxlbmd0aD0wfX1yZXR1cm5bMl19KSl9KSl9O3ZhciBjYWxsUmVuZGVyPWZ1bmN0aW9uKGUsdCxyKXt0cnl7dD10LnJlbmRlciYmdC5yZW5kZXIoKTt7ZS4kZmxhZ3MkJj1+MTZ9e2UuJGZsYWdzJHw9Mn17e3tyZW5kZXJWZG9tKGUsdCl9fX19Y2F0Y2godCl7Y29uc29sZUVycm9yKHQsZS4kaG9zdEVsZW1lbnQkKX1yZXR1cm4gbnVsbH07dmFyIHBvc3RVcGRhdGVDb21wb25lbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS4kY21wTWV0YSQuJHRhZ05hbWUkO3ZhciByPWUuJGhvc3RFbGVtZW50JDt2YXIgbj1jcmVhdGVUaW1lKFwicG9zdFVwZGF0ZVwiLHQpO3ZhciBhPWUuJGxhenlJbnN0YW5jZSQ7dmFyIG89ZS4kYW5jZXN0b3JDb21wb25lbnQkO3tzYWZlQ2FsbChhLFwiY29tcG9uZW50RGlkUmVuZGVyXCIpfWlmKCEoZS4kZmxhZ3MkJjY0KSl7ZS4kZmxhZ3MkfD02NDt7YWRkSHlkcmF0ZWRGbGFnKHIpfXtzYWZlQ2FsbChhLFwiY29tcG9uZW50RGlkTG9hZFwiKX1uKCk7e2UuJG9uUmVhZHlSZXNvbHZlJChyKTtpZighbyl7YXBwRGlkTG9hZCgpfX19ZWxzZXt7c2FmZUNhbGwoYSxcImNvbXBvbmVudERpZFVwZGF0ZVwiKX1uKCl9e2UuJG9uSW5zdGFuY2VSZXNvbHZlJChyKX17aWYoZS4kb25SZW5kZXJSZXNvbHZlJCl7ZS4kb25SZW5kZXJSZXNvbHZlJCgpO2UuJG9uUmVuZGVyUmVzb2x2ZSQ9dW5kZWZpbmVkfWlmKGUuJGZsYWdzJCY1MTIpe25leHRUaWNrKChmdW5jdGlvbigpe3JldHVybiBzY2hlZHVsZVVwZGF0ZShlLGZhbHNlKX0pKX1lLiRmbGFncyQmPX4oNHw1MTIpfX07dmFyIGZvcmNlVXBkYXRlPWZ1bmN0aW9uKGUpe3t2YXIgdD1nZXRIb3N0UmVmKGUpO3ZhciByPXQuJGhvc3RFbGVtZW50JC5pc0Nvbm5lY3RlZDtpZihyJiYodC4kZmxhZ3MkJigyfDE2KSk9PT0yKXtzY2hlZHVsZVVwZGF0ZSh0LGZhbHNlKX1yZXR1cm4gcn19O3ZhciBhcHBEaWRMb2FkPWZ1bmN0aW9uKGUpe3thZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCl9bmV4dFRpY2soKGZ1bmN0aW9uKCl7cmV0dXJuIGVtaXRFdmVudCh3aW4sXCJhcHBsb2FkXCIse2RldGFpbDp7bmFtZXNwYWNlOk5BTUVTUEFDRX19KX0pKX07dmFyIHNhZmVDYWxsPWZ1bmN0aW9uKGUsdCxyKXtpZihlJiZlW3RdKXt0cnl7cmV0dXJuIGVbdF0ocil9Y2F0Y2goZSl7Y29uc29sZUVycm9yKGUpfX1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgdGhlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlJiZlLnRoZW4/ZS50aGVuKHQpOnQoKX07dmFyIGFkZEh5ZHJhdGVkRmxhZz1mdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc0xpc3QuYWRkKFwiaHlkcmF0ZWRcIil9O3ZhciBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQscixuKXt2YXIgYT1jcmVhdGVUaW1lKFwiaHlkcmF0ZUNsaWVudFwiLHQpO3ZhciBvPWUuc2hhZG93Um9vdDt2YXIgcz1bXTt2YXIgaT1bXTt2YXIgbD1vP1tdOm51bGw7dmFyICQ9bi4kdm5vZGUkPW5ld1ZOb2RlKHQsbnVsbCk7aWYoIXBsdC4kb3JnTG9jTm9kZXMkKXtpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKGRvYy5ib2R5LHBsdC4kb3JnTG9jTm9kZXMkPW5ldyBNYXApfWVbSFlEUkFURV9JRF09cjtlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0lEKTtjbGllbnRIeWRyYXRlKCQscyxpLGwsZSxlLHIpO3MubWFwKChmdW5jdGlvbihlKXt2YXIgcj1lLiRob3N0SWQkK1wiLlwiK2UuJG5vZGVJZCQ7dmFyIG49cGx0LiRvcmdMb2NOb2RlcyQuZ2V0KHIpO3ZhciBhPWUuJGVsbSQ7aWYobiYmc3VwcG9ydHNTaGFkb3cmJm5bXCJzLWVuXCJdPT09XCJcIil7bi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG4ubmV4dFNpYmxpbmcpfWlmKCFvKXthW1wicy1oblwiXT10O2lmKG4pe2FbXCJzLW9sXCJdPW47YVtcInMtb2xcIl1bXCJzLW5yXCJdPWF9fXBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShyKX0pKTtpZihvKXtsLm1hcCgoZnVuY3Rpb24oZSl7aWYoZSl7by5hcHBlbmRDaGlsZChlKX19KSl9YSgpfTt2YXIgY2xpZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQscixuLGEsbyxzKXt2YXIgaTt2YXIgbDt2YXIgJDt2YXIgYztpZihvLm5vZGVUeXBlPT09MSl7aT1vLmdldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtpZihpKXtsPWkuc3BsaXQoXCIuXCIpO2lmKGxbMF09PT1zfHxsWzBdPT09XCIwXCIpeyQ9eyRmbGFncyQ6MCwkaG9zdElkJDpsWzBdLCRub2RlSWQkOmxbMV0sJGRlcHRoJDpsWzJdLCRpbmRleCQ6bFszXSwkdGFnJDpvLnRhZ05hbWUudG9Mb3dlckNhc2UoKSwkZWxtJDpvLCRhdHRycyQ6bnVsbCwkY2hpbGRyZW4kOm51bGwsJGtleSQ6bnVsbCwkbmFtZSQ6bnVsbCwkdGV4dCQ6bnVsbH07dC5wdXNoKCQpO28ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO2lmKCFlLiRjaGlsZHJlbiQpe2UuJGNoaWxkcmVuJD1bXX1lLiRjaGlsZHJlbiRbJC4kaW5kZXgkXT0kO2U9JDtpZihuJiYkLiRkZXB0aCQ9PT1cIjBcIil7blskLiRpbmRleCRdPSQuJGVsbSR9fX1mb3IoYz1vLmNoaWxkTm9kZXMubGVuZ3RoLTE7Yz49MDtjLS0pe2NsaWVudEh5ZHJhdGUoZSx0LHIsbixhLG8uY2hpbGROb2Rlc1tjXSxzKX1pZihvLnNoYWRvd1Jvb3Qpe2ZvcihjPW8uc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aC0xO2M+PTA7Yy0tKXtjbGllbnRIeWRyYXRlKGUsdCxyLG4sYSxvLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tjXSxzKX19fWVsc2UgaWYoby5ub2RlVHlwZT09PTgpe2w9by5ub2RlVmFsdWUuc3BsaXQoXCIuXCIpO2lmKGxbMV09PT1zfHxsWzFdPT09XCIwXCIpe2k9bFswXTskPXskZmxhZ3MkOjAsJGhvc3RJZCQ6bFsxXSwkbm9kZUlkJDpsWzJdLCRkZXB0aCQ6bFszXSwkaW5kZXgkOmxbNF0sJGVsbSQ6bywkYXR0cnMkOm51bGwsJGNoaWxkcmVuJDpudWxsLCRrZXkkOm51bGwsJG5hbWUkOm51bGwsJHRhZyQ6bnVsbCwkdGV4dCQ6bnVsbH07aWYoaT09PVRFWFRfTk9ERV9JRCl7JC4kZWxtJD1vLm5leHRTaWJsaW5nO2lmKCQuJGVsbSQmJiQuJGVsbSQubm9kZVR5cGU9PT0zKXskLiR0ZXh0JD0kLiRlbG0kLnRleHRDb250ZW50O3QucHVzaCgkKTtvLnJlbW92ZSgpO2lmKCFlLiRjaGlsZHJlbiQpe2UuJGNoaWxkcmVuJD1bXX1lLiRjaGlsZHJlbiRbJC4kaW5kZXgkXT0kO2lmKG4mJiQuJGRlcHRoJD09PVwiMFwiKXtuWyQuJGluZGV4JF09JC4kZWxtJH19fWVsc2UgaWYoJC4kaG9zdElkJD09PXMpe2lmKGk9PT1TTE9UX05PREVfSUQpeyQuJHRhZyQ9XCJzbG90XCI7aWYobFs1XSl7b1tcInMtc25cIl09JC4kbmFtZSQ9bFs1XX1lbHNle29bXCJzLXNuXCJdPVwiXCJ9b1tcInMtc3JcIl09dHJ1ZTtpZihuKXskLiRlbG0kPWRvYy5jcmVhdGVFbGVtZW50KCQuJHRhZyQpO2lmKCQuJG5hbWUkKXskLiRlbG0kLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwkLiRuYW1lJCl9by5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgkLiRlbG0kLG8pO28ucmVtb3ZlKCk7aWYoJC4kZGVwdGgkPT09XCIwXCIpe25bJC4kaW5kZXgkXT0kLiRlbG0kfX1yLnB1c2goJCk7aWYoIWUuJGNoaWxkcmVuJCl7ZS4kY2hpbGRyZW4kPVtdfWUuJGNoaWxkcmVuJFskLiRpbmRleCRdPSR9ZWxzZSBpZihpPT09Q09OVEVOVF9SRUZfSUQpe2lmKG4pe28ucmVtb3ZlKCl9ZWxzZXthW1wicy1jclwiXT1vO29bXCJzLWNuXCJdPXRydWV9fX19fWVsc2UgaWYoZSYmZS4kdGFnJD09PVwic3R5bGVcIil7dmFyIGY9bmV3Vk5vZGUobnVsbCxvLnRleHRDb250ZW50KTtmLiRlbG0kPW87Zi4kaW5kZXgkPVwiMFwiO2UuJGNoaWxkcmVuJD1bZl19fTt2YXIgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQpe2lmKGUubm9kZVR5cGU9PT0xKXt2YXIgcj0wO2Zvcig7cjxlLmNoaWxkTm9kZXMubGVuZ3RoO3IrKyl7aW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShlLmNoaWxkTm9kZXNbcl0sdCl9aWYoZS5zaGFkb3dSb290KXtmb3Iocj0wO3I8ZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoO3IrKyl7aW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tyXSx0KX19fWVsc2UgaWYoZS5ub2RlVHlwZT09PTgpe3ZhciBuPWUubm9kZVZhbHVlLnNwbGl0KFwiLlwiKTtpZihuWzBdPT09T1JHX0xPQ0FUSU9OX0lEKXt0LnNldChuWzFdK1wiLlwiK25bMl0sZSk7ZS5ub2RlVmFsdWU9XCJcIjtlW1wicy1lblwiXT1uWzNdfX19O3ZhciBwYXJzZVByb3BlcnR5VmFsdWU9ZnVuY3Rpb24oZSx0KXtpZihlIT1udWxsJiYhaXNDb21wbGV4VHlwZShlKSl7aWYodCY0KXtyZXR1cm4gZT09PVwiZmFsc2VcIj9mYWxzZTplPT09XCJcInx8ISFlfWlmKHQmMil7cmV0dXJuIHBhcnNlRmxvYXQoZSl9aWYodCYxKXtyZXR1cm4gU3RyaW5nKGUpfXJldHVybiBlfXJldHVybiBlfTt2YXIgZ2V0VmFsdWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZ2V0SG9zdFJlZihlKS4kaW5zdGFuY2VWYWx1ZXMkLmdldCh0KX07dmFyIHNldFZhbHVlPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPWdldEhvc3RSZWYoZSk7dmFyIG89YS4kaG9zdEVsZW1lbnQkO3ZhciBzPWEuJGluc3RhbmNlVmFsdWVzJC5nZXQodCk7dmFyIGk9YS4kZmxhZ3MkO3ZhciBsPWEuJGxhenlJbnN0YW5jZSQ7cj1wYXJzZVByb3BlcnR5VmFsdWUocixuLiRtZW1iZXJzJFt0XVswXSk7dmFyICQ9TnVtYmVyLmlzTmFOKHMpJiZOdW1iZXIuaXNOYU4ocik7dmFyIGM9ciE9PXMmJiEkO2lmKCghKGkmOCl8fHM9PT11bmRlZmluZWQpJiZjKXthLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHQscik7aWYobCl7aWYobi4kd2F0Y2hlcnMkJiZpJjEyOCl7dmFyIGY9bi4kd2F0Y2hlcnMkW3RdO2lmKGYpe2YubWFwKChmdW5jdGlvbihlKXt0cnl7bFtlXShyLHMsdCl9Y2F0Y2goZSl7Y29uc29sZUVycm9yKGUsbyl9fSkpfX1pZigoaSYoMnwxNikpPT09Mil7c2NoZWR1bGVVcGRhdGUoYSxmYWxzZSl9fX19O3ZhciBwcm94eUNvbXBvbmVudD1mdW5jdGlvbihlLHQscil7aWYodC4kbWVtYmVycyQpe2lmKGUud2F0Y2hlcnMpe3QuJHdhdGNoZXJzJD1lLndhdGNoZXJzfXZhciBuPU9iamVjdC5lbnRyaWVzKHQuJG1lbWJlcnMkKTt2YXIgYT1lLnByb3RvdHlwZTtuLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG49ZVswXSxvPWVbMV1bMF07aWYobyYzMXx8ciYyJiZvJjMyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxuLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0VmFsdWUodGhpcyxuKX0sc2V0OmZ1bmN0aW9uKGUpe3NldFZhbHVlKHRoaXMsbixlLHQpfSxjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWV9KX1lbHNlIGlmKHImMSYmbyY2NCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsbix7dmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlW3RdPWFyZ3VtZW50c1t0XX12YXIgcj1nZXRIb3N0UmVmKHRoaXMpO3JldHVybiByLiRvbkluc3RhbmNlUHJvbWlzZSQudGhlbigoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4odD1yLiRsYXp5SW5zdGFuY2UkKVtuXS5hcHBseSh0LGUpfSkpfX0pfX0pKTtpZihyJjEpe3ZhciBvPW5ldyBNYXA7YS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXM7cGx0LmptcCgoZnVuY3Rpb24oKXt2YXIgdD1vLmdldChlKTtpZihuLmhhc093blByb3BlcnR5KHQpKXtyPW5bdF07ZGVsZXRlIG5bdF19ZWxzZSBpZihhLmhhc093blByb3BlcnR5KHQpJiZ0eXBlb2Ygblt0XT09PVwibnVtYmVyXCImJm5bdF09PXIpe3JldHVybn1uW3RdPXI9PT1udWxsJiZ0eXBlb2Ygblt0XT09PVwiYm9vbGVhblwiP2ZhbHNlOnJ9KSl9O2Uub2JzZXJ2ZWRBdHRyaWJ1dGVzPW4uZmlsdGVyKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLHI9ZVsxXTtyZXR1cm4gclswXSYxNX0pKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciByPWVbMF0sbj1lWzFdO3ZhciBhPW5bMV18fHI7by5zZXQoYSxyKTtpZihuWzBdJjUxMil7dC4kYXR0cnNUb1JlZmxlY3QkLnB1c2goW3IsYV0pfXJldHVybiBhfSkpfX1yZXR1cm4gZX07dmFyIGluaXRpYWxpemVDb21wb25lbnQ9ZnVuY3Rpb24oZSx0LHIsbixhKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLG8scyxpLGwsJCxjO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihmKXtzd2l0Y2goZi5sYWJlbCl7Y2FzZSAwOmlmKCEoKHQuJGZsYWdzJCYzMik9PT0wKSlyZXR1cm5bMywzXTt0LiRmbGFncyR8PTMyO2E9bG9hZE1vZHVsZShyKTtpZighYS50aGVuKXJldHVyblszLDJdO249dW5pcXVlVGltZSgpO3JldHVybls0LGFdO2Nhc2UgMTphPWYuc2VudCgpO24oKTtmLmxhYmVsPTI7Y2FzZSAyOmlmKCFhLmlzUHJveGllZCl7e3IuJHdhdGNoZXJzJD1hLndhdGNoZXJzfXByb3h5Q29tcG9uZW50KGEsciwyKTthLmlzUHJveGllZD10cnVlfW89Y3JlYXRlVGltZShcImNyZWF0ZUluc3RhbmNlXCIsci4kdGFnTmFtZSQpO3t0LiRmbGFncyR8PTh9dHJ5e25ldyBhKHQpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlKX17dC4kZmxhZ3MkJj1+OH17dC4kZmxhZ3MkfD0xMjh9bygpO2ZpcmVDb25uZWN0ZWRDYWxsYmFjayh0LiRsYXp5SW5zdGFuY2UkKTtpZihhLnN0eWxlKXtzPWEuc3R5bGU7aWYodHlwZW9mIHMhPT1cInN0cmluZ1wiKXtzPXNbdC4kbW9kZU5hbWUkPWNvbXB1dGVNb2RlKGUpXX1pPWdldFNjb3BlSWQocix0LiRtb2RlTmFtZSQpO2lmKCFzdHlsZXMuaGFzKGkpKXtsPWNyZWF0ZVRpbWUoXCJyZWdpc3RlclN0eWxlc1wiLHIuJHRhZ05hbWUkKTtyZWdpc3RlclN0eWxlKGkscywhIShyLiRmbGFncyQmMSkpO2woKX19Zi5sYWJlbD0zO2Nhc2UgMzokPXQuJGFuY2VzdG9yQ29tcG9uZW50JDtjPWZ1bmN0aW9uKCl7cmV0dXJuIHNjaGVkdWxlVXBkYXRlKHQsdHJ1ZSl9O2lmKCQmJiRbXCJzLXJjXCJdKXskW1wicy1yY1wiXS5wdXNoKGMpfWVsc2V7YygpfXJldHVyblsyXX19KSl9KSl9O3ZhciBmaXJlQ29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7e3NhZmVDYWxsKGUsXCJjb25uZWN0ZWRDYWxsYmFja1wiKX19O3ZhciBjb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbihlKXtpZigocGx0LiRmbGFncyQmMSk9PT0wKXt2YXIgdD1nZXRIb3N0UmVmKGUpO3ZhciByPXQuJGNtcE1ldGEkO3ZhciBuPWNyZWF0ZVRpbWUoXCJjb25uZWN0ZWRDYWxsYmFja1wiLHIuJHRhZ05hbWUkKTtpZighKHQuJGZsYWdzJCYxKSl7dC4kZmxhZ3MkfD0xO3ZhciBhPXZvaWQgMDt7YT1lLmdldEF0dHJpYnV0ZShIWURSQVRFX0lEKTtpZihhKXtpZihyLiRmbGFncyQmMSl7dmFyIG89YWRkU3R5bGUoZS5zaGFkb3dSb290LHIsZS5nZXRBdHRyaWJ1dGUoXCJzLW1vZGVcIikpO2UuY2xhc3NMaXN0LnJlbW92ZShvK1wiLWhcIixvK1wiLXNcIil9aW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZSxyLiR0YWdOYW1lJCxhLHQpfX1pZighYSl7aWYoci4kZmxhZ3MkJig0fDgpKXtzZXRDb250ZW50UmVmZXJlbmNlKGUpfX17dmFyIHM9ZTt3aGlsZShzPXMucGFyZW50Tm9kZXx8cy5ob3N0KXtpZihzLm5vZGVUeXBlPT09MSYmcy5oYXNBdHRyaWJ1dGUoXCJzLWlkXCIpJiZzW1wicy1wXCJdfHxzW1wicy1wXCJdKXthdHRhY2hUb0FuY2VzdG9yKHQsdC4kYW5jZXN0b3JDb21wb25lbnQkPXMpO2JyZWFrfX19aWYoci4kbWVtYmVycyQpe09iamVjdC5lbnRyaWVzKHIuJG1lbWJlcnMkKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sbj10WzFdWzBdO2lmKG4mMzEmJmUuaGFzT3duUHJvcGVydHkocikpe3ZhciBhPWVbcl07ZGVsZXRlIGVbcl07ZVtyXT1hfX0pKX17bmV4dFRpY2soKGZ1bmN0aW9uKCl7cmV0dXJuIGluaXRpYWxpemVDb21wb25lbnQoZSx0LHIpfSkpfX1lbHNle2FkZEhvc3RFdmVudExpc3RlbmVycyhlLHQsci4kbGlzdGVuZXJzJCk7ZmlyZUNvbm5lY3RlZENhbGxiYWNrKHQuJGxhenlJbnN0YW5jZSQpfW4oKX19O3ZhciBzZXRDb250ZW50UmVmZXJlbmNlPWZ1bmN0aW9uKGUpe3ZhciB0PWVbXCJzLWNyXCJdPWRvYy5jcmVhdGVDb21tZW50KFwiXCIpO3RbXCJzLWNuXCJdPXRydWU7ZS5pbnNlcnRCZWZvcmUodCxlLmZpcnN0Q2hpbGQpfTt2YXIgZGlzY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7aWYoKHBsdC4kZmxhZ3MkJjEpPT09MCl7dmFyIHQ9Z2V0SG9zdFJlZihlKTt2YXIgcj10LiRsYXp5SW5zdGFuY2UkO3tpZih0LiRybUxpc3RlbmVycyQpe3QuJHJtTGlzdGVuZXJzJC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7dC4kcm1MaXN0ZW5lcnMkPXVuZGVmaW5lZH19e3NhZmVDYWxsKHIsXCJkaXNjb25uZWN0ZWRDYWxsYmFja1wiKX19fTt2YXIgYm9vdHN0cmFwTGF6eT1mdW5jdGlvbihlLHQpe2lmKHQ9PT12b2lkIDApe3Q9e319dmFyIHI9Y3JlYXRlVGltZSgpO3ZhciBuPVtdO3ZhciBhPXQuZXhjbHVkZXx8W107dmFyIG89d2luLmN1c3RvbUVsZW1lbnRzO3ZhciBzPWRvYy5oZWFkO3ZhciBpPXMucXVlcnlTZWxlY3RvcihcIm1ldGFbY2hhcnNldF1cIik7dmFyIGw9ZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTt2YXIgJD1bXTt2YXIgYz1kb2MucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoSFlEUkFURURfU1RZTEVfSUQsXCJdXCIpKTt2YXIgZjt2YXIgdT10cnVlO3ZhciBkPTA7T2JqZWN0LmFzc2lnbihwbHQsdCk7cGx0LiRyZXNvdXJjZXNVcmwkPW5ldyBVUkwodC5yZXNvdXJjZXNVcmx8fFwiLi9cIixkb2MuYmFzZVVSSSkuaHJlZjt7cGx0LiRmbGFncyR8PTJ9e2Zvcig7ZDxjLmxlbmd0aDtkKyspe3JlZ2lzdGVyU3R5bGUoY1tkXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLGNvbnZlcnRTY29wZWRUb1NoYWRvdyhjW2RdLmlubmVySFRNTCksdHJ1ZSl9fWUubWFwKChmdW5jdGlvbihlKXtlWzFdLm1hcCgoZnVuY3Rpb24odCl7dmFyIHI9eyRmbGFncyQ6dFswXSwkdGFnTmFtZSQ6dFsxXSwkbWVtYmVycyQ6dFsyXSwkbGlzdGVuZXJzJDp0WzNdfTt7ci4kbWVtYmVycyQ9dFsyXX17ci4kbGlzdGVuZXJzJD10WzNdfXtyLiRhdHRyc1RvUmVmbGVjdCQ9W119e3IuJHdhdGNoZXJzJD17fX12YXIgcz1yLiR0YWdOYW1lJDt2YXIgaT1mdW5jdGlvbihlKXtfX2V4dGVuZHModCxlKTtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3Q9bjtyZWdpc3Rlckhvc3QodCxyKTtpZihyLiRmbGFncyQmMSl7e3t0LmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIixkZWxlZ2F0ZXNGb2N1czohIShyLiRmbGFncyQmMTYpfSl9fX1yZXR1cm4gbn10LnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZil7Y2xlYXJUaW1lb3V0KGYpO2Y9bnVsbH1pZih1KXskLnB1c2godGhpcyl9ZWxzZXtwbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBjb25uZWN0ZWRDYWxsYmFjayhlKX0pKX19O3QucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztwbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBkaXNjb25uZWN0ZWRDYWxsYmFjayhlKX0pKX07dC5wcm90b3R5cGUuY29tcG9uZW50T25SZWFkeT1mdW5jdGlvbigpe3JldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSR9O3JldHVybiB0fShIVE1MRWxlbWVudCk7ci4kbGF6eUJ1bmRsZUlkJD1lWzBdO2lmKCFhLmluY2x1ZGVzKHMpJiYhby5nZXQocykpe24ucHVzaChzKTtvLmRlZmluZShzLHByb3h5Q29tcG9uZW50KGksciwxKSl9fSkpfSkpO3tsLmlubmVySFRNTD1uK0hZRFJBVEVEX0NTUztsLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVzXCIsXCJcIik7cy5pbnNlcnRCZWZvcmUobCxpP2kubmV4dFNpYmxpbmc6cy5maXJzdENoaWxkKX11PWZhbHNlO2lmKCQubGVuZ3RoKXskLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29ubmVjdGVkQ2FsbGJhY2soKX0pKX1lbHNle3twbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBmPXNldFRpbWVvdXQoYXBwRGlkTG9hZCwzMCl9KSl9fXIoKX07dmFyIGdldEFzc2V0UGF0aD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVVJMKGUscGx0LiRyZXNvdXJjZXNVcmwkKTtyZXR1cm4gdC5vcmlnaW4hPT13aW4ubG9jYXRpb24ub3JpZ2luP3QuaHJlZjp0LnBhdGhuYW1lfTt2YXIgaG9zdFJlZnM9bmV3IFdlYWtNYXA7dmFyIGdldEhvc3RSZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIGhvc3RSZWZzLmdldChlKX07dmFyIHJlZ2lzdGVySW5zdGFuY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaG9zdFJlZnMuc2V0KHQuJGxhenlJbnN0YW5jZSQ9ZSx0KX07dmFyIHJlZ2lzdGVySG9zdD1mdW5jdGlvbihlLHQpe3ZhciByPXskZmxhZ3MkOjAsJGhvc3RFbGVtZW50JDplLCRjbXBNZXRhJDp0LCRpbnN0YW5jZVZhbHVlcyQ6bmV3IE1hcH07e3IuJG9uSW5zdGFuY2VQcm9taXNlJD1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHIuJG9uSW5zdGFuY2VSZXNvbHZlJD1lfSkpfXtyLiRvblJlYWR5UHJvbWlzZSQ9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiByLiRvblJlYWR5UmVzb2x2ZSQ9ZX0pKTtlW1wicy1wXCJdPVtdO2VbXCJzLXJjXCJdPVtdfWFkZEhvc3RFdmVudExpc3RlbmVycyhlLHIsdC4kbGlzdGVuZXJzJCk7cmV0dXJuIGhvc3RSZWZzLnNldChlLHIpfTt2YXIgaXNNZW1iZXJJbkVsZW1lbnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCBpbiBlfTt2YXIgY29uc29sZUVycm9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKDAsY29uc29sZS5lcnJvcikoZSx0KX07dmFyIGNtcE1vZHVsZXM9bmV3IE1hcDt2YXIgbG9hZE1vZHVsZT1mdW5jdGlvbihlLHQscil7dmFyIG49ZS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLFwiX1wiKTt2YXIgYT1lLiRsYXp5QnVuZGxlSWQkO3ZhciBvPWNtcE1vZHVsZXMuZ2V0KGEpO2lmKG8pe3JldHVybiBvW25dfXJldHVybiBpbXBvcnQoXCIuL1wiLmNvbmNhdChhLFwiLmVudHJ5LmpzXCIpLmNvbmNhdChcIlwiKSkudGhlbigoZnVuY3Rpb24oZSl7e2NtcE1vZHVsZXMuc2V0KGEsZSl9cmV0dXJuIGVbbl19KSxjb25zb2xlRXJyb3IpfTt2YXIgc3R5bGVzPW5ldyBNYXA7dmFyIG1vZGVSZXNvbHV0aW9uQ2hhaW49W107dmFyIHF1ZXVlRG9tUmVhZHM9W107dmFyIHF1ZXVlRG9tV3JpdGVzPVtdO3ZhciBxdWV1ZVRhc2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24ocil7ZS5wdXNoKHIpO2lmKCFxdWV1ZVBlbmRpbmcpe3F1ZXVlUGVuZGluZz10cnVlO2lmKHQmJnBsdC4kZmxhZ3MkJjQpe25leHRUaWNrKGZsdXNoKX1lbHNle3BsdC5yYWYoZmx1c2gpfX19fTt2YXIgY29uc3VtZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7dHJ5e2VbdF0ocGVyZm9ybWFuY2Uubm93KCkpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlKX19ZS5sZW5ndGg9MH07dmFyIGZsdXNoPWZ1bmN0aW9uKCl7Y29uc3VtZShxdWV1ZURvbVJlYWRzKTt7Y29uc3VtZShxdWV1ZURvbVdyaXRlcyk7aWYocXVldWVQZW5kaW5nPXF1ZXVlRG9tUmVhZHMubGVuZ3RoPjApe3BsdC5yYWYoZmx1c2gpfX19O3ZhciBuZXh0VGljaz1mdW5jdGlvbihlKXtyZXR1cm4gcHJvbWlzZVJlc29sdmUoKS50aGVuKGUpfTt2YXIgcmVhZFRhc2s9cXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsZmFsc2UpO3ZhciB3cml0ZVRhc2s9cXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLHRydWUpO3ZhciBCdWlsZD17aXNEZXY6ZmFsc2UsaXNCcm93c2VyOnRydWUsaXNTZXJ2ZXI6ZmFsc2UsaXNUZXN0aW5nOmZhbHNlfTtleHBvcnR7QnVpbGQgYXMgQixIb3N0IGFzIEgsTkFNRVNQQUNFIGFzIE4sc2V0TW9kZSBhcyBhLGJvb3RzdHJhcExhenkgYXMgYix3cml0ZVRhc2sgYXMgYyxkb2MgYXMgZCxjcmVhdGVFdmVudCBhcyBlLHJlYWRUYXNrIGFzIGYsZ2V0TW9kZSBhcyBnLGgsZ2V0RWxlbWVudCBhcyBpLGZvcmNlVXBkYXRlIGFzIGosZ2V0QXNzZXRQYXRoIGFzIGsscHJvbWlzZVJlc29sdmUgYXMgcCxyZWdpc3Rlckluc3RhbmNlIGFzIHIsc2V0UGxhdGZvcm1IZWxwZXJzIGFzIHMsd2luIGFzIHd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2896\n')},8186:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "I": () => (/* binding */ IonicSafeString),\n/* harmony export */   "s": () => (/* binding */ sanitizeDOMString)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar sanitizeDOMString=function(e){try{if(e instanceof IonicSafeString){return e.value}if(!isSanitizerEnabled()||typeof e!=="string"||e===""){return e}var r=document.createDocumentFragment();var n=document.createElement("div");r.appendChild(n);n.innerHTML=e;blockedTags.forEach((function(e){var n=r.querySelectorAll(e);for(var t=n.length-1;t>=0;t--){var i=n[t];if(i.parentNode){i.parentNode.removeChild(i)}else{r.removeChild(i)}var a=getElementChildren(i);for(var l=0;l<a.length;l++){sanitizeElement(a[l])}}}));var t=getElementChildren(r);for(var i=0;i<t.length;i++){sanitizeElement(t[i])}var a=document.createElement("div");a.appendChild(r);var l=a.querySelector("div");return l!==null?l.innerHTML:a.innerHTML}catch(e){console.error(e);return""}};var sanitizeElement=function(e){if(e.nodeType&&e.nodeType!==1){return}for(var r=e.attributes.length-1;r>=0;r--){var n=e.attributes.item(r);var t=n.name;if(!allowedAttributes.includes(t.toLowerCase())){e.removeAttribute(t);continue}var i=n.value;if(i!=null&&i.toLowerCase().includes("javascript:")){e.removeAttribute(t)}}var a=getElementChildren(e);for(var r=0;r<a.length;r++){sanitizeElement(a[r])}};var getElementChildren=function(e){return e.children!=null?e.children:e.childNodes};var isSanitizerEnabled=function(){var e=window;var r=e&&e.Ionic&&e.Ionic.config;if(r){if(r.get){return r.get("sanitizerEnabled",true)}else{return r.sanitizerEnabled===true||r.sanitizerEnabled===undefined}}return true};var allowedAttributes=["class","id","href","src","name","slot"];var blockedTags=["script","style","iframe","meta","link","object","embed"];var IonicSafeString=function(){function e(e){this.value=e}return e}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLGlDQUFpQyxlQUFlLHVEQUF1RCxTQUFTLHdDQUF3QyxvQ0FBb0MsaUJBQWlCLGNBQWMsaUNBQWlDLDRCQUE0QixxQkFBcUIsS0FBSyxLQUFLLFdBQVcsaUJBQWlCLDRCQUE0QixLQUFLLGlCQUFpQiw0QkFBNEIsWUFBWSxXQUFXLEtBQUssd0JBQXdCLEdBQUcsNEJBQTRCLFlBQVksV0FBVyxLQUFLLHNCQUFzQixvQ0FBb0MsaUJBQWlCLDZCQUE2Qix3Q0FBd0MsU0FBUyxpQkFBaUIsV0FBVyxnQ0FBZ0MsK0JBQStCLE9BQU8sZ0NBQWdDLEtBQUssS0FBSywyQkFBMkIsYUFBYSxpREFBaUQscUJBQXFCLFNBQVMsY0FBYyxxREFBcUQsc0JBQXNCLDRCQUE0QixZQUFZLFdBQVcsS0FBSyx3QkFBd0IsbUNBQW1DLGlEQUFpRCxrQ0FBa0MsYUFBYSxpQ0FBaUMsTUFBTSxVQUFVLHNDQUFzQyxLQUFLLGtFQUFrRSxhQUFhLGdFQUFnRSwyRUFBMkUsK0JBQStCLGNBQWMsYUFBYSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtYzg0MWM5MzMuanM/MWJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xudmFyIHNhbml0aXplRE9NU3RyaW5nPWZ1bmN0aW9uKGUpe3RyeXtpZihlIGluc3RhbmNlb2YgSW9uaWNTYWZlU3RyaW5nKXtyZXR1cm4gZS52YWx1ZX1pZighaXNTYW5pdGl6ZXJFbmFibGVkKCl8fHR5cGVvZiBlIT09XCJzdHJpbmdcInx8ZT09PVwiXCIpe3JldHVybiBlfXZhciByPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3IuYXBwZW5kQ2hpbGQobik7bi5pbm5lckhUTUw9ZTtibG9ja2VkVGFncy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1yLnF1ZXJ5U2VsZWN0b3JBbGwoZSk7Zm9yKHZhciB0PW4ubGVuZ3RoLTE7dD49MDt0LS0pe3ZhciBpPW5bdF07aWYoaS5wYXJlbnROb2RlKXtpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaSl9ZWxzZXtyLnJlbW92ZUNoaWxkKGkpfXZhciBhPWdldEVsZW1lbnRDaGlsZHJlbihpKTtmb3IodmFyIGw9MDtsPGEubGVuZ3RoO2wrKyl7c2FuaXRpemVFbGVtZW50KGFbbF0pfX19KSk7dmFyIHQ9Z2V0RWxlbWVudENoaWxkcmVuKHIpO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXtzYW5pdGl6ZUVsZW1lbnQodFtpXSl9dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthLmFwcGVuZENoaWxkKHIpO3ZhciBsPWEucXVlcnlTZWxlY3RvcihcImRpdlwiKTtyZXR1cm4gbCE9PW51bGw/bC5pbm5lckhUTUw6YS5pbm5lckhUTUx9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKTtyZXR1cm5cIlwifX07dmFyIHNhbml0aXplRWxlbWVudD1mdW5jdGlvbihlKXtpZihlLm5vZGVUeXBlJiZlLm5vZGVUeXBlIT09MSl7cmV0dXJufWZvcih2YXIgcj1lLmF0dHJpYnV0ZXMubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciBuPWUuYXR0cmlidXRlcy5pdGVtKHIpO3ZhciB0PW4ubmFtZTtpZighYWxsb3dlZEF0dHJpYnV0ZXMuaW5jbHVkZXModC50b0xvd2VyQ2FzZSgpKSl7ZS5yZW1vdmVBdHRyaWJ1dGUodCk7Y29udGludWV9dmFyIGk9bi52YWx1ZTtpZihpIT1udWxsJiZpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJqYXZhc2NyaXB0OlwiKSl7ZS5yZW1vdmVBdHRyaWJ1dGUodCl9fXZhciBhPWdldEVsZW1lbnRDaGlsZHJlbihlKTtmb3IodmFyIHI9MDtyPGEubGVuZ3RoO3IrKyl7c2FuaXRpemVFbGVtZW50KGFbcl0pfX07dmFyIGdldEVsZW1lbnRDaGlsZHJlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGlsZHJlbiE9bnVsbD9lLmNoaWxkcmVuOmUuY2hpbGROb2Rlc307dmFyIGlzU2FuaXRpemVyRW5hYmxlZD1mdW5jdGlvbigpe3ZhciBlPXdpbmRvdzt2YXIgcj1lJiZlLklvbmljJiZlLklvbmljLmNvbmZpZztpZihyKXtpZihyLmdldCl7cmV0dXJuIHIuZ2V0KFwic2FuaXRpemVyRW5hYmxlZFwiLHRydWUpfWVsc2V7cmV0dXJuIHIuc2FuaXRpemVyRW5hYmxlZD09PXRydWV8fHIuc2FuaXRpemVyRW5hYmxlZD09PXVuZGVmaW5lZH19cmV0dXJuIHRydWV9O3ZhciBhbGxvd2VkQXR0cmlidXRlcz1bXCJjbGFzc1wiLFwiaWRcIixcImhyZWZcIixcInNyY1wiLFwibmFtZVwiLFwic2xvdFwiXTt2YXIgYmxvY2tlZFRhZ3M9W1wic2NyaXB0XCIsXCJzdHlsZVwiLFwiaWZyYW1lXCIsXCJtZXRhXCIsXCJsaW5rXCIsXCJvYmplY3RcIixcImVtYmVkXCJdO3ZhciBJb25pY1NhZmVTdHJpbmc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMudmFsdWU9ZX1yZXR1cm4gZX0oKTtleHBvcnR7SW9uaWNTYWZlU3RyaW5nIGFzIEksc2FuaXRpemVET01TdHJpbmcgYXMgc307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8186\n')},114:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "m": () => (/* binding */ menuController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(655);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7504);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(882);\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7434);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var baseAnimation=function(n){return (0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().duration(n?400:300)};var menuOverlayAnimation=function(n){var e;var r;var t=n.width+8;var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();if(n.isEndSide){e=t+"px";r="0px"}else{e=-t+"px";r="0px"}i.addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(e,")"),"translateX(".concat(r,")"));var o=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var u=o==="ios";var s=u?.2:.25;a.addElement(n.backdropEl).fromTo("opacity",.01,s);return baseAnimation(u).addAnimation([i,a])};var menuPushAnimation=function(n){var e;var r;var t=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var i=n.width;if(n.isEndSide){e=-i+"px";r=i+"px"}else{e=i+"px";r=-i+"px"}var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(r,")"),"translateX(0px)");var o=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(e,")"));var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.backdropEl).fromTo("opacity",.01,.32);return baseAnimation(t==="ios").addAnimation([a,o,u])};var menuRevealAnimation=function(n){var e=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var r=n.width*(n.isEndSide?-1:1)+"px";var t=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(r,")"));return baseAnimation(e==="ios").addAnimation(t)};var createMenuController=function(){var n=new Map;var e=[];var r=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.open()]}return[2,false]}}))}))};var t=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,n!==undefined?c(n):f()];case 1:e=r.sent();if(e!==undefined){return[2,e.close()]}return[2,false]}}))}))};var i=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.toggle()]}return[2,false]}}))}))};var a=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.disabled=!n}return[2,r]}}))}))};var o=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.swipeGesture=n}return[2,r]}}))}))};var u=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e,e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!(n!=null))return[3,2];return[4,c(n)];case 1:e=r.sent();return[2,e!==undefined&&e.isOpen()];case 2:return[4,f()];case 3:e=r.sent();return[2,e!==undefined]}}))}))};var s=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,!e.disabled]}return[2,false]}}))}))};var c=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r,t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:return[4,O()];case 1:i.sent();if(n==="start"||n==="end"){r=E((function(e){return e.side===n&&!e.disabled}));if(r){return[2,r]}return[2,E((function(e){return e.side===n}))]}else if(n!=null){return[2,E((function(e){return e.menuId===n}))]}t=E((function(n){return!n.disabled}));if(t){return[2,t]}return[2,e.length>0?e[0].el:undefined]}}))}))};var f=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,g()]}}))}))};var d=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,w()]}}))}))};var v=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,A()]}}))}))};var l=function(e,r){n.set(e,r)};var m=function(n){if(e.indexOf(n)<0){if(!n.disabled){p(n)}e.push(n)}};var _=function(n){var r=e.indexOf(n);if(r>-1){e.splice(r,1)}};var p=function(n){var r=n.side;e.filter((function(e){return e.side===r&&e!==n})).forEach((function(n){return n.disabled=true}))};var b=function(n,e,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(A()){return[2,false]}if(!e)return[3,3];return[4,f()];case 1:t=i.sent();if(!(t&&n.el!==t))return[3,3];return[4,t.setOpen(false,false)];case 2:i.sent();i.label=3;case 3:return[2,n._setOpen(e,r)]}}))}))};var h=function(e,r){var t=n.get(e);if(!t){throw new Error("animation not registered")}var i=t(r);return i};var g=function(){return E((function(n){return n._isOpen}))};var w=function(){return e.map((function(n){return n.el}))};var A=function(){return e.some((function(n){return n.isAnimating}))};var E=function(n){var r=e.find(n);if(r!==undefined){return r.el}return undefined};var O=function(){return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((function(n){return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__.c)(n,e)}))})))};l("reveal",menuRevealAnimation);l("push",menuPushAnimation);l("overlay",menuOverlayAnimation);if(typeof document!=="undefined"){document.addEventListener("ionBackButton",(function(n){var e=g();if(e){n.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__.MENU_BACK_BUTTON_PRIORITY,(function(){return e.close()}))}}))}return{registerAnimation:l,get:c,getMenus:d,getOpen:f,isEnabled:s,swipeGesture:o,isAnimating:v,isOpen:u,enable:a,toggle:i,close:t,open:r,_getOpenSync:g,_createAnimation:h,_register:m,_unregister:_,_setOpen:b,_setActiveMenu:p}};var menuController=createMenuController();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFrQyxHQUFHLElBQUksb0JBQW9CLGVBQWUsT0FBTyw0Q0FBNEMsV0FBVyxVQUFVLGlCQUFpQixzQkFBc0IsaUJBQWlCLElBQUksaUJBQWlCLDBCQUEwQixZQUFZLElBQUksaUJBQWlCLDJCQUEyQixxQkFBcUIsSUFBSSxrQkFBa0IsZ0JBQWdCLGtCQUFrQixZQUFZLGtCQUFrQixpQkFBaUIsc0ZBQXNGLGdDQUFnQyxPQUFPLHVEQUFnQixNQUFNLEdBQUcsS0FBSyxnQ0FBZ0MsNEJBQTRCLGtDQUFrQyxrQ0FBa0MsdURBQXVELFVBQVUsTUFBTSxrQkFBa0Isd0ZBQXlCLGFBQWEsaUJBQWlCLElBQUksR0FBRyxPQUFPLDROQUE0TiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LWNkYjFjZjk0LmpzPzY5NDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2dlbmVyYXRvcn1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9pbXBvcnR7TUVOVV9CQUNLX0JVVFRPTl9QUklPUklUWX1mcm9tXCIuL2hhcmR3YXJlLWJhY2stYnV0dG9uLWFjZTZhNzFiLmpzXCI7aW1wb3J0e2MgYXMgY29tcG9uZW50T25SZWFkeX1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjtpbXBvcnR7YiBhcyBnZXRJb25Nb2RlfWZyb21cIi4vaW9uaWMtZ2xvYmFsLTBlYmUzMjFjLmpzXCI7aW1wb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7dmFyIGJhc2VBbmltYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGNyZWF0ZUFuaW1hdGlvbigpLmR1cmF0aW9uKG4/NDAwOjMwMCl9O3ZhciBtZW51T3ZlcmxheUFuaW1hdGlvbj1mdW5jdGlvbihuKXt2YXIgZTt2YXIgcjt2YXIgdD1uLndpZHRoKzg7dmFyIGk9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIGE9Y3JlYXRlQW5pbWF0aW9uKCk7aWYobi5pc0VuZFNpZGUpe2U9dCtcInB4XCI7cj1cIjBweFwifWVsc2V7ZT0tdCtcInB4XCI7cj1cIjBweFwifWkuYWRkRWxlbWVudChuLm1lbnVJbm5lckVsKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGUsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocixcIilcIikpO3ZhciBvPWdldElvbk1vZGUobik7dmFyIHU9bz09PVwiaW9zXCI7dmFyIHM9dT8uMjouMjU7YS5hZGRFbGVtZW50KG4uYmFja2Ryb3BFbCkuZnJvbVRvKFwib3BhY2l0eVwiLC4wMSxzKTtyZXR1cm4gYmFzZUFuaW1hdGlvbih1KS5hZGRBbmltYXRpb24oW2ksYV0pfTt2YXIgbWVudVB1c2hBbmltYXRpb249ZnVuY3Rpb24obil7dmFyIGU7dmFyIHI7dmFyIHQ9Z2V0SW9uTW9kZShuKTt2YXIgaT1uLndpZHRoO2lmKG4uaXNFbmRTaWRlKXtlPS1pK1wicHhcIjtyPWkrXCJweFwifWVsc2V7ZT1pK1wicHhcIjtyPS1pK1wicHhcIn12YXIgYT1jcmVhdGVBbmltYXRpb24oKS5hZGRFbGVtZW50KG4ubWVudUlubmVyRWwpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQocixcIilcIiksXCJ0cmFuc2xhdGVYKDBweClcIik7dmFyIG89Y3JlYXRlQW5pbWF0aW9uKCkuYWRkRWxlbWVudChuLmNvbnRlbnRFbCkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKDBweClcIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGUsXCIpXCIpKTt2YXIgdT1jcmVhdGVBbmltYXRpb24oKS5hZGRFbGVtZW50KG4uYmFja2Ryb3BFbCkuZnJvbVRvKFwib3BhY2l0eVwiLC4wMSwuMzIpO3JldHVybiBiYXNlQW5pbWF0aW9uKHQ9PT1cImlvc1wiKS5hZGRBbmltYXRpb24oW2Esbyx1XSl9O3ZhciBtZW51UmV2ZWFsQW5pbWF0aW9uPWZ1bmN0aW9uKG4pe3ZhciBlPWdldElvbk1vZGUobik7dmFyIHI9bi53aWR0aCoobi5pc0VuZFNpZGU/LTE6MSkrXCJweFwiO3ZhciB0PWNyZWF0ZUFuaW1hdGlvbigpLmFkZEVsZW1lbnQobi5jb250ZW50RWwpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWCgwcHgpXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChyLFwiKVwiKSk7cmV0dXJuIGJhc2VBbmltYXRpb24oZT09PVwiaW9zXCIpLmFkZEFuaW1hdGlvbih0KX07dmFyIGNyZWF0ZU1lbnVDb250cm9sbGVyPWZ1bmN0aW9uKCl7dmFyIG49bmV3IE1hcDt2YXIgZT1bXTt2YXIgcj1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMobildO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUpe3JldHVyblsyLGUub3BlbigpXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgdD1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LG4hPT11bmRlZmluZWQ/YyhuKTpmKCldO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUhPT11bmRlZmluZWQpe3JldHVyblsyLGUuY2xvc2UoKV19cmV0dXJuWzIsZmFsc2VdfX0pKX0pKX07dmFyIGk9ZnVuY3Rpb24obil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxjKG4pXTtjYXNlIDE6ZT1yLnNlbnQoKTtpZihlKXtyZXR1cm5bMixlLnRvZ2dsZSgpXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgYT1mdW5jdGlvbihuLGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsYyhlKV07Y2FzZSAxOnI9dC5zZW50KCk7aWYocil7ci5kaXNhYmxlZD0hbn1yZXR1cm5bMixyXX19KSl9KSl9O3ZhciBvPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgcjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxjKGUpXTtjYXNlIDE6cj10LnNlbnQoKTtpZihyKXtyLnN3aXBlR2VzdHVyZT1ufXJldHVyblsyLHJdfX0pKX0pKX07dmFyIHU9ZnVuY3Rpb24obil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKCEobiE9bnVsbCkpcmV0dXJuWzMsMl07cmV0dXJuWzQsYyhuKV07Y2FzZSAxOmU9ci5zZW50KCk7cmV0dXJuWzIsZSE9PXVuZGVmaW5lZCYmZS5pc09wZW4oKV07Y2FzZSAyOnJldHVybls0LGYoKV07Y2FzZSAzOmU9ci5zZW50KCk7cmV0dXJuWzIsZSE9PXVuZGVmaW5lZF19fSkpfSkpfTt2YXIgcz1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMobildO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUpe3JldHVyblsyLCFlLmRpc2FibGVkXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgYz1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByLHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsTygpXTtjYXNlIDE6aS5zZW50KCk7aWYobj09PVwic3RhcnRcInx8bj09PVwiZW5kXCIpe3I9RSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lkZT09PW4mJiFlLmRpc2FibGVkfSkpO2lmKHIpe3JldHVyblsyLHJdfXJldHVyblsyLEUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpZGU9PT1ufSkpXX1lbHNlIGlmKG4hPW51bGwpe3JldHVyblsyLEUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1lbnVJZD09PW59KSldfXQ9RSgoZnVuY3Rpb24obil7cmV0dXJuIW4uZGlzYWJsZWR9KSk7aWYodCl7cmV0dXJuWzIsdF19cmV0dXJuWzIsZS5sZW5ndGg+MD9lWzBdLmVsOnVuZGVmaW5lZF19fSkpfSkpfTt2YXIgZj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsTygpXTtjYXNlIDE6bi5zZW50KCk7cmV0dXJuWzIsZygpXX19KSl9KSl9O3ZhciBkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxPKCldO2Nhc2UgMTpuLnNlbnQoKTtyZXR1cm5bMix3KCldfX0pKX0pKX07dmFyIHY9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LE8oKV07Y2FzZSAxOm4uc2VudCgpO3JldHVyblsyLEEoKV19fSkpfSkpfTt2YXIgbD1mdW5jdGlvbihlLHIpe24uc2V0KGUscil9O3ZhciBtPWZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihuKTwwKXtpZighbi5kaXNhYmxlZCl7cChuKX1lLnB1c2gobil9fTt2YXIgXz1mdW5jdGlvbihuKXt2YXIgcj1lLmluZGV4T2Yobik7aWYocj4tMSl7ZS5zcGxpY2UociwxKX19O3ZhciBwPWZ1bmN0aW9uKG4pe3ZhciByPW4uc2lkZTtlLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lkZT09PXImJmUhPT1ufSkpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3JldHVybiBuLmRpc2FibGVkPXRydWV9KSl9O3ZhciBiPWZ1bmN0aW9uKG4sZSxyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOmlmKEEoKSl7cmV0dXJuWzIsZmFsc2VdfWlmKCFlKXJldHVyblszLDNdO3JldHVybls0LGYoKV07Y2FzZSAxOnQ9aS5zZW50KCk7aWYoISh0JiZuLmVsIT09dCkpcmV0dXJuWzMsM107cmV0dXJuWzQsdC5zZXRPcGVuKGZhbHNlLGZhbHNlKV07Y2FzZSAyOmkuc2VudCgpO2kubGFiZWw9MztjYXNlIDM6cmV0dXJuWzIsbi5fc2V0T3BlbihlLHIpXX19KSl9KSl9O3ZhciBoPWZ1bmN0aW9uKGUscil7dmFyIHQ9bi5nZXQoZSk7aWYoIXQpe3Rocm93IG5ldyBFcnJvcihcImFuaW1hdGlvbiBub3QgcmVnaXN0ZXJlZFwiKX12YXIgaT10KHIpO3JldHVybiBpfTt2YXIgZz1mdW5jdGlvbigpe3JldHVybiBFKChmdW5jdGlvbihuKXtyZXR1cm4gbi5faXNPcGVufSkpfTt2YXIgdz1mdW5jdGlvbigpe3JldHVybiBlLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIG4uZWx9KSl9O3ZhciBBPWZ1bmN0aW9uKCl7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24obil7cmV0dXJuIG4uaXNBbmltYXRpbmd9KSl9O3ZhciBFPWZ1bmN0aW9uKG4pe3ZhciByPWUuZmluZChuKTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5lbH1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgTz1mdW5jdGlvbigpe3JldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tbWVudVwiKSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wb25lbnRPblJlYWR5KG4sZSl9KSl9KSkpfTtsKFwicmV2ZWFsXCIsbWVudVJldmVhbEFuaW1hdGlvbik7bChcInB1c2hcIixtZW51UHVzaEFuaW1hdGlvbik7bChcIm92ZXJsYXlcIixtZW51T3ZlcmxheUFuaW1hdGlvbik7aWYodHlwZW9mIGRvY3VtZW50IT09XCJ1bmRlZmluZWRcIil7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlvbkJhY2tCdXR0b25cIiwoZnVuY3Rpb24obil7dmFyIGU9ZygpO2lmKGUpe24uZGV0YWlsLnJlZ2lzdGVyKE1FTlVfQkFDS19CVVRUT05fUFJJT1JJVFksKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvc2UoKX0pKX19KSl9cmV0dXJue3JlZ2lzdGVyQW5pbWF0aW9uOmwsZ2V0OmMsZ2V0TWVudXM6ZCxnZXRPcGVuOmYsaXNFbmFibGVkOnMsc3dpcGVHZXN0dXJlOm8saXNBbmltYXRpbmc6dixpc09wZW46dSxlbmFibGU6YSx0b2dnbGU6aSxjbG9zZTp0LG9wZW46cixfZ2V0T3BlblN5bmM6ZyxfY3JlYXRlQW5pbWF0aW9uOmgsX3JlZ2lzdGVyOm0sX3VucmVnaXN0ZXI6Xyxfc2V0T3BlbjpiLF9zZXRBY3RpdmVNZW51OnB9fTt2YXIgbWVudUNvbnRyb2xsZXI9Y3JlYXRlTWVudUNvbnRyb2xsZXIoKTtleHBvcnR7bWVudUNvbnRyb2xsZXIgYXMgbX07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n')},2032:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ LIFECYCLE_WILL_ENTER),\n/* harmony export */   "a": () => (/* binding */ LIFECYCLE_DID_ENTER),\n/* harmony export */   "b": () => (/* binding */ LIFECYCLE_WILL_LEAVE),\n/* harmony export */   "c": () => (/* binding */ LIFECYCLE_DID_LEAVE),\n/* harmony export */   "d": () => (/* binding */ LIFECYCLE_WILL_UNLOAD),\n/* harmony export */   "e": () => (/* binding */ deepReady),\n/* harmony export */   "g": () => (/* binding */ getIonPageElement),\n/* harmony export */   "l": () => (/* binding */ lifecycle),\n/* harmony export */   "s": () => (/* binding */ setPageHidden),\n/* harmony export */   "t": () => (/* binding */ transition)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(655);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2896);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var LIFECYCLE_WILL_ENTER="ionViewWillEnter";var LIFECYCLE_DID_ENTER="ionViewDidEnter";var LIFECYCLE_WILL_LEAVE="ionViewWillLeave";var LIFECYCLE_DID_LEAVE="ionViewDidLeave";var LIFECYCLE_WILL_UNLOAD="ionViewWillUnload";var iosTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8360))};var mdTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 2782))};var transition=function(e){return new Promise((function(n,i){(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.c)((function(){beforeTransition(e);runTransition(e).then((function(i){if(i.animation){i.animation.destroy()}afterTransition(e);n(i)}),(function(n){afterTransition(e);i(n)}))}))}))};var beforeTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;setZIndex(n,i,e.direction);if(e.showGoBack){n.classList.add("can-go-back")}else{n.classList.remove("can-go-back")}setPageHidden(n,false);n.style.setProperty("pointer-events","none");if(i){setPageHidden(i,false);i.style.setProperty("pointer-events","none")}};var runTransition=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,getAnimationBuilder(e)];case 1:n=r.sent();i=n&&_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.B.isBrowser?animation(n,e):noAnimation(e);return[2,i]}}))}))};var afterTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;n.classList.remove("ion-page-invisible");n.style.removeProperty("pointer-events");if(i!==undefined){i.classList.remove("ion-page-invisible");i.style.removeProperty("pointer-events")}};var getAnimationBuilder=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!e.leavingEl||!e.animated||e.duration===0){return[2,undefined]}if(e.animationBuilder){return[2,e.animationBuilder]}if(!(e.mode==="ios"))return[3,2];return[4,iosTransitionAnimation()];case 1:i=r.sent().iosTransitionAnimation;return[3,4];case 2:return[4,mdTransitionAnimation()];case 3:i=r.sent().mdTransitionAnimation;r.label=4;case 4:n=i;return[2,n]}}))}))};var animation=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,waitForReady(n,true)];case 1:t.sent();i=e(n.baseEl,n);fireWillEvents(n.enteringEl,n.leavingEl);return[4,playTransition(i,n)];case 2:r=t.sent();if(n.progressCallback){n.progressCallback(undefined)}if(r){fireDidEvents(n.enteringEl,n.leavingEl)}return[2,{hasCompleted:r,animation:i}]}}))}))};var noAnimation=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:n=e.enteringEl;i=e.leavingEl;return[4,waitForReady(e,false)];case 1:r.sent();fireWillEvents(n,i);fireDidEvents(n,i);return[2,{hasCompleted:true}]}}))}))};var waitForReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:i=e.deepWait!==undefined?e.deepWait:n;r=i?[deepReady(e.enteringEl),deepReady(e.leavingEl)]:[shallowReady(e.enteringEl),shallowReady(e.leavingEl)];return[4,Promise.all(r)];case 1:t.sent();return[4,notifyViewReady(e.viewIsReady,e.enteringEl)];case 2:t.sent();return[2]}}))}))};var notifyViewReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(!e)return[3,2];return[4,e(n)];case 1:i.sent();i.label=2;case 2:return[2]}}))}))};var playTransition=function(e,n){var i=n.progressCallback;var r=new Promise((function(n){e.onFinish((function(e){return n(e===1)}))}));if(i){e.progressStart(true);i(e)}else{e.play()}return r};var fireWillEvents=function(e,n){lifecycle(n,LIFECYCLE_WILL_LEAVE);lifecycle(e,LIFECYCLE_WILL_ENTER)};var fireDidEvents=function(e,n){lifecycle(e,LIFECYCLE_DID_ENTER);lifecycle(n,LIFECYCLE_DID_LEAVE)};var lifecycle=function(e,n){if(e){var i=new CustomEvent(n,{bubbles:false,cancelable:false});e.dispatchEvent(i)}};var shallowReady=function(e){if(e){return new Promise((function(n){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(e,n)}))}return Promise.resolve()};var deepReady=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:n=e;if(!n)return[3,6];if(!(n.componentOnReady!=null))return[3,2];return[4,n.componentOnReady()];case 1:i=t.sent();if(i!=null){return[2]}return[3,4];case 2:if(!(n.__registerHost!=null))return[3,4];r=new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.r)(e)}));return[4,r];case 3:t.sent();return[2];case 4:return[4,Promise.all(Array.from(n.children).map(deepReady))];case 5:t.sent();t.label=6;case 6:return[2]}}))}))};var setPageHidden=function(e,n){if(n){e.setAttribute("aria-hidden","true");e.classList.add("ion-page-hidden")}else{e.hidden=false;e.removeAttribute("aria-hidden");e.classList.remove("ion-page-hidden")}};var setZIndex=function(e,n,i){if(e!==undefined){e.style.zIndex=i==="back"?"99":"101"}if(n!==undefined){n.style.zIndex="100"}};var getIonPageElement=function(e){if(e.classList.contains("ion-page")){return e}var n=e.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");if(n){return n}return e};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxHQUFnSSw0Q0FBNEMsMENBQTBDLDRDQUE0QywwQ0FBMEMsOENBQThDLHNDQUFzQyxPQUFPLHlGQUFzQyxFQUFFLHFDQUFxQyxPQUFPLHlGQUFxQyxFQUFFLDJCQUEyQixrQ0FBa0MscURBQVMsYUFBYSxvQkFBb0IsbUNBQW1DLGdCQUFnQixzQkFBc0IsbUJBQW1CLEtBQUssZUFBZSxtQkFBbUIsS0FBSyxHQUFHLEdBQUcsSUFBSSxpQ0FBaUMsbUJBQW1CLGtCQUFrQiwyQkFBMkIsaUJBQWlCLCtCQUErQixLQUFLLGtDQUFrQyx1QkFBdUIsNkNBQTZDLE1BQU0sdUJBQXVCLCtDQUErQyw4QkFBOEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isd0NBQXdDLGtCQUFrQixLQUFLLDJEQUFlLCtCQUErQixhQUFhLEdBQUcsSUFBSSxnQ0FBZ0MsbUJBQW1CLGtCQUFrQix5Q0FBeUMseUNBQXlDLGtCQUFrQix5Q0FBeUMsMkNBQTJDLG9DQUFvQyxPQUFPLDBEQUFTLGtDQUFrQyxRQUFRLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQixxREFBcUQsb0JBQW9CLHVCQUF1Qiw2QkFBNkIsaUNBQWlDLG1DQUFtQyx5Q0FBeUMsWUFBWSx5Q0FBeUMsd0NBQXdDLFVBQVUsV0FBVyxhQUFhLEdBQUcsSUFBSSw0QkFBNEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isc0NBQXNDLGdCQUFnQixnQkFBZ0IseUNBQXlDLDhCQUE4QixrQkFBa0IsdUJBQXVCLDhCQUE4QixNQUFNLHdDQUF3QyxVQUFVLDJCQUEyQixHQUFHLEdBQUcsSUFBSSw0QkFBNEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isc0JBQXNCLGNBQWMsZ0NBQWdDLGdCQUFnQixvQkFBb0IsbUJBQW1CLFVBQVUsa0JBQWtCLEdBQUcsR0FBRyxJQUFJLCtCQUErQixPQUFPLDBEQUFTLGtDQUFrQyxRQUFRLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQiw2Q0FBNkMsNEdBQTRHLHlCQUF5QixnQkFBZ0Isc0RBQXNELGdCQUFnQixXQUFXLEdBQUcsSUFBSSxrQ0FBa0MsT0FBTywwREFBUyxrQ0FBa0MsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLHlCQUF5QixlQUFlLGdCQUFnQixVQUFVLGtCQUFrQixHQUFHLElBQUksaUNBQWlDLHlCQUF5QiwrQkFBK0Isd0JBQXdCLGdCQUFnQixHQUFHLEdBQUcsTUFBTSxzQkFBc0IsS0FBSyxLQUFLLFNBQVMsVUFBVSxpQ0FBaUMsa0NBQWtDLG1DQUFtQyxnQ0FBZ0MsaUNBQWlDLGtDQUFrQyw0QkFBNEIsTUFBTSx5QkFBeUIsK0JBQStCLEVBQUUscUJBQXFCLDZCQUE2QixNQUFNLGdDQUFnQyxPQUFPLHVEQUFnQixNQUFNLEdBQUcsMEJBQTBCLDBCQUEwQixPQUFPLDBEQUFTLGtDQUFrQyxVQUFVLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQixXQUFXLGtCQUFrQiwyQ0FBMkMsK0JBQStCLGtCQUFrQixZQUFZLFVBQVUsWUFBWSxnREFBZ0QsMkJBQTJCLE9BQU8sdURBQUcsSUFBSSxHQUFHLFlBQVksZ0JBQWdCLFVBQVUsb0VBQW9FLGdCQUFnQixVQUFVLGtCQUFrQixHQUFHLElBQUksZ0NBQWdDLE1BQU0scUNBQXFDLG1DQUFtQyxLQUFLLGVBQWUsaUNBQWlDLHdDQUF3Qyw4QkFBOEIsa0JBQWtCLHFDQUFxQyxrQkFBa0IsdUJBQXVCLGtDQUFrQyxxQ0FBcUMsU0FBUyxpRkFBaUYsTUFBTSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtZTZjMmM4MjIuanM/ZGFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZ2VuZXJhdG9yfWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtjIGFzIHdyaXRlVGFzayxCIGFzIEJ1aWxkfWZyb21cIi4vaW5kZXgtYjNlZWNiMTQuanNcIjtpbXBvcnR7YyBhcyBjb21wb25lbnRPblJlYWR5LHIgYXMgcmFmfWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO3ZhciBMSUZFQ1lDTEVfV0lMTF9FTlRFUj1cImlvblZpZXdXaWxsRW50ZXJcIjt2YXIgTElGRUNZQ0xFX0RJRF9FTlRFUj1cImlvblZpZXdEaWRFbnRlclwiO3ZhciBMSUZFQ1lDTEVfV0lMTF9MRUFWRT1cImlvblZpZXdXaWxsTGVhdmVcIjt2YXIgTElGRUNZQ0xFX0RJRF9MRUFWRT1cImlvblZpZXdEaWRMZWF2ZVwiO3ZhciBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQ9XCJpb25WaWV3V2lsbFVubG9hZFwiO3ZhciBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGltcG9ydChcIi4vaW9zLnRyYW5zaXRpb24tOGI2YTc3NmEuanNcIil9O3ZhciBtZFRyYW5zaXRpb25BbmltYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaW1wb3J0KFwiLi9tZC50cmFuc2l0aW9uLWRhODY2MTE5LmpzXCIpfTt2YXIgdHJhbnNpdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4saSl7d3JpdGVUYXNrKChmdW5jdGlvbigpe2JlZm9yZVRyYW5zaXRpb24oZSk7cnVuVHJhbnNpdGlvbihlKS50aGVuKChmdW5jdGlvbihpKXtpZihpLmFuaW1hdGlvbil7aS5hbmltYXRpb24uZGVzdHJveSgpfWFmdGVyVHJhbnNpdGlvbihlKTtuKGkpfSksKGZ1bmN0aW9uKG4pe2FmdGVyVHJhbnNpdGlvbihlKTtpKG4pfSkpfSkpfSkpfTt2YXIgYmVmb3JlVHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgbj1lLmVudGVyaW5nRWw7dmFyIGk9ZS5sZWF2aW5nRWw7c2V0WkluZGV4KG4saSxlLmRpcmVjdGlvbik7aWYoZS5zaG93R29CYWNrKXtuLmNsYXNzTGlzdC5hZGQoXCJjYW4tZ28tYmFja1wiKX1lbHNle24uY2xhc3NMaXN0LnJlbW92ZShcImNhbi1nby1iYWNrXCIpfXNldFBhZ2VIaWRkZW4obixmYWxzZSk7bi5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO2lmKGkpe3NldFBhZ2VIaWRkZW4oaSxmYWxzZSk7aS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpfX07dmFyIHJ1blRyYW5zaXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGdldEFuaW1hdGlvbkJ1aWxkZXIoZSldO2Nhc2UgMTpuPXIuc2VudCgpO2k9biYmQnVpbGQuaXNCcm93c2VyP2FuaW1hdGlvbihuLGUpOm5vQW5pbWF0aW9uKGUpO3JldHVyblsyLGldfX0pKX0pKX07dmFyIGFmdGVyVHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgbj1lLmVudGVyaW5nRWw7dmFyIGk9ZS5sZWF2aW5nRWw7bi5jbGFzc0xpc3QucmVtb3ZlKFwiaW9uLXBhZ2UtaW52aXNpYmxlXCIpO24uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiKTtpZihpIT09dW5kZWZpbmVkKXtpLmNsYXNzTGlzdC5yZW1vdmUoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIpfX07dmFyIGdldEFuaW1hdGlvbkJ1aWxkZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKCFlLmxlYXZpbmdFbHx8IWUuYW5pbWF0ZWR8fGUuZHVyYXRpb249PT0wKXtyZXR1cm5bMix1bmRlZmluZWRdfWlmKGUuYW5pbWF0aW9uQnVpbGRlcil7cmV0dXJuWzIsZS5hbmltYXRpb25CdWlsZGVyXX1pZighKGUubW9kZT09PVwiaW9zXCIpKXJldHVyblszLDJdO3JldHVybls0LGlvc1RyYW5zaXRpb25BbmltYXRpb24oKV07Y2FzZSAxOmk9ci5zZW50KCkuaW9zVHJhbnNpdGlvbkFuaW1hdGlvbjtyZXR1cm5bMyw0XTtjYXNlIDI6cmV0dXJuWzQsbWRUcmFuc2l0aW9uQW5pbWF0aW9uKCldO2Nhc2UgMzppPXIuc2VudCgpLm1kVHJhbnNpdGlvbkFuaW1hdGlvbjtyLmxhYmVsPTQ7Y2FzZSA0Om49aTtyZXR1cm5bMixuXX19KSl9KSl9O3ZhciBhbmltYXRpb249ZnVuY3Rpb24oZSxuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBpLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsd2FpdEZvclJlYWR5KG4sdHJ1ZSldO2Nhc2UgMTp0LnNlbnQoKTtpPWUobi5iYXNlRWwsbik7ZmlyZVdpbGxFdmVudHMobi5lbnRlcmluZ0VsLG4ubGVhdmluZ0VsKTtyZXR1cm5bNCxwbGF5VHJhbnNpdGlvbihpLG4pXTtjYXNlIDI6cj10LnNlbnQoKTtpZihuLnByb2dyZXNzQ2FsbGJhY2spe24ucHJvZ3Jlc3NDYWxsYmFjayh1bmRlZmluZWQpfWlmKHIpe2ZpcmVEaWRFdmVudHMobi5lbnRlcmluZ0VsLG4ubGVhdmluZ0VsKX1yZXR1cm5bMix7aGFzQ29tcGxldGVkOnIsYW5pbWF0aW9uOml9XX19KSl9KSl9O3ZhciBub0FuaW1hdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6bj1lLmVudGVyaW5nRWw7aT1lLmxlYXZpbmdFbDtyZXR1cm5bNCx3YWl0Rm9yUmVhZHkoZSxmYWxzZSldO2Nhc2UgMTpyLnNlbnQoKTtmaXJlV2lsbEV2ZW50cyhuLGkpO2ZpcmVEaWRFdmVudHMobixpKTtyZXR1cm5bMix7aGFzQ29tcGxldGVkOnRydWV9XX19KSl9KSl9O3ZhciB3YWl0Rm9yUmVhZHk9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBpLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6aT1lLmRlZXBXYWl0IT09dW5kZWZpbmVkP2UuZGVlcFdhaXQ6bjtyPWk/W2RlZXBSZWFkeShlLmVudGVyaW5nRWwpLGRlZXBSZWFkeShlLmxlYXZpbmdFbCldOltzaGFsbG93UmVhZHkoZS5lbnRlcmluZ0VsKSxzaGFsbG93UmVhZHkoZS5sZWF2aW5nRWwpXTtyZXR1cm5bNCxQcm9taXNlLmFsbChyKV07Y2FzZSAxOnQuc2VudCgpO3JldHVybls0LG5vdGlmeVZpZXdSZWFkeShlLnZpZXdJc1JlYWR5LGUuZW50ZXJpbmdFbCldO2Nhc2UgMjp0LnNlbnQoKTtyZXR1cm5bMl19fSkpfSkpfTt2YXIgbm90aWZ5Vmlld1JlYWR5PWZ1bmN0aW9uKGUsbil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDppZighZSlyZXR1cm5bMywyXTtyZXR1cm5bNCxlKG4pXTtjYXNlIDE6aS5zZW50KCk7aS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl19fSkpfSkpfTt2YXIgcGxheVRyYW5zaXRpb249ZnVuY3Rpb24oZSxuKXt2YXIgaT1uLnByb2dyZXNzQ2FsbGJhY2s7dmFyIHI9bmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe2Uub25GaW5pc2goKGZ1bmN0aW9uKGUpe3JldHVybiBuKGU9PT0xKX0pKX0pKTtpZihpKXtlLnByb2dyZXNzU3RhcnQodHJ1ZSk7aShlKX1lbHNle2UucGxheSgpfXJldHVybiByfTt2YXIgZmlyZVdpbGxFdmVudHM9ZnVuY3Rpb24oZSxuKXtsaWZlY3ljbGUobixMSUZFQ1lDTEVfV0lMTF9MRUFWRSk7bGlmZWN5Y2xlKGUsTElGRUNZQ0xFX1dJTExfRU5URVIpfTt2YXIgZmlyZURpZEV2ZW50cz1mdW5jdGlvbihlLG4pe2xpZmVjeWNsZShlLExJRkVDWUNMRV9ESURfRU5URVIpO2xpZmVjeWNsZShuLExJRkVDWUNMRV9ESURfTEVBVkUpfTt2YXIgbGlmZWN5Y2xlPWZ1bmN0aW9uKGUsbil7aWYoZSl7dmFyIGk9bmV3IEN1c3RvbUV2ZW50KG4se2J1YmJsZXM6ZmFsc2UsY2FuY2VsYWJsZTpmYWxzZX0pO2UuZGlzcGF0Y2hFdmVudChpKX19O3ZhciBzaGFsbG93UmVhZHk9ZnVuY3Rpb24oZSl7aWYoZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtyZXR1cm4gY29tcG9uZW50T25SZWFkeShlLG4pfSkpfXJldHVybiBQcm9taXNlLnJlc29sdmUoKX07dmFyIGRlZXBSZWFkeT1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGkscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpuPWU7aWYoIW4pcmV0dXJuWzMsNl07aWYoIShuLmNvbXBvbmVudE9uUmVhZHkhPW51bGwpKXJldHVyblszLDJdO3JldHVybls0LG4uY29tcG9uZW50T25SZWFkeSgpXTtjYXNlIDE6aT10LnNlbnQoKTtpZihpIT1udWxsKXtyZXR1cm5bMl19cmV0dXJuWzMsNF07Y2FzZSAyOmlmKCEobi5fX3JlZ2lzdGVySG9zdCE9bnVsbCkpcmV0dXJuWzMsNF07cj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHJhZihlKX0pKTtyZXR1cm5bNCxyXTtjYXNlIDM6dC5zZW50KCk7cmV0dXJuWzJdO2Nhc2UgNDpyZXR1cm5bNCxQcm9taXNlLmFsbChBcnJheS5mcm9tKG4uY2hpbGRyZW4pLm1hcChkZWVwUmVhZHkpKV07Y2FzZSA1OnQuc2VudCgpO3QubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzJdfX0pKX0pKX07dmFyIHNldFBhZ2VIaWRkZW49ZnVuY3Rpb24oZSxuKXtpZihuKXtlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpO2UuY2xhc3NMaXN0LmFkZChcImlvbi1wYWdlLWhpZGRlblwiKX1lbHNle2UuaGlkZGVuPWZhbHNlO2UucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7ZS5jbGFzc0xpc3QucmVtb3ZlKFwiaW9uLXBhZ2UtaGlkZGVuXCIpfX07dmFyIHNldFpJbmRleD1mdW5jdGlvbihlLG4saSl7aWYoZSE9PXVuZGVmaW5lZCl7ZS5zdHlsZS56SW5kZXg9aT09PVwiYmFja1wiP1wiOTlcIjpcIjEwMVwifWlmKG4hPT11bmRlZmluZWQpe24uc3R5bGUuekluZGV4PVwiMTAwXCJ9fTt2YXIgZ2V0SW9uUGFnZUVsZW1lbnQ9ZnVuY3Rpb24oZSl7aWYoZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpb24tcGFnZVwiKSl7cmV0dXJuIGV9dmFyIG49ZS5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gLmlvbi1wYWdlLCA6c2NvcGUgPiBpb24tbmF2LCA6c2NvcGUgPiBpb24tdGFic1wiKTtpZihuKXtyZXR1cm4gbn1yZXR1cm4gZX07ZXhwb3J0e0xJRkVDWUNMRV9XSUxMX0VOVEVSIGFzIEwsTElGRUNZQ0xFX0RJRF9FTlRFUiBhcyBhLExJRkVDWUNMRV9XSUxMX0xFQVZFIGFzIGIsTElGRUNZQ0xFX0RJRF9MRUFWRSBhcyBjLExJRkVDWUNMRV9XSUxMX1VOTE9BRCBhcyBkLGRlZXBSZWFkeSBhcyBlLGdldElvblBhZ2VFbGVtZW50IGFzIGcsbGlmZWN5Y2xlIGFzIGwsc2V0UGFnZUhpZGRlbiBhcyBzLHRyYW5zaXRpb24gYXMgdH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2032\n')},3774:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createAnimation": () => (/* reexport safe */ _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   "iosTransitionAnimation": () => (/* reexport safe */ _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__.iosTransitionAnimation),\n/* harmony export */   "mdTransitionAnimation": () => (/* reexport safe */ _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__.mdTransitionAnimation),\n/* harmony export */   "getTimeGivenProgression": () => (/* reexport safe */ _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__.g),\n/* harmony export */   "createGesture": () => (/* reexport safe */ _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__.createGesture),\n/* harmony export */   "getPlatforms": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.g),\n/* harmony export */   "initialize": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.i),\n/* harmony export */   "isPlatform": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.a),\n/* harmony export */   "componentOnReady": () => (/* reexport safe */ _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.c),\n/* harmony export */   "IonicSafeString": () => (/* reexport safe */ _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__.I),\n/* harmony export */   "LIFECYCLE_DID_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.a),\n/* harmony export */   "LIFECYCLE_DID_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.c),\n/* harmony export */   "LIFECYCLE_WILL_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.L),\n/* harmony export */   "LIFECYCLE_WILL_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.b),\n/* harmony export */   "LIFECYCLE_WILL_UNLOAD": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.d),\n/* harmony export */   "menuController": () => (/* reexport safe */ _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__.m),\n/* harmony export */   "actionSheetController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.b),\n/* harmony export */   "alertController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.a),\n/* harmony export */   "loadingController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.l),\n/* harmony export */   "modalController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.m),\n/* harmony export */   "pickerController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.p),\n/* harmony export */   "popoverController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.c),\n/* harmony export */   "toastController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.t),\n/* harmony export */   "IonicSlides": () => (/* binding */ IonicSlides),\n/* harmony export */   "IonicSwiper": () => (/* binding */ IonicSwiper),\n/* harmony export */   "getMode": () => (/* binding */ getMode),\n/* harmony export */   "setupConfig": () => (/* binding */ setupConfig)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7434);\n/* harmony import */ var _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8360);\n/* harmony import */ var _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2782);\n/* harmony import */ var _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3544);\n/* harmony import */ var _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3876);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(882);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7504);\n/* harmony import */ var _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8186);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2032);\n/* harmony import */ var _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(114);\n/* harmony import */ var _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6250);\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4988);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar setupConfig=function(e){var i=window;var o=i.Ionic;if(o&&o.config&&o.config.constructor.name!=="Object"){return}i.Ionic=i.Ionic||{};i.Ionic.config=Object.assign(Object.assign({},i.Ionic.config),e);return i.Ionic.config};var getMode=function(){var e=window;var i=e&&e.Ionic&&e.Ionic.config;if(i){if(i.mode){return i.mode}else{return i.get("mode")}}return"md"};var setupSwiperInIonic=function(e,i){if(i===void 0){i=true}if(typeof window==="undefined"){return}var o=e.el;var t=o.closest(".ion-page");if(!t){if(i){var r=o.getRootNode();if(r.tagName==="DIV"){var a=new MutationObserver((function(i){var o=i[0];var t=o.oldValue===null;var s=r.classList.contains("ion-page");if(t&&s){a.disconnect();setupSwiperInIonic(e,false)}}));a.observe(r,{attributeFilter:["class"],attributeOldValue:true})}}return}var s=o.closest("ion-modal, ion-popover");if(s){var n=s.tagName==="ION-MODAL"?"ionModalWillPresent":"ionPopoverWillPresent";var l=function(){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.r)((function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(s,n,l)}))};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(s,n,l)}else{var c=new MutationObserver((function(e){var i;var r=e[0];var a=(i=r.oldValue)===null||i===void 0?void 0:i.includes("ion-page-invisible");var s=t.classList.contains("ion-page-invisible");if(!s&&s!==a){o.swiper.update()}}));c.observe(t,{attributeFilter:["class"],attributeOldValue:true})}var d=function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(window,"appload",d)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(window,"appload",d)};var IonicSwiper={name:"ionic",on:{afterInit:function(e){console.warn("[Deprecation Warning]: The IonicSwiper module has been deprecated in favor of the IonSlides module. This change was made to better support the Swiper 7 release. The IonicSwiper module will be removed in Ionic 7.0. See https://ionicframework.com/docs/api/slides#migration for revised migration steps.");setupSwiperInIonic(e)}}};var IonicSlides=function(e){var i=e.swiper,o=e.extendParams;var t={effect:undefined,direction:"horizontal",initialSlide:0,loop:false,parallax:false,slidesPerView:1,spaceBetween:0,speed:300,slidesPerColumn:1,slidesPerColumnFill:"column",slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0,touchEventsTarget:"container",autoplay:false,freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:false,freeModeMinimumVelocity:.02,autoHeight:false,setWrapperSize:false,zoom:{maxRatio:3,minRatio:1,toggle:false},touchRatio:1,touchAngle:45,simulateTouch:true,touchStartPreventDefault:false,shortSwipes:true,longSwipes:true,longSwipesRatio:.5,longSwipesMs:300,followFinger:true,threshold:0,touchMoveStopPropagation:true,touchReleaseOnEdges:false,iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20,resistance:true,resistanceRatio:.85,watchSlidesProgress:false,watchSlidesVisibility:false,preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false,loopAdditionalSlides:0,noSwiping:true,runCallbacksOnInit:true,coverflowEffect:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},flipEffect:{slideShadows:true,limitRotation:true},cubeEffect:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:.94},fadeEffect:{crossFade:false},a11y:{prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide"}};if(i.pagination){t.pagination={type:"bullets",clickable:false,hideOnClick:false}}if(i.scrollbar){t.scrollbar={hide:true}}o(t)};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzJsQyw0QkFBNEIsYUFBYSxjQUFjLHNEQUFzRCxPQUFPLG9CQUFvQiw2Q0FBNkMsb0JBQW9CLHVCQUF1Qix1QkFBdUIsYUFBYSxpQ0FBaUMsTUFBTSxXQUFXLGNBQWMsS0FBSyxzQkFBc0IsWUFBWSxxQ0FBcUMsZUFBZSxPQUFPLGdDQUFnQyxPQUFPLFdBQVcsNkJBQTZCLE9BQU8sTUFBTSxzQkFBc0Isc0JBQXNCLHdDQUF3QyxXQUFXLHdCQUF3Qix1Q0FBdUMsU0FBUyxlQUFlLDZCQUE2QixHQUFHLGFBQWEsaURBQWlELEdBQUcsT0FBTywwQ0FBMEMsTUFBTSw0RUFBNEUsaUJBQWlCLHVEQUFHLGFBQWEsa0JBQWtCLHVEQUFtQixRQUFRLElBQUksdURBQWdCLFFBQVEsS0FBSyx3Q0FBd0MsTUFBTSxXQUFXLGdGQUFnRixpREFBaUQsY0FBYyxtQkFBbUIsR0FBRyxhQUFhLGlEQUFpRCxFQUFFLGlCQUFpQixrQkFBa0IsdURBQW1CLHNCQUFzQix1REFBZ0Isc0JBQXNCLGlCQUFpQixpQkFBaUIsc0JBQXNCLDRUQUE0VCx5QkFBeUIsNEJBQTRCLGdDQUFnQyxPQUFPLHloQkFBeWhCLG1DQUFtQyxraEJBQWtoQiwyREFBMkQsYUFBYSxxQ0FBcUMsYUFBYSw4REFBOEQsYUFBYSxnQkFBZ0IsT0FBTyx3SkFBd0osaUJBQWlCLGNBQWMsa0RBQWtELGdCQUFnQixhQUFhLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9pbmRleC5qcz82MjZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5leHBvcnR7YyBhcyBjcmVhdGVBbmltYXRpb259ZnJvbVwiLi9hbmltYXRpb24tMTlkYmY5YmYuanNcIjtleHBvcnR7aW9zVHJhbnNpdGlvbkFuaW1hdGlvbn1mcm9tXCIuL2lvcy50cmFuc2l0aW9uLThiNmE3NzZhLmpzXCI7ZXhwb3J0e21kVHJhbnNpdGlvbkFuaW1hdGlvbn1mcm9tXCIuL21kLnRyYW5zaXRpb24tZGE4NjYxMTkuanNcIjtleHBvcnR7ZyBhcyBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbn1mcm9tXCIuL2N1YmljLWJlemllci0xNTRhNTNhNS5qc1wiO2V4cG9ydHtjcmVhdGVHZXN0dXJlfWZyb21cIi4vaW5kZXgtNDFiZjQxZjIuanNcIjtleHBvcnR7ZyBhcyBnZXRQbGF0Zm9ybXMsaSBhcyBpbml0aWFsaXplLGEgYXMgaXNQbGF0Zm9ybX1mcm9tXCIuL2lvbmljLWdsb2JhbC0wZWJlMzIxYy5qc1wiO2ltcG9ydHthIGFzIGFkZEV2ZW50TGlzdGVuZXIsciBhcyByYWYsYiBhcyByZW1vdmVFdmVudExpc3RlbmVyfWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO2V4cG9ydHtjIGFzIGNvbXBvbmVudE9uUmVhZHl9ZnJvbVwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7ZXhwb3J0e0kgYXMgSW9uaWNTYWZlU3RyaW5nfWZyb21cIi4vaW5kZXgtYzg0MWM5MzMuanNcIjtleHBvcnR7YSBhcyBMSUZFQ1lDTEVfRElEX0VOVEVSLGMgYXMgTElGRUNZQ0xFX0RJRF9MRUFWRSxMIGFzIExJRkVDWUNMRV9XSUxMX0VOVEVSLGIgYXMgTElGRUNZQ0xFX1dJTExfTEVBVkUsZCBhcyBMSUZFQ1lDTEVfV0lMTF9VTkxPQUR9ZnJvbVwiLi9pbmRleC1lNmMyYzgyMi5qc1wiO2V4cG9ydHttIGFzIG1lbnVDb250cm9sbGVyfWZyb21cIi4vaW5kZXgtY2RiMWNmOTQuanNcIjtleHBvcnR7YiBhcyBhY3Rpb25TaGVldENvbnRyb2xsZXIsYSBhcyBhbGVydENvbnRyb2xsZXIsbCBhcyBsb2FkaW5nQ29udHJvbGxlcixtIGFzIG1vZGFsQ29udHJvbGxlcixwIGFzIHBpY2tlckNvbnRyb2xsZXIsYyBhcyBwb3BvdmVyQ29udHJvbGxlcix0IGFzIHRvYXN0Q29udHJvbGxlcn1mcm9tXCIuL292ZXJsYXlzLTM2ZDM0NzVkLmpzXCI7aW1wb3J0XCIuL2dlc3R1cmUtY29udHJvbGxlci02OGMwMjNhNC5qc1wiO2ltcG9ydFwiLi9pbmRleC1iM2VlY2IxNC5qc1wiO2ltcG9ydFwiLi9oYXJkd2FyZS1iYWNrLWJ1dHRvbi1hY2U2YTcxYi5qc1wiO3ZhciBzZXR1cENvbmZpZz1mdW5jdGlvbihlKXt2YXIgaT13aW5kb3c7dmFyIG89aS5Jb25pYztpZihvJiZvLmNvbmZpZyYmby5jb25maWcuY29uc3RydWN0b3IubmFtZSE9PVwiT2JqZWN0XCIpe3JldHVybn1pLklvbmljPWkuSW9uaWN8fHt9O2kuSW9uaWMuY29uZmlnPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpLklvbmljLmNvbmZpZyksZSk7cmV0dXJuIGkuSW9uaWMuY29uZmlnfTt2YXIgZ2V0TW9kZT1mdW5jdGlvbigpe3ZhciBlPXdpbmRvdzt2YXIgaT1lJiZlLklvbmljJiZlLklvbmljLmNvbmZpZztpZihpKXtpZihpLm1vZGUpe3JldHVybiBpLm1vZGV9ZWxzZXtyZXR1cm4gaS5nZXQoXCJtb2RlXCIpfX1yZXR1cm5cIm1kXCJ9O3ZhciBzZXR1cFN3aXBlckluSW9uaWM9ZnVuY3Rpb24oZSxpKXtpZihpPT09dm9pZCAwKXtpPXRydWV9aWYodHlwZW9mIHdpbmRvdz09PVwidW5kZWZpbmVkXCIpe3JldHVybn12YXIgbz1lLmVsO3ZhciB0PW8uY2xvc2VzdChcIi5pb24tcGFnZVwiKTtpZighdCl7aWYoaSl7dmFyIHI9by5nZXRSb290Tm9kZSgpO2lmKHIudGFnTmFtZT09PVwiRElWXCIpe3ZhciBhPW5ldyBNdXRhdGlvbk9ic2VydmVyKChmdW5jdGlvbihpKXt2YXIgbz1pWzBdO3ZhciB0PW8ub2xkVmFsdWU9PT1udWxsO3ZhciBzPXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaW9uLXBhZ2VcIik7aWYodCYmcyl7YS5kaXNjb25uZWN0KCk7c2V0dXBTd2lwZXJJbklvbmljKGUsZmFsc2UpfX0pKTthLm9ic2VydmUocix7YXR0cmlidXRlRmlsdGVyOltcImNsYXNzXCJdLGF0dHJpYnV0ZU9sZFZhbHVlOnRydWV9KX19cmV0dXJufXZhciBzPW8uY2xvc2VzdChcImlvbi1tb2RhbCwgaW9uLXBvcG92ZXJcIik7aWYocyl7dmFyIG49cy50YWdOYW1lPT09XCJJT04tTU9EQUxcIj9cImlvbk1vZGFsV2lsbFByZXNlbnRcIjpcImlvblBvcG92ZXJXaWxsUHJlc2VudFwiO3ZhciBsPWZ1bmN0aW9uKCl7cmFmKChmdW5jdGlvbigpe28uc3dpcGVyLnVwZGF0ZSgpO3JlbW92ZUV2ZW50TGlzdGVuZXIocyxuLGwpfSkpfTthZGRFdmVudExpc3RlbmVyKHMsbixsKX1lbHNle3ZhciBjPW5ldyBNdXRhdGlvbk9ic2VydmVyKChmdW5jdGlvbihlKXt2YXIgaTt2YXIgcj1lWzBdO3ZhciBhPShpPXIub2xkVmFsdWUpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5pbmNsdWRlcyhcImlvbi1wYWdlLWludmlzaWJsZVwiKTt2YXIgcz10LmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1wYWdlLWludmlzaWJsZVwiKTtpZighcyYmcyE9PWEpe28uc3dpcGVyLnVwZGF0ZSgpfX0pKTtjLm9ic2VydmUodCx7YXR0cmlidXRlRmlsdGVyOltcImNsYXNzXCJdLGF0dHJpYnV0ZU9sZFZhbHVlOnRydWV9KX12YXIgZD1mdW5jdGlvbigpe28uc3dpcGVyLnVwZGF0ZSgpO3JlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LFwiYXBwbG9hZFwiLGQpfTthZGRFdmVudExpc3RlbmVyKHdpbmRvdyxcImFwcGxvYWRcIixkKX07dmFyIElvbmljU3dpcGVyPXtuYW1lOlwiaW9uaWNcIixvbjp7YWZ0ZXJJbml0OmZ1bmN0aW9uKGUpe2NvbnNvbGUud2FybihcIltEZXByZWNhdGlvbiBXYXJuaW5nXTogVGhlIElvbmljU3dpcGVyIG1vZHVsZSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBJb25TbGlkZXMgbW9kdWxlLiBUaGlzIGNoYW5nZSB3YXMgbWFkZSB0byBiZXR0ZXIgc3VwcG9ydCB0aGUgU3dpcGVyIDcgcmVsZWFzZS4gVGhlIElvbmljU3dpcGVyIG1vZHVsZSB3aWxsIGJlIHJlbW92ZWQgaW4gSW9uaWMgNy4wLiBTZWUgaHR0cHM6Ly9pb25pY2ZyYW1ld29yay5jb20vZG9jcy9hcGkvc2xpZGVzI21pZ3JhdGlvbiBmb3IgcmV2aXNlZCBtaWdyYXRpb24gc3RlcHMuXCIpO3NldHVwU3dpcGVySW5Jb25pYyhlKX19fTt2YXIgSW9uaWNTbGlkZXM9ZnVuY3Rpb24oZSl7dmFyIGk9ZS5zd2lwZXIsbz1lLmV4dGVuZFBhcmFtczt2YXIgdD17ZWZmZWN0OnVuZGVmaW5lZCxkaXJlY3Rpb246XCJob3Jpem9udGFsXCIsaW5pdGlhbFNsaWRlOjAsbG9vcDpmYWxzZSxwYXJhbGxheDpmYWxzZSxzbGlkZXNQZXJWaWV3OjEsc3BhY2VCZXR3ZWVuOjAsc3BlZWQ6MzAwLHNsaWRlc1BlckNvbHVtbjoxLHNsaWRlc1BlckNvbHVtbkZpbGw6XCJjb2x1bW5cIixzbGlkZXNQZXJHcm91cDoxLGNlbnRlcmVkU2xpZGVzOmZhbHNlLHNsaWRlc09mZnNldEJlZm9yZTowLHNsaWRlc09mZnNldEFmdGVyOjAsdG91Y2hFdmVudHNUYXJnZXQ6XCJjb250YWluZXJcIixhdXRvcGxheTpmYWxzZSxmcmVlTW9kZTpmYWxzZSxmcmVlTW9kZU1vbWVudHVtOnRydWUsZnJlZU1vZGVNb21lbnR1bVJhdGlvOjEsZnJlZU1vZGVNb21lbnR1bUJvdW5jZTp0cnVlLGZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbzoxLGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOjEsZnJlZU1vZGVTdGlja3k6ZmFsc2UsZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHk6LjAyLGF1dG9IZWlnaHQ6ZmFsc2Usc2V0V3JhcHBlclNpemU6ZmFsc2Usem9vbTp7bWF4UmF0aW86MyxtaW5SYXRpbzoxLHRvZ2dsZTpmYWxzZX0sdG91Y2hSYXRpbzoxLHRvdWNoQW5nbGU6NDUsc2ltdWxhdGVUb3VjaDp0cnVlLHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDpmYWxzZSxzaG9ydFN3aXBlczp0cnVlLGxvbmdTd2lwZXM6dHJ1ZSxsb25nU3dpcGVzUmF0aW86LjUsbG9uZ1N3aXBlc01zOjMwMCxmb2xsb3dGaW5nZXI6dHJ1ZSx0aHJlc2hvbGQ6MCx0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246dHJ1ZSx0b3VjaFJlbGVhc2VPbkVkZ2VzOmZhbHNlLGlPU0VkZ2VTd2lwZURldGVjdGlvbjpmYWxzZSxpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6MjAscmVzaXN0YW5jZTp0cnVlLHJlc2lzdGFuY2VSYXRpbzouODUsd2F0Y2hTbGlkZXNQcm9ncmVzczpmYWxzZSx3YXRjaFNsaWRlc1Zpc2liaWxpdHk6ZmFsc2UscHJldmVudENsaWNrczp0cnVlLHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjp0cnVlLHNsaWRlVG9DbGlja2VkU2xpZGU6ZmFsc2UsbG9vcEFkZGl0aW9uYWxTbGlkZXM6MCxub1N3aXBpbmc6dHJ1ZSxydW5DYWxsYmFja3NPbkluaXQ6dHJ1ZSxjb3ZlcmZsb3dFZmZlY3Q6e3JvdGF0ZTo1MCxzdHJldGNoOjAsZGVwdGg6MTAwLG1vZGlmaWVyOjEsc2xpZGVTaGFkb3dzOnRydWV9LGZsaXBFZmZlY3Q6e3NsaWRlU2hhZG93czp0cnVlLGxpbWl0Um90YXRpb246dHJ1ZX0sY3ViZUVmZmVjdDp7c2xpZGVTaGFkb3dzOnRydWUsc2hhZG93OnRydWUsc2hhZG93T2Zmc2V0OjIwLHNoYWRvd1NjYWxlOi45NH0sZmFkZUVmZmVjdDp7Y3Jvc3NGYWRlOmZhbHNlfSxhMTF5OntwcmV2U2xpZGVNZXNzYWdlOlwiUHJldmlvdXMgc2xpZGVcIixuZXh0U2xpZGVNZXNzYWdlOlwiTmV4dCBzbGlkZVwiLGZpcnN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGVcIixsYXN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwifX07aWYoaS5wYWdpbmF0aW9uKXt0LnBhZ2luYXRpb249e3R5cGU6XCJidWxsZXRzXCIsY2xpY2thYmxlOmZhbHNlLGhpZGVPbkNsaWNrOmZhbHNlfX1pZihpLnNjcm9sbGJhcil7dC5zY3JvbGxiYXI9e2hpZGU6dHJ1ZX19byh0KX07ZXhwb3J0e0lvbmljU2xpZGVzLElvbmljU3dpcGVyLGdldE1vZGUsc2V0dXBDb25maWd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3774\n')},882:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ isPlatform),\n/* harmony export */   "b": () => (/* binding */ getIonMode),\n/* harmony export */   "c": () => (/* binding */ config),\n/* harmony export */   "g": () => (/* binding */ getPlatforms),\n/* harmony export */   "i": () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar Config=function(){function e(){this.m=new Map}e.prototype.reset=function(e){this.m=new Map(Object.entries(e))};e.prototype.get=function(e,t){var n=this.m.get(e);return n!==undefined?n:t};e.prototype.getBoolean=function(e,t){if(t===void 0){t=false}var n=this.m.get(e);if(n===undefined){return t}if(typeof n==="string"){return n==="true"}return!!n};e.prototype.getNumber=function(e,t){var n=parseFloat(this.m.get(e));return isNaN(n)?t!==undefined?t:NaN:n};e.prototype.set=function(e,t){this.m.set(e,t)};return e}();var config=new Config;var configFromSession=function(e){try{var t=e.sessionStorage.getItem(IONIC_SESSION_KEY);return t!==null?JSON.parse(t):{}}catch(e){return{}}};var saveConfig=function(e,t){try{e.sessionStorage.setItem(IONIC_SESSION_KEY,JSON.stringify(t))}catch(e){return}};var configFromURL=function(e){var t={};e.location.search.slice(1).split("&").map((function(e){return e.split("=")})).map((function(e){var t=e[0],n=e[1];return[decodeURIComponent(t),decodeURIComponent(n)]})).filter((function(e){var t=e[0];return startsWith(t,IONIC_PREFIX)})).map((function(e){var t=e[0],n=e[1];return[t.slice(IONIC_PREFIX.length),n]})).forEach((function(e){var n=e[0],i=e[1];t[n]=i}));return t};var startsWith=function(e,t){return e.substr(0,t.length)===t};var IONIC_PREFIX="ionic:";var IONIC_SESSION_KEY="ionic-persist-config";var getPlatforms=function(e){return setupPlatforms(e)};var isPlatform=function(e,t){if(typeof e==="string"){t=e;e=undefined}return getPlatforms(e).includes(t)};var setupPlatforms=function(e){if(e===void 0){e=window}if(typeof e==="undefined"){return[]}e.Ionic=e.Ionic||{};var t=e.Ionic.platforms;if(t==null){t=e.Ionic.platforms=detectPlatforms(e);t.forEach((function(t){return e.document.documentElement.classList.add("plt-".concat(t))}))}return t};var detectPlatforms=function(e){var t=config.get("platform");return Object.keys(PLATFORMS_MAP).filter((function(n){var i=t&&t[n];return typeof i==="function"?i(e):PLATFORMS_MAP[n](e)}))};var isMobileWeb=function(e){return isMobile(e)&&!isHybrid(e)};var isIpad=function(e){if(testUserAgent(e,/iPad/i)){return true}if(testUserAgent(e,/Macintosh/i)&&isMobile(e)){return true}return false};var isIphone=function(e){return testUserAgent(e,/iPhone/i)};var isIOS=function(e){return testUserAgent(e,/iPhone|iPod/i)||isIpad(e)};var isAndroid=function(e){return testUserAgent(e,/android|sink/i)};var isAndroidTablet=function(e){return isAndroid(e)&&!testUserAgent(e,/mobile/i)};var isPhablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return i>390&&i<520&&(r>620&&r<800)};var isTablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return isIpad(e)||isAndroidTablet(e)||i>460&&i<820&&(r>780&&r<1400)};var isMobile=function(e){return matchMedia(e,"(any-pointer:coarse)")};var isDesktop=function(e){return!isMobile(e)};var isHybrid=function(e){return isCordova(e)||isCapacitorNative(e)};var isCordova=function(e){return!!(e["cordova"]||e["phonegap"]||e["PhoneGap"])};var isCapacitorNative=function(e){var t=e["Capacitor"];return!!(t&&t.isNative)};var isElectron=function(e){return testUserAgent(e,/electron/i)};var isPWA=function(e){return!!(e.matchMedia&&e.matchMedia("(display-mode: standalone)").matches||e.navigator.standalone)};var testUserAgent=function(e,t){return t.test(e.navigator.userAgent)};var matchMedia=function(e,t){return e.matchMedia&&e.matchMedia(t).matches};var PLATFORMS_MAP={ipad:isIpad,iphone:isIphone,ios:isIOS,android:isAndroid,phablet:isPhablet,tablet:isTablet,cordova:isCordova,capacitor:isCapacitorNative,electron:isElectron,pwa:isPWA,mobile:isMobile,mobileweb:isMobileWeb,desktop:isDesktop,hybrid:isHybrid};var defaultMode;var getIonMode=function(e){return e&&(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.g)(e)||defaultMode};var initialize=function(e){if(e===void 0){e={}}if(typeof window==="undefined"){return}var t=window.document;var n=window;var i=n.Ionic=n.Ionic||{};var r={};if(e._ael){r.ael=e._ael}if(e._rel){r.rel=e._rel}if(e._ce){r.ce=e._ce}(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.s)(r);var o=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},configFromSession(n)),{persistConfig:false}),i.config),configFromURL(n)),e);config.reset(o);if(config.getBoolean("persistConfig")){saveConfig(n,o)}setupPlatforms(n);i.config=config;i.mode=defaultMode=config.get("mode",t.documentElement.getAttribute("mode")||(isPlatform(n,"ios")?"ios":"md"));config.set("mode",defaultMode);t.documentElement.setAttribute("mode",defaultMode);t.documentElement.classList.add(defaultMode);if(config.getBoolean("_testing")){config.set("animated",false)}var a=function(e){return e.tagName&&e.tagName.startsWith("ION-")};var s=function(e){return["ios","md"].includes(e)};(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.a)((function(e){while(e){var t=e.mode||e.getAttribute("mode");if(t){if(s(t)){return t}else if(a(e)){console.warn(\'Invalid ionic mode: "\'+t+\'", expected: "ios" or "md"\')}}e=e.parentElement}return defaultMode}))};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNtRixzQkFBc0IsYUFBYSxlQUFlLDhCQUE4QixtQ0FBbUMsOEJBQThCLG9CQUFvQiwwQkFBMEIscUNBQXFDLGVBQWUsUUFBUSxvQkFBb0Isa0JBQWtCLFNBQVMsd0JBQXdCLGtCQUFrQixXQUFXLG9DQUFvQyxnQ0FBZ0MsdUNBQXVDLDhCQUE4QixpQkFBaUIsU0FBUyxHQUFHLHNCQUFzQixrQ0FBa0MsSUFBSSxrREFBa0QsaUNBQWlDLFNBQVMsV0FBVyw2QkFBNkIsSUFBSSw4REFBOEQsU0FBUyxTQUFTLDhCQUE4QixTQUFTLHVEQUF1RCxvQkFBb0Isb0JBQW9CLGtCQUFrQixvREFBb0QsdUJBQXVCLFdBQVcsa0NBQWtDLG9CQUFvQixrQkFBa0IsdUNBQXVDLHdCQUF3QixrQkFBa0IsT0FBTyxHQUFHLFVBQVUsNkJBQTZCLGlDQUFpQywwQkFBMEIsNkNBQTZDLDZCQUE2QiwwQkFBMEIsNkJBQTZCLHdCQUF3QixJQUFJLFlBQVksb0NBQW9DLCtCQUErQixlQUFlLFNBQVMsMkJBQTJCLFNBQVMsb0JBQW9CLHdCQUF3QixZQUFZLHVDQUF1Qyx1QkFBdUIsa0VBQWtFLEdBQUcsVUFBVSxnQ0FBZ0MsNkJBQTZCLHNEQUFzRCxjQUFjLHNEQUFzRCxJQUFJLDRCQUE0QixrQ0FBa0MsdUJBQXVCLDZCQUE2QixZQUFZLCtDQUErQyxZQUFZLGNBQWMseUJBQXlCLG1DQUFtQyxzQkFBc0IsbURBQW1ELDBCQUEwQix5Q0FBeUMsZ0NBQWdDLGtEQUFrRCwwQkFBMEIsbUJBQW1CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHFDQUFxQyx5QkFBeUIsbUJBQW1CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHFFQUFxRSx5QkFBeUIsNkNBQTZDLDBCQUEwQixvQkFBb0IseUJBQXlCLDJDQUEyQywwQkFBMEIsc0RBQXNELGtDQUFrQyxxQkFBcUIseUJBQXlCLDJCQUEyQixxQ0FBcUMsc0JBQXNCLG9HQUFvRyxnQ0FBZ0Msc0NBQXNDLDZCQUE2Qiw4Q0FBOEMsbUJBQW1CLCtPQUErTyxnQkFBZ0IsMkJBQTJCLFVBQVUscURBQU8sa0JBQWtCLDJCQUEyQixlQUFlLEtBQUssZ0NBQWdDLE9BQU8sc0JBQXNCLGFBQWEsMEJBQTBCLFNBQVMsV0FBVyxhQUFhLFdBQVcsYUFBYSxVQUFVLFdBQVcscURBQWtCLElBQUksOEVBQThFLHdCQUF3QixvQkFBb0IsaUNBQWlDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsK0dBQStHLCtCQUErQixtREFBbUQsNkNBQTZDLGtDQUFrQyw2QkFBNkIsa0JBQWtCLGdEQUFnRCxrQkFBa0IsZ0NBQWdDLHFEQUFPLGNBQWMsU0FBUyxxQ0FBcUMsTUFBTSxTQUFTLFNBQVMsY0FBYyxzRUFBc0Usa0JBQWtCLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2lvbmljLWdsb2JhbC0wZWJlMzIxYy5qcz9hM2IzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnR7cyBhcyBzZXRQbGF0Zm9ybUhlbHBlcnMsZyBhcyBnZXRNb2RlLGEgYXMgc2V0TW9kZX1mcm9tXCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7dmFyIENvbmZpZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLm09bmV3IE1hcH1lLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbihlKXt0aGlzLm09bmV3IE1hcChPYmplY3QuZW50cmllcyhlKSl9O2UucHJvdG90eXBlLmdldD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubS5nZXQoZSk7cmV0dXJuIG4hPT11bmRlZmluZWQ/bjp0fTtlLnByb3RvdHlwZS5nZXRCb29sZWFuPWZ1bmN0aW9uKGUsdCl7aWYodD09PXZvaWQgMCl7dD1mYWxzZX12YXIgbj10aGlzLm0uZ2V0KGUpO2lmKG49PT11bmRlZmluZWQpe3JldHVybiB0fWlmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7cmV0dXJuIG49PT1cInRydWVcIn1yZXR1cm4hIW59O2UucHJvdG90eXBlLmdldE51bWJlcj1mdW5jdGlvbihlLHQpe3ZhciBuPXBhcnNlRmxvYXQodGhpcy5tLmdldChlKSk7cmV0dXJuIGlzTmFOKG4pP3QhPT11bmRlZmluZWQ/dDpOYU46bn07ZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUsdCl7dGhpcy5tLnNldChlLHQpfTtyZXR1cm4gZX0oKTt2YXIgY29uZmlnPW5ldyBDb25maWc7dmFyIGNvbmZpZ0Zyb21TZXNzaW9uPWZ1bmN0aW9uKGUpe3RyeXt2YXIgdD1lLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oSU9OSUNfU0VTU0lPTl9LRVkpO3JldHVybiB0IT09bnVsbD9KU09OLnBhcnNlKHQpOnt9fWNhdGNoKGUpe3JldHVybnt9fX07dmFyIHNhdmVDb25maWc9ZnVuY3Rpb24oZSx0KXt0cnl7ZS5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKElPTklDX1NFU1NJT05fS0VZLEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaChlKXtyZXR1cm59fTt2YXIgY29uZmlnRnJvbVVSTD1mdW5jdGlvbihlKXt2YXIgdD17fTtlLmxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdChcIiZcIikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIj1cIil9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXTtyZXR1cm5bZGVjb2RlVVJJQ29tcG9uZW50KHQpLGRlY29kZVVSSUNvbXBvbmVudChuKV19KSkuZmlsdGVyKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdO3JldHVybiBzdGFydHNXaXRoKHQsSU9OSUNfUFJFRklYKX0pKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVyblt0LnNsaWNlKElPTklDX1BSRUZJWC5sZW5ndGgpLG5dfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0saT1lWzFdO3Rbbl09aX0pKTtyZXR1cm4gdH07dmFyIHN0YXJ0c1dpdGg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zdWJzdHIoMCx0Lmxlbmd0aCk9PT10fTt2YXIgSU9OSUNfUFJFRklYPVwiaW9uaWM6XCI7dmFyIElPTklDX1NFU1NJT05fS0VZPVwiaW9uaWMtcGVyc2lzdC1jb25maWdcIjt2YXIgZ2V0UGxhdGZvcm1zPWZ1bmN0aW9uKGUpe3JldHVybiBzZXR1cFBsYXRmb3JtcyhlKX07dmFyIGlzUGxhdGZvcm09ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3Q9ZTtlPXVuZGVmaW5lZH1yZXR1cm4gZ2V0UGxhdGZvcm1zKGUpLmluY2x1ZGVzKHQpfTt2YXIgc2V0dXBQbGF0Zm9ybXM9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT13aW5kb3d9aWYodHlwZW9mIGU9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm5bXX1lLklvbmljPWUuSW9uaWN8fHt9O3ZhciB0PWUuSW9uaWMucGxhdGZvcm1zO2lmKHQ9PW51bGwpe3Q9ZS5Jb25pYy5wbGF0Zm9ybXM9ZGV0ZWN0UGxhdGZvcm1zKGUpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwbHQtXCIuY29uY2F0KHQpKX0pKX1yZXR1cm4gdH07dmFyIGRldGVjdFBsYXRmb3Jtcz1mdW5jdGlvbihlKXt2YXIgdD1jb25maWcuZ2V0KFwicGxhdGZvcm1cIik7cmV0dXJuIE9iamVjdC5rZXlzKFBMQVRGT1JNU19NQVApLmZpbHRlcigoZnVuY3Rpb24obil7dmFyIGk9dCYmdFtuXTtyZXR1cm4gdHlwZW9mIGk9PT1cImZ1bmN0aW9uXCI/aShlKTpQTEFURk9STVNfTUFQW25dKGUpfSkpfTt2YXIgaXNNb2JpbGVXZWI9ZnVuY3Rpb24oZSl7cmV0dXJuIGlzTW9iaWxlKGUpJiYhaXNIeWJyaWQoZSl9O3ZhciBpc0lwYWQ9ZnVuY3Rpb24oZSl7aWYodGVzdFVzZXJBZ2VudChlLC9pUGFkL2kpKXtyZXR1cm4gdHJ1ZX1pZih0ZXN0VXNlckFnZW50KGUsL01hY2ludG9zaC9pKSYmaXNNb2JpbGUoZSkpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dmFyIGlzSXBob25lPWZ1bmN0aW9uKGUpe3JldHVybiB0ZXN0VXNlckFnZW50KGUsL2lQaG9uZS9pKX07dmFyIGlzSU9TPWZ1bmN0aW9uKGUpe3JldHVybiB0ZXN0VXNlckFnZW50KGUsL2lQaG9uZXxpUG9kL2kpfHxpc0lwYWQoZSl9O3ZhciBpc0FuZHJvaWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvYW5kcm9pZHxzaW5rL2kpfTt2YXIgaXNBbmRyb2lkVGFibGV0PWZ1bmN0aW9uKGUpe3JldHVybiBpc0FuZHJvaWQoZSkmJiF0ZXN0VXNlckFnZW50KGUsL21vYmlsZS9pKX07dmFyIGlzUGhhYmxldD1mdW5jdGlvbihlKXt2YXIgdD1lLmlubmVyV2lkdGg7dmFyIG49ZS5pbm5lckhlaWdodDt2YXIgaT1NYXRoLm1pbih0LG4pO3ZhciByPU1hdGgubWF4KHQsbik7cmV0dXJuIGk+MzkwJiZpPDUyMCYmKHI+NjIwJiZyPDgwMCl9O3ZhciBpc1RhYmxldD1mdW5jdGlvbihlKXt2YXIgdD1lLmlubmVyV2lkdGg7dmFyIG49ZS5pbm5lckhlaWdodDt2YXIgaT1NYXRoLm1pbih0LG4pO3ZhciByPU1hdGgubWF4KHQsbik7cmV0dXJuIGlzSXBhZChlKXx8aXNBbmRyb2lkVGFibGV0KGUpfHxpPjQ2MCYmaTw4MjAmJihyPjc4MCYmcjwxNDAwKX07dmFyIGlzTW9iaWxlPWZ1bmN0aW9uKGUpe3JldHVybiBtYXRjaE1lZGlhKGUsXCIoYW55LXBvaW50ZXI6Y29hcnNlKVwiKX07dmFyIGlzRGVza3RvcD1mdW5jdGlvbihlKXtyZXR1cm4haXNNb2JpbGUoZSl9O3ZhciBpc0h5YnJpZD1mdW5jdGlvbihlKXtyZXR1cm4gaXNDb3Jkb3ZhKGUpfHxpc0NhcGFjaXRvck5hdGl2ZShlKX07dmFyIGlzQ29yZG92YT1mdW5jdGlvbihlKXtyZXR1cm4hIShlW1wiY29yZG92YVwiXXx8ZVtcInBob25lZ2FwXCJdfHxlW1wiUGhvbmVHYXBcIl0pfTt2YXIgaXNDYXBhY2l0b3JOYXRpdmU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVtcIkNhcGFjaXRvclwiXTtyZXR1cm4hISh0JiZ0LmlzTmF0aXZlKX07dmFyIGlzRWxlY3Ryb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvZWxlY3Ryb24vaSl9O3ZhciBpc1BXQT1mdW5jdGlvbihlKXtyZXR1cm4hIShlLm1hdGNoTWVkaWEmJmUubWF0Y2hNZWRpYShcIihkaXNwbGF5LW1vZGU6IHN0YW5kYWxvbmUpXCIpLm1hdGNoZXN8fGUubmF2aWdhdG9yLnN0YW5kYWxvbmUpfTt2YXIgdGVzdFVzZXJBZ2VudD1mdW5jdGlvbihlLHQpe3JldHVybiB0LnRlc3QoZS5uYXZpZ2F0b3IudXNlckFnZW50KX07dmFyIG1hdGNoTWVkaWE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXRjaE1lZGlhJiZlLm1hdGNoTWVkaWEodCkubWF0Y2hlc307dmFyIFBMQVRGT1JNU19NQVA9e2lwYWQ6aXNJcGFkLGlwaG9uZTppc0lwaG9uZSxpb3M6aXNJT1MsYW5kcm9pZDppc0FuZHJvaWQscGhhYmxldDppc1BoYWJsZXQsdGFibGV0OmlzVGFibGV0LGNvcmRvdmE6aXNDb3Jkb3ZhLGNhcGFjaXRvcjppc0NhcGFjaXRvck5hdGl2ZSxlbGVjdHJvbjppc0VsZWN0cm9uLHB3YTppc1BXQSxtb2JpbGU6aXNNb2JpbGUsbW9iaWxld2ViOmlzTW9iaWxlV2ViLGRlc2t0b3A6aXNEZXNrdG9wLGh5YnJpZDppc0h5YnJpZH07dmFyIGRlZmF1bHRNb2RlO3ZhciBnZXRJb25Nb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZnZXRNb2RlKGUpfHxkZWZhdWx0TW9kZX07dmFyIGluaXRpYWxpemU9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT17fX1pZih0eXBlb2Ygd2luZG93PT09XCJ1bmRlZmluZWRcIil7cmV0dXJufXZhciB0PXdpbmRvdy5kb2N1bWVudDt2YXIgbj13aW5kb3c7dmFyIGk9bi5Jb25pYz1uLklvbmljfHx7fTt2YXIgcj17fTtpZihlLl9hZWwpe3IuYWVsPWUuX2FlbH1pZihlLl9yZWwpe3IucmVsPWUuX3JlbH1pZihlLl9jZSl7ci5jZT1lLl9jZX1zZXRQbGF0Zm9ybUhlbHBlcnMocik7dmFyIG89T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGNvbmZpZ0Zyb21TZXNzaW9uKG4pKSx7cGVyc2lzdENvbmZpZzpmYWxzZX0pLGkuY29uZmlnKSxjb25maWdGcm9tVVJMKG4pKSxlKTtjb25maWcucmVzZXQobyk7aWYoY29uZmlnLmdldEJvb2xlYW4oXCJwZXJzaXN0Q29uZmlnXCIpKXtzYXZlQ29uZmlnKG4sbyl9c2V0dXBQbGF0Zm9ybXMobik7aS5jb25maWc9Y29uZmlnO2kubW9kZT1kZWZhdWx0TW9kZT1jb25maWcuZ2V0KFwibW9kZVwiLHQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcIm1vZGVcIil8fChpc1BsYXRmb3JtKG4sXCJpb3NcIik/XCJpb3NcIjpcIm1kXCIpKTtjb25maWcuc2V0KFwibW9kZVwiLGRlZmF1bHRNb2RlKTt0LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtb2RlXCIsZGVmYXVsdE1vZGUpO3QuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmYXVsdE1vZGUpO2lmKGNvbmZpZy5nZXRCb29sZWFuKFwiX3Rlc3RpbmdcIikpe2NvbmZpZy5zZXQoXCJhbmltYXRlZFwiLGZhbHNlKX12YXIgYT1mdW5jdGlvbihlKXtyZXR1cm4gZS50YWdOYW1lJiZlLnRhZ05hbWUuc3RhcnRzV2l0aChcIklPTi1cIil9O3ZhciBzPWZ1bmN0aW9uKGUpe3JldHVybltcImlvc1wiLFwibWRcIl0uaW5jbHVkZXMoZSl9O3NldE1vZGUoKGZ1bmN0aW9uKGUpe3doaWxlKGUpe3ZhciB0PWUubW9kZXx8ZS5nZXRBdHRyaWJ1dGUoXCJtb2RlXCIpO2lmKHQpe2lmKHModCkpe3JldHVybiB0fWVsc2UgaWYoYShlKSl7Y29uc29sZS53YXJuKCdJbnZhbGlkIGlvbmljIG1vZGU6IFwiJyt0KydcIiwgZXhwZWN0ZWQ6IFwiaW9zXCIgb3IgXCJtZFwiJyl9fWU9ZS5wYXJlbnRFbGVtZW50fXJldHVybiBkZWZhdWx0TW9kZX0pKX07ZXhwb3J0e2lzUGxhdGZvcm0gYXMgYSxnZXRJb25Nb2RlIGFzIGIsY29uZmlnIGFzIGMsZ2V0UGxhdGZvcm1zIGFzIGcsaW5pdGlhbGl6ZSBhcyBpfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///882\n')},8360:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "iosTransitionAnimation": () => (/* binding */ iosTransitionAnimation),\n/* harmony export */   "shadow": () => (/* binding */ shadow)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar DURATION=540;var getClonedElement=function(t){return document.querySelector("".concat(t,".ion-cloned-element"))};var shadow=function(t){return t.shadowRoot||t};var getLargeTitle=function(t){var e=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var a="ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large";if(e!=null){var o=e.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");return o!=null?o.querySelector(a):null}return t.querySelector(a)};var getBackButton=function(t,e){var a=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var o=[];if(a!=null){var r=a.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");if(r!=null){o=r.querySelectorAll("ion-buttons")}}else{o=t.querySelectorAll("ion-buttons")}for(var n=0,i=o;n<i.length;n++){var l=i[n];var c=l.closest("ion-header");var s=c&&!c.classList.contains("header-collapse-condense-inactive");var f=l.querySelector("ion-back-button");var d=l.classList.contains("buttons-collapse");var m=l.slot==="start"||l.slot==="";if(f!==null&&m&&(d&&s&&e||!d)){return f}}return null};var createLargeTitleTransition=function(t,e,a,o,r){var n=getBackButton(o,a);var i=getLargeTitle(r);var l=getLargeTitle(o);var c=getBackButton(r,a);var s=n!==null&&i!==null&&!a;var f=l!==null&&c!==null&&a;if(s){var d=i.getBoundingClientRect();var m=n.getBoundingClientRect();animateLargeTitle(t,e,a,i,d,m);animateBackButton(t,e,a,n,d,m)}else if(f){var v=l.getBoundingClientRect();var p=c.getBoundingClientRect();animateLargeTitle(t,e,a,l,v,p);animateBackButton(t,e,a,c,v,p)}return{forward:s,backward:f}};var animateBackButton=function(t,e,a,o,r,n){var i=e?"calc(100% - ".concat(n.right+4,"px)"):"".concat(n.left-4,"px");var l=e?"7px":"-7px";var c=e?"-4px":"4px";var s=e?"-4px":"4px";var f=e?"right":"left";var d=e?"left":"right";var m=[{offset:0,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")},{offset:1,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")}];var v=[{offset:0,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")}];var p=a?v:m;var y=[{offset:0,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")}];var u=[{offset:0,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.2,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")}];var b=a?u:y;var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var S=getClonedElement("ion-back-button");var T=shadow(S).querySelector(".button-text");var h=shadow(S).querySelector("ion-icon");S.text=o.text;S.mode=o.mode;S.icon=o.icon;S.color=o.color;S.disabled=o.disabled;S.style.setProperty("display","block");S.style.setProperty("position","fixed");A.addElement(h);g.addElement(T);g.beforeStyles({"transform-origin":"".concat(f," center")}).beforeAddWrite((function(){o.style.setProperty("display","none");S.style.setProperty(f,i)})).afterAddWrite((function(){o.style.setProperty("display","");S.style.setProperty("display","none");S.style.removeProperty(f)})).keyframes(p);A.beforeStyles({"transform-origin":"".concat(d," center")}).keyframes(b);t.addAnimation([g,A])};var animateLargeTitle=function(t,e,a,o,r,n){var i;var l=e?"calc(100% - ".concat(r.right,"px)"):"".concat(r.left,"px");var c=e?"-18px":"18px";var s=e?"right":"left";var f=[{offset:0,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.49)")},{offset:.1,opacity:0},{offset:1,opacity:1,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")}];var d=[{offset:0,opacity:.99,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.5)")}];var m=a?f:d;var v=getClonedElement("ion-title");var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();v.innerText=o.innerText;v.size=o.size;v.color=o.color;p.addElement(v);p.beforeStyles((i={"transform-origin":"".concat(s," center"),height:"46px",display:"",position:"relative"},i[s]=l,i)).beforeAddWrite((function(){o.style.setProperty("display","none")})).afterAddWrite((function(){o.style.setProperty("display","");v.style.setProperty("display","none")})).keyframes(m);t.addAnimation(p)};var iosTransitionAnimation=function(t,e){try{var a="cubic-bezier(0.32,0.72,0,1)";var o="opacity";var r="transform";var n="0%";var i=.8;var l=t.ownerDocument.dir==="rtl";var c=l?"-99.5%":"99.5%";var s=l?"33%":"-33%";var f=e.enteringEl;var d=e.leavingEl;var m=e.direction==="back";var v=f.querySelector(":scope > ion-content");var p=f.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");var y=f.querySelectorAll(":scope > ion-header > ion-toolbar");var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();u.addElement(f).duration(e.duration||DURATION).easing(e.easing||a).fill("both").beforeRemoveClass("ion-page-invisible");if(d&&t){var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();g.addElement(t);u.addAnimation(g)}if(!v&&y.length===0&&p.length===0){b.addElement(f.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{b.addElement(v);b.addElement(p)}u.addAnimation(b);if(m){b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,i,1)}else{b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"))}if(v){var A=shadow(v).querySelector(".transition-effect");if(A){var S=A.querySelector(".transition-cover");var T=A.querySelector(".transition-shadow");var h=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var x=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var E=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();h.addElement(A).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});x.addElement(S).beforeClearStyles([o]).fromTo(o,0,.1);E.addElement(T).beforeClearStyles([o]).fromTo(o,.03,.7);h.addAnimation([x,E]);b.addAnimation([h])}}var q=f.querySelector("ion-header.header-collapse-condense");var X=createLargeTitleTransition(u,l,m,f,d),C=X.forward,k=X.backward;y.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);u.addAnimation(e);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var r=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var i=Array.from(t.querySelectorAll("ion-buttons,[menuToggle]"));var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v;if(m){v=i.filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}))}else{v=i.filter((function(t){return!t.classList.contains("buttons-collapse")}))}r.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();p.addElement(t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"));var y=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();y.addElement(shadow(t).querySelector(".toolbar-background"));var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var g=t.querySelector("ion-back-button");if(g){b.addElement(g)}e.addAnimation([a,r,p,y,b]);r.fromTo(o,.01,1);p.fromTo(o,.01,1);if(m){if(!d){a.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")"));b.fromTo(o,.01,1)}else{if(!q){a.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"));y.beforeClearStyles([o,"transform"]);var A=f===null||f===void 0?void 0:f.translucent;if(!A){y.fromTo(o,.01,"var(--opacity)")}else{y.fromTo("transform",l?"translateX(-100%)":"translateX(100%)","translateX(0px)")}if(!C){b.fromTo(o,.01,1)}if(g&&!C){var S=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();S.addElement(shadow(g).querySelector(".button-text")).fromTo("transform",l?"translateX(-100px)":"translateX(100px)","translateX(0px)");e.addAnimation(S)}}}));if(d){var w=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var B=d.querySelector(":scope > ion-content");var L=d.querySelectorAll(":scope > ion-header > ion-toolbar");var P=d.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");if(!B&&L.length===0&&P.length===0){w.addElement(d.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{w.addElement(B);w.addElement(P)}u.addAnimation(w);if(m){w.beforeClearStyles([o]).fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");var R=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(d);u.afterAddWrite((function(){if(u.getDirection()==="normal"){R.style.setProperty("display","none")}}))}else{w.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,1,i)}if(B){var I=shadow(B).querySelector(".transition-effect");if(I){var N=I.querySelector(".transition-cover");var W=I.querySelector(".transition-shadow");var j=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var D=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var O=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();j.addElement(I).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});D.addElement(N).beforeClearStyles([o]).fromTo(o,.1,0);O.addElement(W).beforeClearStyles([o]).fromTo(o,.7,.03);j.addAnimation([D,O]);w.addAnimation([j])}}L.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var c=t.querySelectorAll("ion-buttons,[menuToggle]");var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v=Array.from(c).filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}));i.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var y=t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])");if(y.length>0){p.addElement(y)}var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();b.addElement(shadow(t).querySelector(".toolbar-background"));var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=t.querySelector("ion-back-button");if(A){g.addElement(A)}e.addAnimation([a,i,p,g,b]);u.addAnimation(e);g.fromTo(o,.99,0);i.fromTo(o,.99,0);p.fromTo(o,.99,0);if(m){if(!d){a.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)").fromTo(o,.99,0)}p.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");b.beforeClearStyles([o,"transform"]);var S=f===null||f===void 0?void 0:f.translucent;if(!S){b.fromTo(o,"var(--opacity)",0)}else{b.fromTo("transform","translateX(0px)",l?"translateX(-100%)":"translateX(100%)")}if(A&&!k){var T=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();T.addElement(shadow(A).querySelector(".button-text")).fromTo("transform","translateX(".concat(n,")"),"translateX(".concat((l?-124:124)+"px",")"));e.addAnimation(T)}}else{if(!d){a.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,.99,0).afterClearStyles([r,o])}p.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).afterClearStyles([r,o]);g.afterClearStyles([o]);a.afterClearStyles([o]);i.afterClearStyles([o])}}))}return u}catch(t){throw t}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU8sa0JBQWtCLFVBQVUsTUFBTSx5REFBZSxHQUFHLHVJQUF1SSxvQkFBb0IsR0FBRyxNQUFNLE1BQU0seURBQWUsR0FBRyw4Q0FBOEMsOERBQThELDhGQUE4RixtQ0FBbUMseUZBQXlGLEtBQUssZ0JBQWdCLGdCQUFnQixrQkFBa0IsTUFBTSxrSEFBa0gsTUFBTSxxREFBaUIsSUFBSSw0QkFBNEIsZ0NBQWdDLHVDQUF1QyxHQUFHLEtBQUssNEZBQTRGLE1BQU0sb0RBQW9ELE1BQU0sMkNBQTJDLDRDQUE0QyxNQUFNLHlEQUFlLEdBQUcsTUFBTSx5REFBZSxHQUFHLE1BQU0seURBQWUsR0FBRyw4QkFBOEIsNEJBQTRCLGVBQWUsc0JBQXNCLEVBQUUsc0RBQXNELHdEQUF3RCxzQkFBc0IscUJBQXFCLHVCQUF1QixNQUFNLHlEQUFlLEdBQUcsZ0JBQWdCLE1BQU0seURBQWUsR0FBRywyQ0FBMkMsTUFBTSx5REFBZSxHQUFHLHFEQUFxRCw4QkFBOEIsbUVBQW1FLHdDQUF3QywrQ0FBK0MsaUJBQWlCLEdBQUcsZ0JBQWdCLE1BQU0seURBQWUsR0FBRyx5RkFBeUYsZUFBZSxnQkFBZ0IsTUFBTSx5REFBZSxHQUFHLDZEQUE2RCxNQUFNLHlEQUFlLEdBQUcseUNBQXlDLE1BQU0sZ0JBQWdCLDRCQUE0QixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0IsTUFBTSxPQUFPLDJHQUEyRywyRkFBMkYscUNBQXFDLGdEQUFnRCxPQUFPLCtCQUErQixLQUFLLGlGQUFpRixVQUFVLE1BQU0seURBQWUsR0FBRyxrSkFBa0osbUJBQW1CLEtBQUssT0FBTyxzSEFBc0gsc0dBQXNHLHdCQUF3Qix3QkFBd0IseUJBQXlCLEdBQUcsU0FBUyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW9zLnRyYW5zaXRpb24tOGI2YTc3NmEuanM/M2I5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7aW1wb3J0e2cgYXMgZ2V0SW9uUGFnZUVsZW1lbnR9ZnJvbVwiLi9pbmRleC1lNmMyYzgyMi5qc1wiO2ltcG9ydFwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7aW1wb3J0XCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7dmFyIERVUkFUSU9OPTU0MDt2YXIgZ2V0Q2xvbmVkRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIlwiLmNvbmNhdCh0LFwiLmlvbi1jbG9uZWQtZWxlbWVudFwiKSl9O3ZhciBzaGFkb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhZG93Um9vdHx8dH07dmFyIGdldExhcmdlVGl0bGU9ZnVuY3Rpb24odCl7dmFyIGU9dC50YWdOYW1lPT09XCJJT04tVEFCU1wiP3Q6dC5xdWVyeVNlbGVjdG9yKFwiaW9uLXRhYnNcIik7dmFyIGE9XCJpb24tY29udGVudCBpb24taGVhZGVyOm5vdCguaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlKSBpb24tdGl0bGUudGl0bGUtbGFyZ2VcIjtpZihlIT1udWxsKXt2YXIgbz1lLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFiOm5vdCgudGFiLWhpZGRlbiksIC5pb24tcGFnZTpub3QoLmlvbi1wYWdlLWhpZGRlbilcIik7cmV0dXJuIG8hPW51bGw/by5xdWVyeVNlbGVjdG9yKGEpOm51bGx9cmV0dXJuIHQucXVlcnlTZWxlY3RvcihhKX07dmFyIGdldEJhY2tCdXR0b249ZnVuY3Rpb24odCxlKXt2YXIgYT10LnRhZ05hbWU9PT1cIklPTi1UQUJTXCI/dDp0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFic1wiKTt2YXIgbz1bXTtpZihhIT1udWxsKXt2YXIgcj1hLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFiOm5vdCgudGFiLWhpZGRlbiksIC5pb24tcGFnZTpub3QoLmlvbi1wYWdlLWhpZGRlbilcIik7aWYociE9bnVsbCl7bz1yLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tYnV0dG9uc1wiKX19ZWxzZXtvPXQucXVlcnlTZWxlY3RvckFsbChcImlvbi1idXR0b25zXCIpfWZvcih2YXIgbj0wLGk9bztuPGkubGVuZ3RoO24rKyl7dmFyIGw9aVtuXTt2YXIgYz1sLmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBzPWMmJiFjLmNsYXNzTGlzdC5jb250YWlucyhcImhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZVwiKTt2YXIgZj1sLnF1ZXJ5U2VsZWN0b3IoXCJpb24tYmFjay1idXR0b25cIik7dmFyIGQ9bC5jbGFzc0xpc3QuY29udGFpbnMoXCJidXR0b25zLWNvbGxhcHNlXCIpO3ZhciBtPWwuc2xvdD09PVwic3RhcnRcInx8bC5zbG90PT09XCJcIjtpZihmIT09bnVsbCYmbSYmKGQmJnMmJmV8fCFkKSl7cmV0dXJuIGZ9fXJldHVybiBudWxsfTt2YXIgY3JlYXRlTGFyZ2VUaXRsZVRyYW5zaXRpb249ZnVuY3Rpb24odCxlLGEsbyxyKXt2YXIgbj1nZXRCYWNrQnV0dG9uKG8sYSk7dmFyIGk9Z2V0TGFyZ2VUaXRsZShyKTt2YXIgbD1nZXRMYXJnZVRpdGxlKG8pO3ZhciBjPWdldEJhY2tCdXR0b24ocixhKTt2YXIgcz1uIT09bnVsbCYmaSE9PW51bGwmJiFhO3ZhciBmPWwhPT1udWxsJiZjIT09bnVsbCYmYTtpZihzKXt2YXIgZD1pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBtPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7YW5pbWF0ZUxhcmdlVGl0bGUodCxlLGEsaSxkLG0pO2FuaW1hdGVCYWNrQnV0dG9uKHQsZSxhLG4sZCxtKX1lbHNlIGlmKGYpe3ZhciB2PWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIHA9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTthbmltYXRlTGFyZ2VUaXRsZSh0LGUsYSxsLHYscCk7YW5pbWF0ZUJhY2tCdXR0b24odCxlLGEsYyx2LHApfXJldHVybntmb3J3YXJkOnMsYmFja3dhcmQ6Zn19O3ZhciBhbmltYXRlQmFja0J1dHRvbj1mdW5jdGlvbih0LGUsYSxvLHIsbil7dmFyIGk9ZT9cImNhbGMoMTAwJSAtIFwiLmNvbmNhdChuLnJpZ2h0KzQsXCJweClcIik6XCJcIi5jb25jYXQobi5sZWZ0LTQsXCJweFwiKTt2YXIgbD1lP1wiN3B4XCI6XCItN3B4XCI7dmFyIGM9ZT9cIi00cHhcIjpcIjRweFwiO3ZhciBzPWU/XCItNHB4XCI6XCI0cHhcIjt2YXIgZj1lP1wicmlnaHRcIjpcImxlZnRcIjt2YXIgZD1lP1wibGVmdFwiOlwicmlnaHRcIjt2YXIgbT1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQobCxcIiwgXCIpLmNvbmNhdChyLnRvcC00MCxcInB4LCAwKSBzY2FsZSgyLjEpXCIpfSx7b2Zmc2V0OjEsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChjLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfV07dmFyIHY9W3tvZmZzZXQ6MCxvcGFjaXR5OjEsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KGMsXCIsIFwiKS5jb25jYXQobi50b3AtNDYsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjYsb3BhY2l0eTowfSx7b2Zmc2V0OjEsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChsLFwiLCBcIikuY29uY2F0KHIudG9wLTQwLFwicHgsIDApIHNjYWxlKDIuMSlcIil9XTt2YXIgcD1hP3Y6bTt2YXIgeT1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQocyxcIiwgXCIpLmNvbmNhdChuLnRvcC00MSxcInB4LCAwKSBzY2FsZSgwLjYpXCIpfSx7b2Zmc2V0OjEsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfV07dmFyIHU9W3tvZmZzZXQ6MCxvcGFjaXR5OjEsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHMsXCIsIFwiKS5jb25jYXQobi50b3AtNDYsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjIsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQxLFwicHgsIDApIHNjYWxlKDAuNilcIil9LHtvZmZzZXQ6MSxvcGFjaXR5OjAsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHMsXCIsIFwiKS5jb25jYXQobi50b3AtNDEsXCJweCwgMCkgc2NhbGUoMC42KVwiKX1dO3ZhciBiPWE/dTp5O3ZhciBnPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBBPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBTPWdldENsb25lZEVsZW1lbnQoXCJpb24tYmFjay1idXR0b25cIik7dmFyIFQ9c2hhZG93KFMpLnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uLXRleHRcIik7dmFyIGg9c2hhZG93KFMpLnF1ZXJ5U2VsZWN0b3IoXCJpb24taWNvblwiKTtTLnRleHQ9by50ZXh0O1MubW9kZT1vLm1vZGU7Uy5pY29uPW8uaWNvbjtTLmNvbG9yPW8uY29sb3I7Uy5kaXNhYmxlZD1vLmRpc2FibGVkO1Muc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJibG9ja1wiKTtTLnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIixcImZpeGVkXCIpO0EuYWRkRWxlbWVudChoKTtnLmFkZEVsZW1lbnQoVCk7Zy5iZWZvcmVTdHlsZXMoe1widHJhbnNmb3JtLW9yaWdpblwiOlwiXCIuY29uY2F0KGYsXCIgY2VudGVyXCIpfSkuYmVmb3JlQWRkV3JpdGUoKGZ1bmN0aW9uKCl7by5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIik7Uy5zdHlsZS5zZXRQcm9wZXJ0eShmLGkpfSkpLmFmdGVyQWRkV3JpdGUoKGZ1bmN0aW9uKCl7by5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIlwiKTtTLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiKTtTLnN0eWxlLnJlbW92ZVByb3BlcnR5KGYpfSkpLmtleWZyYW1lcyhwKTtBLmJlZm9yZVN0eWxlcyh7XCJ0cmFuc2Zvcm0tb3JpZ2luXCI6XCJcIi5jb25jYXQoZCxcIiBjZW50ZXJcIil9KS5rZXlmcmFtZXMoYik7dC5hZGRBbmltYXRpb24oW2csQV0pfTt2YXIgYW5pbWF0ZUxhcmdlVGl0bGU9ZnVuY3Rpb24odCxlLGEsbyxyLG4pe3ZhciBpO3ZhciBsPWU/XCJjYWxjKDEwMCUgLSBcIi5jb25jYXQoci5yaWdodCxcInB4KVwiKTpcIlwiLmNvbmNhdChyLmxlZnQsXCJweFwiKTt2YXIgYz1lP1wiLTE4cHhcIjpcIjE4cHhcIjt2YXIgcz1lP1wicmlnaHRcIjpcImxlZnRcIjt2YXIgZj1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoYyxcIiwgXCIpLmNvbmNhdChuLnRvcC00LFwicHgsIDApIHNjYWxlKDAuNDkpXCIpfSx7b2Zmc2V0Oi4xLG9wYWNpdHk6MH0se29mZnNldDoxLG9wYWNpdHk6MSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZCgwLCBcIi5jb25jYXQoci50b3AtMixcInB4LCAwKSBzY2FsZSgxKVwiKX1dO3ZhciBkPVt7b2Zmc2V0OjAsb3BhY2l0eTouOTksdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoMCwgXCIuY29uY2F0KHIudG9wLTIsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjYsb3BhY2l0eTowfSx7b2Zmc2V0OjEsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChjLFwiLCBcIikuY29uY2F0KG4udG9wLTQsXCJweCwgMCkgc2NhbGUoMC41KVwiKX1dO3ZhciBtPWE/ZjpkO3ZhciB2PWdldENsb25lZEVsZW1lbnQoXCJpb24tdGl0bGVcIik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7di5pbm5lclRleHQ9by5pbm5lclRleHQ7di5zaXplPW8uc2l6ZTt2LmNvbG9yPW8uY29sb3I7cC5hZGRFbGVtZW50KHYpO3AuYmVmb3JlU3R5bGVzKChpPXtcInRyYW5zZm9ybS1vcmlnaW5cIjpcIlwiLmNvbmNhdChzLFwiIGNlbnRlclwiKSxoZWlnaHQ6XCI0NnB4XCIsZGlzcGxheTpcIlwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIn0saVtzXT1sLGkpKS5iZWZvcmVBZGRXcml0ZSgoZnVuY3Rpb24oKXtvLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiKX0pKS5hZnRlckFkZFdyaXRlKChmdW5jdGlvbigpe28uc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJcIik7di5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9KSkua2V5ZnJhbWVzKG0pO3QuYWRkQW5pbWF0aW9uKHApfTt2YXIgaW9zVHJhbnNpdGlvbkFuaW1hdGlvbj1mdW5jdGlvbih0LGUpe3RyeXt2YXIgYT1cImN1YmljLWJlemllcigwLjMyLDAuNzIsMCwxKVwiO3ZhciBvPVwib3BhY2l0eVwiO3ZhciByPVwidHJhbnNmb3JtXCI7dmFyIG49XCIwJVwiO3ZhciBpPS44O3ZhciBsPXQub3duZXJEb2N1bWVudC5kaXI9PT1cInJ0bFwiO3ZhciBjPWw/XCItOTkuNSVcIjpcIjk5LjUlXCI7dmFyIHM9bD9cIjMzJVwiOlwiLTMzJVwiO3ZhciBmPWUuZW50ZXJpbmdFbDt2YXIgZD1lLmxlYXZpbmdFbDt2YXIgbT1lLmRpcmVjdGlvbj09PVwiYmFja1wiO3ZhciB2PWYucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IGlvbi1jb250ZW50XCIpO3ZhciBwPWYucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiAqOm5vdChpb24tdG9vbGJhciksIDpzY29wZSA+IGlvbi1mb290ZXIgPiAqXCIpO3ZhciB5PWYucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiBpb24tdG9vbGJhclwiKTt2YXIgdT1jcmVhdGVBbmltYXRpb24oKTt2YXIgYj1jcmVhdGVBbmltYXRpb24oKTt1LmFkZEVsZW1lbnQoZikuZHVyYXRpb24oZS5kdXJhdGlvbnx8RFVSQVRJT04pLmVhc2luZyhlLmVhc2luZ3x8YSkuZmlsbChcImJvdGhcIikuYmVmb3JlUmVtb3ZlQ2xhc3MoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aWYoZCYmdCl7dmFyIGc9Y3JlYXRlQW5pbWF0aW9uKCk7Zy5hZGRFbGVtZW50KHQpO3UuYWRkQW5pbWF0aW9uKGcpfWlmKCF2JiZ5Lmxlbmd0aD09PTAmJnAubGVuZ3RoPT09MCl7Yi5hZGRFbGVtZW50KGYucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IC5pb24tcGFnZSwgOnNjb3BlID4gaW9uLW5hdiwgOnNjb3BlID4gaW9uLXRhYnNcIikpfWVsc2V7Yi5hZGRFbGVtZW50KHYpO2IuYWRkRWxlbWVudChwKX11LmFkZEFuaW1hdGlvbihiKTtpZihtKXtiLmJlZm9yZUNsZWFyU3R5bGVzKFtvXSkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obyxpLDEpfWVsc2V7Yi5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQoYyxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSl9aWYodil7dmFyIEE9c2hhZG93KHYpLnF1ZXJ5U2VsZWN0b3IoXCIudHJhbnNpdGlvbi1lZmZlY3RcIik7aWYoQSl7dmFyIFM9QS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tY292ZXJcIik7dmFyIFQ9QS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tc2hhZG93XCIpO3ZhciBoPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciB4PWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBFPWNyZWF0ZUFuaW1hdGlvbigpO2guYWRkRWxlbWVudChBKS5iZWZvcmVTdHlsZXMoe29wYWNpdHk6XCIxXCIsZGlzcGxheTpcImJsb2NrXCJ9KS5hZnRlclN0eWxlcyh7b3BhY2l0eTpcIlwiLGRpc3BsYXk6XCJcIn0pO3guYWRkRWxlbWVudChTKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLDAsLjEpO0UuYWRkRWxlbWVudChUKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC4wMywuNyk7aC5hZGRBbmltYXRpb24oW3gsRV0pO2IuYWRkQW5pbWF0aW9uKFtoXSl9fXZhciBxPWYucXVlcnlTZWxlY3RvcihcImlvbi1oZWFkZXIuaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlXCIpO3ZhciBYPWNyZWF0ZUxhcmdlVGl0bGVUcmFuc2l0aW9uKHUsbCxtLGYsZCksQz1YLmZvcndhcmQsaz1YLmJhY2t3YXJkO3kuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Y3JlYXRlQW5pbWF0aW9uKCk7ZS5hZGRFbGVtZW50KHQpO3UuYWRkQW5pbWF0aW9uKGUpO3ZhciBhPWNyZWF0ZUFuaW1hdGlvbigpO2EuYWRkRWxlbWVudCh0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGl0bGVcIikpO3ZhciByPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBpPUFycmF5LmZyb20odC5xdWVyeVNlbGVjdG9yQWxsKFwiaW9uLWJ1dHRvbnMsW21lbnVUb2dnbGVdXCIpKTt2YXIgZj10LmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBkPWYmJmYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlXCIpO3ZhciB2O2lmKG0pe3Y9aS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBlPXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYnV0dG9ucy1jb2xsYXBzZVwiKTtyZXR1cm4gZSYmIWR8fCFlfSkpfWVsc2V7dj1pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYnV0dG9ucy1jb2xsYXBzZVwiKX0pKX1yLmFkZEVsZW1lbnQodik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7cC5hZGRFbGVtZW50KHQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+ICo6bm90KGlvbi10aXRsZSk6bm90KGlvbi1idXR0b25zKTpub3QoW21lbnVUb2dnbGVdKVwiKSk7dmFyIHk9Y3JlYXRlQW5pbWF0aW9uKCk7eS5hZGRFbGVtZW50KHNoYWRvdyh0KS5xdWVyeVNlbGVjdG9yKFwiLnRvb2xiYXItYmFja2dyb3VuZFwiKSk7dmFyIGI9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIGc9dC5xdWVyeVNlbGVjdG9yKFwiaW9uLWJhY2stYnV0dG9uXCIpO2lmKGcpe2IuYWRkRWxlbWVudChnKX1lLmFkZEFuaW1hdGlvbihbYSxyLHAseSxiXSk7ci5mcm9tVG8obywuMDEsMSk7cC5mcm9tVG8obywuMDEsMSk7aWYobSl7aWYoIWQpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obywuMDEsMSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIikpO2IuZnJvbVRvKG8sLjAxLDEpfWVsc2V7aWYoIXEpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChjLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obywuMDEsMSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGMsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIikpO3kuYmVmb3JlQ2xlYXJTdHlsZXMoW28sXCJ0cmFuc2Zvcm1cIl0pO3ZhciBBPWY9PT1udWxsfHxmPT09dm9pZCAwP3ZvaWQgMDpmLnRyYW5zbHVjZW50O2lmKCFBKXt5LmZyb21UbyhvLC4wMSxcInZhcigtLW9wYWNpdHkpXCIpfWVsc2V7eS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixsP1widHJhbnNsYXRlWCgtMTAwJSlcIjpcInRyYW5zbGF0ZVgoMTAwJSlcIixcInRyYW5zbGF0ZVgoMHB4KVwiKX1pZighQyl7Yi5mcm9tVG8obywuMDEsMSl9aWYoZyYmIUMpe3ZhciBTPWNyZWF0ZUFuaW1hdGlvbigpO1MuYWRkRWxlbWVudChzaGFkb3coZykucXVlcnlTZWxlY3RvcihcIi5idXR0b24tdGV4dFwiKSkuZnJvbVRvKFwidHJhbnNmb3JtXCIsbD9cInRyYW5zbGF0ZVgoLTEwMHB4KVwiOlwidHJhbnNsYXRlWCgxMDBweClcIixcInRyYW5zbGF0ZVgoMHB4KVwiKTtlLmFkZEFuaW1hdGlvbihTKX19fSkpO2lmKGQpe3ZhciB3PWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBCPWQucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IGlvbi1jb250ZW50XCIpO3ZhciBMPWQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiBpb24tdG9vbGJhclwiKTt2YXIgUD1kLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBpb24taGVhZGVyID4gKjpub3QoaW9uLXRvb2xiYXIpLCA6c2NvcGUgPiBpb24tZm9vdGVyID4gKlwiKTtpZighQiYmTC5sZW5ndGg9PT0wJiZQLmxlbmd0aD09PTApe3cuYWRkRWxlbWVudChkLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiAuaW9uLXBhZ2UsIDpzY29wZSA+IGlvbi1uYXYsIDpzY29wZSA+IGlvbi10YWJzXCIpKX1lbHNle3cuYWRkRWxlbWVudChCKTt3LmFkZEVsZW1lbnQoUCl9dS5hZGRBbmltYXRpb24odyk7aWYobSl7dy5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIiksbD9cInRyYW5zbGF0ZVgoLTEwMCUpXCI6XCJ0cmFuc2xhdGVYKDEwMCUpXCIpO3ZhciBSPWdldElvblBhZ2VFbGVtZW50KGQpO3UuYWZ0ZXJBZGRXcml0ZSgoZnVuY3Rpb24oKXtpZih1LmdldERpcmVjdGlvbigpPT09XCJub3JtYWxcIil7Ui5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9fSkpfWVsc2V7dy5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIikpLmZyb21UbyhvLDEsaSl9aWYoQil7dmFyIEk9c2hhZG93KEIpLnF1ZXJ5U2VsZWN0b3IoXCIudHJhbnNpdGlvbi1lZmZlY3RcIik7aWYoSSl7dmFyIE49SS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tY292ZXJcIik7dmFyIFc9SS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tc2hhZG93XCIpO3ZhciBqPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBEPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBPPWNyZWF0ZUFuaW1hdGlvbigpO2ouYWRkRWxlbWVudChJKS5iZWZvcmVTdHlsZXMoe29wYWNpdHk6XCIxXCIsZGlzcGxheTpcImJsb2NrXCJ9KS5hZnRlclN0eWxlcyh7b3BhY2l0eTpcIlwiLGRpc3BsYXk6XCJcIn0pO0QuYWRkRWxlbWVudChOKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC4xLDApO08uYWRkRWxlbWVudChXKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC43LC4wMyk7ai5hZGRBbmltYXRpb24oW0QsT10pO3cuYWRkQW5pbWF0aW9uKFtqXSl9fUwuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Y3JlYXRlQW5pbWF0aW9uKCk7ZS5hZGRFbGVtZW50KHQpO3ZhciBhPWNyZWF0ZUFuaW1hdGlvbigpO2EuYWRkRWxlbWVudCh0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGl0bGVcIikpO3ZhciBpPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBjPXQucXVlcnlTZWxlY3RvckFsbChcImlvbi1idXR0b25zLFttZW51VG9nZ2xlXVwiKTt2YXIgZj10LmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBkPWYmJmYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlXCIpO3ZhciB2PUFycmF5LmZyb20oYykuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZT10LmNsYXNzTGlzdC5jb250YWlucyhcImJ1dHRvbnMtY29sbGFwc2VcIik7cmV0dXJuIGUmJiFkfHwhZX0pKTtpLmFkZEVsZW1lbnQodik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIHk9dC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gKjpub3QoaW9uLXRpdGxlKTpub3QoaW9uLWJ1dHRvbnMpOm5vdChbbWVudVRvZ2dsZV0pXCIpO2lmKHkubGVuZ3RoPjApe3AuYWRkRWxlbWVudCh5KX12YXIgYj1jcmVhdGVBbmltYXRpb24oKTtiLmFkZEVsZW1lbnQoc2hhZG93KHQpLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbGJhci1iYWNrZ3JvdW5kXCIpKTt2YXIgZz1jcmVhdGVBbmltYXRpb24oKTt2YXIgQT10LnF1ZXJ5U2VsZWN0b3IoXCJpb24tYmFjay1idXR0b25cIik7aWYoQSl7Zy5hZGRFbGVtZW50KEEpfWUuYWRkQW5pbWF0aW9uKFthLGkscCxnLGJdKTt1LmFkZEFuaW1hdGlvbihlKTtnLmZyb21UbyhvLC45OSwwKTtpLmZyb21UbyhvLC45OSwwKTtwLmZyb21UbyhvLC45OSwwKTtpZihtKXtpZighZCl7YS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKS5mcm9tVG8obywuOTksMCl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKTtiLmJlZm9yZUNsZWFyU3R5bGVzKFtvLFwidHJhbnNmb3JtXCJdKTt2YXIgUz1mPT09bnVsbHx8Zj09PXZvaWQgMD92b2lkIDA6Zi50cmFuc2x1Y2VudDtpZighUyl7Yi5mcm9tVG8obyxcInZhcigtLW9wYWNpdHkpXCIsMCl9ZWxzZXtiLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWCgwcHgpXCIsbD9cInRyYW5zbGF0ZVgoLTEwMCUpXCI6XCJ0cmFuc2xhdGVYKDEwMCUpXCIpfWlmKEEmJiFrKXt2YXIgVD1jcmVhdGVBbmltYXRpb24oKTtULmFkZEVsZW1lbnQoc2hhZG93KEEpLnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uLXRleHRcIikpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdCgobD8tMTI0OjEyNCkrXCJweFwiLFwiKVwiKSk7ZS5hZGRBbmltYXRpb24oVCl9fWVsc2V7aWYoIWQpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpKS5mcm9tVG8obywuOTksMCkuYWZ0ZXJDbGVhclN0eWxlcyhbcixvXSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIikpLmFmdGVyQ2xlYXJTdHlsZXMoW3Isb10pO2cuYWZ0ZXJDbGVhclN0eWxlcyhbb10pO2EuYWZ0ZXJDbGVhclN0eWxlcyhbb10pO2kuYWZ0ZXJDbGVhclN0eWxlcyhbb10pfX0pKX1yZXR1cm4gdX1jYXRjaCh0KXt0aHJvdyB0fX07ZXhwb3J0e2lvc1RyYW5zaXRpb25BbmltYXRpb24sc2hhZG93fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8360\n')},2782:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mdTransitionAnimation": () => (/* binding */ mdTransitionAnimation)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar mdTransitionAnimation=function(e,n){var a="40px";var t="0px";var i=n.direction==="back";var o=n.enteringEl;var r=n.leavingEl;var m=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(o);var c=m.querySelector("ion-toolbar");var s=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();s.addElement(m).fill("both").beforeRemoveClass("ion-page-invisible");if(i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)")}else{s.duration(n.duration||280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform","translateY(".concat(a,")"),"translateY(".concat(t,")")).fromTo("opacity",.01,1)}if(c){var l=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();l.addElement(c);s.addAnimation(l)}if(r&&i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)");var d=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();d.addElement((0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(r)).onFinish((function(e){if(e===1&&d.elements.length>0){d.elements[0].style.setProperty("display","none")}})).fromTo("transform","translateY(".concat(t,")"),"translateY(".concat(a,")")).fromTo("opacity",1,0);s.addAnimation(d)}return s};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzRLLHdDQUF3QyxhQUFhLFlBQVksMkJBQTJCLG1CQUFtQixrQkFBa0IsTUFBTSxxREFBaUIsSUFBSSxxQ0FBcUMsTUFBTSx5REFBZSxHQUFHLHFFQUFxRSxNQUFNLHVFQUF1RSxLQUFLLHlLQUF5SyxNQUFNLE1BQU0seURBQWUsR0FBRyxnQkFBZ0Isa0JBQWtCLFNBQVMsdUVBQXVFLE1BQU0seURBQWUsR0FBRyxhQUFhLHFEQUFpQiwyQkFBMkIsK0JBQStCLG1EQUFtRCxxR0FBcUcsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvbWQudHJhbnNpdGlvbi1kYTg2NjExOS5qcz85ZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnR7YyBhcyBjcmVhdGVBbmltYXRpb259ZnJvbVwiLi9hbmltYXRpb24tMTlkYmY5YmYuanNcIjtpbXBvcnR7ZyBhcyBnZXRJb25QYWdlRWxlbWVudH1mcm9tXCIuL2luZGV4LWU2YzJjODIyLmpzXCI7aW1wb3J0XCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjtpbXBvcnRcIi4vaW5kZXgtYjNlZWNiMTQuanNcIjt2YXIgbWRUcmFuc2l0aW9uQW5pbWF0aW9uPWZ1bmN0aW9uKGUsbil7dmFyIGE9XCI0MHB4XCI7dmFyIHQ9XCIwcHhcIjt2YXIgaT1uLmRpcmVjdGlvbj09PVwiYmFja1wiO3ZhciBvPW4uZW50ZXJpbmdFbDt2YXIgcj1uLmxlYXZpbmdFbDt2YXIgbT1nZXRJb25QYWdlRWxlbWVudChvKTt2YXIgYz1tLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdG9vbGJhclwiKTt2YXIgcz1jcmVhdGVBbmltYXRpb24oKTtzLmFkZEVsZW1lbnQobSkuZmlsbChcImJvdGhcIikuYmVmb3JlUmVtb3ZlQ2xhc3MoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aWYoaSl7cy5kdXJhdGlvbihuLmR1cmF0aW9ufHwyMDApLmVhc2luZyhcImN1YmljLWJlemllcigwLjQ3LDAsMC43NDUsMC43MTUpXCIpfWVsc2V7cy5kdXJhdGlvbihuLmR1cmF0aW9ufHwyODApLmVhc2luZyhcImN1YmljLWJlemllcigwLjM2LDAuNjYsMC4wNCwxKVwiKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVkoXCIuY29uY2F0KGEsXCIpXCIpLFwidHJhbnNsYXRlWShcIi5jb25jYXQodCxcIilcIikpLmZyb21UbyhcIm9wYWNpdHlcIiwuMDEsMSl9aWYoYyl7dmFyIGw9Y3JlYXRlQW5pbWF0aW9uKCk7bC5hZGRFbGVtZW50KGMpO3MuYWRkQW5pbWF0aW9uKGwpfWlmKHImJmkpe3MuZHVyYXRpb24obi5kdXJhdGlvbnx8MjAwKS5lYXNpbmcoXCJjdWJpYy1iZXppZXIoMC40NywwLDAuNzQ1LDAuNzE1KVwiKTt2YXIgZD1jcmVhdGVBbmltYXRpb24oKTtkLmFkZEVsZW1lbnQoZ2V0SW9uUGFnZUVsZW1lbnQocikpLm9uRmluaXNoKChmdW5jdGlvbihlKXtpZihlPT09MSYmZC5lbGVtZW50cy5sZW5ndGg+MCl7ZC5lbGVtZW50c1swXS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9fSkpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWShcIi5jb25jYXQodCxcIilcIiksXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdChhLFwiKVwiKSkuZnJvbVRvKFwib3BhY2l0eVwiLDEsMCk7cy5hZGRBbmltYXRpb24oZCl9cmV0dXJuIHN9O2V4cG9ydHttZFRyYW5zaXRpb25BbmltYXRpb259OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2782\n')},6250:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ BACKDROP),\n/* harmony export */   "a": () => (/* binding */ alertController),\n/* harmony export */   "b": () => (/* binding */ actionSheetController),\n/* harmony export */   "c": () => (/* binding */ popoverController),\n/* harmony export */   "d": () => (/* binding */ present),\n/* harmony export */   "e": () => (/* binding */ prepareOverlay),\n/* harmony export */   "f": () => (/* binding */ dismiss),\n/* harmony export */   "g": () => (/* binding */ eventMethod),\n/* harmony export */   "h": () => (/* binding */ activeAnimations),\n/* harmony export */   "i": () => (/* binding */ isCancel),\n/* harmony export */   "j": () => (/* binding */ focusFirstDescendant),\n/* harmony export */   "k": () => (/* binding */ getOverlay),\n/* harmony export */   "l": () => (/* binding */ loadingController),\n/* harmony export */   "m": () => (/* binding */ modalController),\n/* harmony export */   "p": () => (/* binding */ pickerController),\n/* harmony export */   "s": () => (/* binding */ safeCall),\n/* harmony export */   "t": () => (/* binding */ toastController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(655);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(882);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var lastId=0;var activeAnimations=new WeakMap;var createController=function(e){return{create:function(t){return createOverlay(e,t)},dismiss:function(t,n,r){return dismissOverlay(document,t,n,e,r)},getTop:function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(this,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){return[2,getOverlay(document,e)]}))}))}}};var alertController=createController("ion-alert");var actionSheetController=createController("ion-action-sheet");var loadingController=createController("ion-loading");var modalController=createController("ion-modal");var pickerController=createController("ion-picker");var popoverController=createController("ion-popover");var toastController=createController("ion-toast");var prepareOverlay=function(e){if(typeof document!=="undefined"){connectListeners(document)}var t=lastId++;e.overlayIndex=t;if(!e.hasAttribute("id")){e.id="ion-overlay-".concat(t)}};var createOverlay=function(e,t){if(typeof window!=="undefined"&&typeof window.customElements!=="undefined"){return window.customElements.whenDefined(e).then((function(){var n=document.createElement(e);n.classList.add("overlay-hidden");Object.assign(n,Object.assign(Object.assign({},t),{hasController:true}));getAppRoot(document).appendChild(n);return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(n,e)}))}))}return Promise.resolve()};var focusableQueryString=\'[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])\';var innerFocusableQueryString="input:not([type=hidden]), textarea, button, select";var focusFirstDescendant=function(e,t){var n=e.querySelector(focusableQueryString);var r=n&&n.shadowRoot;if(r){n=r.querySelector(innerFocusableQueryString)||n}if(n){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.f)(n)}else{t.focus()}};var isOverlayHidden=function(e){return e.classList.contains("overlay-hidden")};var focusLastDescendant=function(e,t){var n=Array.from(e.querySelectorAll(focusableQueryString));var r=n.length>0?n[n.length-1]:null;var o=r&&r.shadowRoot;if(o){r=o.querySelector(innerFocusableQueryString)||r}if(r){r.focus()}else{t.focus()}};var trapKeyboardFocus=function(e,t){var n=getOverlay(t,"ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover");var r=e.target;if(!n||!r){return}if(n.classList.contains("ion-disable-focus-trap")){return}var o=function(){if(n===r){n.lastFocus=undefined}else{var e=(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.g)(n);if(!e.contains(r)){return}var o=e.querySelector(".ion-overlay-wrapper");if(!o){return}if(o.contains(r)){n.lastFocus=r}else{var i=n.lastFocus;focusFirstDescendant(o,n);if(i===t.activeElement){focusLastDescendant(o,n)}n.lastFocus=t.activeElement}}};var i=function(){if(n.contains(r)){n.lastFocus=r}else{var e=n.lastFocus;focusFirstDescendant(n,n);if(e===t.activeElement){focusLastDescendant(n,n)}n.lastFocus=t.activeElement}};if(n.shadowRoot){i()}else{o()}};var connectListeners=function(e){if(lastId===0){lastId=1;e.addEventListener("focus",(function(t){trapKeyboardFocus(t,e)}),true);e.addEventListener("ionBackButton",(function(t){var n=getOverlay(e);if(n&&n.backdropDismiss){t.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__.OVERLAY_BACK_BUTTON_PRIORITY,(function(){return n.dismiss(undefined,BACKDROP)}))}}));e.addEventListener("keyup",(function(t){if(t.key==="Escape"){var n=getOverlay(e);if(n&&n.backdropDismiss){n.dismiss(undefined,BACKDROP)}}}))}};var dismissOverlay=function(e,t,n,r,o){var i=getOverlay(e,r,o);if(!i){return Promise.reject("overlay does not exist")}return i.dismiss(t,n)};var getOverlays=function(e,t){if(t===undefined){t="ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast"}return Array.from(e.querySelectorAll(t)).filter((function(e){return e.overlayIndex>0}))};var getOverlay=function(e,t,n){var r=getOverlays(e,t).filter((function(e){return!isOverlayHidden(e)}));return n===undefined?r[r.length-1]:r.find((function(e){return e.id===n}))};var setRootAriaHidden=function(e){if(e===void 0){e=false}var t=getAppRoot(document);var n=t.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");if(!n){return}if(e){n.setAttribute("aria-hidden","true")}else{n.removeAttribute("aria-hidden")}};var present=function(e,t,n,r,o){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,a,s,l,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(u){switch(u.label){case 0:if(e.presented){return[2]}setRootAriaHidden(true);e.presented=true;e.willPresent.emit();(i=e.willPresentShorthand)===null||i===void 0?void 0:i.emit();s=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);l=e.enterAnimation?e.enterAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(t,s==="ios"?n:r);return[4,overlayAnimation(e,l,e.el,o)];case 1:c=u.sent();if(c){e.didPresent.emit();(a=e.didPresentShorthand)===null||a===void 0?void 0:a.emit()}if(e.el.tagName!=="ION-TOAST"){focusPreviousElementOnDismiss(e.el)}if(e.keyboardClose){e.el.focus()}return[2]}}))}))};var focusPreviousElementOnDismiss=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:t=document.activeElement;if(!t){return[2]}n=t&&t.shadowRoot;if(n){t=n.querySelector(innerFocusableQueryString)||t}return[4,e.onDidDismiss()];case 1:r.sent();t.focus();return[2]}}))}))};var dismiss=function(e,t,n,r,o,i,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var s,l,c,u,d;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(v){switch(v.label){case 0:if(!e.presented){return[2,false]}setRootAriaHidden(false);e.presented=false;v.label=1;case 1:v.trys.push([1,4,,5]);e.el.style.setProperty("pointer-events","none");e.willDismiss.emit({data:t,role:n});(s=e.willDismissShorthand)===null||s===void 0?void 0:s.emit({data:t,role:n});c=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);u=e.leaveAnimation?e.leaveAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(r,c==="ios"?o:i);if(!(n!=="gesture"))return[3,3];return[4,overlayAnimation(e,u,e.el,a)];case 2:v.sent();v.label=3;case 3:e.didDismiss.emit({data:t,role:n});(l=e.didDismissShorthand)===null||l===void 0?void 0:l.emit({data:t,role:n});activeAnimations.delete(e);e.el.classList.add("overlay-hidden");e.el.style.removeProperty("pointer-events");return[3,5];case 4:d=v.sent();console.error(d);return[3,5];case 5:e.el.remove();return[2,true]}}))}))};var getAppRoot=function(e){return e.querySelector("ion-app")||e.body};var overlayAnimation=function(e,t,n,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var o,i,a;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(s){switch(s.label){case 0:n.classList.remove("overlay-hidden");o=e.el;i=t(o,r);if(!e.animated||!_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.getBoolean("animated",true)){i.duration(0)}if(e.keyboardClose){i.beforeAddWrite((function(){var e=n.ownerDocument.activeElement;if(e&&e.matches("input,ion-input, ion-textarea")){e.blur()}}))}a=activeAnimations.get(e)||[];activeAnimations.set(e,(0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)([],a,true),[i],false));return[4,i.play()];case 1:s.sent();return[2,true]}}))}))};var eventMethod=function(e,t){var n;var r=new Promise((function(e){return n=e}));onceEvent(e,t,(function(e){n(e.detail)}));return r};var onceEvent=function(e,t,n){var r=function(o){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.b)(e,t,r);n(o)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.a)(e,t,r)};var isCancel=function(e){return e==="cancel"||e===BACKDROP};var defaultGate=function(e){return e()};var safeCall=function(e,t){if(typeof e==="function"){var n=_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get("_zoneGate",defaultGate);return n((function(){try{return e(t)}catch(e){throw e}}))}return undefined};var BACKDROP="backdrop";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG1CQUFtQixnQkFBZ0IsNENBQTRDLE9BQU8sU0FBUyxpQkFBaUIsbUVBQWlCLG1CQUFtQixjQUFjLG9CQUFvQiw2QkFBNkIsb0NBQW9DLGtEQUFrRCxVQUFVLEdBQUcsOEJBQThCLHVCQUF1Qiw4REFBYSxDQUFDLDhEQUFhLHdCQUF3QixtQkFBbUIsZ0JBQWdCLGdCQUFnQixHQUFHLElBQUksOEJBQThCLE1BQU0sK0JBQStCLFdBQVcsR0FBRywyQkFBMkIsWUFBWSxHQUFHLFVBQVUsOEJBQThCLGtCQUFrQix1REFBbUIsUUFBUSxNQUFNLHVEQUFnQixTQUFTLHlCQUF5QixtQ0FBbUMsNEJBQTRCLFlBQVksMkJBQTJCLDBCQUEwQixNQUFNLDREQUFVLDBCQUEwQixxQkFBcUIsSUFBSSxZQUFZLFNBQVMsU0FBUyxHQUFHLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L292ZXJsYXlzLTM2ZDM0NzVkLmpzPzRkMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2dlbmVyYXRvcixfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtiIGFzIGdldElvbk1vZGUsYyBhcyBjb25maWd9ZnJvbVwiLi9pb25pYy1nbG9iYWwtMGViZTMyMWMuanNcIjtpbXBvcnR7T1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWX1mcm9tXCIuL2hhcmR3YXJlLWJhY2stYnV0dG9uLWFjZTZhNzFiLmpzXCI7aW1wb3J0e2MgYXMgY29tcG9uZW50T25SZWFkeSxmIGFzIGZvY3VzRWxlbWVudCxhIGFzIGFkZEV2ZW50TGlzdGVuZXIsYiBhcyByZW1vdmVFdmVudExpc3RlbmVyLGcgYXMgZ2V0RWxlbWVudFJvb3R9ZnJvbVwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7dmFyIGxhc3RJZD0wO3ZhciBhY3RpdmVBbmltYXRpb25zPW5ldyBXZWFrTWFwO3ZhciBjcmVhdGVDb250cm9sbGVyPWZ1bmN0aW9uKGUpe3JldHVybntjcmVhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIGNyZWF0ZU92ZXJsYXkoZSx0KX0sZGlzbWlzczpmdW5jdGlvbih0LG4scil7cmV0dXJuIGRpc21pc3NPdmVybGF5KGRvY3VtZW50LHQsbixlLHIpfSxnZXRUb3A6ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsZ2V0T3ZlcmxheShkb2N1bWVudCxlKV19KSl9KSl9fX07dmFyIGFsZXJ0Q29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLWFsZXJ0XCIpO3ZhciBhY3Rpb25TaGVldENvbnRyb2xsZXI9Y3JlYXRlQ29udHJvbGxlcihcImlvbi1hY3Rpb24tc2hlZXRcIik7dmFyIGxvYWRpbmdDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tbG9hZGluZ1wiKTt2YXIgbW9kYWxDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tbW9kYWxcIik7dmFyIHBpY2tlckNvbnRyb2xsZXI9Y3JlYXRlQ29udHJvbGxlcihcImlvbi1waWNrZXJcIik7dmFyIHBvcG92ZXJDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tcG9wb3ZlclwiKTt2YXIgdG9hc3RDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tdG9hc3RcIik7dmFyIHByZXBhcmVPdmVybGF5PWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCIpe2Nvbm5lY3RMaXN0ZW5lcnMoZG9jdW1lbnQpfXZhciB0PWxhc3RJZCsrO2Uub3ZlcmxheUluZGV4PXQ7aWYoIWUuaGFzQXR0cmlidXRlKFwiaWRcIikpe2UuaWQ9XCJpb24tb3ZlcmxheS1cIi5jb25jYXQodCl9fTt2YXIgY3JlYXRlT3ZlcmxheT1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2Ygd2luZG93LmN1c3RvbUVsZW1lbnRzIT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIHdpbmRvdy5jdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChlKS50aGVuKChmdW5jdGlvbigpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7bi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheS1oaWRkZW5cIik7T2JqZWN0LmFzc2lnbihuLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7aGFzQ29udHJvbGxlcjp0cnVlfSkpO2dldEFwcFJvb3QoZG9jdW1lbnQpLmFwcGVuZENoaWxkKG4pO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbXBvbmVudE9uUmVhZHkobixlKX0pKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9O3ZhciBmb2N1c2FibGVRdWVyeVN0cmluZz0nW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KFt0YWJpbmRleF49XCItXCJdKSwgdGV4dGFyZWE6bm90KFt0YWJpbmRleF49XCItXCJdKSwgYnV0dG9uOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIHNlbGVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCAuaW9uLWZvY3VzYWJsZTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pJzt2YXIgaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZz1cImlucHV0Om5vdChbdHlwZT1oaWRkZW5dKSwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XCI7dmFyIGZvY3VzRmlyc3REZXNjZW5kYW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5xdWVyeVNlbGVjdG9yKGZvY3VzYWJsZVF1ZXJ5U3RyaW5nKTt2YXIgcj1uJiZuLnNoYWRvd1Jvb3Q7aWYocil7bj1yLnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZyl8fG59aWYobil7Zm9jdXNFbGVtZW50KG4pfWVsc2V7dC5mb2N1cygpfX07dmFyIGlzT3ZlcmxheUhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMoXCJvdmVybGF5LWhpZGRlblwiKX07dmFyIGZvY3VzTGFzdERlc2NlbmRhbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1BcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVRdWVyeVN0cmluZykpO3ZhciByPW4ubGVuZ3RoPjA/bltuLmxlbmd0aC0xXTpudWxsO3ZhciBvPXImJnIuc2hhZG93Um9vdDtpZihvKXtyPW8ucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKXx8cn1pZihyKXtyLmZvY3VzKCl9ZWxzZXt0LmZvY3VzKCl9fTt2YXIgdHJhcEtleWJvYXJkRm9jdXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRPdmVybGF5KHQsXCJpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3ZlclwiKTt2YXIgcj1lLnRhcmdldDtpZighbnx8IXIpe3JldHVybn1pZihuLmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1kaXNhYmxlLWZvY3VzLXRyYXBcIikpe3JldHVybn12YXIgbz1mdW5jdGlvbigpe2lmKG49PT1yKXtuLmxhc3RGb2N1cz11bmRlZmluZWR9ZWxzZXt2YXIgZT1nZXRFbGVtZW50Um9vdChuKTtpZighZS5jb250YWlucyhyKSl7cmV0dXJufXZhciBvPWUucXVlcnlTZWxlY3RvcihcIi5pb24tb3ZlcmxheS13cmFwcGVyXCIpO2lmKCFvKXtyZXR1cm59aWYoby5jb250YWlucyhyKSl7bi5sYXN0Rm9jdXM9cn1lbHNle3ZhciBpPW4ubGFzdEZvY3VzO2ZvY3VzRmlyc3REZXNjZW5kYW50KG8sbik7aWYoaT09PXQuYWN0aXZlRWxlbWVudCl7Zm9jdXNMYXN0RGVzY2VuZGFudChvLG4pfW4ubGFzdEZvY3VzPXQuYWN0aXZlRWxlbWVudH19fTt2YXIgaT1mdW5jdGlvbigpe2lmKG4uY29udGFpbnMocikpe24ubGFzdEZvY3VzPXJ9ZWxzZXt2YXIgZT1uLmxhc3RGb2N1cztmb2N1c0ZpcnN0RGVzY2VuZGFudChuLG4pO2lmKGU9PT10LmFjdGl2ZUVsZW1lbnQpe2ZvY3VzTGFzdERlc2NlbmRhbnQobixuKX1uLmxhc3RGb2N1cz10LmFjdGl2ZUVsZW1lbnR9fTtpZihuLnNoYWRvd1Jvb3Qpe2koKX1lbHNle28oKX19O3ZhciBjb25uZWN0TGlzdGVuZXJzPWZ1bmN0aW9uKGUpe2lmKGxhc3RJZD09PTApe2xhc3RJZD0xO2UuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsKGZ1bmN0aW9uKHQpe3RyYXBLZXlib2FyZEZvY3VzKHQsZSl9KSx0cnVlKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJpb25CYWNrQnV0dG9uXCIsKGZ1bmN0aW9uKHQpe3ZhciBuPWdldE92ZXJsYXkoZSk7aWYobiYmbi5iYWNrZHJvcERpc21pc3Mpe3QuZGV0YWlsLnJlZ2lzdGVyKE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFksKGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGlzbWlzcyh1bmRlZmluZWQsQkFDS0RST1ApfSkpfX0pKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLChmdW5jdGlvbih0KXtpZih0LmtleT09PVwiRXNjYXBlXCIpe3ZhciBuPWdldE92ZXJsYXkoZSk7aWYobiYmbi5iYWNrZHJvcERpc21pc3Mpe24uZGlzbWlzcyh1bmRlZmluZWQsQkFDS0RST1ApfX19KSl9fTt2YXIgZGlzbWlzc092ZXJsYXk9ZnVuY3Rpb24oZSx0LG4scixvKXt2YXIgaT1nZXRPdmVybGF5KGUscixvKTtpZighaSl7cmV0dXJuIFByb21pc2UucmVqZWN0KFwib3ZlcmxheSBkb2VzIG5vdCBleGlzdFwiKX1yZXR1cm4gaS5kaXNtaXNzKHQsbil9O3ZhciBnZXRPdmVybGF5cz1mdW5jdGlvbihlLHQpe2lmKHQ9PT11bmRlZmluZWQpe3Q9XCJpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3Zlcixpb24tdG9hc3RcIn1yZXR1cm4gQXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUub3ZlcmxheUluZGV4PjB9KSl9O3ZhciBnZXRPdmVybGF5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1nZXRPdmVybGF5cyhlLHQpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIWlzT3ZlcmxheUhpZGRlbihlKX0pKTtyZXR1cm4gbj09PXVuZGVmaW5lZD9yW3IubGVuZ3RoLTFdOnIuZmluZCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1ufSkpfTt2YXIgc2V0Um9vdEFyaWFIaWRkZW49ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1mYWxzZX12YXIgdD1nZXRBcHBSb290KGRvY3VtZW50KTt2YXIgbj10LnF1ZXJ5U2VsZWN0b3IoXCJpb24tcm91dGVyLW91dGxldCwgaW9uLW5hdiwgI2lvbi12aWV3LWNvbnRhaW5lci1yb290XCIpO2lmKCFuKXtyZXR1cm59aWYoZSl7bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKX1lbHNle24ucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIil9fTt2YXIgcHJlc2VudD1mdW5jdGlvbihlLHQsbixyLG8pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGksYSxzLGwsYztyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDppZihlLnByZXNlbnRlZCl7cmV0dXJuWzJdfXNldFJvb3RBcmlhSGlkZGVuKHRydWUpO2UucHJlc2VudGVkPXRydWU7ZS53aWxsUHJlc2VudC5lbWl0KCk7KGk9ZS53aWxsUHJlc2VudFNob3J0aGFuZCk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLmVtaXQoKTtzPWdldElvbk1vZGUoZSk7bD1lLmVudGVyQW5pbWF0aW9uP2UuZW50ZXJBbmltYXRpb246Y29uZmlnLmdldCh0LHM9PT1cImlvc1wiP246cik7cmV0dXJuWzQsb3ZlcmxheUFuaW1hdGlvbihlLGwsZS5lbCxvKV07Y2FzZSAxOmM9dS5zZW50KCk7aWYoYyl7ZS5kaWRQcmVzZW50LmVtaXQoKTsoYT1lLmRpZFByZXNlbnRTaG9ydGhhbmQpPT09bnVsbHx8YT09PXZvaWQgMD92b2lkIDA6YS5lbWl0KCl9aWYoZS5lbC50YWdOYW1lIT09XCJJT04tVE9BU1RcIil7Zm9jdXNQcmV2aW91c0VsZW1lbnRPbkRpc21pc3MoZS5lbCl9aWYoZS5rZXlib2FyZENsb3NlKXtlLmVsLmZvY3VzKCl9cmV0dXJuWzJdfX0pKX0pKX07dmFyIGZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoIXQpe3JldHVyblsyXX1uPXQmJnQuc2hhZG93Um9vdDtpZihuKXt0PW4ucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKXx8dH1yZXR1cm5bNCxlLm9uRGlkRGlzbWlzcygpXTtjYXNlIDE6ci5zZW50KCk7dC5mb2N1cygpO3JldHVyblsyXX19KSl9KSl9O3ZhciBkaXNtaXNzPWZ1bmN0aW9uKGUsdCxuLHIsbyxpLGEpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHMsbCxjLHUsZDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odil7c3dpdGNoKHYubGFiZWwpe2Nhc2UgMDppZighZS5wcmVzZW50ZWQpe3JldHVyblsyLGZhbHNlXX1zZXRSb290QXJpYUhpZGRlbihmYWxzZSk7ZS5wcmVzZW50ZWQ9ZmFsc2U7di5sYWJlbD0xO2Nhc2UgMTp2LnRyeXMucHVzaChbMSw0LCw1XSk7ZS5lbC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO2Uud2lsbERpc21pc3MuZW1pdCh7ZGF0YTp0LHJvbGU6bn0pOyhzPWUud2lsbERpc21pc3NTaG9ydGhhbmQpPT09bnVsbHx8cz09PXZvaWQgMD92b2lkIDA6cy5lbWl0KHtkYXRhOnQscm9sZTpufSk7Yz1nZXRJb25Nb2RlKGUpO3U9ZS5sZWF2ZUFuaW1hdGlvbj9lLmxlYXZlQW5pbWF0aW9uOmNvbmZpZy5nZXQocixjPT09XCJpb3NcIj9vOmkpO2lmKCEobiE9PVwiZ2VzdHVyZVwiKSlyZXR1cm5bMywzXTtyZXR1cm5bNCxvdmVybGF5QW5pbWF0aW9uKGUsdSxlLmVsLGEpXTtjYXNlIDI6di5zZW50KCk7di5sYWJlbD0zO2Nhc2UgMzplLmRpZERpc21pc3MuZW1pdCh7ZGF0YTp0LHJvbGU6bn0pOyhsPWUuZGlkRGlzbWlzc1Nob3J0aGFuZCk9PT1udWxsfHxsPT09dm9pZCAwP3ZvaWQgMDpsLmVtaXQoe2RhdGE6dCxyb2xlOm59KTthY3RpdmVBbmltYXRpb25zLmRlbGV0ZShlKTtlLmVsLmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5LWhpZGRlblwiKTtlLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIik7cmV0dXJuWzMsNV07Y2FzZSA0OmQ9di5zZW50KCk7Y29uc29sZS5lcnJvcihkKTtyZXR1cm5bMyw1XTtjYXNlIDU6ZS5lbC5yZW1vdmUoKTtyZXR1cm5bMix0cnVlXX19KSl9KSl9O3ZhciBnZXRBcHBSb290PWZ1bmN0aW9uKGUpe3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJpb24tYXBwXCIpfHxlLmJvZHl9O3ZhciBvdmVybGF5QW5pbWF0aW9uPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG8saSxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihzKXtzd2l0Y2gocy5sYWJlbCl7Y2FzZSAwOm4uY2xhc3NMaXN0LnJlbW92ZShcIm92ZXJsYXktaGlkZGVuXCIpO289ZS5lbDtpPXQobyxyKTtpZighZS5hbmltYXRlZHx8IWNvbmZpZy5nZXRCb29sZWFuKFwiYW5pbWF0ZWRcIix0cnVlKSl7aS5kdXJhdGlvbigwKX1pZihlLmtleWJvYXJkQ2xvc2Upe2kuYmVmb3JlQWRkV3JpdGUoKGZ1bmN0aW9uKCl7dmFyIGU9bi5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoZSYmZS5tYXRjaGVzKFwiaW5wdXQsaW9uLWlucHV0LCBpb24tdGV4dGFyZWFcIikpe2UuYmx1cigpfX0pKX1hPWFjdGl2ZUFuaW1hdGlvbnMuZ2V0KGUpfHxbXTthY3RpdmVBbmltYXRpb25zLnNldChlLF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxhLHRydWUpLFtpXSxmYWxzZSkpO3JldHVybls0LGkucGxheSgpXTtjYXNlIDE6cy5zZW50KCk7cmV0dXJuWzIsdHJ1ZV19fSkpfSkpfTt2YXIgZXZlbnRNZXRob2Q9ZnVuY3Rpb24oZSx0KXt2YXIgbjt2YXIgcj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIG49ZX0pKTtvbmNlRXZlbnQoZSx0LChmdW5jdGlvbihlKXtuKGUuZGV0YWlsKX0pKTtyZXR1cm4gcn07dmFyIG9uY2VFdmVudD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZnVuY3Rpb24obyl7cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQscik7bihvKX07YWRkRXZlbnRMaXN0ZW5lcihlLHQscil9O3ZhciBpc0NhbmNlbD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PVwiY2FuY2VsXCJ8fGU9PT1CQUNLRFJPUH07dmFyIGRlZmF1bHRHYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBlKCl9O3ZhciBzYWZlQ2FsbD1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiBlPT09XCJmdW5jdGlvblwiKXt2YXIgbj1jb25maWcuZ2V0KFwiX3pvbmVHYXRlXCIsZGVmYXVsdEdhdGUpO3JldHVybiBuKChmdW5jdGlvbigpe3RyeXtyZXR1cm4gZSh0KX1jYXRjaChlKXt0aHJvdyBlfX0pKX1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgQkFDS0RST1A9XCJiYWNrZHJvcFwiO2V4cG9ydHtCQUNLRFJPUCBhcyBCLGFsZXJ0Q29udHJvbGxlciBhcyBhLGFjdGlvblNoZWV0Q29udHJvbGxlciBhcyBiLHBvcG92ZXJDb250cm9sbGVyIGFzIGMscHJlc2VudCBhcyBkLHByZXBhcmVPdmVybGF5IGFzIGUsZGlzbWlzcyBhcyBmLGV2ZW50TWV0aG9kIGFzIGcsYWN0aXZlQW5pbWF0aW9ucyBhcyBoLGlzQ2FuY2VsIGFzIGksZm9jdXNGaXJzdERlc2NlbmRhbnQgYXMgaixnZXRPdmVybGF5IGFzIGssbG9hZGluZ0NvbnRyb2xsZXIgYXMgbCxtb2RhbENvbnRyb2xsZXIgYXMgbSxwaWNrZXJDb250cm9sbGVyIGFzIHAsc2FmZUNhbGwgYXMgcyx0b2FzdENvbnRyb2xsZXIgYXMgdH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6250\n')},6491:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"YG\": () => (/* binding */ index_esm_IonButton),\n  \"PM\": () => (/* binding */ index_esm_IonCard),\n  \"FN\": () => (/* binding */ index_esm_IonCardContent),\n  \"W2\": () => (/* binding */ index_esm_IonContent),\n  \"fr\": () => (/* binding */ index_esm_IonFooter),\n  \"Gu\": () => (/* binding */ index_esm_IonHeader),\n  \"Ie\": () => (/* binding */ index_esm_IonItem),\n  \"Q$\": () => (/* binding */ index_esm_IonLabel),\n  \"q_\": () => (/* binding */ index_esm_IonList),\n  \"yh\": () => (/* binding */ index_esm_IonListHeader),\n  \"_i\": () => (/* binding */ IonPage),\n  \"yW\": () => (/* binding */ index_esm_IonText),\n  \"wd\": () => (/* binding */ index_esm_IonTitle),\n  \"sr\": () => (/* binding */ index_esm_IonToolbar)\n});\n\n// UNUSED EXPORTS: CreateAnimation, DefaultIonLifeCycleContext, IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButtons, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonDatetime, IonFab, IonFabButton, IonFabList, IonGrid, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLifeCycleContext, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRedirect, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRoute, IonRouterContext, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonTabsContext, IonTextarea, IonThumbnail, IonToast, IonToggle, IonVirtualScroll, IonicSafeString, IonicSlides, IonicSwiper, LocationHistory, NavContext, NavManager, RouteManagerContext, StackContext, ViewLifeCycleManager, ViewStacks, createAnimation, createGesture, generateId, getConfig, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation, setupIonicReact, useIonActionSheet, useIonAlert, useIonLoading, useIonModal, useIonPicker, useIonPopover, useIonRouter, useIonToast, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./node_modules/@stencil/core/internal/client/index.js + 1 modules\nvar client = __webpack_require__(7210);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ionic-global.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nclass Config {\n  constructor() {\n    this.m = new Map();\n  }\n  reset(configObj) {\n    this.m = new Map(Object.entries(configObj));\n  }\n  get(key, fallback) {\n    const value = this.m.get(key);\n    return value !== undefined ? value : fallback;\n  }\n  getBoolean(key, fallback = false) {\n    const val = this.m.get(key);\n    if (val === undefined) {\n      return fallback;\n    }\n    if (typeof val === 'string') {\n      return val === 'true';\n    }\n    return !!val;\n  }\n  getNumber(key, fallback) {\n    const val = parseFloat(this.m.get(key));\n    return isNaN(val) ? (fallback !== undefined ? fallback : NaN) : val;\n  }\n  set(key, value) {\n    this.m.set(key, value);\n  }\n}\nconst ionic_global_config = /*@__PURE__*/ new Config();\nconst configFromSession = (win) => {\n  try {\n    const configStr = win.sessionStorage.getItem(IONIC_SESSION_KEY);\n    return configStr !== null ? JSON.parse(configStr) : {};\n  }\n  catch (e) {\n    return {};\n  }\n};\nconst saveConfig = (win, c) => {\n  try {\n    win.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c));\n  }\n  catch (e) {\n    return;\n  }\n};\nconst configFromURL = (win) => {\n  const configObj = {};\n  win.location.search\n    .slice(1)\n    .split('&')\n    .map(entry => entry.split('='))\n    .map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)])\n    .filter(([key]) => startsWith(key, IONIC_PREFIX))\n    .map(([key, value]) => [key.slice(IONIC_PREFIX.length), value])\n    .forEach(([key, value]) => {\n    configObj[key] = value;\n  });\n  return configObj;\n};\nconst startsWith = (input, search) => {\n  return input.substr(0, search.length) === search;\n};\nconst IONIC_PREFIX = 'ionic:';\nconst IONIC_SESSION_KEY = 'ionic-persist-config';\n\nconst getPlatforms = (win) => setupPlatforms(win);\nconst isPlatform = (winOrPlatform, platform) => {\n  if (typeof winOrPlatform === 'string') {\n    platform = winOrPlatform;\n    winOrPlatform = undefined;\n  }\n  return getPlatforms(winOrPlatform).includes(platform);\n};\nconst setupPlatforms = (win = window) => {\n  if (typeof win === 'undefined') {\n    return [];\n  }\n  win.Ionic = win.Ionic || {};\n  let platforms = win.Ionic.platforms;\n  if (platforms == null) {\n    platforms = win.Ionic.platforms = detectPlatforms(win);\n    platforms.forEach(p => win.document.documentElement.classList.add(`plt-${p}`));\n  }\n  return platforms;\n};\nconst detectPlatforms = (win) => {\n  const customPlatformMethods = ionic_global_config.get('platform');\n  return Object.keys(PLATFORMS_MAP).filter(p => {\n    const customMethod = customPlatformMethods && customPlatformMethods[p];\n    return typeof customMethod === 'function' ? customMethod(win) : PLATFORMS_MAP[p](win);\n  });\n};\nconst isMobileWeb = (win) => isMobile(win) && !isHybrid(win);\nconst isIpad = (win) => {\n  // iOS 12 and below\n  if (testUserAgent(win, /iPad/i)) {\n    return true;\n  }\n  // iOS 13+\n  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {\n    return true;\n  }\n  return false;\n};\nconst isIphone = (win) => testUserAgent(win, /iPhone/i);\nconst isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);\nconst isAndroid = (win) => testUserAgent(win, /android|sink/i);\nconst isAndroidTablet = (win) => {\n  return isAndroid(win) && !testUserAgent(win, /mobile/i);\n};\nconst isPhablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (smallest > 390 && smallest < 520) &&\n    (largest > 620 && largest < 800);\n};\nconst isTablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (isIpad(win) ||\n    isAndroidTablet(win) ||\n    ((smallest > 460 && smallest < 820) &&\n      (largest > 780 && largest < 1400)));\n};\nconst isMobile = (win) => matchMedia(win, '(any-pointer:coarse)');\nconst isDesktop = (win) => !isMobile(win);\nconst isHybrid = (win) => isCordova(win) || isCapacitorNative(win);\nconst isCordova = (win) => !!(win['cordova'] || win['phonegap'] || win['PhoneGap']);\nconst isCapacitorNative = (win) => {\n  const capacitor = win['Capacitor'];\n  return !!(capacitor && capacitor.isNative);\n};\nconst isElectron = (win) => testUserAgent(win, /electron/i);\nconst isPWA = (win) => !!((win.matchMedia && win.matchMedia('(display-mode: standalone)').matches) || win.navigator.standalone);\nconst testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);\nconst matchMedia = (win, query) => win.matchMedia && win.matchMedia(query).matches;\nconst PLATFORMS_MAP = {\n  'ipad': isIpad,\n  'iphone': isIphone,\n  'ios': isIOS,\n  'android': isAndroid,\n  'phablet': isPhablet,\n  'tablet': isTablet,\n  'cordova': isCordova,\n  'capacitor': isCapacitorNative,\n  'electron': isElectron,\n  'pwa': isPWA,\n  'mobile': isMobile,\n  'mobileweb': isMobileWeb,\n  'desktop': isDesktop,\n  'hybrid': isHybrid\n};\n\nlet defaultMode;\nconst ionic_global_getIonMode = (ref) => {\n  return (ref && (0,client/* getMode */.iJ)(ref)) || defaultMode;\n};\nconst ionic_global_initialize = (userConfig = {}) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const doc = window.document;\n  const win = window;\n  Context.config = ionic_global_config;\n  const Ionic = win.Ionic = win.Ionic || {};\n  const platformHelpers = {};\n  if (userConfig._ael) {\n    platformHelpers.ael = userConfig._ael;\n  }\n  if (userConfig._rel) {\n    platformHelpers.rel = userConfig._rel;\n  }\n  if (userConfig._ce) {\n    platformHelpers.ce = userConfig._ce;\n  }\n  setPlatformHelpers(platformHelpers);\n  // create the Ionic.config from raw config object (if it exists)\n  // and convert Ionic.config into a ConfigApi that has a get() fn\n  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win)), { persistConfig: false }), Ionic.config), configFromURL(win)), userConfig);\n  ionic_global_config.reset(configObj);\n  if (ionic_global_config.getBoolean('persistConfig')) {\n    saveConfig(win, configObj);\n  }\n  // Setup platforms\n  setupPlatforms(win);\n  // first see if the mode was set as an attribute on <html>\n  // which could have been set by the user, or by pre-rendering\n  // otherwise get the mode via config settings, and fallback to md\n  Ionic.config = ionic_global_config;\n  Ionic.mode = defaultMode = ionic_global_config.get('mode', (doc.documentElement.getAttribute('mode')) || (isPlatform(win, 'ios') ? 'ios' : 'md'));\n  ionic_global_config.set('mode', defaultMode);\n  doc.documentElement.setAttribute('mode', defaultMode);\n  doc.documentElement.classList.add(defaultMode);\n  if (ionic_global_config.getBoolean('_testing')) {\n    ionic_global_config.set('animated', false);\n  }\n  const isIonicElement = (elm) => elm.tagName && elm.tagName.startsWith('ION-');\n  const isAllowedIonicModeValue = (elmMode) => ['ios', 'md'].includes(elmMode);\n  setMode((elm) => {\n    while (elm) {\n      const elmMode = elm.mode || elm.getAttribute('mode');\n      if (elmMode) {\n        if (isAllowedIonicModeValue(elmMode)) {\n          return elmMode;\n        }\n        else if (isIonicElement(elm)) {\n          console.warn('Invalid ionic mode: \"' + elmMode + '\", expected: \"ios\" or \"md\"');\n        }\n      }\n      elm = elm.parentElement;\n    }\n    return defaultMode;\n  });\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/helpers.js\nvar helpers = __webpack_require__(6587);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/overlays.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getOverlay(document, tagName);\n    }\n  };\n};\nconst overlays_alertController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-alert')));\nconst actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nconst overlays_loadingController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-loading')));\nconst overlays_modalController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-modal')));\nconst overlays_pickerController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-picker')));\nconst overlays_popoverController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-popover')));\nconst toastController = /*@__PURE__*/ createController('ion-toast');\nconst prepareOverlay = (el) => {\n  /* tslint:disable-next-line */\n  if (typeof document !== 'undefined') {\n    connectListeners(document);\n  }\n  const overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${overlayIndex}`;\n  }\n};\nconst createOverlay = (tagName, opts) => {\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise(resolve => (0,helpers.c)(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]), input:not([type=hidden]):not([tabindex^=\"-\"]), textarea:not([tabindex^=\"-\"]), button:not([tabindex^=\"-\"]), select:not([tabindex^=\"-\"]), .ion-focusable:not([tabindex^=\"-\"])';\nconst innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';\nconst focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput && firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput && lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    }\n    else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      }\n      else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    }\n    else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  }\n  else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = (doc) => {\n  if (lastId === 0) {\n    lastId = 1;\n    doc.addEventListener('focus', (ev) => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', ev => {\n      const lastOverlay = getOverlay(doc);\n      if (lastOverlay && lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keyup', ev => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getOverlay(doc);\n        if (lastOverlay && lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\nconst getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector))\n    .filter(c => c.overlayIndex > 0);\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getOverlay = (doc, overlayTag, id) => {\n  const overlays = getOverlays(doc, overlayTag).filter(o => !isOverlayHidden(o));\n  return (id === undefined)\n    ? overlays[overlays.length - 1]\n    : overlays.find(o => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  }\n  else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = (overlay.enterAnimation)\n    ? overlay.enterAnimation\n    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  if (overlay.keyboardClose) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement && previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  setRootAriaHidden(false);\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({ data, role });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n    const mode = getIonMode(overlay);\n    const animationBuilder = (overlay.leaveAnimation)\n      ? overlay.leaveAnimation\n      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== 'gesture') {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({ data, role });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n  }\n  catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = (doc) => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement && activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nconst eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise(r => resolve = r);\n  onceEvent(element, eventName, (event) => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n  const handler = (ev) => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nconst isCancel = (role) => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      }\n      catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nconst BACKDROP = 'backdrop';\n\n\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(655);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(3935);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-card-content.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst cardContentIosCss = \"ion-card-content{display:block;position:relative}.card-content-ios{padding-left:20px;padding-right:20px;padding-top:20px;padding-bottom:20px;font-size:16px;line-height:1.4}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.card-content-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px}}.card-content-ios h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-ios h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-ios h3,.card-content-ios h4,.card-content-ios h5,.card-content-ios h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-ios p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px}ion-card-header+.card-content-ios{padding-top:0}\";\n\nconst cardContentMdCss = \"ion-card-content{display:block;position:relative}.card-content-md{padding-left:16px;padding-right:16px;padding-top:13px;padding-bottom:13px;font-size:14px;line-height:1.5}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.card-content-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.card-content-md h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-md h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-md h3,.card-content-md h4,.card-content-md h5,.card-content-md h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-md p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:1.5}ion-card-header+.card-content-md{padding-top:0}\";\n\nconst CardContent = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { class: {\n        [mode]: true,\n        // Used internally for styling\n        [`card-content-${mode}`]: true\n      } }));\n  }\n  static get style() { return {\n    ios: cardContentIosCss,\n    md: cardContentMdCss\n  }; }\n}, [32, \"ion-card-content\"]);\nfunction ion_card_content_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-card-content\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-card-content\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, CardContent);\n      }\n      break;\n  } });\n}\n\nconst IonCardContent = (/* unused pure expression or super */ null && (CardContent));\nconst defineCustomElement = ion_card_content_defineCustomElement$1;\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/dir.js\nvar dir = __webpack_require__(545);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/theme.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return (typeof color === 'string' && color.length > 0) ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter(c => c != null)\n      .map(c => c.trim())\n      .filter(c => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach(c => map[c] = true);\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-content.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\nconst contentCss = \":host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.outer-content){--background:var(--ion-color-step-50, #f2f2f2)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:manipulation;touch-action:manipulation}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.inner-scroll{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:\\\"\\\"}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:10px;height:100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAgCAYAAAAIXrg4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTE3MDgzRkQ5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTE3MDgzRkU5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMTcwODNGQjlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMTcwODNGQzlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmePEuQAAABNSURBVHjaYvz//z8DIxAwMDAwATGMhmFmPDQuOSZks0AMmoJBaQHjkPfB0Lfg/2gQjVow+HPy/yHvg9GiYjQfjMbBqAWjFgy/4hogwADYqwdzxy5BuwAAAABJRU5ErkJggg==);background-repeat:repeat-y;background-size:10px 16px}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}\";\n\nconst Content = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionScrollStart = (0,client/* createEvent */.yM)(this, \"ionScrollStart\", 7);\n    this.ionScroll = (0,client/* createEvent */.yM)(this, \"ionScroll\", 7);\n    this.ionScrollEnd = (0,client/* createEvent */.yM)(this, \"ionScrollEnd\", 7);\n    this.isScrolling = false;\n    this.lastScroll = 0;\n    this.queued = false;\n    this.cTop = -1;\n    this.cBottom = -1;\n    this.isMainContent = true;\n    // Detail is used in a hot loop in the scroll event, by allocating it here\n    // V8 will be able to inline any read/write to it since it's a monomorphic class.\n    // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n    this.detail = {\n      scrollTop: 0,\n      scrollLeft: 0,\n      type: 'scroll',\n      event: undefined,\n      startX: 0,\n      startY: 0,\n      startTime: 0,\n      currentX: 0,\n      currentY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      currentTime: 0,\n      data: undefined,\n      isScrolling: true,\n    };\n    /**\n     * If `true`, the content will scroll behind the headers\n     * and footers. This effect can easily be seen by setting the toolbar\n     * to transparent.\n     */\n    this.fullscreen = false;\n    /**\n     * If you want to enable the content scrolling in the X axis, set this property to `true`.\n     */\n    this.scrollX = false;\n    /**\n     * If you want to disable the content scrolling in the Y axis, set this property to `false`.\n     */\n    this.scrollY = true;\n    /**\n     * Because of performance reasons, ionScroll events are disabled by default, in order to enable them\n     * and start listening from (ionScroll), set this property to `true`.\n     */\n    this.scrollEvents = false;\n  }\n  connectedCallback() {\n    this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;\n  }\n  disconnectedCallback() {\n    this.onScrollEnd();\n  }\n  onAppLoad() {\n    this.resize();\n  }\n  shouldForceOverscroll() {\n    const { forceOverscroll } = this;\n    const mode = ionic_global_getIonMode(this);\n    return forceOverscroll === undefined\n      ? mode === 'ios' && isPlatform('ios')\n      : forceOverscroll;\n  }\n  resize() {\n    if (this.fullscreen) {\n      (0,client/* readTask */.wj)(() => this.readDimensions());\n    }\n    else if (this.cTop !== 0 || this.cBottom !== 0) {\n      this.cTop = this.cBottom = 0;\n      (0,client/* forceUpdate */.xE)(this);\n    }\n  }\n  readDimensions() {\n    const page = getPageElement(this.el);\n    const top = Math.max(this.el.offsetTop, 0);\n    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);\n    const dirty = top !== this.cTop || bottom !== this.cBottom;\n    if (dirty) {\n      this.cTop = top;\n      this.cBottom = bottom;\n      (0,client/* forceUpdate */.xE)(this);\n    }\n  }\n  onScroll(ev) {\n    const timeStamp = Date.now();\n    const shouldStart = !this.isScrolling;\n    this.lastScroll = timeStamp;\n    if (shouldStart) {\n      this.onScrollStart();\n    }\n    if (!this.queued && this.scrollEvents) {\n      this.queued = true;\n      (0,client/* readTask */.wj)(ts => {\n        this.queued = false;\n        this.detail.event = ev;\n        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);\n        this.ionScroll.emit(this.detail);\n      });\n    }\n  }\n  /**\n   * Get the element where the actual scrolling takes place.\n   * This element can be used to subscribe to `scroll` events or manually modify\n   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:\n   *\n   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\n   * and `scrollToPoint()` to scroll the content into a certain point.\n   */\n  async getScrollElement() {\n    /**\n     * If this gets called in certain early lifecycle hooks (ex: Vue onMounted),\n     * scrollEl won't be defined yet with the custom elements build, so wait for it to load in.\n     */\n    if (!this.scrollEl) {\n      await new Promise(resolve => (0,helpers.c)(this.el, resolve));\n    }\n    return Promise.resolve(this.scrollEl);\n  }\n  /**\n   * Scroll to the top of the component.\n   *\n   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.\n   */\n  scrollToTop(duration = 0) {\n    return this.scrollToPoint(undefined, 0, duration);\n  }\n  /**\n   * Scroll to the bottom of the component.\n   *\n   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.\n   */\n  async scrollToBottom(duration = 0) {\n    const scrollEl = await this.getScrollElement();\n    const y = scrollEl.scrollHeight - scrollEl.clientHeight;\n    return this.scrollToPoint(undefined, y, duration);\n  }\n  /**\n   * Scroll by a specified X/Y distance in the component.\n   *\n   * @param x The amount to scroll by on the horizontal axis.\n   * @param y The amount to scroll by on the vertical axis.\n   * @param duration The amount of time to take scrolling by that amount.\n   */\n  async scrollByPoint(x, y, duration) {\n    const scrollEl = await this.getScrollElement();\n    return this.scrollToPoint(x + scrollEl.scrollLeft, y + scrollEl.scrollTop, duration);\n  }\n  /**\n   * Scroll to a specified X/Y location in the component.\n   *\n   * @param x The point to scroll to on the horizontal axis.\n   * @param y The point to scroll to on the vertical axis.\n   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.\n   */\n  async scrollToPoint(x, y, duration = 0) {\n    const el = await this.getScrollElement();\n    if (duration < 32) {\n      if (y != null) {\n        el.scrollTop = y;\n      }\n      if (x != null) {\n        el.scrollLeft = x;\n      }\n      return;\n    }\n    let resolve;\n    let startTime = 0;\n    const promise = new Promise(r => resolve = r);\n    const fromY = el.scrollTop;\n    const fromX = el.scrollLeft;\n    const deltaY = y != null ? y - fromY : 0;\n    const deltaX = x != null ? x - fromX : 0;\n    // scroll loop\n    const step = (timeStamp) => {\n      const linearTime = Math.min(1, ((timeStamp - startTime) / duration)) - 1;\n      const easedT = Math.pow(linearTime, 3) + 1;\n      if (deltaY !== 0) {\n        el.scrollTop = Math.floor((easedT * deltaY) + fromY);\n      }\n      if (deltaX !== 0) {\n        el.scrollLeft = Math.floor((easedT * deltaX) + fromX);\n      }\n      if (easedT < 1) {\n        // do not use DomController here\n        // must use nativeRaf in order to fire in the next frame\n        // TODO: remove as any\n        requestAnimationFrame(step);\n      }\n      else {\n        resolve();\n      }\n    };\n    // chill out for a frame first\n    requestAnimationFrame(ts => {\n      startTime = ts;\n      step(ts);\n    });\n    return promise;\n  }\n  onScrollStart() {\n    this.isScrolling = true;\n    this.ionScrollStart.emit({\n      isScrolling: true\n    });\n    if (this.watchDog) {\n      clearInterval(this.watchDog);\n    }\n    // watchdog\n    this.watchDog = setInterval(() => {\n      if (this.lastScroll < Date.now() - 120) {\n        this.onScrollEnd();\n      }\n    }, 100);\n  }\n  onScrollEnd() {\n    clearInterval(this.watchDog);\n    this.watchDog = null;\n    if (this.isScrolling) {\n      this.isScrolling = false;\n      this.ionScrollEnd.emit({\n        isScrolling: false\n      });\n    }\n  }\n  render() {\n    const { isMainContent, scrollX, scrollY, el } = this;\n    const rtl = (0,dir.i)(el) ? 'rtl' : 'ltr';\n    const mode = ionic_global_getIonMode(this);\n    const forceOverscroll = this.shouldForceOverscroll();\n    const transitionShadow = mode === 'ios';\n    const TagType = isMainContent ? 'main' : 'div';\n    this.resize();\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n        'content-sizing': hostContext('ion-popover', this.el),\n        'overscroll': forceOverscroll,\n        [`content-${rtl}`]: true\n      }), style: {\n        '--offset-top': `${this.cTop}px`,\n        '--offset-bottom': `${this.cBottom}px`,\n      } }, (0,client.h)(\"div\", { id: \"background-content\", part: \"background\" }), (0,client.h)(TagType, { class: {\n        'inner-scroll': true,\n        'scroll-x': scrollX,\n        'scroll-y': scrollY,\n        'overscroll': (scrollX || scrollY) && forceOverscroll\n      }, ref: (scrollEl) => this.scrollEl = scrollEl, onScroll: (this.scrollEvents) ? (ev) => this.onScroll(ev) : undefined, part: \"scroll\" }, (0,client.h)(\"slot\", null)), transitionShadow ? ((0,client.h)(\"div\", { class: \"transition-effect\" }, (0,client.h)(\"div\", { class: \"transition-cover\" }), (0,client.h)(\"div\", { class: \"transition-shadow\" }))) : null, (0,client.h)(\"slot\", { name: \"fixed\" })));\n  }\n  get el() { return this; }\n  static get style() { return contentCss; }\n}, [1, \"ion-content\", {\n    \"color\": [513],\n    \"fullscreen\": [4],\n    \"forceOverscroll\": [1028, \"force-overscroll\"],\n    \"scrollX\": [4, \"scroll-x\"],\n    \"scrollY\": [4, \"scroll-y\"],\n    \"scrollEvents\": [4, \"scroll-events\"],\n    \"getScrollElement\": [64],\n    \"scrollToTop\": [64],\n    \"scrollToBottom\": [64],\n    \"scrollByPoint\": [64],\n    \"scrollToPoint\": [64]\n  }, [[8, \"appload\", \"onAppLoad\"]]]);\nconst getParentElement = (el) => {\n  if (el.parentElement) {\n    // normal element with a parent element\n    return el.parentElement;\n  }\n  if (el.parentNode && el.parentNode.host) {\n    // shadow dom's document fragment\n    return el.parentNode.host;\n  }\n  return null;\n};\nconst getPageElement = (el) => {\n  const tabs = el.closest('ion-tabs');\n  if (tabs) {\n    return tabs;\n  }\n  /**\n   * If we're in a popover, we need to use its wrapper so we can account for space\n   * between the popover and the edges of the screen. But if the popover contains\n   * its own page element, we should use that instead.\n   */\n  const page = el.closest('ion-app, ion-page, .ion-page, page-inner, .popover-content');\n  if (page) {\n    return page;\n  }\n  return getParentElement(el);\n};\n// ******** DOM READ ****************\nconst updateScrollDetail = (detail, el, timestamp, shouldStart) => {\n  const prevX = detail.currentX;\n  const prevY = detail.currentY;\n  const prevT = detail.currentTime;\n  const currentX = el.scrollLeft;\n  const currentY = el.scrollTop;\n  const timeDelta = timestamp - prevT;\n  if (shouldStart) {\n    // remember the start positions\n    detail.startTime = timestamp;\n    detail.startX = currentX;\n    detail.startY = currentY;\n    detail.velocityX = detail.velocityY = 0;\n  }\n  detail.currentTime = timestamp;\n  detail.currentX = detail.scrollLeft = currentX;\n  detail.currentY = detail.scrollTop = currentY;\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  if (timeDelta > 0 && timeDelta < 100) {\n    const velocityX = (currentX - prevX) / timeDelta;\n    const velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n};\nfunction ion_content_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-content\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-content\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Content);\n      }\n      break;\n  } });\n}\n\nconst IonContent = (/* unused pure expression or super */ null && (Content));\nconst ion_content_defineCustomElement = ion_content_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-footer.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst handleFooterFade = (scrollEl, baseEl) => {\n  (0,client/* readTask */.wj)(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const maxScroll = scrollEl.scrollHeight - scrollEl.clientHeight;\n    /**\n     * Toolbar background will fade\n     * out over fadeDuration in pixels.\n     */\n    const fadeDuration = 10;\n    /**\n     * Begin fading out maxScroll - 30px\n     * from the bottom of the content.\n     * Also determine how close we are\n     * to starting the fade. If we are\n     * before the starting point, the\n     * scale value will get clamped to 0.\n     * If we are after the maxScroll (rubber\n     * band scrolling), the scale value will\n     * get clamped to 1.\n     */\n    const fadeStart = maxScroll - fadeDuration;\n    const distanceToStart = scrollTop - fadeStart;\n    const scale = (0,helpers.j)(0, 1 - (distanceToStart / fadeDuration), 1);\n    (0,client/* writeTask */.Iu)(() => {\n      baseEl.style.setProperty('--opacity-scale', scale.toString());\n    });\n  });\n};\n\nconst footerIosCss = \"ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-ios ion-toolbar:first-of-type{--border-width:0.55px 0 0}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.footer-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.footer-translucent-ios ion-toolbar{--opacity:.8}}.footer-ios.ion-no-border ion-toolbar:first-of-type{--border-width:0}.footer-collapse-fade ion-toolbar{--opacity-scale:inherit}\";\n\nconst footerMdCss = \"ion-footer{display:block;position:relative;-ms-flex-order:1;order:1;width:100%;z-index:10}ion-footer ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-md::before{left:0;top:-2px;bottom:auto;background-position:left 0 top 0;position:absolute;width:100%;height:2px;background-image:url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==\\\");background-repeat:repeat-x;content:\\\"\\\"}[dir=rtl] .footer-md::before,:host-context([dir=rtl]) .footer-md::before{left:unset;right:unset;right:0}[dir=rtl] .footer-md::before,:host-context([dir=rtl]) .footer-md::before{background-position:right 0 top 0}.footer-md.ion-no-border::before{display:none}\";\n\nconst Footer = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    /**\n     * If `true`, the footer will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     *\n     * Note: In order to scroll content behind the footer, the `fullscreen`\n     * attribute needs to be set on the content.\n     */\n    this.translucent = false;\n    this.checkCollapsibleFooter = () => {\n      const mode = ionic_global_getIonMode(this);\n      if (mode !== 'ios') {\n        return;\n      }\n      const { collapse } = this;\n      const hasFade = collapse === 'fade';\n      this.destroyCollapsibleFooter();\n      if (hasFade) {\n        const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n        const contentEl = (pageEl) ? pageEl.querySelector('ion-content') : null;\n        this.setupFadeFooter(contentEl);\n      }\n    };\n    this.setupFadeFooter = async (contentEl) => {\n      if (!contentEl) {\n        console.error('ion-footer requires a content to collapse. Make sure there is an ion-content.');\n        return;\n      }\n      await new Promise(resolve => (0,helpers.c)(contentEl, resolve));\n      const scrollEl = this.scrollEl = await contentEl.getScrollElement();\n      /**\n       * Handle fading of toolbars on scroll\n       */\n      this.contentScrollCallback = () => { handleFooterFade(scrollEl, this.el); };\n      scrollEl.addEventListener('scroll', this.contentScrollCallback);\n      handleFooterFade(scrollEl, this.el);\n    };\n  }\n  componentDidLoad() {\n    this.checkCollapsibleFooter();\n  }\n  componentDidUpdate() {\n    this.checkCollapsibleFooter();\n  }\n  destroyCollapsibleFooter() {\n    if (this.scrollEl && this.contentScrollCallback) {\n      this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);\n      this.contentScrollCallback = undefined;\n    }\n  }\n  render() {\n    const { translucent, collapse } = this;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"contentinfo\", class: {\n        [mode]: true,\n        // Used internally for styling\n        [`footer-${mode}`]: true,\n        [`footer-translucent`]: translucent,\n        [`footer-translucent-${mode}`]: translucent,\n        [`footer-collapse-${collapse}`]: collapse !== undefined,\n      } }, mode === 'ios' && translucent &&\n      (0,client.h)(\"div\", { class: \"footer-background\" }), (0,client.h)(\"slot\", null)));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: footerIosCss,\n    md: footerMdCss\n  }; }\n}, [36, \"ion-footer\", {\n    \"collapse\": [1],\n    \"translucent\": [4]\n  }]);\nfunction ion_footer_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-footer\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-footer\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Footer);\n      }\n      break;\n  } });\n}\n\nconst IonFooter = (/* unused pure expression or super */ null && (Footer));\nconst ion_footer_defineCustomElement = ion_footer_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-header.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\nconst TRANSITION = 'all 0.2s ease-in-out';\nconst cloneElement = (tagName) => {\n  const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);\n  if (getCachedEl !== null) {\n    return getCachedEl;\n  }\n  const clonedEl = document.createElement(tagName);\n  clonedEl.classList.add('ion-cloned-element');\n  clonedEl.style.setProperty('display', 'none');\n  document.body.appendChild(clonedEl);\n  return clonedEl;\n};\nconst createHeaderIndex = (headerEl) => {\n  if (!headerEl) {\n    return;\n  }\n  const toolbars = headerEl.querySelectorAll('ion-toolbar');\n  return {\n    el: headerEl,\n    toolbars: Array.from(toolbars).map((toolbar) => {\n      const ionTitleEl = toolbar.querySelector('ion-title');\n      return {\n        el: toolbar,\n        background: toolbar.shadowRoot.querySelector('.toolbar-background'),\n        ionTitleEl,\n        innerTitleEl: (ionTitleEl) ? ionTitleEl.shadowRoot.querySelector('.toolbar-title') : null,\n        ionButtonsEl: Array.from(toolbar.querySelectorAll('ion-buttons')) || []\n      };\n    }) || []\n  };\n};\nconst handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {\n  (0,client/* readTask */.wj)(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const scale = (0,helpers.j)(1, 1 + (-scrollTop / 500), 1.1);\n    // Native refresher should not cause titles to scale\n    const nativeRefresher = contentEl.querySelector('ion-refresher.refresher-native');\n    if (nativeRefresher === null) {\n      (0,client/* writeTask */.Iu)(() => {\n        scaleLargeTitles(scrollHeaderIndex.toolbars, scale);\n      });\n    }\n  });\n};\nconst setToolbarBackgroundOpacity = (headerEl, opacity) => {\n  /**\n   * Fading in the backdrop opacity\n   * should happen after the large title\n   * has collapsed, so it is handled\n   * by handleHeaderFade()\n   */\n  if (headerEl.collapse === 'fade') {\n    return;\n  }\n  if (opacity === undefined) {\n    headerEl.style.removeProperty('--opacity-scale');\n  }\n  else {\n    headerEl.style.setProperty('--opacity-scale', opacity.toString());\n  }\n};\nconst handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {\n  if (!ev[0].isIntersecting) {\n    return;\n  }\n  /**\n   * There is a bug in Safari where overflow scrolling on a non-body element\n   * does not always reset the scrollTop position to 0 when letting go. It will\n   * set to 1 once the rubber band effect has ended. This causes the background to\n   * appear slightly on certain app setups.\n   *\n   * Additionally, we check if user is rubber banding (scrolling is negative)\n   * as this can mean they are using pull to refresh. Once the refresher starts,\n   * the content is transformed which can cause the intersection observer to erroneously\n   * fire here as well.\n   */\n  const scale = (ev[0].intersectionRatio > 0.9 || scrollTop <= 0) ? 0 : ((1 - ev[0].intersectionRatio) * 100) / 75;\n  setToolbarBackgroundOpacity(mainHeaderIndex.el, (scale === 1) ? undefined : scale);\n};\n/**\n * If toolbars are intersecting, hide the scrollable toolbar content\n * and show the primary toolbar content. If the toolbars are not intersecting,\n * hide the primary toolbar content and show the scrollable toolbar content\n */\nconst handleToolbarIntersection = (ev, mainHeaderIndex, scrollHeaderIndex, scrollEl) => {\n  (0,client/* writeTask */.Iu)(() => {\n    const scrollTop = scrollEl.scrollTop;\n    handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);\n    const event = ev[0];\n    const intersection = event.intersectionRect;\n    const intersectionArea = intersection.width * intersection.height;\n    const rootArea = event.rootBounds.width * event.rootBounds.height;\n    const isPageHidden = intersectionArea === 0 && rootArea === 0;\n    const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);\n    const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);\n    const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);\n    if (isPageHidden || isPageTransitioning) {\n      return;\n    }\n    if (event.isIntersecting) {\n      setHeaderActive(mainHeaderIndex, false);\n      setHeaderActive(scrollHeaderIndex);\n    }\n    else {\n      /**\n       * There is a bug with IntersectionObserver on Safari\n       * where `event.isIntersecting === false` when cancelling\n       * a swipe to go back gesture. Checking the intersection\n       * x, y, width, and height provides a workaround. This bug\n       * does not happen when using Safari + Web Animations,\n       * only Safari + CSS Animations.\n       */\n      const hasValidIntersection = (intersection.x === 0 && intersection.y === 0) || (intersection.width !== 0 && intersection.height !== 0);\n      if (hasValidIntersection && scrollTop > 0) {\n        setHeaderActive(mainHeaderIndex);\n        setHeaderActive(scrollHeaderIndex, false);\n        setToolbarBackgroundOpacity(mainHeaderIndex.el);\n      }\n    }\n  });\n};\nconst setHeaderActive = (headerIndex, active = true) => {\n  if (active) {\n    headerIndex.el.classList.remove('header-collapse-condense-inactive');\n  }\n  else {\n    headerIndex.el.classList.add('header-collapse-condense-inactive');\n  }\n};\nconst scaleLargeTitles = (toolbars = [], scale = 1, transition = false) => {\n  toolbars.forEach(toolbar => {\n    const ionTitle = toolbar.ionTitleEl;\n    const titleDiv = toolbar.innerTitleEl;\n    if (!ionTitle || ionTitle.size !== 'large') {\n      return;\n    }\n    titleDiv.style.transition = (transition) ? TRANSITION : '';\n    titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;\n  });\n};\nconst handleHeaderFade = (scrollEl, baseEl, condenseHeader) => {\n  (0,client/* readTask */.wj)(() => {\n    const scrollTop = scrollEl.scrollTop;\n    const baseElHeight = baseEl.clientHeight;\n    const fadeStart = (condenseHeader) ? condenseHeader.clientHeight : 0;\n    /**\n     * If we are using fade header with a condense\n     * header, then the toolbar backgrounds should\n     * not begin to fade in until the condense\n     * header has fully collapsed.\n     *\n     * Additionally, the main content should not\n     * overflow out of the container until the\n     * condense header has fully collapsed. When\n     * using just the condense header the content\n     * should overflow out of the container.\n     */\n    if ((condenseHeader !== null) && (scrollTop < fadeStart)) {\n      baseEl.style.setProperty('--opacity-scale', '0');\n      scrollEl.style.setProperty('clip-path', `inset(${baseElHeight}px 0px 0px 0px)`);\n      return;\n    }\n    const distanceToStart = scrollTop - fadeStart;\n    const fadeDuration = 10;\n    const scale = (0,helpers.j)(0, (distanceToStart / fadeDuration), 1);\n    (0,client/* writeTask */.Iu)(() => {\n      scrollEl.style.removeProperty('clip-path');\n      baseEl.style.setProperty('--opacity-scale', scale.toString());\n    });\n  });\n};\n\nconst headerIosCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:7px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{height:48px;padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}\";\n\nconst headerMdCss = \"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md::after{left:0;bottom:-5px;background-position:left 0 top -2px;position:absolute;width:100%;height:5px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==);background-repeat:repeat-x;content:\\\"\\\"}[dir=rtl] .header-md::after,:host-context([dir=rtl]) .header-md::after{left:unset;right:unset;right:0}[dir=rtl] .header-md::after,:host-context([dir=rtl]) .header-md::after{background-position:right 0 top -2px}.header-collapse-condense{display:none}.header-md.ion-no-border::after{display:none}\";\n\nconst Header = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.inheritedAttributes = {};\n    /**\n     * If `true`, the header will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     *\n     * Note: In order to scroll content behind the header, the `fullscreen`\n     * attribute needs to be set on the content.\n     */\n    this.translucent = false;\n    this.setupFadeHeader = async (contentEl, condenseHeader) => {\n      if (!contentEl) {\n        console.error('ion-header requires a content to collapse. Make sure there is an ion-content.');\n        return;\n      }\n      await new Promise(resolve => (0,helpers.c)(contentEl, resolve));\n      const scrollEl = this.scrollEl = await contentEl.getScrollElement();\n      /**\n       * Handle fading of toolbars on scroll\n       */\n      this.contentScrollCallback = () => { handleHeaderFade(this.scrollEl, this.el, condenseHeader); };\n      scrollEl.addEventListener('scroll', this.contentScrollCallback);\n      handleHeaderFade(this.scrollEl, this.el, condenseHeader);\n    };\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = (0,helpers.i)(this.el, ['role']);\n  }\n  componentDidLoad() {\n    this.checkCollapsibleHeader();\n  }\n  componentDidUpdate() {\n    this.checkCollapsibleHeader();\n  }\n  disconnectedCallback() {\n    this.destroyCollapsibleHeader();\n  }\n  async checkCollapsibleHeader() {\n    const mode = ionic_global_getIonMode(this);\n    if (mode !== 'ios') {\n      return;\n    }\n    const { collapse } = this;\n    const hasCondense = collapse === 'condense';\n    const hasFade = collapse === 'fade';\n    this.destroyCollapsibleHeader();\n    if (hasCondense) {\n      const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n      const contentEl = (pageEl) ? pageEl.querySelector('ion-content') : null;\n      // Cloned elements are always needed in iOS transition\n      (0,client/* writeTask */.Iu)(() => {\n        const title = cloneElement('ion-title');\n        title.size = 'large';\n        cloneElement('ion-back-button');\n      });\n      await this.setupCondenseHeader(contentEl, pageEl);\n    }\n    else if (hasFade) {\n      const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');\n      const contentEl = (pageEl) ? pageEl.querySelector('ion-content') : null;\n      const condenseHeader = (contentEl) ? contentEl.querySelector('ion-header[collapse=\"condense\"]') : null;\n      await this.setupFadeHeader(contentEl, condenseHeader);\n    }\n  }\n  destroyCollapsibleHeader() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      this.intersectionObserver = undefined;\n    }\n    if (this.scrollEl && this.contentScrollCallback) {\n      this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);\n      this.contentScrollCallback = undefined;\n    }\n    if (this.collapsibleMainHeader) {\n      this.collapsibleMainHeader.classList.remove('header-collapse-main');\n      this.collapsibleMainHeader = undefined;\n    }\n  }\n  async setupCondenseHeader(contentEl, pageEl) {\n    if (!contentEl || !pageEl) {\n      console.error('ion-header requires a content to collapse, make sure there is an ion-content.');\n      return;\n    }\n    if (typeof IntersectionObserver === 'undefined') {\n      return;\n    }\n    await new Promise(resolve => (0,helpers.c)(contentEl, resolve));\n    this.scrollEl = await contentEl.getScrollElement();\n    const headers = pageEl.querySelectorAll('ion-header');\n    this.collapsibleMainHeader = Array.from(headers).find((header) => header.collapse !== 'condense');\n    if (!this.collapsibleMainHeader) {\n      return;\n    }\n    const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);\n    const scrollHeaderIndex = createHeaderIndex(this.el);\n    if (!mainHeaderIndex || !scrollHeaderIndex) {\n      return;\n    }\n    setHeaderActive(mainHeaderIndex, false);\n    setToolbarBackgroundOpacity(mainHeaderIndex.el, 0);\n    /**\n     * Handle interaction between toolbar collapse and\n     * showing/hiding content in the primary ion-header\n     * as well as progressively showing/hiding the main header\n     * border as the top-most toolbar collapses or expands.\n     */\n    const toolbarIntersection = (ev) => { handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl); };\n    this.intersectionObserver = new IntersectionObserver(toolbarIntersection, { root: contentEl, threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] });\n    this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);\n    /**\n     * Handle scaling of large iOS titles and\n     * showing/hiding border on last toolbar\n     * in primary header\n     */\n    this.contentScrollCallback = () => { handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl); };\n    this.scrollEl.addEventListener('scroll', this.contentScrollCallback);\n    (0,client/* writeTask */.Iu)(() => {\n      if (this.collapsibleMainHeader !== undefined) {\n        this.collapsibleMainHeader.classList.add('header-collapse-main');\n      }\n    });\n  }\n  render() {\n    const { translucent, inheritedAttributes } = this;\n    const mode = ionic_global_getIonMode(this);\n    const collapse = this.collapse || 'none';\n    // banner role must be at top level, so remove role if inside a menu\n    const roleType = hostContext('ion-menu', this.el) ? 'none' : 'banner';\n    return ((0,client.h)(client/* Host */.AA, Object.assign({ role: roleType, class: {\n        [mode]: true,\n        // Used internally for styling\n        [`header-${mode}`]: true,\n        [`header-translucent`]: this.translucent,\n        [`header-collapse-${collapse}`]: true,\n        [`header-translucent-${mode}`]: this.translucent,\n      } }, inheritedAttributes), mode === 'ios' && translucent &&\n      (0,client.h)(\"div\", { class: \"header-background\" }), (0,client.h)(\"slot\", null)));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: headerIosCss,\n    md: headerMdCss\n  }; }\n}, [36, \"ion-header\", {\n    \"collapse\": [1],\n    \"translucent\": [4]\n  }]);\nfunction ion_header_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-header\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-header\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Header);\n      }\n      break;\n  } });\n}\n\nconst IonHeader = (/* unused pure expression or super */ null && (Header));\nconst ion_header_defineCustomElement = ion_header_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/label.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst labelIosCss = \".item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{white-space:normal}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{font-size:14px;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:14px}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate3d(0,  29px,  0);transform:translate3d(0,  29px,  0);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms ease-in-out;transition:-webkit-transform 150ms ease-in-out;transition:transform 150ms ease-in-out;transition:transform 150ms ease-in-out, -webkit-transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{-webkit-transform:translate3d(0,  28px,  0);transform:translate3d(0,  28px,  0)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:translate3d(0,  0,  0) scale(0.82);transform:translate3d(0,  0,  0) scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:22px;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4)}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}\";\n\nconst labelMdCss = \".item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{white-space:normal}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-md-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{-webkit-transition:none;transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:top left;transform-origin:top left}.label-stacked.label-rtl.sc-ion-label-md-h,.label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform-origin:top right;transform-origin:top right}.label-stacked.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.label-floating.sc-ion-label-md-h{-webkit-transform:translateY(96%);transform:translateY(96%);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}.ion-focused.label-floating.sc-ion-label-md-h,.ion-focused .label-floating.sc-ion-label-md-h,.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(-6px) scale(0.75);transform:translateY(-6px) scale(0.75);position:relative;max-width:-webkit-min-content;max-width:-moz-min-content;max-width:min-content;background-color:var(--ion-item-background, var(--ion-background-color, #fff));overflow:visible;z-index:3}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{position:absolute;width:4px;height:100%;background-color:var(--ion-item-background, var(--ion-background-color, #fff));content:\\\"\\\"}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before{left:calc(-1 * 4px)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{right:calc(-1 * 4px)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.sc-ion-label-md-h{-webkit-transform:translateX(-32px) translateY(-6px) scale(0.75);transform:translateX(-32px) translateY(-6px) scale(0.75)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating.label-rtl,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75);transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75)}.ion-focused.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #3880ff)}.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.item-fill-solid.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-base)}.ion-invalid.ion-touched.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--highlight-color-invalid)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:20px;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, #666666)}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}\";\n\nconst label_Label = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.ionColor = (0,client/* createEvent */.yM)(this, \"ionColor\", 7);\n    this.ionStyle = (0,client/* createEvent */.yM)(this, \"ionStyle\", 7);\n    this.inRange = false;\n    this.noAnimate = false;\n  }\n  componentWillLoad() {\n    this.inRange = !!this.el.closest('ion-range');\n    this.noAnimate = (this.position === 'floating');\n    this.emitStyle();\n    this.emitColor();\n  }\n  componentDidLoad() {\n    if (this.noAnimate) {\n      setTimeout(() => {\n        this.noAnimate = false;\n      }, 1000);\n    }\n  }\n  colorChanged() {\n    this.emitColor();\n  }\n  positionChanged() {\n    this.emitStyle();\n  }\n  emitColor() {\n    const { color } = this;\n    this.ionColor.emit({\n      'item-label-color': color !== undefined,\n      [`ion-color-${color}`]: color !== undefined\n    });\n  }\n  emitStyle() {\n    const { inRange, position } = this;\n    // If the label is inside of a range we don't want\n    // to override the classes added by the label that\n    // is a direct child of the item\n    if (!inRange) {\n      this.ionStyle.emit({\n        'label': true,\n        [`label-${position}`]: position !== undefined\n      });\n    }\n  }\n  render() {\n    const position = this.position;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n        'in-item-color': hostContext('ion-item.ion-color', this.el),\n        [`label-${position}`]: position !== undefined,\n        [`label-no-animate`]: (this.noAnimate),\n        'label-rtl': document.dir === 'rtl'\n      }) }));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"color\": [\"colorChanged\"],\n    \"position\": [\"positionChanged\"]\n  }; }\n  static get style() { return {\n    ios: labelIosCss,\n    md: labelMdCss\n  }; }\n}, [34, \"ion-label\", {\n    \"color\": [513],\n    \"position\": [1],\n    \"noAnimate\": [32]\n  }]);\nfunction label_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-label\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-label\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, label_Label);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-label.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst IonLabel = (/* unused pure expression or super */ null && (Label));\nconst ion_label_defineCustomElement = label_defineCustomElement;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/list.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst listIosCss = \"ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-ios{background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-ios.list-inset{margin-left:16px;margin-right:16px;margin-top:16px;margin-bottom:16px;border-radius:10px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.list-ios.list-inset{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}.list-ios.list-inset ion-item{--border-width:0 0 1px 0;--inner-border-width:0}.list-ios.list-inset ion-item:last-child{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item{--border-width:0;--inner-border-width:0}.list-ios-lines-full .item,.list-ios .item-lines-full{--border-width:0 0 0.55px 0}.list-ios-lines-full .item{--inner-border-width:0}.list-ios-lines-inset .item,.list-ios .item-lines-inset{--inner-border-width:0 0 0.55px 0}.list-ios .item-lines-inset{--border-width:0}.list-ios .item-lines-full{--inner-border-width:0}.list-ios .item-lines-none{--border-width:0;--inner-border-width:0}ion-card .list-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\n\nconst listMdCss = \"ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:hidden}.list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-md>.input:last-child::after{left:0}[dir=rtl] .list-md>.input:last-child::after,:host-context([dir=rtl]) .list-md>.input:last-child::after{left:unset;right:unset;right:0}.list-md.list-inset{margin-left:16px;margin-right:16px;margin-top:16px;margin-bottom:16px;border-radius:2px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.list-md.list-inset{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}.list-md.list-inset ion-item:first-child{--border-radius:2px 2px 0 0;--border-width:0 0 1px 0}.list-md.list-inset ion-item:last-child{--border-radius:0 0 2px, 2px;--border-width:0}.list-md.list-inset .item-interactive{--padding-start:0;--padding-end:0}.list-md.list-inset+ion-list.list-inset{margin-top:0}.list-md-lines-none .item{--border-width:0;--inner-border-width:0}.list-md-lines-full .item,.list-md .item-lines-full{--border-width:0 0 1px 0}.list-md-lines-full .item{--inner-border-width:0}.list-md-lines-inset .item,.list-md .item-lines-inset{--inner-border-width:0 0 1px 0}.list-md .item-lines-inset{--border-width:0}.list-md .item-lines-full{--inner-border-width:0}.list-md .item-lines-none{--border-width:0;--inner-border-width:0}ion-card .list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\n\nconst list_List = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    /**\n     * If `true`, the list will have margin around it and rounded corners.\n     */\n    this.inset = false;\n  }\n  /**\n   * If `ion-item-sliding` are used inside the list, this method closes\n   * any open sliding item.\n   *\n   * Returns `true` if an actual `ion-item-sliding` is closed.\n   */\n  async closeSlidingItems() {\n    const item = this.el.querySelector('ion-item-sliding');\n    if (item && item.closeOpened) {\n      return item.closeOpened();\n    }\n    return false;\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    const { lines, inset } = this;\n    return ((0,client.h)(client/* Host */.AA, { class: {\n        [mode]: true,\n        // Used internally for styling\n        [`list-${mode}`]: true,\n        'list-inset': inset,\n        [`list-lines-${lines}`]: lines !== undefined,\n        [`list-${mode}-lines-${lines}`]: lines !== undefined\n      } }));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: listIosCss,\n    md: listMdCss\n  }; }\n}, [32, \"ion-list\", {\n    \"lines\": [1],\n    \"inset\": [4],\n    \"closeSlidingItems\": [64]\n  }]);\nfunction list_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-list\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-list\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, list_List);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-list.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst IonList = (/* unused pure expression or super */ null && (List));\nconst ion_list_defineCustomElement = list_defineCustomElement;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/list-header.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst listHeaderIosCss = \":host{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.list-header-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex:1 1 auto;flex:1 1 auto}:host(.list-header-lines-inset),:host(.list-header-lines-none){--border-width:0}:host(.list-header-lines-full),:host(.list-header-lines-none){--inner-border-width:0}:host{--background:transparent;--color:var(--ion-color-step-850, #262626);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));padding-left:calc(var(--ion-safe-area-left, 0px) + 20px);position:relative;-ms-flex-align:end;align-items:flex-end;font-size:22px;font-weight:700;letter-spacing:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;-webkit-padding-start:calc(var(--ion-safe-area-left, 0px) + 20px);padding-inline-start:calc(var(--ion-safe-area-left, 0px) + 20px)}}::slotted(ion-button),::slotted(ion-label){margin-top:29px;margin-bottom:6px}::slotted(ion-button){margin-left:3px;margin-right:3px;height:1.4em}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-button){margin-left:unset;margin-right:unset;-webkit-margin-start:3px;margin-inline-start:3px;-webkit-margin-end:3px;margin-inline-end:3px}}:host(.list-header-lines-full){--border-width:0 0 0.55px 0}:host(.list-header-lines-inset){--inner-border-width:0 0 0.55px 0}\";\n\nconst listHeaderMdCss = \":host{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}.list-header-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex:1 1 auto;flex:1 1 auto}:host(.list-header-lines-inset),:host(.list-header-lines-none){--border-width:0}:host(.list-header-lines-full),:host(.list-header-lines-none){--inner-border-width:0}:host{--background:transparent;--color:var(--ion-text-color, #000);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));padding-left:calc(var(--ion-safe-area-left, 0) + 16px);min-height:45px;font-size:14px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;-webkit-padding-start:calc(var(--ion-safe-area-left, 0) + 16px);padding-inline-start:calc(var(--ion-safe-area-left, 0) + 16px)}}:host(.list-header-lines-full){--border-width:0 0 1px 0}:host(.list-header-lines-inset){--inner-border-width:0 0 1px 0}\";\n\nconst list_header_ListHeader = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n  }\n  render() {\n    const { lines } = this;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n        [`list-header-lines-${lines}`]: lines !== undefined,\n      }) }, (0,client.h)(\"div\", { class: \"list-header-inner\" }, (0,client.h)(\"slot\", null))));\n  }\n  static get style() { return {\n    ios: listHeaderIosCss,\n    md: listHeaderMdCss\n  }; }\n}, [33, \"ion-list-header\", {\n    \"color\": [513],\n    \"lines\": [1]\n  }]);\nfunction list_header_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-list-header\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-list-header\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, list_header_ListHeader);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-list-header.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst IonListHeader = (/* unused pure expression or super */ null && (ListHeader));\nconst ion_list_header_defineCustomElement = list_header_defineCustomElement;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-text.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst textCss = \":host(.ion-color){color:var(--ion-color-base)}\";\n\nconst Text = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n      }) }, (0,client.h)(\"slot\", null)));\n  }\n  static get style() { return textCss; }\n}, [1, \"ion-text\", {\n    \"color\": [513]\n  }]);\nfunction ion_text_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-text\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-text\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Text);\n      }\n      break;\n  } });\n}\n\nconst IonText = (/* unused pure expression or super */ null && (Text));\nconst ion_text_defineCustomElement = ion_text_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-title.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst titleIosCss = \":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{left:0;top:0;padding-left:90px;padding-right:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);font-size:17px;font-weight:600;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px}}:host(.title-small){padding-left:9px;padding-right:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:13px;font-weight:normal}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.title-small){padding-left:unset;padding-right:unset;-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px}}:host(.title-large){padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:0;-webkit-transform-origin:left center;transform-origin:left center;bottom:0;-ms-flex-align:end;align-items:flex-end;min-width:100%;padding-bottom:6px;font-size:34px;font-weight:700;text-align:start}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.title-large){padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host(.title-large.title-rtl){-webkit-transform-origin:right center;transform-origin:right center}:host(.title-large.ion-cloned-element){--color:var(--ion-text-color, #000)}:host(.title-large) .toolbar-title{-webkit-transform-origin:inherit;transform-origin:inherit}:host-context([dir=rtl]):host(.title-large) .toolbar-title,:host-context([dir=rtl]).title-large .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}\";\n\nconst titleMdCss = \":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{padding-left:20px;padding-right:20px;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;letter-spacing:0.0125em}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px}}:host(.title-small){width:100%;height:100%;font-size:15px;font-weight:normal}\";\n\nconst ToolbarTitle = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionStyle = (0,client/* createEvent */.yM)(this, \"ionStyle\", 7);\n  }\n  sizeChanged() {\n    this.emitStyle();\n  }\n  connectedCallback() {\n    this.emitStyle();\n  }\n  emitStyle() {\n    const size = this.getSize();\n    this.ionStyle.emit({\n      [`title-${size}`]: true\n    });\n  }\n  getSize() {\n    return (this.size !== undefined) ? this.size : 'default';\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    const size = this.getSize();\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n        [`title-${size}`]: true,\n        'title-rtl': document.dir === 'rtl'\n      }) }, (0,client.h)(\"div\", { class: \"toolbar-title\" }, (0,client.h)(\"slot\", null))));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"size\": [\"sizeChanged\"]\n  }; }\n  static get style() { return {\n    ios: titleIosCss,\n    md: titleMdCss\n  }; }\n}, [33, \"ion-title\", {\n    \"color\": [513],\n    \"size\": [1]\n  }]);\nfunction ion_title_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-title\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-title\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, ToolbarTitle);\n      }\n      break;\n  } });\n}\n\nconst IonTitle = (/* unused pure expression or super */ null && (ToolbarTitle));\nconst ion_title_defineCustomElement = ion_title_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-toolbar.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst toolbarIosCss = \":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toolbar-container{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-color-step-50, #f7f7f7));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:4;order:4;min-width:0}:host(.toolbar-segment) .toolbar-content{display:-ms-inline-flexbox;display:inline-flex}:host(.toolbar-searchbar) .toolbar-container{padding-top:0;padding-bottom:0}:host(.toolbar-searchbar) ::slotted(*){-ms-flex-item-align:start;align-self:start}:host(.toolbar-searchbar) ::slotted(ion-chip){margin-top:3px}:host(.toolbar-searchbar) ::slotted(ion-back-button){height:38px}::slotted(ion-buttons){min-height:38px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:3;order:3}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}:host(.toolbar-title-large) .toolbar-container{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start}:host(.toolbar-title-large) .toolbar-content ion-title{-ms-flex:1;flex:1;-ms-flex-order:8;order:8;min-width:100%}\";\n\nconst toolbarMdCss = \":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.toolbar-container{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, #c1c4cd)));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:3;order:3;min-width:0;max-width:100%}::slotted(ion-segment){min-height:var(--min-height)}::slotted(.buttons-first-slot){margin-left:4px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(.buttons-first-slot){margin-left:unset;-webkit-margin-start:4px;margin-inline-start:4px}}::slotted(.buttons-last-slot){margin-right:4px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(.buttons-last-slot){margin-right:unset;-webkit-margin-end:4px;margin-inline-end:4px}}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:4;order:4}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}\";\n\nconst Toolbar = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.childrenStyles = new Map();\n  }\n  componentWillLoad() {\n    const buttons = Array.from(this.el.querySelectorAll('ion-buttons'));\n    const firstButtons = buttons.find(button => {\n      return button.slot === 'start';\n    });\n    if (firstButtons) {\n      firstButtons.classList.add('buttons-first-slot');\n    }\n    const buttonsReversed = buttons.reverse();\n    const lastButtons = buttonsReversed.find(button => button.slot === 'end') ||\n      buttonsReversed.find(button => button.slot === 'primary') ||\n      buttonsReversed.find(button => button.slot === 'secondary');\n    if (lastButtons) {\n      lastButtons.classList.add('buttons-last-slot');\n    }\n  }\n  childrenStyle(ev) {\n    ev.stopPropagation();\n    const tagName = ev.target.tagName;\n    const updatedStyles = ev.detail;\n    const newStyles = {};\n    const childStyles = this.childrenStyles.get(tagName) || {};\n    let hasStyleChange = false;\n    Object.keys(updatedStyles).forEach(key => {\n      const childKey = `toolbar-${key}`;\n      const newValue = updatedStyles[key];\n      if (newValue !== childStyles[childKey]) {\n        hasStyleChange = true;\n      }\n      if (newValue) {\n        newStyles[childKey] = true;\n      }\n    });\n    if (hasStyleChange) {\n      this.childrenStyles.set(tagName, newStyles);\n      (0,client/* forceUpdate */.xE)(this);\n    }\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    const childStyles = {};\n    this.childrenStyles.forEach(value => {\n      Object.assign(childStyles, value);\n    });\n    return ((0,client.h)(client/* Host */.AA, { class: Object.assign(Object.assign({}, childStyles), createColorClasses(this.color, {\n        [mode]: true,\n        'in-toolbar': hostContext('ion-toolbar', this.el),\n      })) }, (0,client.h)(\"div\", { class: \"toolbar-background\" }), (0,client.h)(\"div\", { class: \"toolbar-container\" }, (0,client.h)(\"slot\", { name: \"start\" }), (0,client.h)(\"slot\", { name: \"secondary\" }), (0,client.h)(\"div\", { class: \"toolbar-content\" }, (0,client.h)(\"slot\", null)), (0,client.h)(\"slot\", { name: \"primary\" }), (0,client.h)(\"slot\", { name: \"end\" }))));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: toolbarIosCss,\n    md: toolbarMdCss\n  }; }\n}, [33, \"ion-toolbar\", {\n    \"color\": [513]\n  }, [[0, \"ionStyle\", \"childrenStyle\"]]]);\nfunction ion_toolbar_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-toolbar\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-toolbar\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Toolbar);\n      }\n      break;\n  } });\n}\n\nconst IonToolbar = (/* unused pure expression or super */ null && (Toolbar));\nconst ion_toolbar_defineCustomElement = ion_toolbar_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/button.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\nconst buttonIosCss = \":host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){margin-left:-0.3em;margin-right:0.3em;margin-top:0;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}::slotted(ion-icon[slot=end]){margin-left:0.3em;margin-right:-0.2em;margin-top:0;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em}}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host{--border-radius:10px;--padding-top:0;--padding-bottom:0;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;margin-left:2px;margin-right:2px;margin-top:4px;margin-bottom:4px;height:2.8em;font-size:16px;font-weight:500;letter-spacing:-0.03em}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}:host(.button-solid){--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}:host(.button-outline){--border-radius:10px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #3880ff);--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;font-size:17px;font-weight:normal;letter-spacing:0}:host(.button-large){--border-radius:12px;--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}:host(.button-small){--border-radius:6px;--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}:host(.button-clear.ion-activated){opacity:0.4}:host(.button-outline.ion-activated.ion-color) .button-native{color:var(--ion-color-contrast)}:host(.button-outline.ion-activated.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}:host(.button-outline.ion-focused.ion-color) .button-native,:host(.button-clear.ion-focused.ion-color) .button-native{color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native::after,:host(.button-clear.ion-focused.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.button-clear:hover),:host(.button-outline:hover){opacity:0.6}:host(.button-clear.ion-color:hover) .button-native,:host(.button-outline.ion-color:hover) .button-native{color:var(--ion-color-base)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:transparent}:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native::after{background:#fff;opacity:0.1}}\";\n\nconst buttonMdCss = \":host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){margin-left:-0.3em;margin-right:0.3em;margin-top:0;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}::slotted(ion-icon[slot=end]){margin-left:0.3em;margin-right:-0.2em;margin-top:0;margin-bottom:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em}}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host{--border-radius:4px;--padding-top:0;--padding-bottom:0;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\\n                background-color 15ms linear,\\n                color 15ms linear;margin-left:2px;margin-right:2px;margin-top:4px;margin-bottom:4px;height:36px;font-size:14px;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}:host(.button-solid){--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}:host(.button-solid.ion-activated){--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}:host(.button-outline){--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-outline.ion-activated.ion-color) .button-native{background:transparent}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-large){--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}:host(.button-small){--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-strong){font-weight:bold}::slotted(ion-icon[slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color.ion-focused) .button-native::after,:host(.button-outline.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}\";\n\nconst Button = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionFocus = (0,client/* createEvent */.yM)(this, \"ionFocus\", 7);\n    this.ionBlur = (0,client/* createEvent */.yM)(this, \"ionBlur\", 7);\n    this.inItem = false;\n    this.inListHeader = false;\n    this.inToolbar = false;\n    this.inheritedAttributes = {};\n    /**\n     * The type of button.\n     */\n    this.buttonType = 'button';\n    /**\n     * If `true`, the user cannot interact with the button.\n     */\n    this.disabled = false;\n    /**\n     * When using a router, it specifies the transition direction when navigating to\n     * another page using `href`.\n     */\n    this.routerDirection = 'forward';\n    /**\n     * If `true`, activates a button with a heavier font weight.\n     */\n    this.strong = false;\n    /**\n     * The type of the button.\n     */\n    this.type = 'button';\n    this.handleClick = (ev) => {\n      if (this.type === 'button') {\n        openURL(this.href, ev, this.routerDirection, this.routerAnimation);\n      }\n      else if ((0,helpers.h)(this.el)) {\n        // this button wants to specifically submit a form\n        // climb up the dom to see if we're in a <form>\n        // and if so, then use JS to submit it\n        const form = this.el.closest('form');\n        if (form) {\n          ev.preventDefault();\n          const fakeButton = document.createElement('button');\n          fakeButton.type = this.type;\n          fakeButton.style.display = 'none';\n          form.appendChild(fakeButton);\n          fakeButton.click();\n          fakeButton.remove();\n        }\n      }\n    };\n    this.onFocus = () => {\n      this.ionFocus.emit();\n    };\n    this.onBlur = () => {\n      this.ionBlur.emit();\n    };\n  }\n  componentWillLoad() {\n    this.inToolbar = !!this.el.closest('ion-buttons');\n    this.inListHeader = !!this.el.closest('ion-list-header');\n    this.inItem = !!this.el.closest('ion-item') || !!this.el.closest('ion-item-divider');\n    this.inheritedAttributes = (0,helpers.i)(this.el, ['aria-label']);\n  }\n  get hasIconOnly() {\n    return !!this.el.querySelector('[slot=\"icon-only\"]');\n  }\n  get rippleType() {\n    const hasClearFill = this.fill === undefined || this.fill === 'clear';\n    // If the button is in a toolbar, has a clear fill (which is the default)\n    // and only has an icon we use the unbounded \"circular\" ripple effect\n    if (hasClearFill && this.hasIconOnly && this.inToolbar) {\n      return 'unbounded';\n    }\n    return 'bounded';\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    const { buttonType, type, disabled, rel, target, size, href, color, expand, hasIconOnly, shape, strong, inheritedAttributes } = this;\n    const finalSize = size === undefined && this.inItem ? 'small' : size;\n    const TagType = href === undefined ? 'button' : 'a';\n    const attrs = (TagType === 'button')\n      ? { type }\n      : {\n        download: this.download,\n        href,\n        rel,\n        target\n      };\n    let fill = this.fill;\n    if (fill === undefined) {\n      fill = this.inToolbar || this.inListHeader ? 'clear' : 'solid';\n    }\n    return ((0,client.h)(client/* Host */.AA, { onClick: this.handleClick, \"aria-disabled\": disabled ? 'true' : null, class: createColorClasses(color, {\n        [mode]: true,\n        [buttonType]: true,\n        [`${buttonType}-${expand}`]: expand !== undefined,\n        [`${buttonType}-${finalSize}`]: finalSize !== undefined,\n        [`${buttonType}-${shape}`]: shape !== undefined,\n        [`${buttonType}-${fill}`]: true,\n        [`${buttonType}-strong`]: strong,\n        'in-toolbar': hostContext('ion-toolbar', this.el),\n        'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),\n        'button-has-icon-only': hasIconOnly,\n        'button-disabled': disabled,\n        'ion-activatable': true,\n        'ion-focusable': true,\n      }) }, (0,client.h)(TagType, Object.assign({}, attrs, { class: \"button-native\", part: \"native\", disabled: disabled, onFocus: this.onFocus, onBlur: this.onBlur }, inheritedAttributes), (0,client.h)(\"span\", { class: \"button-inner\" }, (0,client.h)(\"slot\", { name: \"icon-only\" }), (0,client.h)(\"slot\", { name: \"start\" }), (0,client.h)(\"slot\", null), (0,client.h)(\"slot\", { name: \"end\" })), mode === 'md' && (0,client.h)(\"ion-ripple-effect\", { type: this.rippleType }))));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: buttonIosCss,\n    md: buttonMdCss\n  }; }\n}, [33, \"ion-button\", {\n    \"color\": [513],\n    \"buttonType\": [1025, \"button-type\"],\n    \"disabled\": [516],\n    \"expand\": [513],\n    \"fill\": [1537],\n    \"routerDirection\": [1, \"router-direction\"],\n    \"routerAnimation\": [16],\n    \"download\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"shape\": [513],\n    \"size\": [513],\n    \"strong\": [4],\n    \"target\": [1],\n    \"type\": [1]\n  }]);\nfunction button_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-button\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-button\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Button);\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$1();\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-button.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst IonButton = Button;\nconst ion_button_defineCustomElement = (/* unused pure expression or super */ null && (defineCustomElement$1));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-card.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\nconst cardIosCss = \":host{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.card-disabled){cursor:default;opacity:0.3;pointer-events:none}.card-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}.card-native::-moz-focus-inner{border:0}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}ion-ripple-effect{color:var(--ripple-color)}:host{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-600, #666666)));margin-left:16px;margin-right:16px;margin-top:24px;margin-bottom:24px;border-radius:8px;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-transition:-webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:-webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);transition:transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1), -webkit-transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);font-size:14px;-webkit-box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);box-shadow:0 4px 16px rgba(0, 0, 0, 0.12)}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}:host(.ion-activated){-webkit-transform:scale3d(0.97, 0.97, 1);transform:scale3d(0.97, 0.97, 1)}\";\n\nconst cardMdCss = \":host{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden}:host(.ion-color){background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.card-disabled){cursor:default;opacity:0.3;pointer-events:none}.card-native{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}.card-native::-moz-focus-inner{border:0}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}ion-ripple-effect{color:var(--ripple-color)}:host{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-550, #737373)));margin-left:10px;margin-right:10px;margin-top:10px;margin-bottom:10px;border-radius:4px;font-size:14px;-webkit-box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}\";\n\nconst Card = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    /**\n     * If `true`, a button tag will be rendered and the card will be tappable.\n     */\n    this.button = false;\n    /**\n     * The type of the button. Only used when an `onclick` or `button` property is present.\n     */\n    this.type = 'button';\n    /**\n     * If `true`, the user cannot interact with the card.\n     */\n    this.disabled = false;\n    /**\n     * When using a router, it specifies the transition direction when navigating to\n     * another page using `href`.\n     */\n    this.routerDirection = 'forward';\n  }\n  isClickable() {\n    return (this.href !== undefined || this.button);\n  }\n  renderCard(mode) {\n    const clickable = this.isClickable();\n    if (!clickable) {\n      return [\n        (0,client.h)(\"slot\", null)\n      ];\n    }\n    const { href, routerAnimation, routerDirection } = this;\n    const TagType = clickable ? (href === undefined ? 'button' : 'a') : 'div';\n    const attrs = (TagType === 'button')\n      ? { type: this.type }\n      : {\n        download: this.download,\n        href: this.href,\n        rel: this.rel,\n        target: this.target\n      };\n    return ((0,client.h)(TagType, Object.assign({}, attrs, { class: \"card-native\", part: \"native\", disabled: this.disabled, onClick: (ev) => openURL(href, ev, routerDirection, routerAnimation) }), (0,client.h)(\"slot\", null), clickable && mode === 'md' && (0,client.h)(\"ion-ripple-effect\", null)));\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { class: createColorClasses(this.color, {\n        [mode]: true,\n        'card-disabled': this.disabled,\n        'ion-activatable': this.isClickable()\n      }) }, this.renderCard(mode)));\n  }\n  static get style() { return {\n    ios: cardIosCss,\n    md: cardMdCss\n  }; }\n}, [33, \"ion-card\", {\n    \"color\": [513],\n    \"button\": [4],\n    \"type\": [1],\n    \"disabled\": [4],\n    \"download\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"routerDirection\": [1, \"router-direction\"],\n    \"routerAnimation\": [16],\n    \"target\": [1]\n  }]);\nfunction ion_card_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-card\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-card\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Card);\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$2();\n      }\n      break;\n  } });\n}\n\nconst IonCard = Card;\nconst ion_card_defineCustomElement = (/* unused pure expression or super */ null && (ion_card_defineCustomElement$1));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/index6.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/* Ionicons v6.0.0, ES Modules */\nconst arrowBackSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Arrow Back</title><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>\";\nconst arrowDown = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Arrow Down</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M112 268l144 144 144-144M256 392V100' class='ionicon-fill-none'/></svg>\";\nconst caretBackSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Caret Back</title><path d='M368 64L144 256l224 192V64z'/></svg>\";\nconst caretDownSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Caret Down</title><path d='M64 144l192 224 192-224H64z'/></svg>\";\nconst caretUpSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Caret Up</title><path d='M448 368L256 144 64 368h384z'/></svg>\";\nconst chevronBack = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Back</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M328 112L184 256l144 144' class='ionicon-fill-none'/></svg>\";\nconst chevronDown = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Down</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M112 184l144 144 144-144' class='ionicon-fill-none'/></svg>\";\nconst chevronForward = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Forward</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>\";\nconst chevronForwardOutline = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Forward</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>\";\nconst index6_close = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close</title><path d='M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z'/></svg>\";\nconst closeCircle = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close Circle</title><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>\";\nconst closeSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close</title><path d='M400 145.49L366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49z'/></svg>\";\nconst ellipsisHorizontal = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Ellipsis Horizontal</title><circle cx='256' cy='256' r='48'/><circle cx='416' cy='256' r='48'/><circle cx='96' cy='256' r='48'/></svg>\";\nconst menuOutline = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Menu</title><path stroke-linecap='round' stroke-miterlimit='10' d='M80 160h352M80 256h352M80 352h352' class='ionicon-fill-none ionicon-stroke-width'/></svg>\";\nconst menuSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Menu</title><path d='M64 384h384v-42.67H64zm0-106.67h384v-42.66H64zM64 128v42.67h384V128z'/></svg>\";\nconst reorderThreeOutline = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Reorder Three</title><path stroke-linecap='round' stroke-linejoin='round' d='M96 256h320M96 176h320M96 336h320' class='ionicon-fill-none ionicon-stroke-width'/></svg>\";\nconst reorderTwoSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Reorder Two</title><path stroke-linecap='square' stroke-linejoin='round' stroke-width='44' d='M118 304h276M118 208h276' class='ionicon-fill-none'/></svg>\";\nconst searchOutline = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Search</title><path d='M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M338.29 338.29L448 448' class='ionicon-fill-none ionicon-stroke-width'/></svg>\";\nconst searchSharp = \"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Search</title><path d='M464 428L339.92 303.9a160.48 160.48 0 0030.72-94.58C370.64 120.37 298.27 48 209.32 48S48 120.37 48 209.32s72.37 161.32 161.32 161.32a160.48 160.48 0 0094.58-30.72L428 464zM209.32 319.69a110.38 110.38 0 11110.37-110.37 110.5 110.5 0 01-110.37 110.37z'/></svg>\";\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/item.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\n\n\n\nconst itemIosCss = \":host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-native{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-inner{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--inner-padding-end);padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-bottom{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--inner-padding-end);padding-inline-end:var(--inner-padding-end)}}.item-detail-icon{color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.item-has-focus) .item-native{caret-color:var(--highlight-background)}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select),:host(.item-label-floating) ::slotted(ion-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:12px;z-index:1}.item-counter{margin-left:auto;-webkit-padding-start:16px;padding-inline-start:16px;white-space:nowrap}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-counter{margin-left:unset;-webkit-margin-start:auto;margin-inline-start:auto}}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:44px;--transition:background-color 200ms linear, opacity 200ms linear;--padding-start:20px;--inner-padding-end:10px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:#000;--background-focused:#000;--background-hover:currentColor;--background-activated-opacity:.12;--background-focused-opacity:.15;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--color:var(--ion-item-color, var(--ion-text-color, #000));--highlight-height:0px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);--bottom-padding-start:0px;font-size:17px}:host(.ion-activated){--transition:none}:host(.ion-color.ion-focused) .item-native::after{background:#000;opacity:0.15}:host(.ion-color.ion-activated) .item-native::after{background:#000;opacity:0.12}:host(.item-interactive){--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-full){--border-width:0px 0px 0.55px 0px;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0px 0px 0.55px 0px;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0px;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0px;--show-inset-highlight:0}.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}:host(.item-has-focus) .item-inner-highlight,:host(.item-has-focus) .item-highlight{border-top:none;border-right:none;border-left:none}::slotted([slot=start]){margin-left:0;margin-right:20px;margin-top:2px;margin-bottom:2px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted([slot=start]){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:20px;margin-inline-end:20px}}::slotted([slot=end]){margin-left:10px;margin-right:10px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted([slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}::slotted(ion-icon[slot=start]),::slotted(ion-icon[slot=end]){margin-top:7px;margin-bottom:7px}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}::slotted(.button-small){--padding-top:0px;--padding-bottom:0px;--padding-start:.5em;--padding-end:.5em;height:24px;font-size:13px}::slotted(ion-avatar){width:36px;height:36px}::slotted(ion-thumbnail){width:56px;height:56px}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:10px;margin-right:10px;margin-top:10px;margin-bottom:10px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){margin-left:0px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.item-radio) ::slotted(ion-label),:host(.item-toggle) ::slotted(ion-label){margin-left:unset;-webkit-margin-start:0px;margin-inline-start:0px}}::slotted(ion-label){margin-left:0;margin-right:8px;margin-top:10px;margin-bottom:10px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-label){margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}:host(.item-label-floating),:host(.item-label-stacked){--min-height:68px}:host(.item-label-stacked) ::slotted(ion-select),:host(.item-label-floating) ::slotted(ion-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0px}:host(.item-label-fixed) ::slotted(ion-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:0}\";\n\nconst itemMdCss = \":host{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-native,:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) .item-inner{border-color:var(--ion-color-shade)}:host(.ion-activated) .item-native{color:var(--color-activated)}:host(.ion-activated) .item-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.ion-color.ion-activated) .item-native{color:var(--ion-color-contrast)}:host(.ion-focused) .item-native{color:var(--color-focused)}:host(.ion-focused) .item-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(.ion-color.ion-focused) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-focused) .item-native::after{background:var(--ion-color-contrast)}@media (any-hover: hover){:host(.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--color-hover)}:host(.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native{color:var(--ion-color-contrast)}:host(.ion-color.ion-activatable:not(.ion-focused):hover) .item-native::after{background:var(--ion-color-contrast)}}:host(.item-interactive-disabled:not(.item-multiple-inputs)){cursor:default;pointer-events:none}:host(.item-disabled){cursor:default;opacity:0.3;pointer-events:none}.item-native{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-native{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.item-native::-moz-focus-inner{border:0}.item-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0;-webkit-transition:var(--transition);transition:var(--transition);z-index:-1}button,a{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.item-inner{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);-webkit-box-shadow:var(--inner-box-shadow);box-shadow:var(--inner-box-shadow);overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-inner{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}.item-bottom{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--inner-padding-end);padding-top:0;padding-bottom:0;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-bottom{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--inner-padding-end);padding-inline-end:var(--inner-padding-end)}}.item-detail-icon{color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}::slotted(ion-icon){font-size:1.6em}::slotted(ion-button){--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}::slotted(ion-label:not([slot=end])){-ms-flex:1;flex:1}:host(.item-input){-ms-flex-align:center;align-items:center}.input-wrapper{display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-item-align:stretch;align-self:stretch;text-overflow:ellipsis;overflow:inherit;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.item-label-stacked),:host(.item-label-floating){-ms-flex-align:start;align-items:start}:host(.item-label-stacked) .input-wrapper,:host(.item-label-floating) .input-wrapper{-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column}.item-highlight,.item-inner-highlight{left:0;right:0;top:0;bottom:0;border-radius:inherit;position:absolute;width:100%;height:100%;-webkit-transform:scaleX(0);transform:scaleX(0);-webkit-transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:border-bottom-width 200ms, -webkit-transform 200ms;transition:transform 200ms, border-bottom-width 200ms;transition:transform 200ms, border-bottom-width 200ms, -webkit-transform 200ms;z-index:2;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.item-interactive.item-has-focus) .item-native{caret-color:var(--highlight-background)}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus),:host(.item-interactive.ion-touched.ion-invalid){--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}:host(.item-interactive.ion-focused),:host(.item-interactive.item-has-focus){--highlight-background:var(--highlight-color-focused)}:host(.item-interactive.ion-valid){--highlight-background:var(--highlight-color-valid)}:host(.item-interactive.ion-invalid){--highlight-background:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=helper]){display:none}::slotted([slot=error]){display:none;color:var(--highlight-color-invalid)}:host(.item-interactive.ion-invalid) ::slotted([slot=error]){display:block}:host(:not(.item-label)) ::slotted(ion-select){--padding-start:0;max-width:none}:host(.item-label-stacked) ::slotted(ion-select),:host(.item-label-floating) ::slotted(ion-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0;-ms-flex-item-align:stretch;align-self:stretch;width:100%;max-width:100%}:host(:not(.item-label)) ::slotted(ion-datetime){--padding-start:0}:host(.item-label-stacked) ::slotted(ion-datetime),:host(.item-label-floating) ::slotted(ion-datetime){--padding-start:0;width:100%}:host(.item-multiple-inputs) ::slotted(ion-checkbox),:host(.item-multiple-inputs) ::slotted(ion-datetime),:host(.item-multiple-inputs) ::slotted(ion-radio),:host(.item-multiple-inputs) ::slotted(ion-select){position:relative}:host(.item-textarea){-ms-flex-align:stretch;align-items:stretch}::slotted(ion-reorder[slot]){margin-top:0;margin-bottom:0}ion-ripple-effect{color:var(--ripple-color)}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted([slot=helper]),::slotted([slot=error]),.item-counter{padding-top:5px;font-size:12px;z-index:1}.item-counter{margin-left:auto;-webkit-padding-start:16px;padding-inline-start:16px;white-space:nowrap}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.item-counter{margin-left:unset;-webkit-margin-start:auto;margin-inline-start:auto}}@media (prefers-reduced-motion: reduce){.item-highlight,.item-inner-highlight{-webkit-transition:none;transition:none}}:host{--min-height:48px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--color:var(--ion-item-color, var(--ion-text-color, #000));--transition:opacity 15ms linear, background-color 15ms linear;--padding-start:16px;--inner-padding-end:16px;--inner-border-width:0 0 1px 0;--highlight-height:1px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);font-size:16px;font-weight:normal;text-transform:none}:host(.item-fill-outline){--highlight-height:2px}:host(.item-fill-none.item-interactive.ion-focus) .item-highlight,:host(.item-fill-none.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-none.item-interactive.ion-focus) .item-native,:host(.item-fill-none.item-interactive.item-has-focus) .item-native,:host(.item-fill-none.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1)}:host(.item-fill-outline.item-interactive.ion-focus) .item-highlight,:host(.item-fill-outline.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-highlight{border-width:var(--full-highlight-height);border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-outline.item-interactive.ion-touched.ion-invalid) .item-native{border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-highlight,:host(.item-fill-solid.item-interactive.item-has-focus) .item-highlight,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-highlight{-webkit-transform:scaleX(1);transform:scaleX(1);border-width:0 0 var(--full-highlight-height) 0;border-style:var(--border-style);border-color:var(--highlight-background)}:host(.item-fill-solid.item-interactive.ion-focus) .item-native,:host(.item-fill-solid.item-interactive.item-has-focus) .item-native,:host(.item-fill-solid.item-interactive.ion-touched.ion-invalid) .item-native{border-bottom-color:var(--highlight-background)}:host(.ion-color.ion-activated) .item-native::after{background:transparent}:host(.item-has-focus) .item-native{caret-color:var(--highlight-color-focused)}:host(.item-interactive){--border-width:0 0 1px 0;--inner-border-width:0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-full){--border-width:0 0 1px 0;--show-full-highlight:1;--show-inset-highlight:0}:host(.item-lines-inset){--inner-border-width:0 0 1px 0;--show-full-highlight:0;--show-inset-highlight:1}:host(.item-lines-inset),:host(.item-lines-none){--border-width:0;--show-full-highlight:0}:host(.item-lines-full),:host(.item-lines-none){--inner-border-width:0;--show-inset-highlight:0}:host(.item-fill-outline) .item-highlight{--position-offset:calc(-1 * var(--border-width));left:var(--position-offset);top:var(--position-offset);width:calc(100% + 2 * var(--border-width));height:calc(100% + 2 * var(--border-width));-webkit-transition:none;transition:none}:host-context([dir=rtl]):host(.item-fill-outline) .item-highlight,:host-context([dir=rtl]).item-fill-outline .item-highlight{left:unset;right:unset;right:var(--position-offset)}:host(.item-fill-outline.ion-focused) .item-native,:host(.item-fill-outline.item-has-focus) .item-native{border-color:transparent}:host(.item-multi-line) ::slotted([slot=start]),:host(.item-multi-line) ::slotted([slot=end]){margin-top:16px;margin-bottom:16px;-ms-flex-item-align:start;align-self:flex-start}::slotted([slot=start]){margin-right:32px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted([slot=start]){margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}::slotted([slot=end]){margin-left:32px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted([slot=end]){margin-left:unset;-webkit-margin-start:32px;margin-inline-start:32px}}:host(.item-fill-solid) ::slotted([slot=start]),:host(.item-fill-solid) ::slotted([slot=end]),:host(.item-fill-outline) ::slotted([slot=start]),:host(.item-fill-outline) ::slotted([slot=end]){-ms-flex-item-align:center;align-self:center}::slotted(ion-icon){color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:24px}:host(.ion-color:not(.item-fill-solid):not(.item-fill-outline)) ::slotted(ion-icon){color:var(--ion-color-contrast)}::slotted(ion-icon[slot]){margin-top:12px;margin-bottom:12px}::slotted(ion-icon[slot=start]){margin-right:32px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=start]){margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}::slotted(ion-icon[slot=end]){margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-icon[slot=end]){margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}:host(.item-fill-solid) ::slotted(ion-icon[slot=start]),:host(.item-fill-outline) ::slotted(ion-icon[slot=start]){margin-right:8px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.item-fill-solid) ::slotted(ion-icon[slot=start]),:host(.item-fill-outline) ::slotted(ion-icon[slot=start]){margin-right:unset;-webkit-margin-end:8px;margin-inline-end:8px}}::slotted(ion-toggle[slot=start]),::slotted(ion-toggle[slot=end]){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}::slotted(ion-note){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-ms-flex-item-align:start;align-self:flex-start;font-size:11px}::slotted(ion-note[slot]:not([slot=helper]):not([slot=error])){padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}::slotted(ion-note[slot=start]){padding-right:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-note[slot=start]){padding-right:unset;-webkit-padding-end:16px;padding-inline-end:16px}}::slotted(ion-note[slot=end]){padding-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-note[slot=end]){padding-left:unset;-webkit-padding-start:16px;padding-inline-start:16px}}::slotted(ion-avatar){width:40px;height:40px}::slotted(ion-thumbnail){width:56px;height:56px}::slotted(ion-avatar),::slotted(ion-thumbnail){margin-top:8px;margin-bottom:8px}::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){margin-right:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-avatar[slot=start]),::slotted(ion-thumbnail[slot=start]){margin-right:unset;-webkit-margin-end:16px;margin-inline-end:16px}}::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-avatar[slot=end]),::slotted(ion-thumbnail[slot=end]){margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:10px;margin-bottom:10px}:host(.item-label-stacked) ::slotted([slot=end]),:host(.item-label-floating) ::slotted([slot=end]){margin-top:7px;margin-bottom:7px}:host(.item-label-fixed) ::slotted(ion-select),:host(.item-label-fixed) ::slotted(ion-datetime){--padding-start:8px}:host(.item-toggle) ::slotted(ion-label),:host(.item-radio) ::slotted(ion-label){margin-left:0}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.item-toggle) ::slotted(ion-label),:host(.item-radio) ::slotted(ion-label){margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}::slotted(.button-small){--padding-top:0;--padding-bottom:0;--padding-start:.6em;--padding-end:.6em;height:25px;font-size:12px}:host(.item-label-floating),:host(.item-label-stacked){--min-height:55px}:host(.item-label-stacked) ::slotted(ion-select),:host(.item-label-floating) ::slotted(ion-select){--padding-top:8px;--padding-bottom:8px;--padding-start:0}:host(.ion-focused:not(.ion-color)) ::slotted(.label-stacked),:host(.ion-focused:not(.ion-color)) ::slotted(.label-floating),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-stacked),:host(.item-has-focus:not(.ion-color)) ::slotted(.label-floating){color:var(--ion-color-primary, #3880ff)}:host(.ion-color){--highlight-color-focused:var(--ion-color-contrast)}:host(.item-label-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid.ion-color),:host(.item-fill-outline.ion-color){--highlight-color-focused:var(--ion-color-base)}:host(.item-fill-solid){--background:var(--ion-color-step-50, #f2f2f2);--background-hover:var(--ion-color-step-100, #e6e6e6);--background-focused:var(--ion-color-step-150, #d9d9d9);--border-width:0 0 1px 0;--inner-border-width:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid),:host-context([dir=rtl]).item-fill-solid{border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.item-fill-solid) .item-native{--border-color:var(--ion-color-step-500, gray)}:host(.item-fill-solid.ion-focused) .item-native,:host(.item-fill-solid.item-has-focus) .item-native{--background:var(--background-focused)}:host(.item-fill-solid.item-shape-round){border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.item-fill-solid.item-shape-round),:host-context([dir=rtl]).item-fill-solid.item-shape-round{border-top-left-radius:16px;border-top-right-radius:16px;border-bottom-right-radius:0;border-bottom-left-radius:0}@media (any-hover: hover){:host(.item-fill-solid:hover) .item-native{--background:var(--background-hover);--border-color:var(--ion-color-step-750, #404040)}}:host(.item-fill-outline){--ripple-color:transparent;--background-focused:transparent;--background-hover:transparent;--border-color:var(--ion-color-step-500, gray);--border-width:1px;border:none;overflow:visible}:host(.item-fill-outline) .item-native{--native-padding-left:16px;border-radius:4px}:host(.item-fill-outline.item-shape-round) .item-native{--inner-padding-start:16px;border-radius:28px}:host(.item-fill-outline.item-shape-round) .item-bottom{padding-left:32px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.item-fill-outline.item-shape-round) .item-bottom{padding-left:unset;-webkit-padding-start:32px;padding-inline-start:32px}}:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.ion-focused) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-focus) .item-native ::slotted(ion-textarea:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-input:not(:first-child)),:host(.item-fill-outline.item-label-floating.item-has-value) .item-native ::slotted(ion-textarea:not(:first-child)){-webkit-transform:translateY(-14px);transform:translateY(-14px)}@media (any-hover: hover){:host(.item-fill-outline:hover) .item-native{--border-color:var(--ion-color-step-750, #404040)}}.item-counter{color:rgba(0, 0, 0, 0.6);letter-spacing:0.0333333333em}\";\n\nconst Item = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.labelColorStyles = {};\n    this.itemStyles = new Map();\n    this.multipleInputs = false;\n    this.focusable = true;\n    /**\n     * If `true`, a button tag will be rendered and the item will be tappable.\n     */\n    this.button = false;\n    /**\n     * The icon to use when `detail` is set to `true`.\n     */\n    this.detailIcon = chevronForward;\n    /**\n     * If `true`, the user cannot interact with the item.\n     */\n    this.disabled = false;\n    /**\n     * If `true`, a character counter will display the ratio of characters used and the total character limit. Only applies when the `maxlength` property is set on the inner `ion-input` or `ion-textarea`.\n     */\n    this.counter = false;\n    /**\n     * When using a router, it specifies the transition direction when navigating to\n     * another page using `href`.\n     */\n    this.routerDirection = 'forward';\n    /**\n     * The type of the button. Only used when an `onclick` or `button` property is present.\n     */\n    this.type = 'button';\n  }\n  handleIonChange(ev) {\n    if (this.counter && ev.target === this.getFirstInput()) {\n      this.updateCounterOutput(ev.target);\n    }\n  }\n  labelColorChanged(ev) {\n    const { color } = this;\n    // There will be a conflict with item color if\n    // we apply the label color to item, so we ignore\n    // the label color if the user sets a color on item\n    if (color === undefined) {\n      this.labelColorStyles = ev.detail;\n    }\n  }\n  itemStyle(ev) {\n    ev.stopPropagation();\n    const tagName = ev.target.tagName;\n    const updatedStyles = ev.detail;\n    const newStyles = {};\n    const childStyles = this.itemStyles.get(tagName) || {};\n    let hasStyleChange = false;\n    Object.keys(updatedStyles).forEach(key => {\n      if (updatedStyles[key]) {\n        const itemKey = `item-${key}`;\n        if (!childStyles[itemKey]) {\n          hasStyleChange = true;\n        }\n        newStyles[itemKey] = true;\n      }\n    });\n    if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {\n      hasStyleChange = true;\n    }\n    if (hasStyleChange) {\n      this.itemStyles.set(tagName, newStyles);\n      (0,client/* forceUpdate */.xE)(this);\n    }\n  }\n  connectedCallback() {\n    if (this.counter) {\n      this.updateCounterOutput(this.getFirstInput());\n    }\n    this.hasStartEl();\n  }\n  componentDidUpdate() {\n    // Do not use @Listen here to avoid making all items\n    // appear as clickable to screen readers\n    // https://github.com/ionic-team/ionic-framework/issues/22011\n    const input = this.getFirstInput();\n    if (input && !this.clickListener) {\n      this.clickListener = (ev) => this.delegateFocus(ev, input);\n      this.el.addEventListener('click', this.clickListener);\n    }\n  }\n  disconnectedCallback() {\n    const input = this.getFirstInput();\n    if (input && this.clickListener) {\n      this.el.removeEventListener('click', this.clickListener);\n      this.clickListener = undefined;\n    }\n  }\n  componentDidLoad() {\n    (0,helpers.r)(() => {\n      this.setMultipleInputs();\n      this.focusable = this.isFocusable();\n    });\n  }\n  // If the item contains multiple clickable elements and/or inputs, then the item\n  // should not have a clickable input cover over the entire item to prevent\n  // interfering with their individual click events\n  setMultipleInputs() {\n    // The following elements have a clickable cover that is relative to the entire item\n    const covers = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');\n    // The following elements can accept focus alongside the previous elements\n    // therefore if these elements are also a child of item, we don't want the\n    // input cover on top of those interfering with their clicks\n    const inputs = this.el.querySelectorAll('ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle');\n    // The following elements should also stay clickable when an input with cover is present\n    const clickables = this.el.querySelectorAll('ion-anchor, ion-button, a, button');\n    // Check for multiple inputs to change the position of the input cover to relative\n    // for all of the covered inputs above\n    this.multipleInputs = covers.length + inputs.length > 1\n      || covers.length + clickables.length > 1\n      || covers.length > 0 && this.isClickable();\n  }\n  // If the item contains an input including a checkbox, datetime, select, or radio\n  // then the item will have a clickable input cover that covers the item\n  // that should get the hover, focused and activated states UNLESS it has multiple\n  // inputs, then those need to individually get each click\n  hasCover() {\n    const inputs = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');\n    return inputs.length === 1 && !this.multipleInputs;\n  }\n  // If the item has an href or button property it will render a native\n  // anchor or button that is clickable\n  isClickable() {\n    return (this.href !== undefined || this.button);\n  }\n  canActivate() {\n    return (this.isClickable() || this.hasCover());\n  }\n  isFocusable() {\n    const focusableChild = this.el.querySelector('.ion-focusable');\n    return (this.canActivate() || focusableChild !== null);\n  }\n  getFirstInput() {\n    const inputs = this.el.querySelectorAll('ion-input, ion-textarea');\n    return inputs[0];\n  }\n  // This is needed for WebKit due to a delegatesFocus bug where\n  // clicking on the left padding of an item is not focusing the input\n  // but is opening the keyboard. It will no longer be needed with\n  // iOS 14.\n  delegateFocus(ev, input) {\n    const clickedItem = ev.target.tagName === 'ION-ITEM';\n    let firstActive = false;\n    // If the first input is the same as the active element we need\n    // to focus the first input again, but if the active element\n    // is another input inside of the item we shouldn't switch focus\n    if (document.activeElement) {\n      firstActive = input.querySelector('input, textarea') === document.activeElement;\n    }\n    // Only focus the first input if we clicked on an ion-item\n    // and the first input exists\n    if (clickedItem && (firstActive || !this.multipleInputs)) {\n      input.fireFocusEvents = false;\n      input.setBlur();\n      input.setFocus();\n      (0,helpers.r)(() => {\n        input.fireFocusEvents = true;\n      });\n    }\n  }\n  updateCounterOutput(inputEl) {\n    var _a, _b;\n    if (this.counter && !this.multipleInputs && (inputEl === null || inputEl === void 0 ? void 0 : inputEl.maxlength) !== undefined) {\n      const length = (_b = (_a = inputEl === null || inputEl === void 0 ? void 0 : inputEl.value) === null || _a === void 0 ? void 0 : _a.toString().length) !== null && _b !== void 0 ? _b : '0';\n      this.counterString = `${length} / ${inputEl.maxlength}`;\n    }\n  }\n  hasStartEl() {\n    const startEl = this.el.querySelector('[slot=\"start\"]');\n    if (startEl !== null) {\n      this.el.classList.add('item-has-start-slot');\n    }\n  }\n  render() {\n    const { counterString, detail, detailIcon, download, fill, labelColorStyles, lines, disabled, href, rel, shape, target, routerAnimation, routerDirection } = this;\n    const childStyles = {};\n    const mode = ionic_global_getIonMode(this);\n    const clickable = this.isClickable();\n    const canActivate = this.canActivate();\n    const TagType = clickable ? (href === undefined ? 'button' : 'a') : 'div';\n    const attrs = (TagType === 'button')\n      ? { type: this.type }\n      : {\n        download,\n        href,\n        rel,\n        target\n      };\n    // Only set onClick if the item is clickable to prevent screen\n    // readers from reading all items as clickable\n    const clickFn = clickable ? {\n      onClick: (ev) => { openURL(href, ev, routerDirection, routerAnimation); }\n    } : {};\n    const showDetail = detail !== undefined ? detail : mode === 'ios' && clickable;\n    this.itemStyles.forEach(value => {\n      Object.assign(childStyles, value);\n    });\n    const ariaDisabled = (disabled || childStyles['item-interactive-disabled']) ? 'true' : null;\n    const fillValue = fill || 'none';\n    return ((0,client.h)(client/* Host */.AA, { \"aria-disabled\": ariaDisabled, class: Object.assign(Object.assign(Object.assign({}, childStyles), labelColorStyles), createColorClasses(this.color, {\n        'item': true,\n        [mode]: true,\n        [`item-lines-${lines}`]: lines !== undefined,\n        [`item-fill-${fillValue}`]: true,\n        [`item-shape-${shape}`]: shape !== undefined,\n        'item-disabled': disabled,\n        'in-list': hostContext('ion-list', this.el),\n        'item-multiple-inputs': this.multipleInputs,\n        'ion-activatable': canActivate,\n        'ion-focusable': this.focusable,\n        'item-rtl': document.dir === 'rtl'\n      })) }, (0,client.h)(TagType, Object.assign({}, attrs, { class: \"item-native\", part: \"native\", disabled: disabled }, clickFn), (0,client.h)(\"slot\", { name: \"start\" }), (0,client.h)(\"div\", { class: \"item-inner\" }, (0,client.h)(\"div\", { class: \"input-wrapper\" }, (0,client.h)(\"slot\", null)), (0,client.h)(\"slot\", { name: \"end\" }), showDetail && (0,client.h)(\"ion-icon\", { icon: detailIcon, lazy: false, class: \"item-detail-icon\", part: \"detail-icon\", \"aria-hidden\": \"true\", \"flip-rtl\": detailIcon === chevronForward }), (0,client.h)(\"div\", { class: \"item-inner-highlight\" })), canActivate && mode === 'md' && (0,client.h)(\"ion-ripple-effect\", null), (0,client.h)(\"div\", { class: \"item-highlight\" })), (0,client.h)(\"div\", { class: \"item-bottom\" }, (0,client.h)(\"slot\", { name: \"error\" }), (0,client.h)(\"slot\", { name: \"helper\" }), counterString && (0,client.h)(\"ion-note\", { class: \"item-counter\" }, counterString))));\n  }\n  static get delegatesFocus() { return true; }\n  get el() { return this; }\n  static get style() { return {\n    ios: itemIosCss,\n    md: itemMdCss\n  }; }\n}, [49, \"ion-item\", {\n    \"color\": [513],\n    \"button\": [4],\n    \"detail\": [4],\n    \"detailIcon\": [1, \"detail-icon\"],\n    \"disabled\": [4],\n    \"download\": [1],\n    \"fill\": [1],\n    \"shape\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"lines\": [1],\n    \"counter\": [4],\n    \"routerAnimation\": [16],\n    \"routerDirection\": [1, \"router-direction\"],\n    \"target\": [1],\n    \"type\": [1],\n    \"multipleInputs\": [32],\n    \"focusable\": [32],\n    \"counterString\": [32]\n  }, [[0, \"ionChange\", \"handleIonChange\"], [0, \"ionColor\", \"labelColorChanged\"], [0, \"ionStyle\", \"itemStyle\"]]]);\nfunction item_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-item\", \"ion-icon\", \"ion-note\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-item\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Item);\n      }\n      break;\n    case \"ion-icon\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$3();\n      }\n      break;\n    case \"ion-note\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$2();\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$1();\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-item.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst IonItem = Item;\nconst ion_item_defineCustomElement = (/* unused pure expression or super */ null && (defineCustomElement$1));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/cubic-bezier.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Based on:\n * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier\n * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves\n * TODO: Reduce rounding error\n */\n/**\n * EXPERIMENTAL\n * Given a cubic-bezier curve, get the x value (time) given\n * the y value (progression).\n * Ex: cubic-bezier(0.32, 0.72, 0, 1);\n * P0: (0, 0)\n * P1: (0.32, 0.72)\n * P2: (0, 1)\n * P3: (1, 1)\n *\n * If you give a cubic bezier curve that never reaches the\n * provided progression, this function will return an empty array.\n */\nconst getTimeGivenProgression = (p0, p1, p2, p3, progression) => {\n  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {\n    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);\n  });\n};\n/**\n * Solve a cubic equation in one dimension (time)\n */\nconst solveCubicParametricEquation = (p0, p1, p2, p3, t) => {\n  const partA = (3 * p1) * Math.pow(t - 1, 2);\n  const partB = (-3 * p2 * t) + (3 * p2) + (p3 * t);\n  const partC = p0 * Math.pow(t - 1, 3);\n  return t * (partA + (t * partB)) - partC;\n};\n/**\n * Find the `t` value for a cubic bezier using Cardano's formula\n */\nconst solveCubicBezier = (p0, p1, p2, p3, refPoint) => {\n  p0 -= refPoint;\n  p1 -= refPoint;\n  p2 -= refPoint;\n  p3 -= refPoint;\n  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);\n  return roots.filter(root => root >= 0 && root <= 1);\n};\nconst solveQuadraticEquation = (a, b, c) => {\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant < 0) {\n    return [];\n  }\n  else {\n    return [\n      (-b + Math.sqrt(discriminant)) / (2 * a),\n      (-b - Math.sqrt(discriminant)) / (2 * a)\n    ];\n  }\n};\nconst solveCubicEquation = (a, b, c, d) => {\n  if (a === 0) {\n    return solveQuadraticEquation(b, c, d);\n  }\n  b /= a;\n  c /= a;\n  d /= a;\n  const p = (3 * c - b * b) / 3;\n  const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;\n  if (p === 0) {\n    return [Math.pow(-q, 1 / 3)];\n  }\n  else if (q === 0) {\n    return [Math.sqrt(-p), -Math.sqrt(-p)];\n  }\n  const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);\n  if (discriminant === 0) {\n    return [Math.pow(q / 2, 1 / 2) - b / 3];\n  }\n  else if (discriminant > 0) {\n    return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow((q / 2) + Math.sqrt(discriminant), 1 / 3) - b / 3];\n  }\n  const r = Math.sqrt(Math.pow(-(p / 3), 3));\n  const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));\n  const s = 2 * Math.pow(r, 1 / 3);\n  return [\n    s * Math.cos(phi / 3) - b / 3,\n    s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3,\n    s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3\n  ];\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/framework-delegate.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {\n  if (delegate) {\n    return delegate.attachViewToDom(container, component, componentProps, cssClasses);\n  }\n  if (!inline && typeof component !== 'string' && !(component instanceof HTMLElement)) {\n    throw new Error('framework delegate is missing');\n  }\n  const el = (typeof component === 'string')\n    ? container.ownerDocument && container.ownerDocument.createElement(component)\n    : component;\n  if (cssClasses) {\n    cssClasses.forEach(c => el.classList.add(c));\n  }\n  if (componentProps) {\n    Object.assign(el, componentProps);\n  }\n  container.appendChild(el);\n  await new Promise(resolve => (0,helpers.c)(el, resolve));\n  return el;\n};\nconst detachComponent = (delegate, element) => {\n  if (element) {\n    if (delegate) {\n      const container = element.parentElement;\n      return delegate.removeViewFromDom(container, element);\n    }\n    element.remove();\n  }\n  return Promise.resolve();\n};\nconst CoreDelegate = () => {\n  let BaseComponent;\n  let Reference;\n  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {\n    BaseComponent = parentElement;\n    /**\n     * If passing in a component via the `component` props\n     * we need to append it inside of our overlay component.\n     */\n    if (userComponent) {\n      /**\n       * If passing in the tag name, create\n       * the element otherwise just get a reference\n       * to the component.\n       */\n      const el = (typeof userComponent === 'string')\n        ? BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement(userComponent)\n        : userComponent;\n      /**\n       * Add any css classes passed in\n       * via the cssClasses prop on the overlay.\n       */\n      cssClasses.forEach(c => el.classList.add(c));\n      /**\n       * Add any props passed in\n       * via the componentProps prop on the overlay.\n       */\n      Object.assign(el, userComponentProps);\n      /**\n       * Finally, append the component\n       * inside of the overlay component.\n       */\n      BaseComponent.appendChild(el);\n      await new Promise(resolve => componentOnReady(el, resolve));\n    }\n    else if (BaseComponent.children.length > 0) {\n      // If there is no component, then we need to create a new parent\n      // element to apply the css classes to.\n      const el = BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement('div');\n      cssClasses.forEach(c => el.classList.add(c));\n      // Move each child from the original template to the new parent element.\n      el.append(...BaseComponent.children);\n      // Append the new parent element to the original parent element.\n      BaseComponent.appendChild(el);\n    }\n    /**\n     * Get the root of the app and\n     * add the overlay there.\n     */\n    const app = document.querySelector('ion-app') || document.body;\n    /**\n     * Create a placeholder comment so that\n     * we can return this component to where\n     * it was previously.\n     */\n    Reference = document.createComment('ionic teleport');\n    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);\n    app.appendChild(BaseComponent);\n    return BaseComponent;\n  };\n  const removeViewFromDom = () => {\n    /**\n     * Return component to where it was previously in the DOM.\n     */\n    if (BaseComponent && Reference) {\n      Reference.parentNode.insertBefore(BaseComponent, Reference);\n      Reference.remove();\n    }\n    return Promise.resolve();\n  };\n  return { attachViewToDom, removeViewFromDom };\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/index4.js\nvar index4 = __webpack_require__(5026);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-router-outlet.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\n\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\n\nconst RouterOutlet = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = (0,client/* createEvent */.yM)(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = (0,client/* createEvent */.yM)(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = (0,client/* createEvent */.yM)(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ionic_global_getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await __webpack_require__.e(/* import() */ 5007).then(__webpack_require__.bind(__webpack_require__, 5007))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => this.ani && this.ani.progressStep(step), (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = (shouldComplete) ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation\n    });\n    return {\n      changed,\n      element: this.activeEl\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active ? {\n      id: active.tagName,\n      element: active,\n      params: this.activeParams,\n    } : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && (0,helpers.s)(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && ionic_global_config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || ionic_global_config.get('navAnimation');\n    await (0,index4.t)(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el, progressCallback: (opts.progressAnimation\n        ? ani => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined) }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return ((0,client.h)(\"slot\", null));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"swipeHandler\": [\"swipeHandlerChanged\"]\n  }; }\n  static get style() { return routeOutletCss; }\n}, [1, \"ion-router-outlet\", {\n    \"mode\": [1025],\n    \"delegate\": [16],\n    \"animated\": [4],\n    \"animation\": [16],\n    \"swipeHandler\": [16],\n    \"commit\": [64],\n    \"setRouteId\": [64],\n    \"getRouteId\": [64]\n  }]);\nfunction ion_router_outlet_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router-outlet\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RouterOutlet);\n      }\n      break;\n  } });\n}\n\nconst IonRouterOutlet = (/* unused pure expression or super */ null && (RouterOutlet));\nconst ion_router_outlet_defineCustomElement = ion_router_outlet_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-bar.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabBarIosCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-400, #999999));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}\";\n\nconst tabBarMdCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}\";\n\nconst TabBar = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabBarChanged = (0,client/* createEvent */.yM)(this, \"ionTabBarChanged\", 7);\n    this.keyboardVisible = false;\n    /**\n     * If `true`, the tab bar will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n    this.translucent = false;\n  }\n  selectedTabChanged() {\n    if (this.selectedTab !== undefined) {\n      this.ionTabBarChanged.emit({\n        tab: this.selectedTab\n      });\n    }\n  }\n  componentWillLoad() {\n    this.selectedTabChanged();\n  }\n  connectedCallback() {\n    if (typeof window !== 'undefined') {\n      this.keyboardWillShowHandler = () => {\n        if (this.el.getAttribute('slot') !== 'top') {\n          this.keyboardVisible = true;\n        }\n      };\n      this.keyboardWillHideHandler = () => {\n        setTimeout(() => this.keyboardVisible = false, 50);\n      };\n      window.addEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.addEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n    }\n  }\n  disconnectedCallback() {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.removeEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n      this.keyboardWillShowHandler = this.keyboardWillHideHandler = undefined;\n    }\n  }\n  render() {\n    const { color, translucent, keyboardVisible } = this;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"tablist\", \"aria-hidden\": keyboardVisible ? 'true' : null, class: createColorClasses(color, {\n        [mode]: true,\n        'tab-bar-translucent': translucent,\n        'tab-bar-hidden': keyboardVisible,\n      }) }, (0,client.h)(\"slot\", null)));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"selectedTab\": [\"selectedTabChanged\"]\n  }; }\n  static get style() { return {\n    ios: tabBarIosCss,\n    md: tabBarMdCss\n  }; }\n}, [33, \"ion-tab-bar\", {\n    \"color\": [513],\n    \"selectedTab\": [1, \"selected-tab\"],\n    \"translucent\": [4],\n    \"keyboardVisible\": [32]\n  }]);\nfunction ion_tab_bar_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-bar\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-bar\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabBar);\n      }\n      break;\n  } });\n}\n\nconst IonTabBar = (/* unused pure expression or super */ null && (TabBar));\nconst ion_tab_bar_defineCustomElement = ion_tab_bar_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ripple-effect.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst rippleEffectCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}\";\n\nconst RippleEffect = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    /**\n     * Sets the type of ripple-effect:\n     *\n     * - `bounded`: the ripple effect expands from the user's click position\n     * - `unbounded`: the ripple effect expands from the center of the button and overflows the container.\n     *\n     * NOTE: Surfaces for bounded ripples should have the overflow property set to hidden,\n     * while surfaces for unbounded ripples should have it set to visible.\n     */\n    this.type = 'bounded';\n  }\n  /**\n   * Adds the ripple effect to the parent element.\n   *\n   * @param x The horizontal coordinate of where the ripple should start.\n   * @param y The vertical coordinate of where the ripple should start.\n   */\n  async addRipple(x, y) {\n    return new Promise(resolve => {\n      (0,client/* readTask */.wj)(() => {\n        const rect = this.el.getBoundingClientRect();\n        const width = rect.width;\n        const height = rect.height;\n        const hypotenuse = Math.sqrt(width * width + height * height);\n        const maxDim = Math.max(height, width);\n        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;\n        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n        const finalScale = maxRadius / initialSize;\n        let posX = x - rect.left;\n        let posY = y - rect.top;\n        if (this.unbounded) {\n          posX = width * 0.5;\n          posY = height * 0.5;\n        }\n        const styleX = posX - initialSize * 0.5;\n        const styleY = posY - initialSize * 0.5;\n        const moveX = width * 0.5 - posX;\n        const moveY = height * 0.5 - posY;\n        (0,client/* writeTask */.Iu)(() => {\n          const div = document.createElement('div');\n          div.classList.add('ripple-effect');\n          const style = div.style;\n          style.top = styleY + 'px';\n          style.left = styleX + 'px';\n          style.width = style.height = initialSize + 'px';\n          style.setProperty('--final-scale', `${finalScale}`);\n          style.setProperty('--translate-end', `${moveX}px, ${moveY}px`);\n          const container = this.el.shadowRoot || this.el;\n          container.appendChild(div);\n          setTimeout(() => {\n            resolve(() => {\n              removeRipple(div);\n            });\n          }, 225 + 100);\n        });\n      });\n    });\n  }\n  get unbounded() {\n    return this.type === 'unbounded';\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"presentation\", class: {\n        [mode]: true,\n        'unbounded': this.unbounded\n      } }));\n  }\n  get el() { return this; }\n  static get style() { return rippleEffectCss; }\n}, [1, \"ion-ripple-effect\", {\n    \"type\": [1],\n    \"addRipple\": [64]\n  }]);\nconst removeRipple = (ripple) => {\n  ripple.classList.add('fade-out');\n  setTimeout(() => {\n    ripple.remove();\n  }, 200);\n};\nconst PADDING = 10;\nconst INITIAL_ORIGIN_SCALE = 0.5;\nfunction ripple_effect_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RippleEffect);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-button.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabButtonIosCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){padding-left:6px;padding-right:6px;padding-top:1px;padding-bottom:1px;left:calc(50% + 6px);top:4px;height:auto;font-size:12px;line-height:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\n\nconst tabButtonMdCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}[dir=rtl] ::slotted(ion-icon),:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}::slotted(ion-badge){border-radius:8px;padding-left:2px;padding-right:2px;padding-top:3px;padding-bottom:2px;left:calc(50% + 6px);top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%;top:8px}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:unset;-webkit-margin-end:6px;margin-inline-end:6px}}:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:unset;-webkit-margin-start:6px;margin-inline-start:6px}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}\";\n\nconst TabButton = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabButtonClick = (0,client/* createEvent */.yM)(this, \"ionTabButtonClick\", 7);\n    /**\n     * If `true`, the user cannot interact with the tab button.\n     */\n    this.disabled = false;\n    /**\n     * The selected tab component\n     */\n    this.selected = false;\n    this.onKeyUp = (ev) => {\n      if (ev.key === 'Enter' || ev.key === ' ') {\n        this.selectTab(ev);\n      }\n    };\n    this.onClick = (ev) => {\n      this.selectTab(ev);\n    };\n  }\n  onTabBarChanged(ev) {\n    const dispatchedFrom = ev.target;\n    const parent = this.el.parentElement;\n    if ((ev.composedPath && ev.composedPath().includes(parent)) || (dispatchedFrom && dispatchedFrom.contains(this.el))) {\n      this.selected = this.tab === ev.detail.tab;\n    }\n  }\n  componentWillLoad() {\n    if (this.layout === undefined) {\n      this.layout = ionic_global_config.get('tabButtonLayout', 'icon-top');\n    }\n  }\n  selectTab(ev) {\n    if (this.tab !== undefined) {\n      if (!this.disabled) {\n        this.ionTabButtonClick.emit({\n          tab: this.tab,\n          href: this.href,\n          selected: this.selected\n        });\n      }\n      ev.preventDefault();\n    }\n  }\n  get hasLabel() {\n    return !!this.el.querySelector('ion-label');\n  }\n  get hasIcon() {\n    return !!this.el.querySelector('ion-icon');\n  }\n  get tabIndex() {\n    if (this.disabled) {\n      return -1;\n    }\n    const hasTabIndex = this.el.hasAttribute('tabindex');\n    if (hasTabIndex) {\n      return this.el.getAttribute('tabindex');\n    }\n    return 0;\n  }\n  render() {\n    const { disabled, hasIcon, hasLabel, tabIndex, href, rel, target, layout, selected, tab } = this;\n    const mode = ionic_global_getIonMode(this);\n    const attrs = {\n      download: this.download,\n      href,\n      rel,\n      target\n    };\n    return ((0,client.h)(client/* Host */.AA, { onClick: this.onClick, onKeyup: this.onKeyUp, role: \"tab\", tabindex: tabIndex, \"aria-selected\": selected ? 'true' : null, id: tab !== undefined ? `tab-button-${tab}` : null, class: {\n        [mode]: true,\n        'tab-selected': selected,\n        'tab-disabled': disabled,\n        'tab-has-label': hasLabel,\n        'tab-has-icon': hasIcon,\n        'tab-has-label-only': hasLabel && !hasIcon,\n        'tab-has-icon-only': hasIcon && !hasLabel,\n        [`tab-layout-${layout}`]: true,\n        'ion-activatable': true,\n        'ion-selectable': true,\n        'ion-focusable': true\n      } }, (0,client.h)(\"a\", Object.assign({}, attrs, { tabIndex: -1, class: \"button-native\", part: \"native\" }), (0,client.h)(\"span\", { class: \"button-inner\" }, (0,client.h)(\"slot\", null)), mode === 'md' && (0,client.h)(\"ion-ripple-effect\", { type: \"unbounded\" }))));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: tabButtonIosCss,\n    md: tabButtonMdCss\n  }; }\n}, [33, \"ion-tab-button\", {\n    \"disabled\": [4],\n    \"download\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"layout\": [1025],\n    \"selected\": [1028],\n    \"tab\": [1],\n    \"target\": [1]\n  }, [[8, \"ionTabBarChanged\", \"onTabBarChanged\"]]]);\nfunction ion_tab_button_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-button\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-button\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabButton);\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        ripple_effect_defineCustomElement();\n      }\n      break;\n  } });\n}\n\nconst IonTabButton = (/* unused pure expression or super */ null && (TabButton));\nconst ion_tab_button_defineCustomElement = ion_tab_button_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.12.1 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst client_setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst client_Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst client_setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => client_safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = client_safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = client_safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => client_safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        client_safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            client_safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            client_safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst client_safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && newVal !== oldVal) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 5880).then(__webpack_require__.bind(__webpack_require__, 5880)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        client_safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            client_safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            client_safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst client_defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in client_Context) {\n        return client_Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst client_Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(1875)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ (/* unused pure expression or super */ null && (queueTask(queueDomReads, false)));\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/utils.js\n\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  }\n  else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = (icons) => {\n  const map = getIconMap();\n  Object.keys(icons).forEach(name => map.set(name, icons[name]));\n};\nconst getUrl = (i) => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  return getAssetPath(`svg/${iconName}.svg`);\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  }\n  else if (md && mode === 'md') {\n    iconName = toLower(md);\n  }\n  else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = (src) => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/ion-icon.js\n\n\n\nconst validateContent = (svgContent) => {\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // setup this way to ensure it works on our buddy IE\n  for (let i = div.childNodes.length - 1; i >= 0; i--) {\n    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n      div.removeChild(div.childNodes[i]);\n    }\n  }\n  // must only have 1 root element\n  const svgElm = div.firstElementChild;\n  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n    const svgClass = svgElm.getAttribute('class') || '';\n    svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());\n    // root element must be an svg\n    // lets double check we've got valid elements\n    // do not allow scripts\n    if (isValid(svgElm)) {\n      return div.innerHTML;\n    }\n  }\n  return '';\n};\nconst isValid = (elm) => {\n  if (elm.nodeType === 1) {\n    if (elm.nodeName.toLowerCase() === 'script') {\n      return false;\n    }\n    for (let i = 0; i < elm.attributes.length; i++) {\n      const val = elm.attributes[i].value;\n      if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\n        return false;\n      }\n    }\n    for (let i = 0; i < elm.childNodes.length; i++) {\n      if (!isValid(elm.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconst ioniconContent = new Map();\nconst requests = new Map();\nconst getSvgContent = (url, sanitize) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            ioniconContent.set(url, svgContent || '');\n          });\n        }\n        ioniconContent.set(url, '');\n      });\n      // cache for the same requests\n      requests.set(url, req);\n    }\n    else {\n      // set to empty for ssr scenarios and resolve promise\n      ioniconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n  return req;\n};\n\nconst iconCss = \":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}\";\n\nlet Icon = class extends H {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.iconName = null;\n    this.inheritedAttributes = {};\n    this.isVisible = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ion_icon_getIonMode();\n    /**\n     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\n     * Default, `false`.\n     */\n    this.lazy = false;\n    /**\n     * When set to `false`, SVG content that is HTTP fetched will not be checked\n     * if the response SVG content has any `<script>` elements, or any attributes\n     * that start with `on`, such as `onclick`.\n     * @default true\n     */\n    this.sanitize = true;\n    this.hasAriaHidden = () => {\n      const { el } = this;\n      return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';\n    };\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n  }\n  connectedCallback() {\n    // purposely do not return the promise here because loading\n    // the svg file should not hold up loading the app\n    // only load the svg if it's visible\n    this.waitUntilVisible(this.el, '50px', () => {\n      this.isVisible = true;\n      this.loadIcon();\n    });\n  }\n  disconnectedCallback() {\n    if (this.io) {\n      this.io.disconnect();\n      this.io = undefined;\n    }\n  }\n  waitUntilVisible(el, rootMargin, cb) {\n    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {\n      const io = (this.io = new window.IntersectionObserver((data) => {\n        if (data[0].isIntersecting) {\n          io.disconnect();\n          this.io = undefined;\n          cb();\n        }\n      }, { rootMargin }));\n      io.observe(el);\n    }\n    else {\n      // browser doesn't support IntersectionObserver\n      // so just fallback to always show it\n      cb();\n    }\n  }\n  loadIcon() {\n    if (Build.isBrowser && this.isVisible) {\n      const url = getUrl(this);\n      if (url) {\n        if (ioniconContent.has(url)) {\n          // sync if it's already loaded\n          this.svgContent = ioniconContent.get(url);\n        }\n        else {\n          // async if it hasn't been loaded\n          getSvgContent(url, this.sanitize).then(() => (this.svgContent = ioniconContent.get(url)));\n        }\n      }\n    }\n    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);\n    /**\n     * Come up with a default label\n     * in case user does not provide their own.\n     */\n    if (label) {\n      this.ariaLabel = label.replace(/\\-/g, ' ');\n    }\n  }\n  render() {\n    const { iconName, ariaLabel, inheritedAttributes } = this;\n    const mode = this.mode || 'md';\n    const flipRtl = this.flipRtl ||\n      (iconName &&\n        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&\n        this.flipRtl !== false);\n    /**\n     * Only set the aria-label if a) we have generated\n     * one for the icon and if aria-hidden is not set to \"true\".\n     * If developer wants to set their own aria-label, then\n     * inheritedAttributes down below will override whatever\n     * default label we have set.\n     */\n    return (h(Host, Object.assign({ \"aria-label\": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: \"img\", class: Object.assign(Object.assign({ [mode]: true }, ion_icon_createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, inheritedAttributes), Build.isBrowser && this.svgContent ? (h(\"div\", { class: \"icon-inner\", innerHTML: this.svgContent })) : (h(\"div\", { class: \"icon-inner\" }))));\n  }\n  static get assetsDirs() { return [\"svg\"]; }\n  get el() { return this; }\n  static get watchers() { return {\n    \"name\": [\"loadIcon\"],\n    \"src\": [\"loadIcon\"],\n    \"icon\": [\"loadIcon\"]\n  }; }\n  static get style() { return iconCss; }\n};\nconst ion_icon_getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';\nconst ion_icon_createColorClasses = (color) => {\n  return color\n    ? {\n      'ion-color': true,\n      [`ion-color-${color}`]: true,\n    }\n    : null;\n};\nIcon = /*@__PURE__*/ proxyCustomElement(Icon, [1, \"ion-icon\", {\n    \"mode\": [1025],\n    \"color\": [1],\n    \"ios\": [1],\n    \"md\": [1],\n    \"flipRtl\": [4, \"flip-rtl\"],\n    \"name\": [513],\n    \"src\": [1],\n    \"icon\": [8],\n    \"size\": [1],\n    \"lazy\": [4],\n    \"sanitize\": [4],\n    \"svgContent\": [32],\n    \"isVisible\": [32],\n    \"ariaLabel\": [32]\n  }]);\nfunction ion_icon_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-icon\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-icon\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Icon);\n      }\n      break;\n  } });\n}\n\nconst IonIcon = (/* unused pure expression or super */ null && (Icon));\nconst ion_icon_defineCustomElement = ion_icon_defineCustomElement$1;\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/dist/esm-es5/index.js\nvar esm_es5 = __webpack_require__(3774);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/dist/index.js\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/react/dist/index.esm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IonLifeCycleContext = /*@__PURE__*/ react.createContext({\n    onIonViewWillEnter: () => {\n        return;\n    },\n    ionViewWillEnter: () => {\n        return;\n    },\n    onIonViewDidEnter: () => {\n        return;\n    },\n    ionViewDidEnter: () => {\n        return;\n    },\n    onIonViewWillLeave: () => {\n        return;\n    },\n    ionViewWillLeave: () => {\n        return;\n    },\n    onIonViewDidLeave: () => {\n        return;\n    },\n    ionViewDidLeave: () => {\n        return;\n    },\n});\nconst DefaultIonLifeCycleContext = class {\n    constructor() {\n        this.ionViewWillEnterCallbacks = [];\n        this.ionViewDidEnterCallbacks = [];\n        this.ionViewWillLeaveCallbacks = [];\n        this.ionViewDidLeaveCallbacks = [];\n    }\n    onIonViewWillEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillEnterCallbacks.push(callback);\n        }\n    }\n    ionViewWillEnter() {\n        this.ionViewWillEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidEnterCallbacks.push(callback);\n        }\n    }\n    ionViewDidEnter() {\n        this.ionViewDidEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewWillLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewWillLeave() {\n        this.ionViewWillLeaveCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewDidLeave() {\n        this.ionViewDidLeaveCallbacks.forEach((cb) => cb());\n        this.componentCanBeDestroyed();\n    }\n    onComponentCanBeDestroyed(callback) {\n        this.componentCanBeDestroyedCallback = callback;\n    }\n    componentCanBeDestroyed() {\n        if (this.componentCanBeDestroyedCallback) {\n            this.componentCanBeDestroyedCallback();\n        }\n    }\n};\n\nconst withIonLifeCycle = (WrappedComponent) => {\n    return class IonLifeCycle extends React.Component {\n        constructor(props) {\n            super(props);\n            this.componentRef = React.createRef();\n        }\n        componentDidMount() {\n            const element = this.componentRef.current;\n            this.context.onIonViewWillEnter(() => {\n                if (element && element.ionViewWillEnter) {\n                    element.ionViewWillEnter();\n                }\n            });\n            this.context.onIonViewDidEnter(() => {\n                if (element && element.ionViewDidEnter) {\n                    element.ionViewDidEnter();\n                }\n            });\n            this.context.onIonViewWillLeave(() => {\n                if (element && element.ionViewWillLeave) {\n                    element.ionViewWillLeave();\n                }\n            });\n            this.context.onIonViewDidLeave(() => {\n                if (element && element.ionViewDidLeave) {\n                    element.ionViewDidLeave();\n                }\n            });\n        }\n        render() {\n            return (React.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n                this.context = context;\n                return React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));\n            }));\n        }\n    };\n};\n\nconst useIonViewWillEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillEnter(callback);\n    }, deps);\n};\nconst useIonViewDidEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidEnter(callback);\n    }, deps);\n};\nconst useIonViewWillLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillLeave(callback);\n    }, deps);\n};\nconst useIonViewDidLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidLeave(callback);\n    }, deps);\n};\n\nconst NavContext = /*@__PURE__*/ react.createContext({\n    getIonRedirect: () => undefined,\n    getIonRoute: () => undefined,\n    getPageManager: () => undefined,\n    getStackManager: () => undefined,\n    goBack: (route) => {\n        if (typeof window !== 'undefined') {\n            if (typeof route === 'string') {\n                window.location.pathname = route;\n            }\n            else {\n                window.history.back();\n            }\n        }\n    },\n    navigate: (path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    hasIonicRouter: () => false,\n    routeInfo: undefined,\n    setCurrentTab: () => undefined,\n    changeTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    resetTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n});\n\nconst dashToPascalCase = (str) => str\n    .toLowerCase()\n    .split('-')\n    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))\n    .join('');\nconst camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);\n\nconst attachProps = (node, newProps, oldProps = {}) => {\n    // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n    if (node instanceof Element) {\n        // add any classes in className to the class list\n        const className = getClassName(node.classList, newProps, oldProps);\n        if (className !== '') {\n            node.className = className;\n        }\n        Object.keys(newProps).forEach((name) => {\n            if (name === 'children' ||\n                name === 'style' ||\n                name === 'ref' ||\n                name === 'class' ||\n                name === 'className' ||\n                name === 'forwardedRef') {\n                return;\n            }\n            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                const eventName = name.substring(2);\n                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n                if (!isCoveredByReact(eventNameLc)) {\n                    syncEvent(node, eventNameLc, newProps[name]);\n                }\n            }\n            else {\n                node[name] = newProps[name];\n                const propType = typeof newProps[name];\n                if (propType === 'string') {\n                    node.setAttribute(camelToDashCase(name), newProps[name]);\n                }\n            }\n        });\n    }\n};\nconst getClassName = (classList, newProps, oldProps) => {\n    const newClassProp = newProps.className || newProps.class;\n    const oldClassProp = oldProps.className || oldProps.class;\n    // map the classes to Maps for performance\n    const currentClasses = arrayToMap(classList);\n    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n    const finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach((currentClass) => {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach((s) => finalClassNames.push(s));\n    return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nconst isCoveredByReact = (eventNameSuffix) => {\n    if (typeof document === 'undefined') {\n        return true;\n    }\n    else {\n        const eventName = 'on' + eventNameSuffix;\n        let isSupported = eventName in document;\n        if (!isSupported) {\n            const element = document.createElement('div');\n            element.setAttribute(eventName, 'return;');\n            isSupported = typeof element[eventName] === 'function';\n        }\n        return isSupported;\n    }\n};\nconst syncEvent = (node, eventName, newEventHandler) => {\n    const eventStore = node.__events || (node.__events = {});\n    const oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    // Bind new listener.\n    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n        if (newEventHandler) {\n            newEventHandler.call(this, e);\n        }\n    }));\n};\nconst arrayToMap = (arr) => {\n    const map = new Map();\n    arr.forEach((s) => map.set(s, s));\n    return map;\n};\n\nconst setRef = (ref, value) => {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref != null) {\n        // Cast as a MutableRef so we can assign current\n        ref.current = value;\n    }\n};\nconst mergeRefs = (...refs) => {\n    return (value) => {\n        refs.forEach(ref => {\n            setRef(ref, value);\n        });\n    };\n};\nconst createForwardRef$1 = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_defineCustomElement = (tagName, customElement) => {\n    if (customElement !== undefined &&\n        typeof customElements !== 'undefined' &&\n        !customElements.get(tagName)) {\n        customElements.define(tagName, customElement);\n    }\n};\n\nconst createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends react.Component {\n        constructor(props) {\n            super(props);\n            this.setComponentElRef = (element) => {\n                this.componentEl = element;\n            };\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            attachProps(this.componentEl, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            let propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else {\n                    acc[name] = cProps[name];\n                }\n                return acc;\n            }, {});\n            if (manipulatePropsFunction) {\n                propsToPass = manipulatePropsFunction(this.props, propsToPass);\n            }\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });\n            /**\n             * We use createElement here instead of\n             * React.createElement to work around a\n             * bug in Vite (https://github.com/vitejs/vite/issues/6104).\n             * React.createElement causes all elements to be rendered\n             * as <tagname> instead of the actual Web Component.\n             */\n            return (0,react.createElement)(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    // If context was passed to createReactComponent then conditionally add it to the Component Class\n    if (ReactComponentContext) {\n        ReactComponent.contextType = ReactComponentContext;\n    }\n    return createForwardRef$1(ReactComponent, displayName);\n};\n\n/* eslint-disable */\nconst IonAccordion = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion', undefined, undefined, defineCustomElement$1)));\nconst IonAccordionGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion-group', undefined, undefined, defineCustomElement$2)));\nconst IonAvatar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-avatar', undefined, undefined, defineCustomElement$3)));\nconst IonBackdrop = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-backdrop', undefined, undefined, defineCustomElement$4)));\nconst IonBadge = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-badge', undefined, undefined, defineCustomElement$5)));\nconst IonBreadcrumbs = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-breadcrumbs', undefined, undefined, defineCustomElement$6)));\nconst IonButtons = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-buttons', undefined, undefined, defineCustomElement$7)));\nconst index_esm_IonCardContent = /*@__PURE__*/ createReactComponent('ion-card-content', undefined, undefined, defineCustomElement);\nconst IonCardHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-header', undefined, undefined, defineCustomElement$9)));\nconst IonCardSubtitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-subtitle', undefined, undefined, defineCustomElement$a)));\nconst IonCardTitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-title', undefined, undefined, defineCustomElement$b)));\nconst IonCheckbox = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-checkbox', undefined, undefined, defineCustomElement$c)));\nconst IonChip = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-chip', undefined, undefined, defineCustomElement$d)));\nconst IonCol = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-col', undefined, undefined, defineCustomElement$e)));\nconst index_esm_IonContent = /*@__PURE__*/ createReactComponent('ion-content', undefined, undefined, ion_content_defineCustomElement);\nconst IonDatetime = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-datetime', undefined, undefined, defineCustomElement$g)));\nconst IonFab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab', undefined, undefined, defineCustomElement$h)));\nconst IonFabList = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab-list', undefined, undefined, defineCustomElement$i)));\nconst index_esm_IonFooter = /*@__PURE__*/ createReactComponent('ion-footer', undefined, undefined, ion_footer_defineCustomElement);\nconst IonGrid = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-grid', undefined, undefined, defineCustomElement$k)));\nconst index_esm_IonHeader = /*@__PURE__*/ createReactComponent('ion-header', undefined, undefined, ion_header_defineCustomElement);\nconst IonImg = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-img', undefined, undefined, defineCustomElement$m)));\nconst IonInfiniteScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll', undefined, undefined, defineCustomElement$n)));\nconst IonInfiniteScrollContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll-content', undefined, undefined, defineCustomElement$o)));\nconst IonInput = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-input', undefined, undefined, defineCustomElement$p)));\nconst IonItemDivider = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-divider', undefined, undefined, defineCustomElement$q)));\nconst IonItemGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-group', undefined, undefined, defineCustomElement$r)));\nconst IonItemOptions = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-options', undefined, undefined, defineCustomElement$s)));\nconst IonItemSliding = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-sliding', undefined, undefined, defineCustomElement$t)));\nconst index_esm_IonLabel = /*@__PURE__*/ createReactComponent('ion-label', undefined, undefined, ion_label_defineCustomElement);\nconst index_esm_IonList = /*@__PURE__*/ createReactComponent('ion-list', undefined, undefined, ion_list_defineCustomElement);\nconst index_esm_IonListHeader = /*@__PURE__*/ createReactComponent('ion-list-header', undefined, undefined, ion_list_header_defineCustomElement);\nconst IonMenu = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu', undefined, undefined, defineCustomElement$x)));\nconst IonMenuButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-button', undefined, undefined, defineCustomElement$y)));\nconst IonMenuToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-toggle', undefined, undefined, defineCustomElement$z)));\nconst IonNav = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav', undefined, undefined, defineCustomElement$A)));\nconst IonNavLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav-link', undefined, undefined, defineCustomElement$B)));\nconst IonNote = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-note', undefined, undefined, defineCustomElement$C)));\nconst IonProgressBar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-progress-bar', undefined, undefined, defineCustomElement$D)));\nconst IonRadio = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio', undefined, undefined, defineCustomElement$E)));\nconst IonRadioGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio-group', undefined, undefined, defineCustomElement$F)));\nconst IonRange = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-range', undefined, undefined, defineCustomElement$G)));\nconst IonRefresher = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher', undefined, undefined, defineCustomElement$H)));\nconst IonRefresherContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher-content', undefined, undefined, defineCustomElement$I)));\nconst IonReorder = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder', undefined, undefined, defineCustomElement$J)));\nconst IonReorderGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder-group', undefined, undefined, defineCustomElement$K)));\nconst IonRippleEffect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-ripple-effect', undefined, undefined, defineCustomElement$L)));\nconst IonRow = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-row', undefined, undefined, defineCustomElement$M)));\nconst IonSearchbar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-searchbar', undefined, undefined, defineCustomElement$N)));\nconst IonSegment = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment', undefined, undefined, defineCustomElement$O)));\nconst IonSegmentButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment-button', undefined, undefined, defineCustomElement$P)));\nconst IonSelect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select', undefined, undefined, defineCustomElement$Q)));\nconst IonSelectOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select-option', undefined, undefined, defineCustomElement$R)));\nconst IonSkeletonText = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-skeleton-text', undefined, undefined, defineCustomElement$S)));\nconst IonSlide = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slide', undefined, undefined, defineCustomElement$T)));\nconst IonSlides = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slides', undefined, undefined, defineCustomElement$U)));\nconst IonSpinner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-spinner', undefined, undefined, defineCustomElement$V)));\nconst IonSplitPane = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-split-pane', undefined, undefined, defineCustomElement$W)));\nconst IonTab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-tab', undefined, undefined, defineCustomElement$X)));\nconst index_esm_IonText = /*@__PURE__*/ createReactComponent('ion-text', undefined, undefined, ion_text_defineCustomElement);\nconst IonTextarea = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-textarea', undefined, undefined, defineCustomElement$Z)));\nconst IonThumbnail = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-thumbnail', undefined, undefined, defineCustomElement$_)));\nconst index_esm_IonTitle = /*@__PURE__*/ createReactComponent('ion-title', undefined, undefined, ion_title_defineCustomElement);\nconst IonToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-toggle', undefined, undefined, defineCustomElement$10)));\nconst index_esm_IonToolbar = /*@__PURE__*/ createReactComponent('ion-toolbar', undefined, undefined, ion_toolbar_defineCustomElement);\nconst IonVirtualScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-virtual-scroll', undefined, undefined, defineCustomElement$12)));\n\nconst createForwardRef = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_isPlatform = (platform) => {\n    return isPlatform(window, platform);\n};\nconst index_esm_getPlatforms = () => {\n    return getPlatforms$1(window);\n};\nconst getConfig = () => {\n    if (typeof window !== 'undefined') {\n        const Ionic = window.Ionic;\n        if (Ionic && Ionic.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n};\n\nconst createRoutingComponent = (tagName, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends react.Component {\n        constructor(props) {\n            super(props);\n            this.handleClick = (e) => {\n                const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;\n                if (routerLink !== undefined) {\n                    e.preventDefault();\n                    this.context.navigate(routerLink, routerDirection, undefined, routerAnimation, routerOptions);\n                }\n            };\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = react.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            if (this.props.routerLink && !this.props.href) {\n                newProps.href = this.props.routerLink;\n            }\n            if (newProps.onClick) {\n                const oldClick = newProps.onClick;\n                newProps.onClick = (e) => {\n                    oldClick(e);\n                    if (!e.defaultPrevented) {\n                        this.handleClick(e);\n                    }\n                };\n            }\n            else {\n                newProps.onClick = this.handleClick;\n            }\n            return (0,react.createElement)(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        static get contextType() {\n            return NavContext;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonRouterLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-router-link', IonRouterLink$1)));\nconst index_esm_IonButton = /*@__PURE__*/ createRoutingComponent('ion-button', IonButton);\nconst index_esm_IonCard = /*@__PURE__*/ createRoutingComponent('ion-card', IonCard);\nconst IonFabButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-fab-button', IonFabButton$1)));\nconst index_esm_IonItem = /*@__PURE__*/ createRoutingComponent('ion-item', IonItem);\nconst IonItemOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-item-option', IonItemOption$1)));\nconst IonBreadcrumb = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-breadcrumb', IonBreadcrumb$1)));\n\nconst createControllerComponent = (tagName, controller, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isUnmounted = false;\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        async componentDidMount() {\n            const { isOpen } = this.props;\n            if (isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            this.isUnmounted = true;\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        async componentDidUpdate(prevProps) {\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            this.overlay = await controller.create(Object.assign({}, cProps));\n            attachProps(this.overlay, {\n                [didDismissEventName]: this.handleDismiss,\n                [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),\n                [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),\n                [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e),\n            }, prevProps);\n            // Check isOpen again since the value could have changed during the async call to controller.create\n            // It's also possible for the component to have become unmounted.\n            if (this.props.isOpen === true && this.isUnmounted === false) {\n                setRef(this.props.forwardedRef, this.overlay);\n                await this.overlay.present();\n            }\n        }\n        render() {\n            return null;\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst IonAlert = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-alert', alertController, IonAlert$1)));\n\nconst IonLoading = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-loading', loadingController, IonLoading$1)));\n\nconst index_esm_toastController = {\n    create: (options) => toastController.create(options),\n    dismiss: (data, role, id) => toastController.dismiss(data, role, id),\n    getTop: () => toastController.getTop(),\n};\nconst IonToast = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-toast', index_esm_toastController, IonToast$1)));\n\nconst IonPicker = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-picker', pickerController, IonPicker$1)));\n\nconst createOverlayComponent = (tagName, controller, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isDismissing = false;\n            if (typeof document !== 'undefined') {\n                this.el = document.createElement('div');\n            }\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        componentDidMount() {\n            if (this.props.isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        shouldComponentUpdate(nextProps) {\n            // Check if the overlay component is about to dismiss\n            if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {\n                this.isDismissing = true;\n            }\n            return true;\n        }\n        async componentDidUpdate(prevProps) {\n            if (this.overlay) {\n                attachProps(this.overlay, this.props, prevProps);\n            }\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n                this.isDismissing = false;\n                /**\n                 * Now that the overlay is dismissed\n                 * we need to render again so that any\n                 * inner components will be unmounted\n                 */\n                this.forceUpdate();\n            }\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"children\", \"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });\n            this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));\n            setRef(this.props.forwardedRef, this.overlay);\n            attachProps(this.overlay, elementProps, prevProps);\n            await this.overlay.present();\n        }\n        render() {\n            /**\n             * Continue to render the component even when\n             * overlay is dismissing otherwise component\n             * will be hidden before animation is done.\n             */\n            return ReactDOM.createPortal(this.props.isOpen || this.isDismissing ? this.props.children : null, this.el);\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst index_esm_actionSheetController = {\n    create: (options) => actionSheetController.create(options),\n    dismiss: (data, role, id) => actionSheetController.dismiss(data, role, id),\n    getTop: () => actionSheetController.getTop(),\n};\nconst IonActionSheet = /*@__PURE__*/ (/* unused pure expression or super */ null && (createOverlayComponent('ion-action-sheet', index_esm_actionSheetController, defineCustomElement$13)));\n\nconst createInlineOverlayComponent = (tagName, defineCustomElement) => {\n    if (defineCustomElement) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends React.Component {\n        constructor(props) {\n            super(props);\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = React.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n            // Component is hidden by default\n            this.state = { isOpen: false };\n            // Create a local ref to the inner child element.\n            this.wrapperRef = React.createRef();\n        }\n        componentDidMount() {\n            var _a, _b;\n            this.componentDidUpdate(this.props);\n            /**\n             * Mount the inner component\n             * when overlay is about to open.\n             * Also manually call the onWillPresent\n             * handler if present as setState will\n             * cause the event handlers to be\n             * destroyed and re-created.\n             */\n            (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('willPresent', (evt) => {\n                this.setState({ isOpen: true });\n                this.props.onWillPresent && this.props.onWillPresent(evt);\n            });\n            /**\n             * Unmount the inner component.\n             * React will call Node.removeChild\n             * which expects the child to be\n             * a direct descendent of the parent\n             * but due to the presence of\n             * Web Component slots, this is not\n             * always the case. To work around this\n             * we move the inner component to the root\n             * of the Web Component so React can\n             * cleanup properly.\n             */\n            (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('didDismiss', (evt) => {\n                const wrapper = this.wrapperRef.current;\n                const el = this.ref.current;\n                /**\n                 * This component might be unmounted already, if the containing\n                 * element was removed while the popover was still open. (For\n                 * example, if an item contains an inline popover with a button\n                 * that removes the item.)\n                 */\n                if (wrapper && el) {\n                    el.append(wrapper);\n                    this.setState({ isOpen: false });\n                }\n                this.props.onDidDismiss && this.props.onDidDismiss(evt);\n            });\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            /**\n             * We only want the inner component\n             * to be mounted if the overlay is open,\n             * so conditionally render the component\n             * based on the isOpen state.\n             */\n            return createElement(tagName, newProps, (this.state.isOpen) ?\n                createElement('div', {\n                    id: 'ion-react-wrapper',\n                    ref: this.wrapperRef,\n                    style: {\n                        display: 'flex',\n                        flexDirection: 'column',\n                        height: '100%'\n                    }\n                }, children) :\n                null);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonModal = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-modal', defineCustomElement$14)));\n\nconst IonPopover = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-popover', defineCustomElement$15)));\n\nconst IonContext = react.createContext({\n    addOverlay: () => {\n        return;\n    },\n    removeOverlay: () => {\n        return;\n    },\n});\n\n/**\n * Manages overlays that are added via the useOverlay hook.\n * This is a standalone component so changes to its children don't cause other descendant\n * components to re-render when overlays are added. However, we need to communicate with the IonContext\n * that is set up in <IonApp />, so we register callbacks so when overlays are added to IonContext,\n * they ultimately added here.\n */\nconst IonOverlayManager = ({ onAddOverlay, onRemoveOverlay, }) => {\n    /**\n     * Because of the way we're passing around the addOverlay and removeOverlay\n     * callbacks, by the time they finally get called, they use a stale reference\n     * to the state that only has the initial values. So if two overlays are opened\n     * at the same time, both using useIonModal or similar (such as through nesting),\n     * the second will erase the first from the overlays list. This causes the content\n     * of the first overlay to unmount.\n     *\n     * We wrap the state in useRef to ensure the two callbacks always use the most\n     * up-to-date version.\n     *\n     * Further reading: https://stackoverflow.com/a/56554056\n     */\n    const [overlays, setOverlays] = useState({});\n    const overlaysRef = useRef({});\n    overlaysRef.current = overlays;\n    useEffect(() => {\n        /* Setup the callbacks that get called from <IonApp /> */\n        onAddOverlay(addOverlay);\n        onRemoveOverlay(removeOverlay);\n    }, []);\n    const addOverlay = (id, component, containerElement) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        newOverlays[id] = { component, containerElement };\n        setOverlays(newOverlays);\n    };\n    const removeOverlay = (id) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        delete newOverlays[id];\n        setOverlays(newOverlays);\n    };\n    const overlayKeys = Object.keys(overlays);\n    return (React.createElement(React.Fragment, null, overlayKeys.map((key) => {\n        const overlay = overlays[key];\n        return ReactDOM.createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);\n    })));\n};\n\nconst IonTabButtonInner = /*@__PURE__*/ createReactComponent('ion-tab-button', undefined, undefined, ion_tab_button_defineCustomElement);\nconst IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar', undefined, undefined, ion_tab_bar_defineCustomElement);\nconst IonBackButtonInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-back-button', undefined, undefined, defineCustomElement$18)));\nconst IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet', undefined, undefined, ion_router_outlet_defineCustomElement);\nconst IonAppInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-app', undefined, undefined, defineCustomElement$1a)));\n// ionicons\nconst IonIconInner = /*@__PURE__*/ createReactComponent('ion-icon', undefined, undefined, ion_icon_defineCustomElement);\n\nconst IonApp = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        /*\n          Wire up methods to call into IonOverlayManager\n        */\n        this.ionContext = {\n            addOverlay: (id, overlay, containerElement) => {\n                if (this.addOverlayCallback) {\n                    this.addOverlayCallback(id, overlay, containerElement);\n                }\n            },\n            removeOverlay: (id) => {\n                if (this.removeOverlayCallback) {\n                    this.removeOverlayCallback(id);\n                }\n            },\n        };\n    }\n    render() {\n        return (React.createElement(IonContext.Provider, { value: this.ionContext },\n            React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),\n            React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {\n                    this.addOverlayCallback = callback;\n                }, onRemoveOverlay: (callback) => {\n                    this.removeOverlayCallback = callback;\n                } })));\n    }\n    static get displayName() {\n        return 'IonApp';\n    }\n})()));\n\nconst StackContext = react.createContext({\n    registerIonPage: () => undefined,\n    isInOutlet: () => false,\n});\n\nclass PageManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.ionPageElementRef = react.createRef();\n        // React refs must be stable (not created inline).\n        this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);\n    }\n    componentDidMount() {\n        if (this.ionPageElementRef.current) {\n            if (this.context.isInOutlet()) {\n                this.ionPageElementRef.current.classList.add('ion-page-invisible');\n            }\n            this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);\n            this.ionPageElementRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionPageElementRef.current) {\n            this.ionPageElementRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"routeInfo\", \"forwardedRef\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(\"div\", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonPageInternal extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const _a = this.props, { className, children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (react.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo, forwardedRef: forwardedRef }, props), children)) : (react.createElement(\"div\", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));\n    }\n    static get displayName() {\n        return 'IonPage';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonPage = createForwardRef(IonPageInternal, 'IonPage');\n\nconst IonTabsContext = react.createContext({\n    activeTab: undefined,\n    selectTab: () => false,\n});\n\nconst HTMLElementSSR = (typeof HTMLElement !== 'undefined'\n    ? HTMLElement\n    : class {\n    });\n\nclass OutletPageManager extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    componentDidMount() {\n        if (this.ionRouterOutlet) {\n            (0,esm_es5.componentOnReady)(this.ionRouterOutlet, () => {\n                this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);\n            });\n            this.ionRouterOutlet.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionRouterOutlet) {\n            this.ionRouterOutlet.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { StackManager, children, routeInfo } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"StackManager\", \"children\", \"routeInfo\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(StackManager, { routeInfo: routeInfo },\n                react.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => (this.ionRouterOutlet = val) }, props), children)));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonRouterOutletContainer extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const StackManager = this.context.getStackManager();\n        const _a = this.props, { children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (props.ionPage ? (react.createElement(OutletPageManager, Object.assign({ StackManager: StackManager, routeInfo: this.context.routeInfo }, props), children)) : (react.createElement(StackManager, { routeInfo: this.context.routeInfo },\n            react.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef: forwardedRef }), children)))) : (react.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');\n\nconst index_esm_IonTabButton = /*@__PURE__*/ (() => class extends react.Component {\n    constructor(props) {\n        super(props);\n        this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);\n    }\n    handleIonTabButtonClick() {\n        if (this.props.onClick) {\n            this.props.onClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    tab: this.props.tab,\n                    href: this.props.href,\n                    routeOptions: this.props.routerOptions,\n                },\n            }));\n        }\n    }\n    render() {\n        const _a = this.props, rest = (0,tslib_es6/* __rest */._T)(_a, [\"onClick\"]);\n        return (react.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest)));\n    }\n    static get displayName() {\n        return 'IonTabButton';\n    }\n})();\n\nclass IonTabBarUnwrapped extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.setActiveTabOnContext = (_tab) => { };\n        const tabs = {};\n        react.Children.forEach(props.children, (child) => {\n            var _a, _b, _c, _d;\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                tabs[child.props.tab] = {\n                    originalHref: child.props.href,\n                    currentHref: child.props.href,\n                    originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname)\n                        ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : undefined,\n                    currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname)\n                        ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : undefined,\n                };\n            }\n        });\n        this.state = {\n            tabs,\n        };\n        this.onTabButtonClick = this.onTabButtonClick.bind(this);\n        this.renderTabButton = this.renderTabButton.bind(this);\n        this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);\n        this.selectTab = this.selectTab.bind(this);\n    }\n    componentDidMount() {\n        const tabs = this.state.tabs;\n        const tabKeys = Object.keys(tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = tabs[key].originalHref;\n            return this.props.routeInfo.pathname.startsWith(href);\n        });\n        if (activeTab) {\n            this.setState({\n                activeTab,\n            });\n        }\n    }\n    componentDidUpdate() {\n        if (this.state.activeTab) {\n            this.setActiveTabOnContext(this.state.activeTab);\n        }\n    }\n    selectTab(tab) {\n        const tabUrl = this.state.tabs[tab];\n        if (tabUrl) {\n            this.onTabButtonClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    href: tabUrl.currentHref,\n                    tab,\n                    selected: tab === this.state.activeTab,\n                    routeOptions: undefined,\n                },\n            }));\n            return true;\n        }\n        return false;\n    }\n    static getDerivedStateFromProps(props, state) {\n        var _a, _b, _c;\n        const tabs = Object.assign({}, state.tabs);\n        const tabKeys = Object.keys(state.tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = state.tabs[key].originalHref;\n            return props.routeInfo.pathname.startsWith(href);\n        });\n        // Check to see if the tab button href has changed, and if so, update it in the tabs state\n        react.Children.forEach(props.children, (child) => {\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const tab = tabs[child.props.tab];\n                if (!tab || tab.originalHref !== child.props.href) {\n                    tabs[child.props.tab] = {\n                        originalHref: child.props.href,\n                        currentHref: child.props.href,\n                        originalRouteOptions: child.props.routeOptions,\n                        currentRouteOptions: child.props.routeOptions,\n                    };\n                }\n            }\n        });\n        const { activeTab: prevActiveTab } = state;\n        if (activeTab && prevActiveTab) {\n            const prevHref = state.tabs[prevActiveTab].currentHref;\n            const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;\n            if (activeTab !== prevActiveTab ||\n                prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ||\n                prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {\n                tabs[activeTab] = {\n                    originalHref: tabs[activeTab].originalHref,\n                    currentHref: props.routeInfo.pathname + (props.routeInfo.search || ''),\n                    originalRouteOptions: tabs[activeTab].originalRouteOptions,\n                    currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions,\n                };\n                if (props.routeInfo.routeAction === 'pop' && activeTab !== prevActiveTab) {\n                    // If navigating back and the tabs change, set the prev tab back to its original href\n                    tabs[prevActiveTab] = {\n                        originalHref: tabs[prevActiveTab].originalHref,\n                        currentHref: tabs[prevActiveTab].originalHref,\n                        originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,\n                        currentRouteOptions: tabs[prevActiveTab].currentRouteOptions,\n                    };\n                }\n            }\n        }\n        activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);\n        return {\n            activeTab,\n            tabs,\n        };\n    }\n    onTabButtonClick(e) {\n        const tappedTab = this.state.tabs[e.detail.tab];\n        const originalHref = tappedTab.originalHref;\n        const currentHref = e.detail.href;\n        const { activeTab: prevActiveTab } = this.state;\n        // this.props.onSetCurrentTab(e.detail.tab, this.props.routeInfo);\n        // Clicking the current tab will bring you back to the original href\n        if (prevActiveTab === e.detail.tab) {\n            if (originalHref !== currentHref) {\n                this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);\n            }\n        }\n        else {\n            if (this.props.onIonTabsWillChange) {\n                this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', { detail: { tab: e.detail.tab } }));\n            }\n            if (this.props.onIonTabsDidChange) {\n                this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', { detail: { tab: e.detail.tab } }));\n            }\n            this.setActiveTabOnContext(e.detail.tab);\n            this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);\n        }\n    }\n    renderTabButton(activeTab) {\n        return (child) => {\n            var _a, _b;\n            if (child != null &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const href = child.props.tab === activeTab\n                    ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;\n                const routeOptions = child.props.tab === activeTab\n                    ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;\n                return react.cloneElement(child, {\n                    href,\n                    routeOptions,\n                    onClick: this.onTabButtonClick,\n                });\n            }\n            return null;\n        };\n    }\n    render() {\n        const { activeTab } = this.state;\n        return (react.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), react.Children.map(this.props.children, this.renderTabButton(activeTab))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonTabBarContainer = react.memo((_a) => {\n    var { forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"forwardedRef\"]);\n    const context = (0,react.useContext)(NavContext);\n    return (react.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children));\n});\nconst index_esm_IonTabBar = createForwardRef(IonTabBarContainer, 'IonTabBar');\n\nclass IonTabsElement extends HTMLElementSSR {\n    constructor() {\n        super();\n    }\n}\nif (typeof window !== 'undefined' && window.customElements) {\n    const element = window.customElements.get('ion-tabs');\n    if (!element) {\n        window.customElements.define('ion-tabs', IonTabsElement);\n    }\n}\nconst hostStyles = {\n    display: 'flex',\n    position: 'absolute',\n    top: '0',\n    left: '0',\n    right: '0',\n    bottom: '0',\n    flexDirection: 'column',\n    width: '100%',\n    height: '100%',\n    contain: 'layout size style',\n};\nconst tabsInner = {\n    position: 'relative',\n    flex: 1,\n    contain: 'layout size style',\n};\nconst IonTabs = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        this.routerOutletRef = React.createRef();\n        this.tabBarRef = React.createRef();\n        this.ionTabContextState = {\n            activeTab: undefined,\n            selectTab: () => false,\n        };\n    }\n    componentDidMount() {\n        if (this.tabBarRef.current) {\n            // Grab initial value\n            this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;\n            // Override method\n            this.tabBarRef.current.setActiveTabOnContext = (tab) => {\n                this.ionTabContextState.activeTab = tab;\n            };\n            this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;\n        }\n    }\n    render() {\n        let outlet;\n        let tabBar;\n        const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = __rest(_a, [\"className\", \"onIonTabsDidChange\", \"onIonTabsWillChange\"]);\n        const children = typeof this.props.children === 'function'\n            ? this.props.children(this.ionTabContextState)\n            : this.props.children;\n        React.Children.forEach(children, (child) => {\n            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {\n                return;\n            }\n            if (child.type === index_esm_IonRouterOutlet || child.type.isRouterOutlet) {\n                outlet = React.cloneElement(child);\n            }\n            else if (child.type === Fragment && child.props.children[0].type === index_esm_IonRouterOutlet) {\n                outlet = child.props.children[0];\n            }\n            let childProps = {\n                ref: this.tabBarRef\n            };\n            /**\n             * Only pass these props\n             * down from IonTabs to IonTabBar\n             * if they are defined, otherwise\n             * if you have a handler set on\n             * IonTabBar it will be overridden.\n             */\n            if (onIonTabsDidChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });\n            }\n            if (onIonTabsWillChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });\n            }\n            if (child.type === index_esm_IonTabBar || child.type.isTabBar) {\n                tabBar = React.cloneElement(child, childProps);\n            }\n            else if (child.type === Fragment &&\n                (child.props.children[1].type === index_esm_IonTabBar || child.props.children[1].type.isTabBar)) {\n                tabBar = React.cloneElement(child.props.children[1], childProps);\n            }\n        });\n        if (!outlet) {\n            throw new Error('IonTabs must contain an IonRouterOutlet');\n        }\n        if (!tabBar) {\n            throw new Error('IonTabs needs a IonTabBar');\n        }\n        return (React.createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? (React.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo }, props),\n            React.createElement(\"ion-tabs\", { className: \"ion-tabs\", style: hostStyles },\n                tabBar.props.slot === 'top' ? tabBar : null,\n                React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n                tabBar.props.slot === 'bottom' ? tabBar : null))) : (React.createElement(\"div\", Object.assign({ className: className ? `${className}` : 'ion-tabs' }, props, { style: hostStyles }),\n            tabBar.props.slot === 'top' ? tabBar : null,\n            React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n            tabBar.props.slot === 'bottom' ? tabBar : null))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nconst IonBackButton = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.clickButton = (e) => {\n            const { defaultHref, routerAnimation } = this.props;\n            if (this.context.hasIonicRouter()) {\n                e.stopPropagation();\n                this.context.goBack(defaultHref, routerAnimation);\n            }\n            else if (defaultHref !== undefined) {\n                window.location.href = defaultHref;\n            }\n        };\n    }\n    render() {\n        return React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));\n    }\n    static get displayName() {\n        return 'IonBackButton';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nclass IonIconContainer extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        if (this.props.name) {\n            console.warn('In Ionic React, you import icons from \"ionicons/icons\" and set the icon you imported to the \"icon\" property. Setting the \"name\" property has no effect.');\n        }\n    }\n    render() {\n        var _a, _b;\n        const _c = this.props, { icon, ios, md } = _c, rest = (0,tslib_es6/* __rest */._T)(_c, [\"icon\", \"ios\", \"md\"]);\n        let iconToUse;\n        if (ios || md) {\n            if (index_esm_isPlatform('ios')) {\n                iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n            }\n            else {\n                iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n            }\n        }\n        else {\n            iconToUse = icon;\n        }\n        return (react.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonIcon = createForwardRef(IonIconContainer, 'IonIcon');\n\nclass IonRoute extends react.PureComponent {\n    render() {\n        const IonRouteInner = this.context.getIonRoute();\n        if (!this.context.hasIonicRouter() || !IonRoute) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRoute>');\n            return null;\n        }\n        return React.createElement(IonRouteInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nclass IonRedirect extends react.PureComponent {\n    render() {\n        const IonRedirectInner = this.context.getIonRedirect();\n        if (!this.context.hasIonicRouter() || !IonRedirect) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRedirect>');\n            return null;\n        }\n        return React.createElement(IonRedirectInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nconst IonRouterContext = react.createContext({\n    routeInfo: undefined,\n    push: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    back: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    canGoBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    nativeBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n});\n/**\n * A hook for more direct control over routing in an Ionic React application. Allows you to pass additional meta-data to the router before the call to the native router.\n */\nfunction useIonRouter() {\n    const context = useContext(IonRouterContext);\n    return {\n        back: context.back,\n        push: context.push,\n        goBack: context.back,\n        canGoBack: context.canGoBack,\n        routeInfo: context.routeInfo,\n    };\n}\n\nclass CreateAnimation extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.nodes = new Map();\n        this.animation = createAnimation(props.id);\n    }\n    setupAnimation(props) {\n        const animation = this.animation;\n        if (this.nodes.size > 0) {\n            animation.addElement(Array.from(this.nodes.values()));\n        }\n        checkConfig(animation, props);\n        checkPlayback(animation, props);\n    }\n    componentDidMount() {\n        const props = this.props;\n        this.setupAnimation(props);\n    }\n    componentDidUpdate(prevProps) {\n        const animation = this.animation;\n        const props = this.props;\n        checkConfig(animation, props, prevProps);\n        checkProgress(animation, props, prevProps);\n        checkPlayback(animation, props, prevProps);\n    }\n    render() {\n        const { children } = this.props;\n        return (React.createElement(React.Fragment, null, React.Children.map(children, (child, id) => React.cloneElement(child, { ref: (el) => this.nodes.set(id, el) }))));\n    }\n}\nconst checkConfig = (animation, currentProps = {}, prevProps = {}) => {\n    const reservedProps = [\n        'children',\n        'progressStart',\n        'progressStep',\n        'progressEnd',\n        'pause',\n        'stop',\n        'destroy',\n        'play',\n        'from',\n        'to',\n        'fromTo',\n        'onFinish',\n    ];\n    for (const key in currentProps) {\n        if (currentProps.hasOwnProperty(key) &&\n            !reservedProps.includes(key) &&\n            currentProps[key] !== prevProps[key]) {\n            animation[key](currentProps[key]);\n        }\n    }\n    const fromValues = currentProps.from;\n    if (fromValues && fromValues !== prevProps.from) {\n        const values = Array.isArray(fromValues) ? fromValues : [fromValues];\n        values.forEach((val) => animation.from(val.property, val.value));\n    }\n    const toValues = currentProps.to;\n    if (toValues && toValues !== prevProps.to) {\n        const values = Array.isArray(toValues) ? toValues : [toValues];\n        values.forEach((val) => animation.to(val.property, val.value));\n    }\n    const fromToValues = currentProps.fromTo;\n    if (fromToValues && fromToValues !== prevProps.fromTo) {\n        const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];\n        values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));\n    }\n    const onFinishValues = currentProps.onFinish;\n    if (onFinishValues && onFinishValues !== prevProps.onFinish) {\n        const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];\n        values.forEach((val) => animation.onFinish(val.callback, val.opts));\n    }\n};\nconst checkProgress = (animation, currentProps = {}, prevProps = {}) => {\n    var _a, _b, _c, _d, _e;\n    const { progressStart, progressStep, progressEnd } = currentProps;\n    if (progressStart &&\n        (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) ||\n            ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {\n        animation.progressStart(progressStart.forceLinearEasing, progressStart.step);\n    }\n    if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {\n        animation.progressStep(progressStep.step);\n    }\n    if (progressEnd &&\n        (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) ||\n            ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) ||\n            (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {\n        animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);\n    }\n};\nconst checkPlayback = (animation, currentProps = {}, prevProps = {}) => {\n    if (!prevProps.play && currentProps.play) {\n        animation.play();\n    }\n    if (!prevProps.pause && currentProps.pause) {\n        animation.pause();\n    }\n    if (!prevProps.stop && currentProps.stop) {\n        animation.stop();\n    }\n    if (!prevProps.destroy && currentProps.destroy) {\n        animation.destroy();\n    }\n};\n\nfunction useController(displayName, controller, defineCustomElement) {\n    const overlayRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    defineCustomElement();\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        const handleDismiss = (event) => {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n        };\n        overlayRef.current = await controller.create(Object.assign({}, rest));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n    }, [controller]);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonActionSheet component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonActionSheet() {\n    const controller = useController('IonActionSheet', actionSheetController$1, defineCustomElement$13);\n    const present = useCallback((buttonsOrOptions, header) => {\n        if (Array.isArray(buttonsOrOptions)) {\n            return controller.present({\n                buttons: buttonsOrOptions,\n                header,\n            });\n        }\n        else {\n            return controller.present(buttonsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonAlert component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonAlert() {\n    const controller = useController('IonAlert', alertController, defineCustomElement$1c);\n    const present = useCallback((messageOrOptions, buttons) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonToast component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonToast() {\n    const controller = useController('IonToast', toastController$1, defineCustomElement$1d);\n    const present = useCallback((messageOrOptions, duration) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\nconst ids = { main: 0 };\nconst generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return id.toString();\n};\n\nfunction useOverlay(displayName, controller, defineCustomElement, component, componentProps) {\n    const overlayRef = useRef();\n    const containerElRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    const [isOpen, setIsOpen] = useState(false);\n    const ionContext = useContext(IonContext);\n    const [overlayId] = useState(generateId('overlay'));\n    defineCustomElement();\n    useEffect(() => {\n        if (isOpen && component && containerElRef.current) {\n            if (React.isValidElement(component)) {\n                ionContext.addOverlay(overlayId, component, containerElRef.current);\n            }\n            else {\n                const element = createElement(component, componentProps);\n                ionContext.addOverlay(overlayId, element, containerElRef.current);\n            }\n        }\n    }, [component, containerElRef.current, isOpen, componentProps]);\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        if (typeof document !== 'undefined') {\n            containerElRef.current = document.createElement('div');\n        }\n        overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n        setIsOpen(true);\n        function handleDismiss(event) {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n            containerElRef.current = undefined;\n            setIsOpen(false);\n            ionContext.removeOverlay(overlayId);\n        }\n    }, []);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n        containerElRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonModal component\n * @param component The component that the modal will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonModal(component, componentProps) {\n    const controller = useOverlay('IonModal', modalController, defineCustomElement$14, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @param component The component that the popover will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPopover(component, componentProps) {\n    const controller = useOverlay('IonPopover', popoverController, defineCustomElement$15, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPicker() {\n    const controller = useController('IonPicker', pickerController, defineCustomElement$1e);\n    const present = useCallback((columnsOrOptions, buttons) => {\n        if (Array.isArray(columnsOrOptions)) {\n            return controller.present({\n                columns: columnsOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(columnsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonLoading component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonLoading() {\n    const controller = useController('IonLoading', loadingController, defineCustomElement$1f);\n    const present = useCallback((messageOrOptions = '', duration, spinner) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration,\n                spinner: spinner !== null && spinner !== void 0 ? spinner : 'lines',\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\nconst setupIonicReact = (config = {}) => {\n    /**\n     * By default Ionic Framework hides elements that\n     * are not hydrated, but in the CE build there is no\n     * hydration.\n     * TODO: Remove when all integrations have been\n     * migrated to CE build.\n     */\n    if (typeof document !== 'undefined') {\n        document.documentElement.classList.add('ion-ce');\n    }\n    initialize(Object.assign({}, config));\n};\n\nconst RouteManagerContext = /*@__PURE__*/ react.createContext({\n    addViewItem: () => undefined,\n    canGoBack: () => undefined,\n    clearOutlet: () => undefined,\n    createViewItem: () => undefined,\n    findViewItemByPathname: () => undefined,\n    findLeavingViewItemByRouteInfo: () => undefined,\n    findViewItemByRouteInfo: () => undefined,\n    getChildrenToRender: () => undefined,\n    goBack: () => undefined,\n    unMountViewItem: () => undefined,\n});\n\nclass ViewLifeCycleManager extends react.Component {\n    constructor(props) {\n        super(props);\n        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();\n        this._isMounted = false;\n        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {\n            if (!this.props.mount) {\n                if (this._isMounted) {\n                    this.setState({\n                        show: false,\n                    }, () => this.props.removeView());\n                }\n            }\n        });\n        this.state = {\n            show: true,\n        };\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        this._isMounted = false;\n    }\n    render() {\n        const { show } = this.state;\n        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));\n    }\n}\n\n// const RESTRICT_SIZE = 100;\nclass LocationHistory {\n    constructor() {\n        this.locationHistory = [];\n        this.tabHistory = {};\n    }\n    add(routeInfo) {\n        if (routeInfo.routeAction === 'push' || routeInfo.routeAction == null) {\n            this._add(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'pop') {\n            this._pop(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'replace') {\n            this._replace(routeInfo);\n        }\n        if (routeInfo.routeDirection === 'root') {\n            this._clear();\n            this._add(routeInfo);\n        }\n    }\n    clearTabStack(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            routeInfos.forEach((ri) => {\n                this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);\n            });\n            this.tabHistory[tab] = [];\n        }\n    }\n    update(routeInfo) {\n        const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            this.locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = this.tabHistory[routeInfo.tab || ''];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            this.tabHistory[routeInfo.tab] = [routeInfo];\n        }\n    }\n    _add(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {\n                routeInfos.pop();\n            }\n            routeInfos.push(routeInfo);\n        }\n        this.locationHistory.push(routeInfo);\n    }\n    _areRoutesEqual(route1, route2) {\n        if (!route1 || !route2) {\n            return false;\n        }\n        return route1.pathname === route2.pathname && route1.search === route2.search;\n    }\n    _pop(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // Pop the previous route\n            routeInfos.pop();\n            // Replace the current route with an updated version\n            routeInfos.pop();\n            routeInfos.push(routeInfo);\n        }\n        // Pop the previous route\n        this.locationHistory.pop();\n        // Replace the current route with an updated version\n        this.locationHistory.pop();\n        this.locationHistory.push(routeInfo);\n    }\n    _replace(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        routeInfos && routeInfos.pop();\n        this.locationHistory.pop();\n        this._add(routeInfo);\n    }\n    _clear() {\n        const keys = Object.keys(this.tabHistory);\n        keys.forEach((k) => (this.tabHistory[k] = []));\n        this.locationHistory = [];\n    }\n    _getRouteInfosByKey(key) {\n        let routeInfos;\n        if (key) {\n            routeInfos = this.tabHistory[key];\n            if (!routeInfos) {\n                routeInfos = this.tabHistory[key] = [];\n            }\n        }\n        return routeInfos;\n    }\n    getFirstRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[0];\n        }\n        return undefined;\n    }\n    getCurrentRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[routeInfos.length - 1];\n        }\n        return undefined;\n    }\n    findLastLocation(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            for (let i = routeInfos.length - 2; i >= 0; i--) {\n                const ri = routeInfos[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        for (let i = this.locationHistory.length - 2; i >= 0; i--) {\n            const ri = this.locationHistory[i];\n            if (ri) {\n                if (ri.pathname === routeInfo.pushedByRoute) {\n                    return ri;\n                }\n            }\n        }\n        return undefined;\n    }\n    previous() {\n        return (this.locationHistory[this.locationHistory.length - 2] ||\n            this.locationHistory[this.locationHistory.length - 1]);\n    }\n    current() {\n        return this.locationHistory[this.locationHistory.length - 1];\n    }\n    canGoBack() {\n        return this.locationHistory.length > 1;\n    }\n}\n\nclass NavManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this._isMounted = false;\n        this.ionRouterContextValue = {\n            push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {\n                this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);\n            },\n            back: (animationBuilder) => {\n                this.goBack(undefined, animationBuilder);\n            },\n            canGoBack: () => this.props.locationHistory.canGoBack(),\n            nativeBack: () => this.props.onNativeBack(),\n            routeInfo: this.props.routeInfo,\n        };\n        this.state = {\n            goBack: this.goBack.bind(this),\n            hasIonicRouter: () => true,\n            navigate: this.navigate.bind(this),\n            getIonRedirect: this.getIonRedirect.bind(this),\n            getIonRoute: this.getIonRoute.bind(this),\n            getStackManager: this.getStackManager.bind(this),\n            getPageManager: this.getPageManager.bind(this),\n            routeInfo: this.props.routeInfo,\n            setCurrentTab: this.props.onSetCurrentTab,\n            changeTab: this.props.onChangeTab,\n            resetTab: this.props.onResetTab,\n        };\n        if (typeof document !== 'undefined') {\n            this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);\n            document.addEventListener('ionBackButton', this.handleHardwareBackButton);\n        }\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener('ionBackButton', this.handleHardwareBackButton);\n            this._isMounted = false;\n        }\n    }\n    handleHardwareBackButton(e) {\n        e.detail.register(0, (processNextHandler) => {\n            if (this._isMounted) {\n                this.nativeGoBack();\n                processNextHandler();\n            }\n        });\n    }\n    goBack(route, animationBuilder) {\n        this.props.onNavigateBack(route, animationBuilder);\n    }\n    nativeGoBack() {\n        this.props.onNativeBack();\n    }\n    navigate(path, direction = 'forward', action = 'push', animationBuilder, options, tab) {\n        this.props.onNavigate(path, action, direction, animationBuilder, options, tab);\n    }\n    getPageManager() {\n        return PageManager;\n    }\n    getIonRedirect() {\n        return this.props.ionRedirect;\n    }\n    getIonRoute() {\n        return this.props.ionRoute;\n    }\n    getStackManager() {\n        return this.props.stackManager;\n    }\n    render() {\n        return (React.createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },\n            React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)));\n    }\n}\n\nclass ViewStacks {\n    constructor() {\n        this.viewStacks = {};\n        this.add = this.add.bind(this);\n        this.clear = this.clear.bind(this);\n        this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);\n        this.remove = this.remove.bind(this);\n    }\n    add(viewItem) {\n        const { outletId } = viewItem;\n        if (!this.viewStacks[outletId]) {\n            this.viewStacks[outletId] = [viewItem];\n        }\n        else {\n            this.viewStacks[outletId].push(viewItem);\n        }\n    }\n    clear(outletId) {\n        // Give some time for the leaving views to transition before removing\n        setTimeout(() => {\n            // console.log('Removing viewstack for outletID ' + outletId);\n            delete this.viewStacks[outletId];\n        }, 500);\n    }\n    getViewItemsForOutlet(outletId) {\n        return this.viewStacks[outletId] || [];\n    }\n    remove(viewItem) {\n        const { outletId } = viewItem;\n        const viewStack = this.viewStacks[outletId];\n        if (viewStack) {\n            const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);\n            if (viewItemToRemove) {\n                viewItemToRemove.mount = false;\n                this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);\n            }\n        }\n    }\n    getStackIds() {\n        return Object.keys(this.viewStacks);\n    }\n    getAllViewItems() {\n        const keys = this.getStackIds();\n        const viewItems = [];\n        keys.forEach((k) => {\n            viewItems.push(...this.viewStacks[k]);\n        });\n        return viewItems;\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ5MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUM4Rjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUJBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSx1QkFBVTtBQUNoQixpQkFBaUIsMEJBQU87QUFDeEI7QUFDQSxNQUFNLHVCQUFVLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsNkJBQTZCLHNCQUFzQjtBQUMvSSxFQUFFLG1CQUFNO0FBQ1IsTUFBTSxtQkFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFNO0FBQ3ZCLDZCQUE2QixtQkFBTTtBQUNuQyxFQUFFLG1CQUFNO0FBQ1I7QUFDQTtBQUNBLE1BQU0sbUJBQU07QUFDWixJQUFJLG1CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFNkY7Ozs7O0FDbE83RjtBQUNBO0FBQ0E7QUFDaUU7QUFDUTtBQUNxRTs7QUFFOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQWUsaUJBQWlCLDZFQUE2QjtBQUNuRTtBQUNBLE1BQU0sMEJBQWlCLGlCQUFpQiwrRUFBK0I7QUFDdkUsTUFBTSx3QkFBZSxpQkFBaUIsNkVBQTZCO0FBQ25FLE1BQU0seUJBQWdCLGlCQUFpQiw4RUFBOEI7QUFDckUsTUFBTSwwQkFBaUIsaUJBQWlCLCtFQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVyxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBLG9DQUFvQyxhQUFnQjtBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWSxRQUFRLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUV3Rjs7O0FDakhRO0FBQ0w7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQixVQUFVLFdBQVcsZUFBZSxrQkFBa0IsMENBQTBDLGtDQUFrQyxlQUFlLG9CQUFvQixtQkFBbUIsVUFBVSxzQkFBc0Isa0JBQWtCLCtDQUErQyx5QkFBeUIsY0FBYyxZQUFZLFdBQVcsNkJBQTZCLDZCQUE2QixxQkFBcUIsbUJBQW1CLDBCQUEwQixtQkFBbUIsMEJBQTBCLGtCQUFrQix1Q0FBdUMsMEJBQTBCLG1EQUFtRCw0QkFBNEIscURBQXFELDJCQUEyQixvREFBb0QsMEJBQTBCLG1EQUFtRCwwQkFBMEIsbURBQW1ELHlCQUF5QixrREFBa0Qsd0JBQXdCLGlEQUFpRCx5QkFBeUIsa0RBQWtELHVCQUF1QixnREFBZ0Q7O0FBRWx4Qyx5QkFBeUIsQ0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBZTtBQUN2QixrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxDQUFDLENBQUMsSUFBSSxrQkFBa0IscUlBQXFJLGNBQWMsRUFBRSwyQkFBa0IsaUJBQWlCLFNBQVMsVUFBVSwrRUFBK0UsR0FBRyx3QkFBd0IsZUFBZSx1QkFBdUIsQ0FBQyxVQUFVLGlEQUFpRCxNQUFNLENBQUMsVUFBVSxxQkFBcUI7QUFDamU7QUFDQSw0QkFBNEI7QUFDNUIsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sbUJBQVUsVUFBVSxlQUFlO0FBQ3pDLE1BQU0sMkJBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDhCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGdCQUFnQixvREFBSTtBQUNwQixNQUFNLDRCQUFtQixHQUFHLDhCQUFxQjs7QUFFVDs7Ozs7OztBRXpPOEU7QUFDNkw7QUFDeEg7QUFDNUo7QUFDRTtBQUNzRTtBQUNNO0FBQ1Q7QUFDRTtBQUNIO0FBQ007QUFDSjtBQUNLO0FBQ0Q7QUFDRTtBQUNIO0FBQ0Y7QUFDSjtBQUNEO0FBQ0k7QUFDQztBQUNMO0FBQ0s7QUFDRjtBQUNGO0FBQ0U7QUFDSDtBQUNZO0FBQ1E7QUFDbEI7QUFDTztBQUNGO0FBQ0U7QUFDQTtBQUNQO0FBQ0Q7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNSO0FBQ0s7QUFDSjtBQUNRO0FBQ1A7QUFDTTtBQUNOO0FBQ0k7QUFDUTtBQUNWO0FBQ007QUFDQTtBQUNWO0FBQ007QUFDRjtBQUNPO0FBQ1I7QUFDTztBQUNBO0FBQ1I7QUFDQztBQUNDO0FBQ0c7QUFDUDtBQUNDO0FBQ0k7QUFDQztBQUNKO0FBQ0U7QUFDQztBQUNPO0FBQ2pCO0FBQ1o7QUFDTjtBQUNnQjtBQUNHO0FBQ25CO0FBQ21CO0FBQytCO0FBQ007QUFDTjtBQUNHO0FBQ3BCO0FBQ1A7QUFDRTtBQUNKO0FBQ1E7QUFDRTtBQUNOO0FBQ0c7QUFDVDtBQUNqRDs7QUFFL0MsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSx3QkFBd0I7QUFDckcsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQkFBbUI7O0FBRXZGLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CLGlDQUFpQyxXQUFXLG1CQUFtQjtBQUNqRztBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxNQUFNLDZCQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFnRCxlQUFlLDRCQUFNO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQiw2REFBNkQ7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxrSUFBa0Y7QUFDckgsd0NBQXdDLHdJQUF3RjtBQUNoSSxnQ0FBZ0MsK0hBQStFO0FBQy9HLGtDQUFrQyxpSUFBaUY7QUFDbkgsK0JBQStCLDhIQUE4RTtBQUM3RyxxQ0FBcUMsb0lBQW9GO0FBQ3pILGlDQUFpQyxnSUFBZ0Y7QUFDakgsTUFBTSx3QkFBYyxnRkFBZ0YsbUJBQXFCO0FBQ3pILG9DQUFvQyxvSUFBb0Y7QUFDeEgsc0NBQXNDLHNJQUFzRjtBQUM1SCxtQ0FBbUMsbUlBQW1GO0FBQ3RILGtDQUFrQyxpSUFBaUY7QUFDbkgsOEJBQThCLDZIQUE2RTtBQUMzRyw2QkFBNkIsNEhBQTRFO0FBQ3pHLE1BQU0sb0JBQVUsMkVBQTJFLCtCQUFxQjtBQUNoSCxrQ0FBa0MsaUlBQWlGO0FBQ25ILDZCQUE2Qiw0SEFBNEU7QUFDekcsaUNBQWlDLGlJQUFpRjtBQUNsSCxNQUFNLG1CQUFTLDBFQUEwRSw4QkFBcUI7QUFDOUcsOEJBQThCLDZIQUE2RTtBQUMzRyxNQUFNLG1CQUFTLDBFQUEwRSw4QkFBcUI7QUFDOUcsNkJBQTZCLDRIQUE0RTtBQUN6Ryx3Q0FBd0Msd0lBQXdGO0FBQ2hJLCtDQUErQyxnSkFBZ0c7QUFDL0ksK0JBQStCLDhIQUE4RTtBQUM3RyxxQ0FBcUMscUlBQXFGO0FBQzFILG1DQUFtQyxtSUFBbUY7QUFDdEgscUNBQXFDLHFJQUFxRjtBQUMxSCxxQ0FBcUMscUlBQXFGO0FBQzFILE1BQU0sa0JBQVEseUVBQXlFLDZCQUFxQjtBQUM1RyxNQUFNLGlCQUFPLHdFQUF3RSw0QkFBcUI7QUFDMUcsTUFBTSx1QkFBYSwrRUFBK0UsbUNBQXFCO0FBQ3ZILDhCQUE4Qiw2SEFBNkU7QUFDM0csb0NBQW9DLG9JQUFvRjtBQUN4SCxvQ0FBb0Msb0lBQW9GO0FBQ3hILDZCQUE2Qiw0SEFBNEU7QUFDekcsaUNBQWlDLGlJQUFpRjtBQUNsSCw4QkFBOEIsNkhBQTZFO0FBQzNHLHFDQUFxQyxxSUFBcUY7QUFDMUgsK0JBQStCLDhIQUE4RTtBQUM3RyxvQ0FBb0Msb0lBQW9GO0FBQ3hILCtCQUErQiw4SEFBOEU7QUFDN0csbUNBQW1DLGtJQUFrRjtBQUNySCwwQ0FBMEMsMElBQTBGO0FBQ3BJLGlDQUFpQyxnSUFBZ0Y7QUFDakgsc0NBQXNDLHNJQUFzRjtBQUM1SCxzQ0FBc0Msc0lBQXNGO0FBQzVILDZCQUE2Qiw0SEFBNEU7QUFDekcsbUNBQW1DLGtJQUFrRjtBQUNySCxpQ0FBaUMsZ0lBQWdGO0FBQ2pILHVDQUF1Qyx1SUFBdUY7QUFDOUgsZ0NBQWdDLCtIQUErRTtBQUMvRyxzQ0FBc0Msc0lBQXNGO0FBQzVILHNDQUFzQyxzSUFBc0Y7QUFDNUgsK0JBQStCLDhIQUE4RTtBQUM3RyxnQ0FBZ0MsK0hBQStFO0FBQy9HLGlDQUFpQyxnSUFBZ0Y7QUFDakgsbUNBQW1DLG1JQUFtRjtBQUN0SCw2QkFBNkIsNEhBQTRFO0FBQ3pHLE1BQU0saUJBQU8sd0VBQXdFLDRCQUFxQjtBQUMxRyxrQ0FBa0MsaUlBQWlGO0FBQ25ILG1DQUFtQyxrSUFBa0Y7QUFDckgsTUFBTSxrQkFBUSx5RUFBeUUsNkJBQXFCO0FBQzVHLGdDQUFnQyxnSUFBZ0Y7QUFDaEgsTUFBTSxvQkFBVSwyRUFBMkUsK0JBQXNCO0FBQ2pILHVDQUF1Qyx3SUFBd0Y7O0FBRS9IO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQixpQ0FBaUMsV0FBVyxtQkFBbUI7QUFDakc7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsTUFBTSxvQkFBVTtBQUNoQixXQUFXLFVBQVk7QUFDdkI7QUFDQSxNQUFNLHNCQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDZCQUFtQjtBQUN2QjtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4REFBOEQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBZ0QsZUFBZSw0QkFBTTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCLDJEQUEyRCxrQkFBa0IsbUNBQW1DO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsMEdBQTBEO0FBQzlGLE1BQU0sbUJBQVMsc0RBQXNELFNBQVc7QUFDaEYsTUFBTSxpQkFBTyxvREFBb0QsT0FBUztBQUMxRSxtQ0FBbUMsd0dBQXdEO0FBQzNGLE1BQU0saUJBQU8sb0RBQW9ELE9BQVM7QUFDMUUsb0NBQW9DLDBHQUEwRDtBQUM5RixvQ0FBb0MseUdBQXlEOztBQUU3RjtBQUNBLElBQUksNkJBQW1CO0FBQ3ZCO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQscUNBQXFDLFlBQVk7QUFDakQsc0NBQXNDLFlBQVk7QUFDbEQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVcsbUJBQW1CO0FBQzFGLEtBQUs7QUFDTDs7QUFFQSwrQkFBK0IsbUhBQW1FOztBQUVsRyxpQ0FBaUMseUhBQXlFOztBQUUxRyxNQUFNLHlCQUFlO0FBQ3JCLHlCQUF5QixzQkFBd0I7QUFDakQsaUNBQWlDLHVCQUF5QjtBQUMxRCxrQkFBa0Isc0JBQXdCO0FBQzFDO0FBQ0EsK0JBQStCLHVGQUF1Qyx5QkFBZSxhQUFhOztBQUVsRyxnQ0FBZ0Msc0hBQXNFOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQscUNBQXFDLFlBQVk7QUFDakQsc0NBQXNDLFlBQVk7QUFDbEQsc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYSw4VUFBOFU7QUFDMVosaUZBQWlGLG1CQUFtQix3Q0FBd0M7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXLG1CQUFtQjtBQUMxRixLQUFLO0FBQ0w7O0FBRUEsTUFBTSwrQkFBcUI7QUFDM0IseUJBQXlCLDRCQUE4QjtBQUN2RCxpQ0FBaUMsNkJBQStCO0FBQ2hFLGtCQUFrQiw0QkFBOEI7QUFDaEQ7QUFDQSxxQ0FBcUMsMkZBQTJDLCtCQUFxQix5QkFBeUI7O0FBRTlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBZ0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQiwyREFBMkQsa0JBQWtCLG1DQUFtQztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUhBQWlFOztBQUVoRyxpQ0FBaUMsbUhBQW1FOztBQUVwRyxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixJQUFJO0FBQ2pHLEtBQUs7QUFDTDs7QUFFQSxxR0FBcUcsa0NBQXNCO0FBQzNILCtGQUErRiwrQkFBc0I7QUFDckgseUNBQXlDLHFJQUFxRjtBQUM5SCwyR0FBMkcscUNBQXNCO0FBQ2pJLGtDQUFrQyw2SEFBNkU7QUFDL0c7QUFDQSwwRkFBMEYsNEJBQXNCOztBQUVoSCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdCQUF3QjtBQUNuRiw2REFBNkQ7QUFDN0QscURBQXFEO0FBQ3JEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtDQUErQyxjQUFjLDRCQUFNO0FBQ3BHLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSxvQkFBb0IsbUJBQW1CLHdCQUF3QiwwQkFBMEIsV0FBVyxvREFBb0Q7QUFDeEosU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DLGNBQWMsNEJBQU07QUFDekYsZ0RBQWdELG1CQUFtQiw4QkFBOEIsMEJBQTBCLFVBQVUsdUVBQXVFLHdCQUF3QixtQkFBbUIsd0JBQXdCLG1DQUFtQyxVQUFVLG1DQUFtQztBQUMvVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUFnQjtBQUM1QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0NBQW9DLGNBQWMsNEJBQU07QUFDekYsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLG9CQUFvQixtQkFBbUIsaUJBQWlCLHNCQUFzQjtBQUM5RSxnQkFBZ0IsbUJBQW1CLHVDQUF1QywrQ0FBK0M7QUFDekgsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUIsY0FBYyw0QkFBTTtBQUM5RSxpRUFBaUUsbUJBQW1CLG9DQUFvQywrREFBK0Qsd0JBQXdCLG1CQUFtQixpQkFBaUIsbUNBQW1DO0FBQ3RSLFlBQVksbUJBQW1CLHVDQUF1QyxXQUFXLDRCQUE0QixtQkFBbUIsbUJBQW1CLHVDQUF1QyxtQkFBbUI7QUFDN007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQWU7O0FBRXJCLE1BQU0sc0JBQVksc0NBQXNDLGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUFNO0FBQzVDLGdCQUFnQixtQkFBbUIsb0NBQW9DLG1EQUFtRDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsVUFBVSxxQkFBcUI7QUFDcEg7QUFDQTtBQUNBLG1GQUFtRixVQUFVLHFCQUFxQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsbUJBQW1CLGlDQUFpQyxnQkFBZ0Isd0JBQXdCLEdBQUcsa0JBQWtCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxVQUFVLGVBQWUsY0FBYyw0QkFBTTtBQUM3QyxvQkFBb0Isb0JBQVU7QUFDOUIsWUFBWSxtQkFBbUIscUNBQXFDLG1CQUFtQixXQUFXLHFEQUFxRCxvQ0FBb0MsMENBQTBDO0FBQ3JPLENBQUM7QUFDRCxNQUFNLG1CQUFTOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQXFEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUFlO0FBQzlDO0FBQ0E7QUFDQSxpRkFBaUYseUJBQWU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCLG9CQUFvQjtBQUNoRztBQUNBO0FBQ0EsMkRBQTJELGlCQUFpQixxQkFBcUI7QUFDakc7QUFDQSwrQkFBK0IsbUJBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1CQUFTO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdDQUFnQyxvRkFBb0YsMEJBQTBCLFVBQVUsMkNBQTJDO0FBQ2xRLDhDQUE4QywwQ0FBMEM7QUFDeEY7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGLGdIQUFnSCwwQkFBMEIsVUFBVSxnQkFBZ0IsV0FBVyxtQkFBbUI7QUFDbE07QUFDQSx5Q0FBeUMsMkNBQTJDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUosb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsMkJBQTJCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0IsYUFBYSw0QkFBTTtBQUNwRTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUIsK0JBQStCLCtDQUErQztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBTzs7QUFFYix1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixrSUFBa0kscUNBQXFDO0FBQ3ZLO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRCxtREFBbUQsWUFBWTtBQUMvRCxvREFBb0QsWUFBWTtBQUNoRSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUEyRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWTtBQUMzRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRCxtREFBbUQsWUFBWTtBQUMvRCxvREFBb0QsWUFBWTtBQUNoRSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUEyRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsV0FBVyxtQ0FBbUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZO0FBQzNGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsb0VBQW9FLGlDQUFpQztBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQ0FBcUMsaUJBQWlCLGlDQUFpQyxHQUFHO0FBQ3JKLDZEQUE2RCxxQ0FBcUMsaUNBQWlDLGlDQUFpQyxHQUFHO0FBQ3ZLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFK21EO0FBQy9tRCIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb25pYy1nbG9iYWwuanM/ZjhlNyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvb3ZlcmxheXMuanM/ZTJmOSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNhcmQtY29udGVudC5qcz9kN2JmIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy90aGVtZS5qcz81NGJmIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY29udGVudC5qcz8wMjg5Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZm9vdGVyLmpzPzcyN2QiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1oZWFkZXIuanM/NTAzZSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvbGFiZWwuanM/NzM2MyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWxhYmVsLmpzP2YyM2QiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2xpc3QuanM/ODgzZCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWxpc3QuanM/NDEzZSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvbGlzdC1oZWFkZXIuanM/MWQ5NyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWxpc3QtaGVhZGVyLmpzPzRjYjMiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10ZXh0LmpzP2YxZTkiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10aXRsZS5qcz9lMDM1Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdG9vbGJhci5qcz8xOWM3Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9idXR0b24uanM/OWYwZiIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJ1dHRvbi5qcz83OWE0Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC5qcz9jZWFmIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pbmRleDYuanM/NmRjYyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaXRlbS5qcz9lM2IwIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS5qcz9hYTcxIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9jdWJpYy1iZXppZXIuanM/YzUxMCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvZnJhbWV3b3JrLWRlbGVnYXRlLmpzP2MxMjEiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yb3V0ZXItb3V0bGV0LmpzP2JiYTkiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10YWItYmFyLmpzP2ZjNmYiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL3JpcHBsZS1lZmZlY3QuanM/NjA1YiIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRhYi1idXR0b24uanM/OGM5MCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2EzMDAiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9pb25pY29ucy9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanM/ODQxOSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL2NvbXBvbmVudHMvdXRpbHMuanM/OTY4OCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL2NvbXBvbmVudHMvaW9uLWljb24uanM/OGEzYyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvaW5kZXguanM/ZmU3MCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9yZWFjdC9kaXN0L2luZGV4LmVzbS5qcz83OGZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBDb250ZXh0LCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldE1vZGUsIGdldE1vZGUgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5cbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubSA9IG5ldyBNYXAoKTtcbiAgfVxuICByZXNldChjb25maWdPYmopIHtcbiAgICB0aGlzLm0gPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iaikpO1xuICB9XG4gIGdldChrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLm0uZ2V0KGtleSk7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGZhbGxiYWNrO1xuICB9XG4gIGdldEJvb2xlYW4oa2V5LCBmYWxsYmFjayA9IGZhbHNlKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5tLmdldChrZXkpO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWwgPT09ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuICEhdmFsO1xuICB9XG4gIGdldE51bWJlcihrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgdmFsID0gcGFyc2VGbG9hdCh0aGlzLm0uZ2V0KGtleSkpO1xuICAgIHJldHVybiBpc05hTih2YWwpID8gKGZhbGxiYWNrICE9PSB1bmRlZmluZWQgPyBmYWxsYmFjayA6IE5hTikgOiB2YWw7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm0uc2V0KGtleSwgdmFsdWUpO1xuICB9XG59XG5jb25zdCBjb25maWcgPSAvKkBfX1BVUkVfXyovIG5ldyBDb25maWcoKTtcbmNvbnN0IGNvbmZpZ0Zyb21TZXNzaW9uID0gKHdpbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbmZpZ1N0ciA9IHdpbi5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKElPTklDX1NFU1NJT05fS0VZKTtcbiAgICByZXR1cm4gY29uZmlnU3RyICE9PSBudWxsID8gSlNPTi5wYXJzZShjb25maWdTdHIpIDoge307XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5jb25zdCBzYXZlQ29uZmlnID0gKHdpbiwgYykgPT4ge1xuICB0cnkge1xuICAgIHdpbi5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKElPTklDX1NFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShjKSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn07XG5jb25zdCBjb25maWdGcm9tVVJMID0gKHdpbikgPT4ge1xuICBjb25zdCBjb25maWdPYmogPSB7fTtcbiAgd2luLmxvY2F0aW9uLnNlYXJjaFxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zcGxpdCgnPScpKVxuICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2RlY29kZVVSSUNvbXBvbmVudChrZXkpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpXSlcbiAgICAuZmlsdGVyKChba2V5XSkgPT4gc3RhcnRzV2l0aChrZXksIElPTklDX1BSRUZJWCkpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LnNsaWNlKElPTklDX1BSRUZJWC5sZW5ndGgpLCB2YWx1ZV0pXG4gICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbmZpZ09ialtrZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gY29uZmlnT2JqO1xufTtcbmNvbnN0IHN0YXJ0c1dpdGggPSAoaW5wdXQsIHNlYXJjaCkgPT4ge1xuICByZXR1cm4gaW5wdXQuc3Vic3RyKDAsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59O1xuY29uc3QgSU9OSUNfUFJFRklYID0gJ2lvbmljOic7XG5jb25zdCBJT05JQ19TRVNTSU9OX0tFWSA9ICdpb25pYy1wZXJzaXN0LWNvbmZpZyc7XG5cbmNvbnN0IGdldFBsYXRmb3JtcyA9ICh3aW4pID0+IHNldHVwUGxhdGZvcm1zKHdpbik7XG5jb25zdCBpc1BsYXRmb3JtID0gKHdpbk9yUGxhdGZvcm0sIHBsYXRmb3JtKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luT3JQbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICBwbGF0Zm9ybSA9IHdpbk9yUGxhdGZvcm07XG4gICAgd2luT3JQbGF0Zm9ybSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0UGxhdGZvcm1zKHdpbk9yUGxhdGZvcm0pLmluY2x1ZGVzKHBsYXRmb3JtKTtcbn07XG5jb25zdCBzZXR1cFBsYXRmb3JtcyA9ICh3aW4gPSB3aW5kb3cpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHdpbi5Jb25pYyA9IHdpbi5Jb25pYyB8fCB7fTtcbiAgbGV0IHBsYXRmb3JtcyA9IHdpbi5Jb25pYy5wbGF0Zm9ybXM7XG4gIGlmIChwbGF0Zm9ybXMgPT0gbnVsbCkge1xuICAgIHBsYXRmb3JtcyA9IHdpbi5Jb25pYy5wbGF0Zm9ybXMgPSBkZXRlY3RQbGF0Zm9ybXMod2luKTtcbiAgICBwbGF0Zm9ybXMuZm9yRWFjaChwID0+IHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChgcGx0LSR7cH1gKSk7XG4gIH1cbiAgcmV0dXJuIHBsYXRmb3Jtcztcbn07XG5jb25zdCBkZXRlY3RQbGF0Zm9ybXMgPSAod2luKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVBsYXRmb3JtTWV0aG9kcyA9IGNvbmZpZy5nZXQoJ3BsYXRmb3JtJyk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhQTEFURk9STVNfTUFQKS5maWx0ZXIocCA9PiB7XG4gICAgY29uc3QgY3VzdG9tTWV0aG9kID0gY3VzdG9tUGxhdGZvcm1NZXRob2RzICYmIGN1c3RvbVBsYXRmb3JtTWV0aG9kc1twXTtcbiAgICByZXR1cm4gdHlwZW9mIGN1c3RvbU1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1ldGhvZCh3aW4pIDogUExBVEZPUk1TX01BUFtwXSh3aW4pO1xuICB9KTtcbn07XG5jb25zdCBpc01vYmlsZVdlYiA9ICh3aW4pID0+IGlzTW9iaWxlKHdpbikgJiYgIWlzSHlicmlkKHdpbik7XG5jb25zdCBpc0lwYWQgPSAod2luKSA9PiB7XG4gIC8vIGlPUyAxMiBhbmQgYmVsb3dcbiAgaWYgKHRlc3RVc2VyQWdlbnQod2luLCAvaVBhZC9pKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGlPUyAxMytcbiAgaWYgKHRlc3RVc2VyQWdlbnQod2luLCAvTWFjaW50b3NoL2kpICYmIGlzTW9iaWxlKHdpbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNJcGhvbmUgPSAod2luKSA9PiB0ZXN0VXNlckFnZW50KHdpbiwgL2lQaG9uZS9pKTtcbmNvbnN0IGlzSU9TID0gKHdpbikgPT4gdGVzdFVzZXJBZ2VudCh3aW4sIC9pUGhvbmV8aVBvZC9pKSB8fCBpc0lwYWQod2luKTtcbmNvbnN0IGlzQW5kcm9pZCA9ICh3aW4pID0+IHRlc3RVc2VyQWdlbnQod2luLCAvYW5kcm9pZHxzaW5rL2kpO1xuY29uc3QgaXNBbmRyb2lkVGFibGV0ID0gKHdpbikgPT4ge1xuICByZXR1cm4gaXNBbmRyb2lkKHdpbikgJiYgIXRlc3RVc2VyQWdlbnQod2luLCAvbW9iaWxlL2kpO1xufTtcbmNvbnN0IGlzUGhhYmxldCA9ICh3aW4pID0+IHtcbiAgY29uc3Qgd2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luLmlubmVySGVpZ2h0O1xuICBjb25zdCBzbWFsbGVzdCA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBsYXJnZXN0ID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiAoc21hbGxlc3QgPiAzOTAgJiYgc21hbGxlc3QgPCA1MjApICYmXG4gICAgKGxhcmdlc3QgPiA2MjAgJiYgbGFyZ2VzdCA8IDgwMCk7XG59O1xuY29uc3QgaXNUYWJsZXQgPSAod2luKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbi5pbm5lckhlaWdodDtcbiAgY29uc3Qgc21hbGxlc3QgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgbGFyZ2VzdCA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICByZXR1cm4gKGlzSXBhZCh3aW4pIHx8XG4gICAgaXNBbmRyb2lkVGFibGV0KHdpbikgfHxcbiAgICAoKHNtYWxsZXN0ID4gNDYwICYmIHNtYWxsZXN0IDwgODIwKSAmJlxuICAgICAgKGxhcmdlc3QgPiA3ODAgJiYgbGFyZ2VzdCA8IDE0MDApKSk7XG59O1xuY29uc3QgaXNNb2JpbGUgPSAod2luKSA9PiBtYXRjaE1lZGlhKHdpbiwgJyhhbnktcG9pbnRlcjpjb2Fyc2UpJyk7XG5jb25zdCBpc0Rlc2t0b3AgPSAod2luKSA9PiAhaXNNb2JpbGUod2luKTtcbmNvbnN0IGlzSHlicmlkID0gKHdpbikgPT4gaXNDb3Jkb3ZhKHdpbikgfHwgaXNDYXBhY2l0b3JOYXRpdmUod2luKTtcbmNvbnN0IGlzQ29yZG92YSA9ICh3aW4pID0+ICEhKHdpblsnY29yZG92YSddIHx8IHdpblsncGhvbmVnYXAnXSB8fCB3aW5bJ1Bob25lR2FwJ10pO1xuY29uc3QgaXNDYXBhY2l0b3JOYXRpdmUgPSAod2luKSA9PiB7XG4gIGNvbnN0IGNhcGFjaXRvciA9IHdpblsnQ2FwYWNpdG9yJ107XG4gIHJldHVybiAhIShjYXBhY2l0b3IgJiYgY2FwYWNpdG9yLmlzTmF0aXZlKTtcbn07XG5jb25zdCBpc0VsZWN0cm9uID0gKHdpbikgPT4gdGVzdFVzZXJBZ2VudCh3aW4sIC9lbGVjdHJvbi9pKTtcbmNvbnN0IGlzUFdBID0gKHdpbikgPT4gISEoKHdpbi5tYXRjaE1lZGlhICYmIHdpbi5tYXRjaE1lZGlhKCcoZGlzcGxheS1tb2RlOiBzdGFuZGFsb25lKScpLm1hdGNoZXMpIHx8IHdpbi5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG5jb25zdCB0ZXN0VXNlckFnZW50ID0gKHdpbiwgZXhwcikgPT4gZXhwci50ZXN0KHdpbi5uYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IG1hdGNoTWVkaWEgPSAod2luLCBxdWVyeSkgPT4gd2luLm1hdGNoTWVkaWEgJiYgd2luLm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XG5jb25zdCBQTEFURk9STVNfTUFQID0ge1xuICAnaXBhZCc6IGlzSXBhZCxcbiAgJ2lwaG9uZSc6IGlzSXBob25lLFxuICAnaW9zJzogaXNJT1MsXG4gICdhbmRyb2lkJzogaXNBbmRyb2lkLFxuICAncGhhYmxldCc6IGlzUGhhYmxldCxcbiAgJ3RhYmxldCc6IGlzVGFibGV0LFxuICAnY29yZG92YSc6IGlzQ29yZG92YSxcbiAgJ2NhcGFjaXRvcic6IGlzQ2FwYWNpdG9yTmF0aXZlLFxuICAnZWxlY3Ryb24nOiBpc0VsZWN0cm9uLFxuICAncHdhJzogaXNQV0EsXG4gICdtb2JpbGUnOiBpc01vYmlsZSxcbiAgJ21vYmlsZXdlYic6IGlzTW9iaWxlV2ViLFxuICAnZGVza3RvcCc6IGlzRGVza3RvcCxcbiAgJ2h5YnJpZCc6IGlzSHlicmlkXG59O1xuXG5sZXQgZGVmYXVsdE1vZGU7XG5jb25zdCBnZXRJb25Nb2RlID0gKHJlZikgPT4ge1xuICByZXR1cm4gKHJlZiAmJiBnZXRNb2RlKHJlZikpIHx8IGRlZmF1bHRNb2RlO1xufTtcbmNvbnN0IGluaXRpYWxpemUgPSAodXNlckNvbmZpZyA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgQ29udGV4dC5jb25maWcgPSBjb25maWc7XG4gIGNvbnN0IElvbmljID0gd2luLklvbmljID0gd2luLklvbmljIHx8IHt9O1xuICBjb25zdCBwbGF0Zm9ybUhlbHBlcnMgPSB7fTtcbiAgaWYgKHVzZXJDb25maWcuX2FlbCkge1xuICAgIHBsYXRmb3JtSGVscGVycy5hZWwgPSB1c2VyQ29uZmlnLl9hZWw7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcuX3JlbCkge1xuICAgIHBsYXRmb3JtSGVscGVycy5yZWwgPSB1c2VyQ29uZmlnLl9yZWw7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcuX2NlKSB7XG4gICAgcGxhdGZvcm1IZWxwZXJzLmNlID0gdXNlckNvbmZpZy5fY2U7XG4gIH1cbiAgc2V0UGxhdGZvcm1IZWxwZXJzKHBsYXRmb3JtSGVscGVycyk7XG4gIC8vIGNyZWF0ZSB0aGUgSW9uaWMuY29uZmlnIGZyb20gcmF3IGNvbmZpZyBvYmplY3QgKGlmIGl0IGV4aXN0cylcbiAgLy8gYW5kIGNvbnZlcnQgSW9uaWMuY29uZmlnIGludG8gYSBDb25maWdBcGkgdGhhdCBoYXMgYSBnZXQoKSBmblxuICBjb25zdCBjb25maWdPYmogPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ0Zyb21TZXNzaW9uKHdpbikpLCB7IHBlcnNpc3RDb25maWc6IGZhbHNlIH0pLCBJb25pYy5jb25maWcpLCBjb25maWdGcm9tVVJMKHdpbikpLCB1c2VyQ29uZmlnKTtcbiAgY29uZmlnLnJlc2V0KGNvbmZpZ09iaik7XG4gIGlmIChjb25maWcuZ2V0Qm9vbGVhbigncGVyc2lzdENvbmZpZycpKSB7XG4gICAgc2F2ZUNvbmZpZyh3aW4sIGNvbmZpZ09iaik7XG4gIH1cbiAgLy8gU2V0dXAgcGxhdGZvcm1zXG4gIHNldHVwUGxhdGZvcm1zKHdpbik7XG4gIC8vIGZpcnN0IHNlZSBpZiB0aGUgbW9kZSB3YXMgc2V0IGFzIGFuIGF0dHJpYnV0ZSBvbiA8aHRtbD5cbiAgLy8gd2hpY2ggY291bGQgaGF2ZSBiZWVuIHNldCBieSB0aGUgdXNlciwgb3IgYnkgcHJlLXJlbmRlcmluZ1xuICAvLyBvdGhlcndpc2UgZ2V0IHRoZSBtb2RlIHZpYSBjb25maWcgc2V0dGluZ3MsIGFuZCBmYWxsYmFjayB0byBtZFxuICBJb25pYy5jb25maWcgPSBjb25maWc7XG4gIElvbmljLm1vZGUgPSBkZWZhdWx0TW9kZSA9IGNvbmZpZy5nZXQoJ21vZGUnLCAoZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGUnKSkgfHwgKGlzUGxhdGZvcm0od2luLCAnaW9zJykgPyAnaW9zJyA6ICdtZCcpKTtcbiAgY29uZmlnLnNldCgnbW9kZScsIGRlZmF1bHRNb2RlKTtcbiAgZG9jLmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBkZWZhdWx0TW9kZSk7XG4gIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkZWZhdWx0TW9kZSk7XG4gIGlmIChjb25maWcuZ2V0Qm9vbGVhbignX3Rlc3RpbmcnKSkge1xuICAgIGNvbmZpZy5zZXQoJ2FuaW1hdGVkJywgZmFsc2UpO1xuICB9XG4gIGNvbnN0IGlzSW9uaWNFbGVtZW50ID0gKGVsbSkgPT4gZWxtLnRhZ05hbWUgJiYgZWxtLnRhZ05hbWUuc3RhcnRzV2l0aCgnSU9OLScpO1xuICBjb25zdCBpc0FsbG93ZWRJb25pY01vZGVWYWx1ZSA9IChlbG1Nb2RlKSA9PiBbJ2lvcycsICdtZCddLmluY2x1ZGVzKGVsbU1vZGUpO1xuICBzZXRNb2RlKChlbG0pID0+IHtcbiAgICB3aGlsZSAoZWxtKSB7XG4gICAgICBjb25zdCBlbG1Nb2RlID0gZWxtLm1vZGUgfHwgZWxtLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgaWYgKGVsbU1vZGUpIHtcbiAgICAgICAgaWYgKGlzQWxsb3dlZElvbmljTW9kZVZhbHVlKGVsbU1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsbU1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJb25pY0VsZW1lbnQoZWxtKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBpb25pYyBtb2RlOiBcIicgKyBlbG1Nb2RlICsgJ1wiLCBleHBlY3RlZDogXCJpb3NcIiBvciBcIm1kXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxtID0gZWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0TW9kZTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBpc1BsYXRmb3JtIGFzIGEsIGdldElvbk1vZGUgYXMgYiwgY29uZmlnIGFzIGMsIGdldFBsYXRmb3JtcyBhcyBnLCBpbml0aWFsaXplIGFzIGkgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUsIGMgYXMgY29uZmlnIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWSB9IGZyb20gJy4vaGFyZHdhcmUtYmFjay1idXR0b24uanMnO1xuaW1wb3J0IHsgYyBhcyBjb21wb25lbnRPblJlYWR5LCBmIGFzIGZvY3VzRWxlbWVudCwgYSBhcyBhZGRFdmVudExpc3RlbmVyLCBiIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGcgYXMgZ2V0RWxlbWVudFJvb3QgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5sZXQgbGFzdElkID0gMDtcbmNvbnN0IGFjdGl2ZUFuaW1hdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgY3JlYXRlQ29udHJvbGxlciA9ICh0YWdOYW1lKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVPdmVybGF5KHRhZ05hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGlzbWlzcyhkYXRhLCByb2xlLCBpZCkge1xuICAgICAgcmV0dXJuIGRpc21pc3NPdmVybGF5KGRvY3VtZW50LCBkYXRhLCByb2xlLCB0YWdOYW1lLCBpZCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRUb3AoKSB7XG4gICAgICByZXR1cm4gZ2V0T3ZlcmxheShkb2N1bWVudCwgdGFnTmFtZSk7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGFsZXJ0Q29udHJvbGxlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlcignaW9uLWFsZXJ0Jyk7XG5jb25zdCBhY3Rpb25TaGVldENvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1hY3Rpb24tc2hlZXQnKTtcbmNvbnN0IGxvYWRpbmdDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tbG9hZGluZycpO1xuY29uc3QgbW9kYWxDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tbW9kYWwnKTtcbmNvbnN0IHBpY2tlckNvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1waWNrZXInKTtcbmNvbnN0IHBvcG92ZXJDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tcG9wb3ZlcicpO1xuY29uc3QgdG9hc3RDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tdG9hc3QnKTtcbmNvbnN0IHByZXBhcmVPdmVybGF5ID0gKGVsKSA9PiB7XG4gIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSAqL1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbm5lY3RMaXN0ZW5lcnMoZG9jdW1lbnQpO1xuICB9XG4gIGNvbnN0IG92ZXJsYXlJbmRleCA9IGxhc3RJZCsrO1xuICBlbC5vdmVybGF5SW5kZXggPSBvdmVybGF5SW5kZXg7XG4gIGlmICghZWwuaGFzQXR0cmlidXRlKCdpZCcpKSB7XG4gICAgZWwuaWQgPSBgaW9uLW92ZXJsYXktJHtvdmVybGF5SW5kZXh9YDtcbiAgfVxufTtcbmNvbnN0IGNyZWF0ZU92ZXJsYXkgPSAodGFnTmFtZSwgb3B0cykgPT4ge1xuICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuY3VzdG9tRWxlbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5jdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCh0YWdOYW1lKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdvdmVybGF5LWhpZGRlbicpO1xuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0IHRoZSBwYXNzZWQgaW4gb3ZlcmxheSBvcHRpb25zIGludG8gcHJvcHNcbiAgICAgICAqIHRoYXQgZ2V0IHBhc3NlZCBkb3duIGludG8gdGhlIG5ldyBvdmVybGF5LlxuICAgICAgICovXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgaGFzQ29udHJvbGxlcjogdHJ1ZSB9KSk7XG4gICAgICAvLyBhcHBlbmQgdGhlIG92ZXJsYXkgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgYm9keVxuICAgICAgZ2V0QXBwUm9vdChkb2N1bWVudCkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjb21wb25lbnRPblJlYWR5KGVsZW1lbnQsIHJlc29sdmUpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuY29uc3QgZm9jdXNhYmxlUXVlcnlTdHJpbmcgPSAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KFt0YWJpbmRleF49XCItXCJdKSwgdGV4dGFyZWE6bm90KFt0YWJpbmRleF49XCItXCJdKSwgYnV0dG9uOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIHNlbGVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCAuaW9uLWZvY3VzYWJsZTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pJztcbmNvbnN0IGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmcgPSAnaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3QnO1xuY29uc3QgZm9jdXNGaXJzdERlc2NlbmRhbnQgPSAocmVmLCBvdmVybGF5KSA9PiB7XG4gIGxldCBmaXJzdElucHV0ID0gcmVmLnF1ZXJ5U2VsZWN0b3IoZm9jdXNhYmxlUXVlcnlTdHJpbmcpO1xuICBjb25zdCBzaGFkb3dSb290ID0gZmlyc3RJbnB1dCAmJiBmaXJzdElucHV0LnNoYWRvd1Jvb3Q7XG4gIGlmIChzaGFkb3dSb290KSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGlubmVyIGZvY3VzYWJsZSBlbGVtZW50cywganVzdCBmb2N1cyB0aGUgaG9zdCBlbGVtZW50LlxuICAgIGZpcnN0SW5wdXQgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZykgfHwgZmlyc3RJbnB1dDtcbiAgfVxuICBpZiAoZmlyc3RJbnB1dCkge1xuICAgIGZvY3VzRWxlbWVudChmaXJzdElucHV0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBGb2N1cyBvdmVybGF5IGluc3RlYWQgb2YgbGV0dGluZyBmb2N1cyBlc2NhcGVcbiAgICBvdmVybGF5LmZvY3VzKCk7XG4gIH1cbn07XG5jb25zdCBpc092ZXJsYXlIaWRkZW4gPSAob3ZlcmxheSkgPT4gb3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ292ZXJsYXktaGlkZGVuJyk7XG5jb25zdCBmb2N1c0xhc3REZXNjZW5kYW50ID0gKHJlZiwgb3ZlcmxheSkgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKHJlZi5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZVF1ZXJ5U3RyaW5nKSk7XG4gIGxldCBsYXN0SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMCA/IGlucHV0c1tpbnB1dHMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICBjb25zdCBzaGFkb3dSb290ID0gbGFzdElucHV0ICYmIGxhc3RJbnB1dC5zaGFkb3dSb290O1xuICBpZiAoc2hhZG93Um9vdCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBpbm5lciBmb2N1c2FibGUgZWxlbWVudHMsIGp1c3QgZm9jdXMgdGhlIGhvc3QgZWxlbWVudC5cbiAgICBsYXN0SW5wdXQgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZykgfHwgbGFzdElucHV0O1xuICB9XG4gIGlmIChsYXN0SW5wdXQpIHtcbiAgICBsYXN0SW5wdXQuZm9jdXMoKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBGb2N1cyBvdmVybGF5IGluc3RlYWQgb2YgbGV0dGluZyBmb2N1cyBlc2NhcGVcbiAgICBvdmVybGF5LmZvY3VzKCk7XG4gIH1cbn07XG4vKipcbiAqIFRyYXBzIGtleWJvYXJkIGZvY3VzIGluc2lkZSBvZiBvdmVybGF5IGNvbXBvbmVudHMuXG4gKiBCYXNlZCBvbiBodHRwczovL3czYy5naXRodWIuaW8vYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvZGlhbG9nLW1vZGFsL2FsZXJ0ZGlhbG9nLmh0bWxcbiAqIFRoaXMgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiBBY3Rpb24gU2hlZXQsIEFsZXJ0LCBMb2FkaW5nLCBNb2RhbCxcbiAqIFBpY2tlciwgYW5kIFBvcG92ZXIuXG4gKiBTaG91bGQgTk9UIGluY2x1ZGU6IFRvYXN0XG4gKi9cbmNvbnN0IHRyYXBLZXlib2FyZEZvY3VzID0gKGV2LCBkb2MpID0+IHtcbiAgY29uc3QgbGFzdE92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYywgJ2lvbi1hbGVydCxpb24tYWN0aW9uLXNoZWV0LGlvbi1sb2FkaW5nLGlvbi1tb2RhbCxpb24tcGlja2VyLGlvbi1wb3BvdmVyJyk7XG4gIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiAgLyoqXG4gICAqIElmIG5vIGFjdGl2ZSBvdmVybGF5LCBpZ25vcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogSWYgdGhpcyBjb21wb25lbnQgdXNlcyB0aGUgc2hhZG93IGRvbSxcbiAgICogdGhpcyBnbG9iYWwgbGlzdGVuZXIgaXMgcG9pbnRsZXNzXG4gICAqIHNpbmNlIGl0IHdpbGwgbm90IGNhdGNoIHRoZSBmb2N1c1xuICAgKiB0cmFwcyBhcyB0aGV5IGFyZSBpbnNpZGUgdGhlIHNoYWRvdyByb290LlxuICAgKiBXZSBuZWVkIHRvIGFkZCBhIGxpc3RlbmVyIHRvIHRoZSBzaGFkb3cgcm9vdFxuICAgKiBpdHNlbGYgdG8gZW5zdXJlIHRoZSBmb2N1cyB0cmFwIHdvcmtzLlxuICAgKi9cbiAgaWYgKCFsYXN0T3ZlcmxheSB8fCAhdGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgaW9uLWRpc2FibGUtZm9jdXMtdHJhcCBjbGFzc1xuICAgKiBpcyBwcmVzZW50IG9uIGFuIG92ZXJsYXksIHRoZW4gdGhpcyBjb21wb25lbnRcbiAgICogaW5zdGFuY2UgaGFzIG9wdGVkIG91dCBvZiBmb2N1cyB0cmFwcGluZy5cbiAgICogQW4gZXhhbXBsZSBvZiB0aGlzIGlzIHdoZW4gdGhlIHNoZWV0IG1vZGFsXG4gICAqIGhhcyBhIGJhY2tkcm9wIHRoYXQgaXMgZGlzYWJsZWQuIFRoZSBjb250ZW50XG4gICAqIGJlaGluZCB0aGUgc2hlZXQgc2hvdWxkIGJlIGZvY3VzYWJsZSB1bnRpbFxuICAgKiB0aGUgYmFja2Ryb3AgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlmIChsYXN0T3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ2lvbi1kaXNhYmxlLWZvY3VzLXRyYXAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0cmFwU2NvcGVkRm9jdXMgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIGZvY3VzaW5nIHRoZSBvdmVybGF5LCBjbGVhclxuICAgICAqIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudCBzbyB0aGF0IGhpdHRpbmdcbiAgICAgKiB0YWIgYWN0aXZhdGVzIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAqIGluIHRoZSBvdmVybGF5IHdyYXBwZXIuXG4gICAgICovXG4gICAgaWYgKGxhc3RPdmVybGF5ID09PSB0YXJnZXQpIHtcbiAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICAgIC8qKlxuICAgICAgICogT3RoZXJ3aXNlLCB3ZSBtdXN0IGJlIGZvY3VzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAqIGluc2lkZSBvZiB0aGUgb3ZlcmxheS4gVGhlIHR3byBwb3NzaWJsZSBvcHRpb25zXG4gICAgICAgKiBoZXJlIGFyZSBhbiBpbnB1dC9idXR0b24vZXRjIG9yIHRoZSBpb24tZm9jdXMtdHJhcFxuICAgICAgICogZWxlbWVudC4gVGhlIGZvY3VzIHRyYXAgZWxlbWVudCBpcyB1c2VkIHRvIHByZXZlbnRcbiAgICAgICAqIHRoZSBrZXlib2FyZCBmb2N1cyBmcm9tIGxlYXZpbmcgdGhlIG92ZXJsYXkgd2hlblxuICAgICAgICogdXNpbmcgVGFiIG9yIHNjcmVlbiBhc3Npc3RhbnRzLlxuICAgICAgICovXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBXZSBkbyBub3Qgd2FudCB0byBmb2N1cyB0aGUgdHJhcHMsIHNvIGdldCB0aGUgb3ZlcmxheVxuICAgICAgICogd3JhcHBlciBlbGVtZW50IGFzIHRoZSB0cmFwcyBsaXZlIG91dHNpZGUgb2YgdGhlIHdyYXBwZXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG92ZXJsYXlSb290ID0gZ2V0RWxlbWVudFJvb3QobGFzdE92ZXJsYXkpO1xuICAgICAgaWYgKCFvdmVybGF5Um9vdC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXlXcmFwcGVyID0gb3ZlcmxheVJvb3QucXVlcnlTZWxlY3RvcignLmlvbi1vdmVybGF5LXdyYXBwZXInKTtcbiAgICAgIGlmICghb3ZlcmxheVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGluc2lkZSB0aGUgd3JhcHBlciwgbGV0IHRoZSBicm93c2VyXG4gICAgICAgKiBmb2N1cyBhcyBub3JtYWwgYW5kIGtlZXAgYSBsb2cgb2YgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBpZiAob3ZlcmxheVdyYXBwZXIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICBsYXN0T3ZlcmxheS5sYXN0Rm9jdXMgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE90aGVyd2lzZSwgd2UgbXVzdCBoYXZlIGZvY3VzZWQgb25lIG9mIHRoZSBmb2N1cyB0cmFwcy5cbiAgICAgICAgICogV2UgbmVlZCB0byB3cmFwIHRoZSBmb2N1cyB0byBlaXRoZXIgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICogb3IgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmNlIHdlIGNhbGwgYGZvY3VzRmlyc3REZXNjZW5kYW50YCBhbmQgZm9jdXMgdGhlIGZpcnN0XG4gICAgICAgICAqIGRlc2NlbmRhbnQsIGFub3RoZXIgZm9jdXMgZXZlbnQgd2lsbCBmaXJlIHdoaWNoIHdpbGxcbiAgICAgICAgICogY2F1c2UgYGxhc3RPdmVybGF5Lmxhc3RGb2N1c2AgdG8gYmUgdXBkYXRlZCBiZWZvcmVcbiAgICAgICAgICogd2UgY2FuIHJ1biB0aGUgY29kZSBhZnRlciB0aGF0LiBXZSB3aWxsIGNhY2hlIHRoZSB2YWx1ZVxuICAgICAgICAgKiBoZXJlIHRvIGF2b2lkIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0T3ZlcmxheS5sYXN0Rm9jdXM7XG4gICAgICAgIC8vIEZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBvdmVybGF5IHdyYXBwZXJcbiAgICAgICAgZm9jdXNGaXJzdERlc2NlbmRhbnQob3ZlcmxheVdyYXBwZXIsIGxhc3RPdmVybGF5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjYWNoZWQgbGFzdCBmb2N1c2VkIGVsZW1lbnQgaXMgdGhlXG4gICAgICAgICAqIHNhbWUgYXMgdGhlIGFjdGl2ZSBlbGVtZW50LCB0aGVuIHdlIG5lZWRcbiAgICAgICAgICogdG8gd3JhcCBmb2N1cyB0byB0aGUgbGFzdCBkZXNjZW5kYW50LiBUaGlzIGhhcHBlbnNcbiAgICAgICAgICogd2hlbiB0aGUgZmlyc3QgZGVzY2VuZGFudCBpcyBmb2N1c2VkLCBhbmQgdGhlIHVzZXJcbiAgICAgICAgICogcHJlc3NlcyBTaGlmdCArIFRhYi4gVGhlIHByZXZpb3VzIGxpbmUgd2lsbCBmb2N1c1xuICAgICAgICAgKiB0aGUgc2FtZSBkZXNjZW5kYW50IGFnYWluICh0aGUgZmlyc3Qgb25lKSwgY2F1c2luZ1xuICAgICAgICAgKiBsYXN0IGZvY3VzIHRvIGVxdWFsIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChsYXN0Rm9jdXMgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgZm9jdXNMYXN0RGVzY2VuZGFudChvdmVybGF5V3JhcHBlciwgbGFzdE92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhcFNoYWRvd0ZvY3VzID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgaW5zaWRlIHRoZSB3cmFwcGVyLCBsZXQgdGhlIGJyb3dzZXJcbiAgICAgKiBmb2N1cyBhcyBub3JtYWwgYW5kIGtlZXAgYSBsb2cgb2YgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGlmIChsYXN0T3ZlcmxheS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBsYXN0T3ZlcmxheS5sYXN0Rm9jdXMgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBPdGhlcndpc2UsIHdlIGFyZSBhYm91dCB0byBoYXZlIGZvY3VzXG4gICAgICAgKiBnbyBvdXQgb2YgdGhlIG92ZXJsYXkuIFdlIG5lZWQgdG8gd3JhcFxuICAgICAgICogdGhlIGZvY3VzIHRvIGVpdGhlciB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICogb3IgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBPbmNlIHdlIGNhbGwgYGZvY3VzRmlyc3REZXNjZW5kYW50YCBhbmQgZm9jdXMgdGhlIGZpcnN0XG4gICAgICAgKiBkZXNjZW5kYW50LCBhbm90aGVyIGZvY3VzIGV2ZW50IHdpbGwgZmlyZSB3aGljaCB3aWxsXG4gICAgICAgKiBjYXVzZSBgbGFzdE92ZXJsYXkubGFzdEZvY3VzYCB0byBiZSB1cGRhdGVkIGJlZm9yZVxuICAgICAgICogd2UgY2FuIHJ1biB0aGUgY29kZSBhZnRlciB0aGF0LiBXZSB3aWxsIGNhY2hlIHRoZSB2YWx1ZVxuICAgICAgICogaGVyZSB0byBhdm9pZCB0aGF0LlxuICAgICAgICovXG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0T3ZlcmxheS5sYXN0Rm9jdXM7XG4gICAgICAvLyBGb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgb3ZlcmxheSB3cmFwcGVyXG4gICAgICBmb2N1c0ZpcnN0RGVzY2VuZGFudChsYXN0T3ZlcmxheSwgbGFzdE92ZXJsYXkpO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgY2FjaGVkIGxhc3QgZm9jdXNlZCBlbGVtZW50IGlzIHRoZVxuICAgICAgICogc2FtZSBhcyB0aGUgYWN0aXZlIGVsZW1lbnQsIHRoZW4gd2UgbmVlZFxuICAgICAgICogdG8gd3JhcCBmb2N1cyB0byB0aGUgbGFzdCBkZXNjZW5kYW50LiBUaGlzIGhhcHBlbnNcbiAgICAgICAqIHdoZW4gdGhlIGZpcnN0IGRlc2NlbmRhbnQgaXMgZm9jdXNlZCwgYW5kIHRoZSB1c2VyXG4gICAgICAgKiBwcmVzc2VzIFNoaWZ0ICsgVGFiLiBUaGUgcHJldmlvdXMgbGluZSB3aWxsIGZvY3VzXG4gICAgICAgKiB0aGUgc2FtZSBkZXNjZW5kYW50IGFnYWluICh0aGUgZmlyc3Qgb25lKSwgY2F1c2luZ1xuICAgICAgICogbGFzdCBmb2N1cyB0byBlcXVhbCB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0Rm9jdXMgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIGZvY3VzTGFzdERlc2NlbmRhbnQobGFzdE92ZXJsYXksIGxhc3RPdmVybGF5KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgfTtcbiAgaWYgKGxhc3RPdmVybGF5LnNoYWRvd1Jvb3QpIHtcbiAgICB0cmFwU2hhZG93Rm9jdXMoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0cmFwU2NvcGVkRm9jdXMoKTtcbiAgfVxufTtcbmNvbnN0IGNvbm5lY3RMaXN0ZW5lcnMgPSAoZG9jKSA9PiB7XG4gIGlmIChsYXN0SWQgPT09IDApIHtcbiAgICBsYXN0SWQgPSAxO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChldikgPT4ge1xuICAgICAgdHJhcEtleWJvYXJkRm9jdXMoZXYsIGRvYyk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgLy8gaGFuZGxlIGJhY2stYnV0dG9uIGNsaWNrXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbkJhY2tCdXR0b24nLCBldiA9PiB7XG4gICAgICBjb25zdCBsYXN0T3ZlcmxheSA9IGdldE92ZXJsYXkoZG9jKTtcbiAgICAgIGlmIChsYXN0T3ZlcmxheSAmJiBsYXN0T3ZlcmxheS5iYWNrZHJvcERpc21pc3MpIHtcbiAgICAgICAgZXYuZGV0YWlsLnJlZ2lzdGVyKE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFksICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGFzdE92ZXJsYXkuZGlzbWlzcyh1bmRlZmluZWQsIEJBQ0tEUk9QKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIEVTQyB0byBjbG9zZSBvdmVybGF5XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZXYgPT4ge1xuICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgY29uc3QgbGFzdE92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYyk7XG4gICAgICAgIGlmIChsYXN0T3ZlcmxheSAmJiBsYXN0T3ZlcmxheS5iYWNrZHJvcERpc21pc3MpIHtcbiAgICAgICAgICBsYXN0T3ZlcmxheS5kaXNtaXNzKHVuZGVmaW5lZCwgQkFDS0RST1ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCBkaXNtaXNzT3ZlcmxheSA9IChkb2MsIGRhdGEsIHJvbGUsIG92ZXJsYXlUYWcsIGlkKSA9PiB7XG4gIGNvbnN0IG92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYywgb3ZlcmxheVRhZywgaWQpO1xuICBpZiAoIW92ZXJsYXkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ292ZXJsYXkgZG9lcyBub3QgZXhpc3QnKTtcbiAgfVxuICByZXR1cm4gb3ZlcmxheS5kaXNtaXNzKGRhdGEsIHJvbGUpO1xufTtcbmNvbnN0IGdldE92ZXJsYXlzID0gKGRvYywgc2VsZWN0b3IpID0+IHtcbiAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICBzZWxlY3RvciA9ICdpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3Zlcixpb24tdG9hc3QnO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAuZmlsdGVyKGMgPT4gYy5vdmVybGF5SW5kZXggPiAwKTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gb3ZlcmxheSBlbGVtZW50XG4gKiBAcGFyYW0gZG9jIFRoZSBkb2N1bWVudCB0byBmaW5kIHRoZSBlbGVtZW50IHdpdGhpbi5cbiAqIEBwYXJhbSBvdmVybGF5VGFnIFRoZSBzZWxlY3RvciBmb3IgdGhlIG92ZXJsYXksIGRlZmF1bHRzIHRvIElvbmljIG92ZXJsYXkgY29tcG9uZW50cy5cbiAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBvdmVybGF5IGluc3RhbmNlLlxuICogQHJldHVybnMgVGhlIG92ZXJsYXkgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiBubyBvdmVybGF5IGVsZW1lbnQgaXMgZm91bmQuXG4gKi9cbmNvbnN0IGdldE92ZXJsYXkgPSAoZG9jLCBvdmVybGF5VGFnLCBpZCkgPT4ge1xuICBjb25zdCBvdmVybGF5cyA9IGdldE92ZXJsYXlzKGRvYywgb3ZlcmxheVRhZykuZmlsdGVyKG8gPT4gIWlzT3ZlcmxheUhpZGRlbihvKSk7XG4gIHJldHVybiAoaWQgPT09IHVuZGVmaW5lZClcbiAgICA/IG92ZXJsYXlzW292ZXJsYXlzLmxlbmd0aCAtIDFdXG4gICAgOiBvdmVybGF5cy5maW5kKG8gPT4gby5pZCA9PT0gaWQpO1xufTtcbi8qKlxuICogV2hlbiBhbiBvdmVybGF5IGlzIHByZXNlbnRlZCwgdGhlIG1haW5cbiAqIGZvY3VzIGlzIHRoZSBvdmVybGF5IG5vdCB0aGUgcGFnZSBjb250ZW50LlxuICogV2UgbmVlZCB0byByZW1vdmUgdGhlIHBhZ2UgY29udGVudCBmcm9tIHRoZVxuICogYWNjZXNzaWJpbGl0eSB0cmVlIG90aGVyd2lzZSB3aGVuXG4gKiB1c2VycyB1c2UgXCJyZWFkIHNjcmVlbiBmcm9tIHRvcFwiIGdlc3R1cmVzIHdpdGhcbiAqIFRhbGtCYWNrIGFuZCBWb2ljZU92ZXIsIHRoZSBzY3JlZW4gcmVhZGVyIHdpbGwgYmVnaW5cbiAqIHRvIHJlYWQgdGhlIGNvbnRlbnQgdW5kZXJuZWF0aCB0aGUgb3ZlcmxheS5cbiAqXG4gKiBXZSBuZWVkIGEgY29udGFpbmVyIHdoZXJlIGFsbCBwYWdlIGNvbXBvbmVudHNcbiAqIGV4aXN0IHRoYXQgaXMgc2VwYXJhdGUgZnJvbSB3aGVyZSB0aGUgb3ZlcmxheXNcbiAqIGFyZSBhZGRlZCBpbiB0aGUgRE9NLiBGb3IgbW9zdCBhcHBzLCB0aGlzIGVsZW1lbnRcbiAqIGlzIHRoZSB0b3AgbW9zdCBpb24tcm91dGVyLW91dGxldC4gSW4gdGhlIGV2ZW50XG4gKiB0aGF0IGRldnMgYXJlIG5vdCB1c2luZyBhIHJvdXRlcixcbiAqIHRoZXkgd2lsbCBuZWVkIHRvIGFkZCB0aGUgXCJpb24tdmlldy1jb250YWluZXItcm9vdFwiXG4gKiBpZCB0byB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGVpciB2aWV3cy5cbiAqXG4gKiBUT0RPOiBJZiBGcmFtZXdvcmsgc3VwcG9ydHMgaGF2aW5nIG11bHRpcGxlIHRvcFxuICogbGV2ZWwgcm91dGVyIG91dGxldHMgd2Ugd291bGQgbmVlZCB0byB1cGRhdGUgdGhpcy5cbiAqIEV4YW1wbGU6IE9uZSBvdXRsZXQgZm9yIHNpZGUgbWVudSBhbmQgb25lIG91dGxldFxuICogZm9yIG1haW4gY29udGVudC5cbiAqL1xuY29uc3Qgc2V0Um9vdEFyaWFIaWRkZW4gPSAoaGlkZGVuID0gZmFsc2UpID0+IHtcbiAgY29uc3Qgcm9vdCA9IGdldEFwcFJvb3QoZG9jdW1lbnQpO1xuICBjb25zdCB2aWV3Q29udGFpbmVyID0gcm9vdC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyLW91dGxldCwgaW9uLW5hdiwgI2lvbi12aWV3LWNvbnRhaW5lci1yb290Jyk7XG4gIGlmICghdmlld0NvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaGlkZGVuKSB7XG4gICAgdmlld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2aWV3Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgfVxufTtcbmNvbnN0IHByZXNlbnQgPSBhc3luYyAob3ZlcmxheSwgbmFtZSwgaW9zRW50ZXJBbmltYXRpb24sIG1kRW50ZXJBbmltYXRpb24sIG9wdHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKG92ZXJsYXkucHJlc2VudGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNldFJvb3RBcmlhSGlkZGVuKHRydWUpO1xuICBvdmVybGF5LnByZXNlbnRlZCA9IHRydWU7XG4gIG92ZXJsYXkud2lsbFByZXNlbnQuZW1pdCgpO1xuICAoX2EgPSBvdmVybGF5LndpbGxQcmVzZW50U2hvcnRoYW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdCgpO1xuICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZShvdmVybGF5KTtcbiAgLy8gZ2V0IHRoZSB1c2VyJ3MgYW5pbWF0aW9uIGZuIGlmIG9uZSB3YXMgcHJvdmlkZWRcbiAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IChvdmVybGF5LmVudGVyQW5pbWF0aW9uKVxuICAgID8gb3ZlcmxheS5lbnRlckFuaW1hdGlvblxuICAgIDogY29uZmlnLmdldChuYW1lLCBtb2RlID09PSAnaW9zJyA/IGlvc0VudGVyQW5pbWF0aW9uIDogbWRFbnRlckFuaW1hdGlvbik7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IGF3YWl0IG92ZXJsYXlBbmltYXRpb24ob3ZlcmxheSwgYW5pbWF0aW9uQnVpbGRlciwgb3ZlcmxheS5lbCwgb3B0cyk7XG4gIGlmIChjb21wbGV0ZWQpIHtcbiAgICBvdmVybGF5LmRpZFByZXNlbnQuZW1pdCgpO1xuICAgIChfYiA9IG92ZXJsYXkuZGlkUHJlc2VudFNob3J0aGFuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXQoKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiBhbiBvdmVybGF5IHRoYXQgc3RlYWxzIGZvY3VzXG4gICAqIGlzIGRpc21pc3NlZCwgZm9jdXMgc2hvdWxkIGJlIHJldHVybmVkXG4gICAqIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWRcbiAgICogcHJpb3IgdG8gdGhlIG92ZXJsYXkgb3BlbmluZy4gVG9hc3RcbiAgICogZG9lcyBub3Qgc3RlYWwgZm9jdXMgYW5kIGlzIGV4Y2x1ZGVkXG4gICAqIGZyb20gcmV0dXJuaW5nIGZvY3VzIGFzIGEgcmVzdWx0LlxuICAgKi9cbiAgaWYgKG92ZXJsYXkuZWwudGFnTmFtZSAhPT0gJ0lPTi1UT0FTVCcpIHtcbiAgICBmb2N1c1ByZXZpb3VzRWxlbWVudE9uRGlzbWlzcyhvdmVybGF5LmVsKTtcbiAgfVxuICBpZiAob3ZlcmxheS5rZXlib2FyZENsb3NlKSB7XG4gICAgb3ZlcmxheS5lbC5mb2N1cygpO1xuICB9XG59O1xuLyoqXG4gKiBXaGVuIGFuIG92ZXJsYXkgY29tcG9uZW50IGlzIGRpc21pc3NlZCxcbiAqIGZvY3VzIHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgZWxlbWVudFxuICogdGhhdCBwcmVzZW50ZWQgdGhlIG92ZXJsYXkuIE90aGVyd2lzZVxuICogZm9jdXMgd2lsbCBiZSBzZXQgb24gdGhlIGJvZHkgd2hpY2hcbiAqIG1lYW5zIHRoYXQgcGVvcGxlIHVzaW5nIHNjcmVlbiByZWFkZXJzXG4gKiBvciB0YWJiaW5nIHdpbGwgbmVlZCB0byByZS1uYXZpZ2F0ZVxuICogdG8gd2hlcmUgdGhleSB3ZXJlIGJlZm9yZSB0aGV5XG4gKiBvcGVuZWQgdGhlIG92ZXJsYXkuXG4gKi9cbmNvbnN0IGZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzID0gYXN5bmMgKG92ZXJsYXlFbCkgPT4ge1xuICBsZXQgcHJldmlvdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCFwcmV2aW91c0VsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2hhZG93Um9vdCA9IHByZXZpb3VzRWxlbWVudCAmJiBwcmV2aW91c0VsZW1lbnQuc2hhZG93Um9vdDtcbiAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaW5uZXIgZm9jdXNhYmxlIGVsZW1lbnRzLCBqdXN0IGZvY3VzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgcHJldmlvdXNFbGVtZW50ID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmcpIHx8IHByZXZpb3VzRWxlbWVudDtcbiAgfVxuICBhd2FpdCBvdmVybGF5RWwub25EaWREaXNtaXNzKCk7XG4gIHByZXZpb3VzRWxlbWVudC5mb2N1cygpO1xufTtcbmNvbnN0IGRpc21pc3MgPSBhc3luYyAob3ZlcmxheSwgZGF0YSwgcm9sZSwgbmFtZSwgaW9zTGVhdmVBbmltYXRpb24sIG1kTGVhdmVBbmltYXRpb24sIG9wdHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKCFvdmVybGF5LnByZXNlbnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzZXRSb290QXJpYUhpZGRlbihmYWxzZSk7XG4gIG92ZXJsYXkucHJlc2VudGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgLy8gT3ZlcmxheSBjb250ZW50cyBzaG91bGQgbm90IGJlIGNsaWNrYWJsZSBkdXJpbmcgZGlzbWlzc1xuICAgIG92ZXJsYXkuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgICBvdmVybGF5LndpbGxEaXNtaXNzLmVtaXQoeyBkYXRhLCByb2xlIH0pO1xuICAgIChfYSA9IG92ZXJsYXkud2lsbERpc21pc3NTaG9ydGhhbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0KHsgZGF0YSwgcm9sZSB9KTtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZShvdmVybGF5KTtcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gKG92ZXJsYXkubGVhdmVBbmltYXRpb24pXG4gICAgICA/IG92ZXJsYXkubGVhdmVBbmltYXRpb25cbiAgICAgIDogY29uZmlnLmdldChuYW1lLCBtb2RlID09PSAnaW9zJyA/IGlvc0xlYXZlQW5pbWF0aW9uIDogbWRMZWF2ZUFuaW1hdGlvbik7XG4gICAgLy8gSWYgZGlzbWlzc2VkIHZpYSBnZXN0dXJlLCBubyBuZWVkIHRvIHBsYXkgbGVhdmluZyBhbmltYXRpb24gYWdhaW5cbiAgICBpZiAocm9sZSAhPT0gJ2dlc3R1cmUnKSB7XG4gICAgICBhd2FpdCBvdmVybGF5QW5pbWF0aW9uKG92ZXJsYXksIGFuaW1hdGlvbkJ1aWxkZXIsIG92ZXJsYXkuZWwsIG9wdHMpO1xuICAgIH1cbiAgICBvdmVybGF5LmRpZERpc21pc3MuZW1pdCh7IGRhdGEsIHJvbGUgfSk7XG4gICAgKF9iID0gb3ZlcmxheS5kaWREaXNtaXNzU2hvcnRoYW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdCh7IGRhdGEsIHJvbGUgfSk7XG4gICAgYWN0aXZlQW5pbWF0aW9ucy5kZWxldGUob3ZlcmxheSk7XG4gICAgLyoqXG4gICAgICogTWFrZSBvdmVybGF5IGhpZGRlbiBhZ2FpbiBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZC5cbiAgICAgKiBXZSBjYW4gc2FmZWx5IHJlbW92ZSBwb2ludGVyLWV2ZW50czogbm9uZSBhc1xuICAgICAqIG92ZXJsYXktaGlkZGVuIHdpbGwgc2V0IGRpc3BsYXk6IG5vbmUuXG4gICAgICovXG4gICAgb3ZlcmxheS5lbC5jbGFzc0xpc3QuYWRkKCdvdmVybGF5LWhpZGRlbicpO1xuICAgIG92ZXJsYXkuZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJyk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxuICBvdmVybGF5LmVsLnJlbW92ZSgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBnZXRBcHBSb290ID0gKGRvYykgPT4ge1xuICByZXR1cm4gZG9jLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1hcHAnKSB8fCBkb2MuYm9keTtcbn07XG5jb25zdCBvdmVybGF5QW5pbWF0aW9uID0gYXN5bmMgKG92ZXJsYXksIGFuaW1hdGlvbkJ1aWxkZXIsIGJhc2VFbCwgb3B0cykgPT4ge1xuICAvLyBNYWtlIG92ZXJsYXkgdmlzaWJsZSBpbiBjYXNlIGl0J3MgaGlkZGVuXG4gIGJhc2VFbC5jbGFzc0xpc3QucmVtb3ZlKCdvdmVybGF5LWhpZGRlbicpO1xuICBjb25zdCBhbmlSb290ID0gb3ZlcmxheS5lbDtcbiAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0aW9uQnVpbGRlcihhbmlSb290LCBvcHRzKTtcbiAgaWYgKCFvdmVybGF5LmFuaW1hdGVkIHx8ICFjb25maWcuZ2V0Qm9vbGVhbignYW5pbWF0ZWQnLCB0cnVlKSkge1xuICAgIGFuaW1hdGlvbi5kdXJhdGlvbigwKTtcbiAgfVxuICBpZiAob3ZlcmxheS5rZXlib2FyZENsb3NlKSB7XG4gICAgYW5pbWF0aW9uLmJlZm9yZUFkZFdyaXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBiYXNlRWwub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5tYXRjaGVzKCdpbnB1dCxpb24taW5wdXQsIGlvbi10ZXh0YXJlYScpKSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUFuaSA9IGFjdGl2ZUFuaW1hdGlvbnMuZ2V0KG92ZXJsYXkpIHx8IFtdO1xuICBhY3RpdmVBbmltYXRpb25zLnNldChvdmVybGF5LCBbLi4uYWN0aXZlQW5pLCBhbmltYXRpb25dKTtcbiAgYXdhaXQgYW5pbWF0aW9uLnBsYXkoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgZXZlbnRNZXRob2QgPSAoZWxlbWVudCwgZXZlbnROYW1lKSA9PiB7XG4gIGxldCByZXNvbHZlO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gIG9uY2VFdmVudChlbGVtZW50LCBldmVudE5hbWUsIChldmVudCkgPT4ge1xuICAgIHJlc29sdmUoZXZlbnQuZGV0YWlsKTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IG9uY2VFdmVudCA9IChlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXYpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgY2FsbGJhY2soZXYpO1xuICB9O1xuICBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuY29uc3QgaXNDYW5jZWwgPSAocm9sZSkgPT4ge1xuICByZXR1cm4gcm9sZSA9PT0gJ2NhbmNlbCcgfHwgcm9sZSA9PT0gQkFDS0RST1A7XG59O1xuY29uc3QgZGVmYXVsdEdhdGUgPSAoaCkgPT4gaCgpO1xuLyoqXG4gKiBDYWxscyBhIGRldmVsb3BlciBwcm92aWRlZCBtZXRob2Qgd2hpbGUgYXZvaWRpbmdcbiAqIEFuZ3VsYXIgWm9uZXMuIFNpbmNlIHRoZSBoYW5kbGVyIGlzIHByb3ZpZGVkIGJ5XG4gKiB0aGUgZGV2ZWxvcGVyLCB3ZSBzaG91bGQgdGhyb3cgYW55IGVycm9yc1xuICogcmVjZWl2ZWQgc28gdGhhdCBkZXZlbG9wZXItcHJvdmlkZWQgYnVnXG4gKiB0cmFja2luZyBzb2Z0d2FyZSBjYW4gbG9nIGl0LlxuICovXG5jb25zdCBzYWZlQ2FsbCA9IChoYW5kbGVyLCBhcmcpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgam1wID0gY29uZmlnLmdldCgnX3pvbmVHYXRlJywgZGVmYXVsdEdhdGUpO1xuICAgIHJldHVybiBqbXAoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoYXJnKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBCQUNLRFJPUCA9ICdiYWNrZHJvcCc7XG5cbmV4cG9ydCB7IEJBQ0tEUk9QIGFzIEIsIGFsZXJ0Q29udHJvbGxlciBhcyBhLCBhY3Rpb25TaGVldENvbnRyb2xsZXIgYXMgYiwgcG9wb3ZlckNvbnRyb2xsZXIgYXMgYywgcHJlc2VudCBhcyBkLCBwcmVwYXJlT3ZlcmxheSBhcyBlLCBkaXNtaXNzIGFzIGYsIGV2ZW50TWV0aG9kIGFzIGcsIGZvY3VzRmlyc3REZXNjZW5kYW50IGFzIGgsIGlzQ2FuY2VsIGFzIGksIGdldE92ZXJsYXkgYXMgaiwgYWN0aXZlQW5pbWF0aW9ucyBhcyBrLCBsb2FkaW5nQ29udHJvbGxlciBhcyBsLCBtb2RhbENvbnRyb2xsZXIgYXMgbSwgcGlja2VyQ29udHJvbGxlciBhcyBwLCBzYWZlQ2FsbCBhcyBzLCB0b2FzdENvbnRyb2xsZXIgYXMgdCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5cbmNvbnN0IGNhcmRDb250ZW50SW9zQ3NzID0gXCJpb24tY2FyZC1jb250ZW50e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmV9LmNhcmQtY29udGVudC1pb3N7cGFkZGluZy1sZWZ0OjIwcHg7cGFkZGluZy1yaWdodDoyMHB4O3BhZGRpbmctdG9wOjIwcHg7cGFkZGluZy1ib3R0b206MjBweDtmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxLjR9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuY2FyZC1jb250ZW50LWlvc3twYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6MjBweDtwYWRkaW5nLWlubGluZS1zdGFydDoyMHB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6MjBweDtwYWRkaW5nLWlubGluZS1lbmQ6MjBweH19LmNhcmQtY29udGVudC1pb3MgaDF7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjI0cHg7Zm9udC13ZWlnaHQ6bm9ybWFsfS5jYXJkLWNvbnRlbnQtaW9zIGgye21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjE2cHg7Zm9udC13ZWlnaHQ6bm9ybWFsfS5jYXJkLWNvbnRlbnQtaW9zIGgzLC5jYXJkLWNvbnRlbnQtaW9zIGg0LC5jYXJkLWNvbnRlbnQtaW9zIGg1LC5jYXJkLWNvbnRlbnQtaW9zIGg2e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6bm9ybWFsfS5jYXJkLWNvbnRlbnQtaW9zIHB7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjE0cHh9aW9uLWNhcmQtaGVhZGVyKy5jYXJkLWNvbnRlbnQtaW9ze3BhZGRpbmctdG9wOjB9XCI7XG5cbmNvbnN0IGNhcmRDb250ZW50TWRDc3MgPSBcImlvbi1jYXJkLWNvbnRlbnR7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0uY2FyZC1jb250ZW50LW1ke3BhZGRpbmctbGVmdDoxNnB4O3BhZGRpbmctcmlnaHQ6MTZweDtwYWRkaW5nLXRvcDoxM3B4O3BhZGRpbmctYm90dG9tOjEzcHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS41fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7LmNhcmQtY29udGVudC1tZHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6MTZweDtwYWRkaW5nLWlubGluZS1zdGFydDoxNnB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6MTZweDtwYWRkaW5nLWlubGluZS1lbmQ6MTZweH19LmNhcmQtY29udGVudC1tZCBoMXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MjRweDtmb250LXdlaWdodDpub3JtYWx9LmNhcmQtY29udGVudC1tZCBoMnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH0uY2FyZC1jb250ZW50LW1kIGgzLC5jYXJkLWNvbnRlbnQtbWQgaDQsLmNhcmQtY29udGVudC1tZCBoNSwuY2FyZC1jb250ZW50LW1kIGg2e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6bm9ybWFsfS5jYXJkLWNvbnRlbnQtbWQgcHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDpub3JtYWw7bGluZS1oZWlnaHQ6MS41fWlvbi1jYXJkLWhlYWRlcisuY2FyZC1jb250ZW50LW1ke3BhZGRpbmctdG9wOjB9XCI7XG5cbmNvbnN0IENhcmRDb250ZW50ID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBmb3Igc3R5bGluZ1xuICAgICAgICBbYGNhcmQtY29udGVudC0ke21vZGV9YF06IHRydWVcbiAgICAgIH0gfSkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBjYXJkQ29udGVudElvc0NzcyxcbiAgICBtZDogY2FyZENvbnRlbnRNZENzc1xuICB9OyB9XG59LCBbMzIsIFwiaW9uLWNhcmQtY29udGVudFwiXSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1jYXJkLWNvbnRlbnRcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1jYXJkLWNvbnRlbnRcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBDYXJkQ29udGVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uQ2FyZENvbnRlbnQgPSBDYXJkQ29udGVudDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkNhcmRDb250ZW50LCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgaG9zdENvbnRleHQgPSAoc2VsZWN0b3IsIGVsKSA9PiB7XG4gIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKSAhPT0gbnVsbDtcbn07XG4vKipcbiAqIENyZWF0ZSB0aGUgbW9kZSBhbmQgY29sb3IgY2xhc3NlcyBmb3IgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgY2xhc3NlcyBwYXNzZWQgaW5cbiAqL1xuY29uc3QgY3JlYXRlQ29sb3JDbGFzc2VzID0gKGNvbG9yLCBjc3NDbGFzc01hcCkgPT4ge1xuICByZXR1cm4gKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubGVuZ3RoID4gMCkgPyBPYmplY3QuYXNzaWduKHsgJ2lvbi1jb2xvcic6IHRydWUsIFtgaW9uLWNvbG9yLSR7Y29sb3J9YF06IHRydWUgfSwgY3NzQ2xhc3NNYXApIDogY3NzQ2xhc3NNYXA7XG59O1xuY29uc3QgZ2V0Q2xhc3NMaXN0ID0gKGNsYXNzZXMpID0+IHtcbiAgaWYgKGNsYXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIGFycmF5XG4gICAgICAuZmlsdGVyKGMgPT4gYyAhPSBudWxsKVxuICAgICAgLm1hcChjID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcihjID0+IGMgIT09ICcnKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuY29uc3QgZ2V0Q2xhc3NNYXAgPSAoY2xhc3NlcykgPT4ge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZ2V0Q2xhc3NMaXN0KGNsYXNzZXMpLmZvckVhY2goYyA9PiBtYXBbY10gPSB0cnVlKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBjcmVhdGVFdmVudCwgcmVhZFRhc2ssIGZvcmNlVXBkYXRlLCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlLCBhIGFzIGlzUGxhdGZvcm0gfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuaW1wb3J0IHsgaSBhcyBpc1JUTCB9IGZyb20gJy4vZGlyLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzLCBoIGFzIGhvc3RDb250ZXh0IH0gZnJvbSAnLi90aGVtZS5qcyc7XG5cbmNvbnN0IGNvbnRlbnRDc3MgPSBcIjpob3N0ey0tYmFja2dyb3VuZDp2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7LS1jb2xvcjp2YXIoLS1pb24tdGV4dC1jb2xvciwgIzAwMCk7LS1wYWRkaW5nLXRvcDowcHg7LS1wYWRkaW5nLWJvdHRvbTowcHg7LS1wYWRkaW5nLXN0YXJ0OjBweDstLXBhZGRpbmctZW5kOjBweDstLWtleWJvYXJkLW9mZnNldDowcHg7LS1vZmZzZXQtdG9wOjBweDstLW9mZnNldC1ib3R0b206MHB4Oy0tb3ZlcmZsb3c6YXV0bztkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4OjE7ZmxleDoxO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7bWFyZ2luOjAgIWltcG9ydGFudDtwYWRkaW5nOjAgIWltcG9ydGFudDtmb250LWZhbWlseTp2YXIoLS1pb24tZm9udC1mYW1pbHksIGluaGVyaXQpO2NvbnRhaW46c2l6ZSBzdHlsZX06aG9zdCguaW9uLWNvbG9yKSAuaW5uZXItc2Nyb2xse2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpO2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLm91dGVyLWNvbnRlbnQpey0tYmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3Itc3RlcC01MCwgI2YyZjJmMil9I2JhY2tncm91bmQtY29udGVudHtsZWZ0OjBweDtyaWdodDowcHg7dG9wOmNhbGModmFyKC0tb2Zmc2V0LXRvcCkgKiAtMSk7Ym90dG9tOmNhbGModmFyKC0tb2Zmc2V0LWJvdHRvbSkgKiAtMSk7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKX0uaW5uZXItc2Nyb2xse2xlZnQ6MHB4O3JpZ2h0OjBweDt0b3A6Y2FsYyh2YXIoLS1vZmZzZXQtdG9wKSAqIC0xKTtib3R0b206Y2FsYyh2YXIoLS1vZmZzZXQtYm90dG9tKSAqIC0xKTtwYWRkaW5nLWxlZnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1yaWdodDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy10b3A6Y2FsYyh2YXIoLS1wYWRkaW5nLXRvcCkgKyB2YXIoLS1vZmZzZXQtdG9wKSk7cGFkZGluZy1ib3R0b206Y2FsYyh2YXIoLS1wYWRkaW5nLWJvdHRvbSkgKyB2YXIoLS1rZXlib2FyZC1vZmZzZXQpICsgdmFyKC0tb2Zmc2V0LWJvdHRvbSkpO3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOnZhcigtLWNvbG9yKTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuOy1tcy10b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9uO3RvdWNoLWFjdGlvbjptYW5pcHVsYXRpb259QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaW5uZXItc2Nyb2xse3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0uc2Nyb2xsLXksLnNjcm9sbC14ey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3otaW5kZXg6MDt3aWxsLWNoYW5nZTpzY3JvbGwtcG9zaXRpb259LnNjcm9sbC15e292ZXJmbG93LXk6dmFyKC0tb3ZlcmZsb3cpO292ZXJzY3JvbGwtYmVoYXZpb3IteTpjb250YWlufS5zY3JvbGwteHtvdmVyZmxvdy14OnZhcigtLW92ZXJmbG93KTtvdmVyc2Nyb2xsLWJlaGF2aW9yLXg6Y29udGFpbn0ub3ZlcnNjcm9sbDo6YmVmb3JlLC5vdmVyc2Nyb2xsOjphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxcHg7aGVpZ2h0OjFweDtjb250ZW50OlxcXCJcXFwifS5vdmVyc2Nyb2xsOjpiZWZvcmV7Ym90dG9tOi0xcHh9Lm92ZXJzY3JvbGw6OmFmdGVye3RvcDotMXB4fTpob3N0KC5jb250ZW50LXNpemluZyl7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWluLWhlaWdodDowO2NvbnRhaW46bm9uZX06aG9zdCguY29udGVudC1zaXppbmcpIC5pbm5lci1zY3JvbGx7cG9zaXRpb246cmVsYXRpdmU7dG9wOjA7Ym90dG9tOjA7bWFyZ2luLXRvcDpjYWxjKHZhcigtLW9mZnNldC10b3ApICogLTEpO21hcmdpbi1ib3R0b206Y2FsYyh2YXIoLS1vZmZzZXQtYm90dG9tKSAqIC0xKX0udHJhbnNpdGlvbi1lZmZlY3R7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMHZoO29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lfTpob3N0KC5jb250ZW50LWx0cikgLnRyYW5zaXRpb24tZWZmZWN0e2xlZnQ6LTEwMCU7fTpob3N0KC5jb250ZW50LXJ0bCkgLnRyYW5zaXRpb24tZWZmZWN0e3JpZ2h0Oi0xMDAlO30udHJhbnNpdGlvbi1jb3Zlcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDpibGFjaztvcGFjaXR5OjAuMX0udHJhbnNpdGlvbi1zaGFkb3d7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMHB4O2hlaWdodDoxMDAlO2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQmdBQUFBZ0NBWUFBQUFJWHJnNEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeWhwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOaTFqTVRRMUlEYzVMakUyTXpRNU9Td2dNakF4T0M4d09DOHhNeTB4TmpvME1Eb3lNaUFnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESURJd01Ua2dLRTFoWTJsdWRHOXphQ2tpSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2TVRFM01EZ3pSa1E1UVRreU1URkZPVUV3TnpRNU1rSkZSRUUxTlVZMk1qUWlJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbmh0Y0M1a2FXUTZNVEUzTURnelJrVTVRVGt5TVRGRk9VRXdOelE1TWtKRlJFRTFOVVkyTWpRaVBpQThlRzF3VFUwNlJHVnlhWFpsWkVaeWIyMGdjM1JTWldZNmFXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEb3hNVGN3T0ROR1FqbEJPVEl4TVVVNVFUQTNORGt5UWtWRVFUVTFSall5TkNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRveE1UY3dPRE5HUXpsQk9USXhNVVU1UVRBM05Ea3lRa1ZFUVRVMVJqWXlOQ0l2UGlBOEwzSmtaanBFWlhOamNtbHdkR2x2Ymo0Z1BDOXlaR1k2VWtSR1BpQThMM2c2ZUcxd2JXVjBZVDRnUEQ5NGNHRmphMlYwSUdWdVpEMGljaUkvUG1lUEV1UUFBQUJOU1VSQlZIamFZdnovL3o4REl4QXdNREF3QVRHTWhtRm1QRFF1T1Naa3MwQU1tb0pCYVFIamtQZkIwTGZnLzJnUWpWb3crSFB5L3lIdmc5R2lZalFmak1iQnFBV2pGZ3kvNGhvZ3dBRFlxd2R6eHk1QnV3QUFBQUJKUlU1RXJrSmdnZz09KTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteTtiYWNrZ3JvdW5kLXNpemU6MTBweCAxNnB4fTpob3N0KC5jb250ZW50LWx0cikgLnRyYW5zaXRpb24tc2hhZG93e3JpZ2h0OjA7fTpob3N0KC5jb250ZW50LXJ0bCkgLnRyYW5zaXRpb24tc2hhZG93e2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZVgoLTEpfTo6c2xvdHRlZChbc2xvdD1maXhlZF0pe3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9XCI7XG5cbmNvbnN0IENvbnRlbnQgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uU2Nyb2xsU3RhcnQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblNjcm9sbFN0YXJ0XCIsIDcpO1xuICAgIHRoaXMuaW9uU2Nyb2xsID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25TY3JvbGxcIiwgNyk7XG4gICAgdGhpcy5pb25TY3JvbGxFbmQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblNjcm9sbEVuZFwiLCA3KTtcbiAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0U2Nyb2xsID0gMDtcbiAgICB0aGlzLnF1ZXVlZCA9IGZhbHNlO1xuICAgIHRoaXMuY1RvcCA9IC0xO1xuICAgIHRoaXMuY0JvdHRvbSA9IC0xO1xuICAgIHRoaXMuaXNNYWluQ29udGVudCA9IHRydWU7XG4gICAgLy8gRGV0YWlsIGlzIHVzZWQgaW4gYSBob3QgbG9vcCBpbiB0aGUgc2Nyb2xsIGV2ZW50LCBieSBhbGxvY2F0aW5nIGl0IGhlcmVcbiAgICAvLyBWOCB3aWxsIGJlIGFibGUgdG8gaW5saW5lIGFueSByZWFkL3dyaXRlIHRvIGl0IHNpbmNlIGl0J3MgYSBtb25vbW9ycGhpYyBjbGFzcy5cbiAgICAvLyBodHRwczovL21yYWxlLnBoL2Jsb2cvMjAxNS8wMS8xMS93aGF0cy11cC13aXRoLW1vbm9tb3JwaGlzbS5odG1sXG4gICAgdGhpcy5kZXRhaWwgPSB7XG4gICAgICBzY3JvbGxUb3A6IDAsXG4gICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgdHlwZTogJ3Njcm9sbCcsXG4gICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgc3RhcnRYOiAwLFxuICAgICAgc3RhcnRZOiAwLFxuICAgICAgc3RhcnRUaW1lOiAwLFxuICAgICAgY3VycmVudFg6IDAsXG4gICAgICBjdXJyZW50WTogMCxcbiAgICAgIHZlbG9jaXR5WDogMCxcbiAgICAgIHZlbG9jaXR5WTogMCxcbiAgICAgIGRlbHRhWDogMCxcbiAgICAgIGRlbHRhWTogMCxcbiAgICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgaXNTY3JvbGxpbmc6IHRydWUsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb250ZW50IHdpbGwgc2Nyb2xsIGJlaGluZCB0aGUgaGVhZGVyc1xuICAgICAqIGFuZCBmb290ZXJzLiBUaGlzIGVmZmVjdCBjYW4gZWFzaWx5IGJlIHNlZW4gYnkgc2V0dGluZyB0aGUgdG9vbGJhclxuICAgICAqIHRvIHRyYW5zcGFyZW50LlxuICAgICAqL1xuICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElmIHlvdSB3YW50IHRvIGVuYWJsZSB0aGUgY29udGVudCBzY3JvbGxpbmcgaW4gdGhlIFggYXhpcywgc2V0IHRoaXMgcHJvcGVydHkgdG8gYHRydWVgLlxuICAgICAqL1xuICAgIHRoaXMuc2Nyb2xsWCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElmIHlvdSB3YW50IHRvIGRpc2FibGUgdGhlIGNvbnRlbnQgc2Nyb2xsaW5nIGluIHRoZSBZIGF4aXMsIHNldCB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAuXG4gICAgICovXG4gICAgdGhpcy5zY3JvbGxZID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGlvblNjcm9sbCBldmVudHMgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGluIG9yZGVyIHRvIGVuYWJsZSB0aGVtXG4gICAgICogYW5kIHN0YXJ0IGxpc3RlbmluZyBmcm9tIChpb25TY3JvbGwpLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgdHJ1ZWAuXG4gICAgICovXG4gICAgdGhpcy5zY3JvbGxFdmVudHMgPSBmYWxzZTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmlzTWFpbkNvbnRlbnQgPSB0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1tZW51LCBpb24tcG9wb3ZlciwgaW9uLW1vZGFsJykgPT09IG51bGw7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vblNjcm9sbEVuZCgpO1xuICB9XG4gIG9uQXBwTG9hZCgpIHtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9XG4gIHNob3VsZEZvcmNlT3ZlcnNjcm9sbCgpIHtcbiAgICBjb25zdCB7IGZvcmNlT3ZlcnNjcm9sbCB9ID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gZm9yY2VPdmVyc2Nyb2xsID09PSB1bmRlZmluZWRcbiAgICAgID8gbW9kZSA9PT0gJ2lvcycgJiYgaXNQbGF0Zm9ybSgnaW9zJylcbiAgICAgIDogZm9yY2VPdmVyc2Nyb2xsO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICByZWFkVGFzaygoKSA9PiB0aGlzLnJlYWREaW1lbnNpb25zKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNUb3AgIT09IDAgfHwgdGhpcy5jQm90dG9tICE9PSAwKSB7XG4gICAgICB0aGlzLmNUb3AgPSB0aGlzLmNCb3R0b20gPSAwO1xuICAgICAgZm9yY2VVcGRhdGUodGhpcyk7XG4gICAgfVxuICB9XG4gIHJlYWREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHBhZ2UgPSBnZXRQYWdlRWxlbWVudCh0aGlzLmVsKTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLm1heCh0aGlzLmVsLm9mZnNldFRvcCwgMCk7XG4gICAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgocGFnZS5vZmZzZXRIZWlnaHQgLSB0b3AgLSB0aGlzLmVsLm9mZnNldEhlaWdodCwgMCk7XG4gICAgY29uc3QgZGlydHkgPSB0b3AgIT09IHRoaXMuY1RvcCB8fCBib3R0b20gIT09IHRoaXMuY0JvdHRvbTtcbiAgICBpZiAoZGlydHkpIHtcbiAgICAgIHRoaXMuY1RvcCA9IHRvcDtcbiAgICAgIHRoaXMuY0JvdHRvbSA9IGJvdHRvbTtcbiAgICAgIGZvcmNlVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvblNjcm9sbChldikge1xuICAgIGNvbnN0IHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3Qgc2hvdWxkU3RhcnQgPSAhdGhpcy5pc1Njcm9sbGluZztcbiAgICB0aGlzLmxhc3RTY3JvbGwgPSB0aW1lU3RhbXA7XG4gICAgaWYgKHNob3VsZFN0YXJ0KSB7XG4gICAgICB0aGlzLm9uU2Nyb2xsU3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnF1ZXVlZCAmJiB0aGlzLnNjcm9sbEV2ZW50cykge1xuICAgICAgdGhpcy5xdWV1ZWQgPSB0cnVlO1xuICAgICAgcmVhZFRhc2sodHMgPT4ge1xuICAgICAgICB0aGlzLnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRldGFpbC5ldmVudCA9IGV2O1xuICAgICAgICB1cGRhdGVTY3JvbGxEZXRhaWwodGhpcy5kZXRhaWwsIHRoaXMuc2Nyb2xsRWwsIHRzLCBzaG91bGRTdGFydCk7XG4gICAgICAgIHRoaXMuaW9uU2Nyb2xsLmVtaXQodGhpcy5kZXRhaWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGFjdHVhbCBzY3JvbGxpbmcgdGFrZXMgcGxhY2UuXG4gICAqIFRoaXMgZWxlbWVudCBjYW4gYmUgdXNlZCB0byBzdWJzY3JpYmUgdG8gYHNjcm9sbGAgZXZlbnRzIG9yIG1hbnVhbGx5IG1vZGlmeVxuICAgKiBgc2Nyb2xsVG9wYC4gSG93ZXZlciwgaXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIEFQSSBwcm92aWRlZCBieSBgaW9uLWNvbnRlbnRgOlxuICAgKlxuICAgKiBpLmUuIFVzaW5nIGBpb25TY3JvbGxgLCBgaW9uU2Nyb2xsU3RhcnRgLCBgaW9uU2Nyb2xsRW5kYCBmb3Igc2Nyb2xsaW5nIGV2ZW50c1xuICAgKiBhbmQgYHNjcm9sbFRvUG9pbnQoKWAgdG8gc2Nyb2xsIHRoZSBjb250ZW50IGludG8gYSBjZXJ0YWluIHBvaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0U2Nyb2xsRWxlbWVudCgpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGdldHMgY2FsbGVkIGluIGNlcnRhaW4gZWFybHkgbGlmZWN5Y2xlIGhvb2tzIChleDogVnVlIG9uTW91bnRlZCksXG4gICAgICogc2Nyb2xsRWwgd29uJ3QgYmUgZGVmaW5lZCB5ZXQgd2l0aCB0aGUgY3VzdG9tIGVsZW1lbnRzIGJ1aWxkLCBzbyB3YWl0IGZvciBpdCB0byBsb2FkIGluLlxuICAgICAqL1xuICAgIGlmICghdGhpcy5zY3JvbGxFbCkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjb21wb25lbnRPblJlYWR5KHRoaXMuZWwsIHJlc29sdmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNjcm9sbEVsKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBhbW91bnQgb2YgdGltZSB0byB0YWtlIHNjcm9sbGluZyB0byB0aGUgdG9wLiBEZWZhdWx0cyB0byBgMGAuXG4gICAqL1xuICBzY3JvbGxUb1RvcChkdXJhdGlvbiA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUb1BvaW50KHVuZGVmaW5lZCwgMCwgZHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHRha2Ugc2Nyb2xsaW5nIHRvIHRoZSBib3R0b20uIERlZmF1bHRzIHRvIGAwYC5cbiAgICovXG4gIGFzeW5jIHNjcm9sbFRvQm90dG9tKGR1cmF0aW9uID0gMCkge1xuICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgdGhpcy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgY29uc3QgeSA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCAtIHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUb1BvaW50KHVuZGVmaW5lZCwgeSwgZHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBTY3JvbGwgYnkgYSBzcGVjaWZpZWQgWC9ZIGRpc3RhbmNlIGluIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBhbW91bnQgdG8gc2Nyb2xsIGJ5IG9uIHRoZSBob3Jpem9udGFsIGF4aXMuXG4gICAqIEBwYXJhbSB5IFRoZSBhbW91bnQgdG8gc2Nyb2xsIGJ5IG9uIHRoZSB2ZXJ0aWNhbCBheGlzLlxuICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHRha2Ugc2Nyb2xsaW5nIGJ5IHRoYXQgYW1vdW50LlxuICAgKi9cbiAgYXN5bmMgc2Nyb2xsQnlQb2ludCh4LCB5LCBkdXJhdGlvbikge1xuICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgdGhpcy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9Qb2ludCh4ICsgc2Nyb2xsRWwuc2Nyb2xsTGVmdCwgeSArIHNjcm9sbEVsLnNjcm9sbFRvcCwgZHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gYSBzcGVjaWZpZWQgWC9ZIGxvY2F0aW9uIGluIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBwb2ludCB0byBzY3JvbGwgdG8gb24gdGhlIGhvcml6b250YWwgYXhpcy5cbiAgICogQHBhcmFtIHkgVGhlIHBvaW50IHRvIHNjcm9sbCB0byBvbiB0aGUgdmVydGljYWwgYXhpcy5cbiAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBhbW91bnQgb2YgdGltZSB0byB0YWtlIHNjcm9sbGluZyB0byB0aGF0IHBvaW50LiBEZWZhdWx0cyB0byBgMGAuXG4gICAqL1xuICBhc3luYyBzY3JvbGxUb1BvaW50KHgsIHksIGR1cmF0aW9uID0gMCkge1xuICAgIGNvbnN0IGVsID0gYXdhaXQgdGhpcy5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgaWYgKGR1cmF0aW9uIDwgMzIpIHtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0geTtcbiAgICAgIH1cbiAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCBzdGFydFRpbWUgPSAwO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgICBjb25zdCBmcm9tWSA9IGVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBmcm9tWCA9IGVsLnNjcm9sbExlZnQ7XG4gICAgY29uc3QgZGVsdGFZID0geSAhPSBudWxsID8geSAtIGZyb21ZIDogMDtcbiAgICBjb25zdCBkZWx0YVggPSB4ICE9IG51bGwgPyB4IC0gZnJvbVggOiAwO1xuICAgIC8vIHNjcm9sbCBsb29wXG4gICAgY29uc3Qgc3RlcCA9ICh0aW1lU3RhbXApID0+IHtcbiAgICAgIGNvbnN0IGxpbmVhclRpbWUgPSBNYXRoLm1pbigxLCAoKHRpbWVTdGFtcCAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbikpIC0gMTtcbiAgICAgIGNvbnN0IGVhc2VkVCA9IE1hdGgucG93KGxpbmVhclRpbWUsIDMpICsgMTtcbiAgICAgIGlmIChkZWx0YVkgIT09IDApIHtcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gTWF0aC5mbG9vcigoZWFzZWRUICogZGVsdGFZKSArIGZyb21ZKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWx0YVggIT09IDApIHtcbiAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IE1hdGguZmxvb3IoKGVhc2VkVCAqIGRlbHRhWCkgKyBmcm9tWCk7XG4gICAgICB9XG4gICAgICBpZiAoZWFzZWRUIDwgMSkge1xuICAgICAgICAvLyBkbyBub3QgdXNlIERvbUNvbnRyb2xsZXIgaGVyZVxuICAgICAgICAvLyBtdXN0IHVzZSBuYXRpdmVSYWYgaW4gb3JkZXIgdG8gZmlyZSBpbiB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYXMgYW55XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBjaGlsbCBvdXQgZm9yIGEgZnJhbWUgZmlyc3RcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodHMgPT4ge1xuICAgICAgc3RhcnRUaW1lID0gdHM7XG4gICAgICBzdGVwKHRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBvblNjcm9sbFN0YXJ0KCkge1xuICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW9uU2Nyb2xsU3RhcnQuZW1pdCh7XG4gICAgICBpc1Njcm9sbGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLndhdGNoRG9nKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMud2F0Y2hEb2cpO1xuICAgIH1cbiAgICAvLyB3YXRjaGRvZ1xuICAgIHRoaXMud2F0Y2hEb2cgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5sYXN0U2Nyb2xsIDwgRGF0ZS5ub3coKSAtIDEyMCkge1xuICAgICAgICB0aGlzLm9uU2Nyb2xsRW5kKCk7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgfVxuICBvblNjcm9sbEVuZCgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMud2F0Y2hEb2cpO1xuICAgIHRoaXMud2F0Y2hEb2cgPSBudWxsO1xuICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmlvblNjcm9sbEVuZC5lbWl0KHtcbiAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNNYWluQ29udGVudCwgc2Nyb2xsWCwgc2Nyb2xsWSwgZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgcnRsID0gaXNSVEwoZWwpID8gJ3J0bCcgOiAnbHRyJztcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICBjb25zdCBmb3JjZU92ZXJzY3JvbGwgPSB0aGlzLnNob3VsZEZvcmNlT3ZlcnNjcm9sbCgpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25TaGFkb3cgPSBtb2RlID09PSAnaW9zJztcbiAgICBjb25zdCBUYWdUeXBlID0gaXNNYWluQ29udGVudCA/ICdtYWluJyA6ICdkaXYnO1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IGNyZWF0ZUNvbG9yQ2xhc3Nlcyh0aGlzLmNvbG9yLCB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgJ2NvbnRlbnQtc2l6aW5nJzogaG9zdENvbnRleHQoJ2lvbi1wb3BvdmVyJywgdGhpcy5lbCksXG4gICAgICAgICdvdmVyc2Nyb2xsJzogZm9yY2VPdmVyc2Nyb2xsLFxuICAgICAgICBbYGNvbnRlbnQtJHtydGx9YF06IHRydWVcbiAgICAgIH0pLCBzdHlsZToge1xuICAgICAgICAnLS1vZmZzZXQtdG9wJzogYCR7dGhpcy5jVG9wfXB4YCxcbiAgICAgICAgJy0tb2Zmc2V0LWJvdHRvbSc6IGAke3RoaXMuY0JvdHRvbX1weGAsXG4gICAgICB9IH0sIGgoXCJkaXZcIiwgeyBpZDogXCJiYWNrZ3JvdW5kLWNvbnRlbnRcIiwgcGFydDogXCJiYWNrZ3JvdW5kXCIgfSksIGgoVGFnVHlwZSwgeyBjbGFzczoge1xuICAgICAgICAnaW5uZXItc2Nyb2xsJzogdHJ1ZSxcbiAgICAgICAgJ3Njcm9sbC14Jzogc2Nyb2xsWCxcbiAgICAgICAgJ3Njcm9sbC15Jzogc2Nyb2xsWSxcbiAgICAgICAgJ292ZXJzY3JvbGwnOiAoc2Nyb2xsWCB8fCBzY3JvbGxZKSAmJiBmb3JjZU92ZXJzY3JvbGxcbiAgICAgIH0sIHJlZjogKHNjcm9sbEVsKSA9PiB0aGlzLnNjcm9sbEVsID0gc2Nyb2xsRWwsIG9uU2Nyb2xsOiAodGhpcy5zY3JvbGxFdmVudHMpID8gKGV2KSA9PiB0aGlzLm9uU2Nyb2xsKGV2KSA6IHVuZGVmaW5lZCwgcGFydDogXCJzY3JvbGxcIiB9LCBoKFwic2xvdFwiLCBudWxsKSksIHRyYW5zaXRpb25TaGFkb3cgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBcInRyYW5zaXRpb24tZWZmZWN0XCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRyYW5zaXRpb24tY292ZXJcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRyYW5zaXRpb24tc2hhZG93XCIgfSkpKSA6IG51bGwsIGgoXCJzbG90XCIsIHsgbmFtZTogXCJmaXhlZFwiIH0pKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gY29udGVudENzczsgfVxufSwgWzEsIFwiaW9uLWNvbnRlbnRcIiwge1xuICAgIFwiY29sb3JcIjogWzUxM10sXG4gICAgXCJmdWxsc2NyZWVuXCI6IFs0XSxcbiAgICBcImZvcmNlT3ZlcnNjcm9sbFwiOiBbMTAyOCwgXCJmb3JjZS1vdmVyc2Nyb2xsXCJdLFxuICAgIFwic2Nyb2xsWFwiOiBbNCwgXCJzY3JvbGwteFwiXSxcbiAgICBcInNjcm9sbFlcIjogWzQsIFwic2Nyb2xsLXlcIl0sXG4gICAgXCJzY3JvbGxFdmVudHNcIjogWzQsIFwic2Nyb2xsLWV2ZW50c1wiXSxcbiAgICBcImdldFNjcm9sbEVsZW1lbnRcIjogWzY0XSxcbiAgICBcInNjcm9sbFRvVG9wXCI6IFs2NF0sXG4gICAgXCJzY3JvbGxUb0JvdHRvbVwiOiBbNjRdLFxuICAgIFwic2Nyb2xsQnlQb2ludFwiOiBbNjRdLFxuICAgIFwic2Nyb2xsVG9Qb2ludFwiOiBbNjRdXG4gIH0sIFtbOCwgXCJhcHBsb2FkXCIsIFwib25BcHBMb2FkXCJdXV0pO1xuY29uc3QgZ2V0UGFyZW50RWxlbWVudCA9IChlbCkgPT4ge1xuICBpZiAoZWwucGFyZW50RWxlbWVudCkge1xuICAgIC8vIG5vcm1hbCBlbGVtZW50IHdpdGggYSBwYXJlbnQgZWxlbWVudFxuICAgIHJldHVybiBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuaG9zdCkge1xuICAgIC8vIHNoYWRvdyBkb20ncyBkb2N1bWVudCBmcmFnbWVudFxuICAgIHJldHVybiBlbC5wYXJlbnROb2RlLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0UGFnZUVsZW1lbnQgPSAoZWwpID0+IHtcbiAgY29uc3QgdGFicyA9IGVsLmNsb3Nlc3QoJ2lvbi10YWJzJyk7XG4gIGlmICh0YWJzKSB7XG4gICAgcmV0dXJuIHRhYnM7XG4gIH1cbiAgLyoqXG4gICAqIElmIHdlJ3JlIGluIGEgcG9wb3Zlciwgd2UgbmVlZCB0byB1c2UgaXRzIHdyYXBwZXIgc28gd2UgY2FuIGFjY291bnQgZm9yIHNwYWNlXG4gICAqIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBlZGdlcyBvZiB0aGUgc2NyZWVuLiBCdXQgaWYgdGhlIHBvcG92ZXIgY29udGFpbnNcbiAgICogaXRzIG93biBwYWdlIGVsZW1lbnQsIHdlIHNob3VsZCB1c2UgdGhhdCBpbnN0ZWFkLlxuICAgKi9cbiAgY29uc3QgcGFnZSA9IGVsLmNsb3Nlc3QoJ2lvbi1hcHAsIGlvbi1wYWdlLCAuaW9uLXBhZ2UsIHBhZ2UtaW5uZXIsIC5wb3BvdmVyLWNvbnRlbnQnKTtcbiAgaWYgKHBhZ2UpIHtcbiAgICByZXR1cm4gcGFnZTtcbiAgfVxuICByZXR1cm4gZ2V0UGFyZW50RWxlbWVudChlbCk7XG59O1xuLy8gKioqKioqKiogRE9NIFJFQUQgKioqKioqKioqKioqKioqKlxuY29uc3QgdXBkYXRlU2Nyb2xsRGV0YWlsID0gKGRldGFpbCwgZWwsIHRpbWVzdGFtcCwgc2hvdWxkU3RhcnQpID0+IHtcbiAgY29uc3QgcHJldlggPSBkZXRhaWwuY3VycmVudFg7XG4gIGNvbnN0IHByZXZZID0gZGV0YWlsLmN1cnJlbnRZO1xuICBjb25zdCBwcmV2VCA9IGRldGFpbC5jdXJyZW50VGltZTtcbiAgY29uc3QgY3VycmVudFggPSBlbC5zY3JvbGxMZWZ0O1xuICBjb25zdCBjdXJyZW50WSA9IGVsLnNjcm9sbFRvcDtcbiAgY29uc3QgdGltZURlbHRhID0gdGltZXN0YW1wIC0gcHJldlQ7XG4gIGlmIChzaG91bGRTdGFydCkge1xuICAgIC8vIHJlbWVtYmVyIHRoZSBzdGFydCBwb3NpdGlvbnNcbiAgICBkZXRhaWwuc3RhcnRUaW1lID0gdGltZXN0YW1wO1xuICAgIGRldGFpbC5zdGFydFggPSBjdXJyZW50WDtcbiAgICBkZXRhaWwuc3RhcnRZID0gY3VycmVudFk7XG4gICAgZGV0YWlsLnZlbG9jaXR5WCA9IGRldGFpbC52ZWxvY2l0eVkgPSAwO1xuICB9XG4gIGRldGFpbC5jdXJyZW50VGltZSA9IHRpbWVzdGFtcDtcbiAgZGV0YWlsLmN1cnJlbnRYID0gZGV0YWlsLnNjcm9sbExlZnQgPSBjdXJyZW50WDtcbiAgZGV0YWlsLmN1cnJlbnRZID0gZGV0YWlsLnNjcm9sbFRvcCA9IGN1cnJlbnRZO1xuICBkZXRhaWwuZGVsdGFYID0gY3VycmVudFggLSBkZXRhaWwuc3RhcnRYO1xuICBkZXRhaWwuZGVsdGFZID0gY3VycmVudFkgLSBkZXRhaWwuc3RhcnRZO1xuICBpZiAodGltZURlbHRhID4gMCAmJiB0aW1lRGVsdGEgPCAxMDApIHtcbiAgICBjb25zdCB2ZWxvY2l0eVggPSAoY3VycmVudFggLSBwcmV2WCkgLyB0aW1lRGVsdGE7XG4gICAgY29uc3QgdmVsb2NpdHlZID0gKGN1cnJlbnRZIC0gcHJldlkpIC8gdGltZURlbHRhO1xuICAgIGRldGFpbC52ZWxvY2l0eVggPSB2ZWxvY2l0eVggKiAwLjcgKyBkZXRhaWwudmVsb2NpdHlYICogMC4zO1xuICAgIGRldGFpbC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVkgKiAwLjcgKyBkZXRhaWwudmVsb2NpdHlZICogMC4zO1xuICB9XG59O1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tY29udGVudFwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLWNvbnRlbnRcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBDb250ZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25Db250ZW50ID0gQ29udGVudDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkNvbnRlbnQsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByZWFkVGFzaywgd3JpdGVUYXNrLCBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgaiBhcyBjbGFtcCwgYyBhcyBjb21wb25lbnRPblJlYWR5IH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcblxuY29uc3QgaGFuZGxlRm9vdGVyRmFkZSA9IChzY3JvbGxFbCwgYmFzZUVsKSA9PiB7XG4gIHJlYWRUYXNrKCgpID0+IHtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxFbC5zY3JvbGxUb3A7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgIC8qKlxuICAgICAqIFRvb2xiYXIgYmFja2dyb3VuZCB3aWxsIGZhZGVcbiAgICAgKiBvdXQgb3ZlciBmYWRlRHVyYXRpb24gaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGNvbnN0IGZhZGVEdXJhdGlvbiA9IDEwO1xuICAgIC8qKlxuICAgICAqIEJlZ2luIGZhZGluZyBvdXQgbWF4U2Nyb2xsIC0gMzBweFxuICAgICAqIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgY29udGVudC5cbiAgICAgKiBBbHNvIGRldGVybWluZSBob3cgY2xvc2Ugd2UgYXJlXG4gICAgICogdG8gc3RhcnRpbmcgdGhlIGZhZGUuIElmIHdlIGFyZVxuICAgICAqIGJlZm9yZSB0aGUgc3RhcnRpbmcgcG9pbnQsIHRoZVxuICAgICAqIHNjYWxlIHZhbHVlIHdpbGwgZ2V0IGNsYW1wZWQgdG8gMC5cbiAgICAgKiBJZiB3ZSBhcmUgYWZ0ZXIgdGhlIG1heFNjcm9sbCAocnViYmVyXG4gICAgICogYmFuZCBzY3JvbGxpbmcpLCB0aGUgc2NhbGUgdmFsdWUgd2lsbFxuICAgICAqIGdldCBjbGFtcGVkIHRvIDEuXG4gICAgICovXG4gICAgY29uc3QgZmFkZVN0YXJ0ID0gbWF4U2Nyb2xsIC0gZmFkZUR1cmF0aW9uO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9TdGFydCA9IHNjcm9sbFRvcCAtIGZhZGVTdGFydDtcbiAgICBjb25zdCBzY2FsZSA9IGNsYW1wKDAsIDEgLSAoZGlzdGFuY2VUb1N0YXJ0IC8gZmFkZUR1cmF0aW9uKSwgMSk7XG4gICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgIGJhc2VFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1vcGFjaXR5LXNjYWxlJywgc2NhbGUudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgZm9vdGVySW9zQ3NzID0gXCJpb24tZm9vdGVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxO3dpZHRoOjEwMCU7ei1pbmRleDoxMH1pb24tZm9vdGVyIGlvbi10b29sYmFyOmxhc3Qtb2YtdHlwZXtwYWRkaW5nLWJvdHRvbTp2YXIoLS1pb24tc2FmZS1hcmVhLWJvdHRvbSwgMCl9LmZvb3Rlci1pb3MgaW9uLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZXstLWJvcmRlci13aWR0aDowLjU1cHggMCAwfUBzdXBwb3J0cyAoKC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDApKSBvciAoYmFja2Ryb3AtZmlsdGVyOiBibHVyKDApKSl7LmZvb3Rlci1iYWNrZ3JvdW5ke2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDE4MCUpIGJsdXIoMjBweCk7YmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDE4MCUpIGJsdXIoMjBweCl9LmZvb3Rlci10cmFuc2x1Y2VudC1pb3MgaW9uLXRvb2xiYXJ7LS1vcGFjaXR5Oi44fX0uZm9vdGVyLWlvcy5pb24tbm8tYm9yZGVyIGlvbi10b29sYmFyOmZpcnN0LW9mLXR5cGV7LS1ib3JkZXItd2lkdGg6MH0uZm9vdGVyLWNvbGxhcHNlLWZhZGUgaW9uLXRvb2xiYXJ7LS1vcGFjaXR5LXNjYWxlOmluaGVyaXR9XCI7XG5cbmNvbnN0IGZvb3Rlck1kQ3NzID0gXCJpb24tZm9vdGVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxO3dpZHRoOjEwMCU7ei1pbmRleDoxMH1pb24tZm9vdGVyIGlvbi10b29sYmFyOmxhc3Qtb2YtdHlwZXtwYWRkaW5nLWJvdHRvbTp2YXIoLS1pb24tc2FmZS1hcmVhLWJvdHRvbSwgMCl9LmZvb3Rlci1tZDo6YmVmb3Jle2xlZnQ6MDt0b3A6LTJweDtib3R0b206YXV0bztiYWNrZ3JvdW5kLXBvc2l0aW9uOmxlZnQgMCB0b3AgMDtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO2hlaWdodDoycHg7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBSEJBTUFBQUR6RHRCeEFBQUFEMUJNVkVVQUFBQUFBQUFBQUFBQUFBQUFBQUJQRHVlTkFBQUFCWFJTVGxNVUNTMGdCSWgvVFhFQUFBQWFTVVJCVkFqWFl4Q0VBZ1k0VUlJQ0JtTW9nTXNnRkx0QUFRQ05Td1haS09kUHhnQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7Y29udGVudDpcXFwiXFxcIn1bZGlyPXJ0bF0gLmZvb3Rlci1tZDo6YmVmb3JlLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKSAuZm9vdGVyLW1kOjpiZWZvcmV7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDowfVtkaXI9cnRsXSAuZm9vdGVyLW1kOjpiZWZvcmUsOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pIC5mb290ZXItbWQ6OmJlZm9yZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOnJpZ2h0IDAgdG9wIDB9LmZvb3Rlci1tZC5pb24tbm8tYm9yZGVyOjpiZWZvcmV7ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBGb290ZXIgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgZm9vdGVyIHdpbGwgYmUgdHJhbnNsdWNlbnQuXG4gICAgICogT25seSBhcHBsaWVzIHdoZW4gdGhlIG1vZGUgaXMgYFwiaW9zXCJgIGFuZCB0aGUgZGV2aWNlIHN1cHBvcnRzXG4gICAgICogW2BiYWNrZHJvcC1maWx0ZXJgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvYmFja2Ryb3AtZmlsdGVyI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiBvcmRlciB0byBzY3JvbGwgY29udGVudCBiZWhpbmQgdGhlIGZvb3RlciwgdGhlIGBmdWxsc2NyZWVuYFxuICAgICAqIGF0dHJpYnV0ZSBuZWVkcyB0byBiZSBzZXQgb24gdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgdGhpcy50cmFuc2x1Y2VudCA9IGZhbHNlO1xuICAgIHRoaXMuY2hlY2tDb2xsYXBzaWJsZUZvb3RlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgICAgaWYgKG1vZGUgIT09ICdpb3MnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29sbGFwc2UgfSA9IHRoaXM7XG4gICAgICBjb25zdCBoYXNGYWRlID0gY29sbGFwc2UgPT09ICdmYWRlJztcbiAgICAgIHRoaXMuZGVzdHJveUNvbGxhcHNpYmxlRm9vdGVyKCk7XG4gICAgICBpZiAoaGFzRmFkZSkge1xuICAgICAgICBjb25zdCBwYWdlRWwgPSB0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1hcHAsaW9uLXBhZ2UsLmlvbi1wYWdlLHBhZ2UtaW5uZXInKTtcbiAgICAgICAgY29uc3QgY29udGVudEVsID0gKHBhZ2VFbCkgPyBwYWdlRWwucXVlcnlTZWxlY3RvcignaW9uLWNvbnRlbnQnKSA6IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dXBGYWRlRm9vdGVyKGNvbnRlbnRFbCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNldHVwRmFkZUZvb3RlciA9IGFzeW5jIChjb250ZW50RWwpID0+IHtcbiAgICAgIGlmICghY29udGVudEVsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2lvbi1mb290ZXIgcmVxdWlyZXMgYSBjb250ZW50IHRvIGNvbGxhcHNlLiBNYWtlIHN1cmUgdGhlcmUgaXMgYW4gaW9uLWNvbnRlbnQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShjb250ZW50RWwsIHJlc29sdmUpKTtcbiAgICAgIGNvbnN0IHNjcm9sbEVsID0gdGhpcy5zY3JvbGxFbCA9IGF3YWl0IGNvbnRlbnRFbC5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZSBmYWRpbmcgb2YgdG9vbGJhcnMgb24gc2Nyb2xsXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29udGVudFNjcm9sbENhbGxiYWNrID0gKCkgPT4geyBoYW5kbGVGb290ZXJGYWRlKHNjcm9sbEVsLCB0aGlzLmVsKTsgfTtcbiAgICAgIHNjcm9sbEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuY29udGVudFNjcm9sbENhbGxiYWNrKTtcbiAgICAgIGhhbmRsZUZvb3RlckZhZGUoc2Nyb2xsRWwsIHRoaXMuZWwpO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICB0aGlzLmNoZWNrQ29sbGFwc2libGVGb290ZXIoKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5jaGVja0NvbGxhcHNpYmxlRm9vdGVyKCk7XG4gIH1cbiAgZGVzdHJveUNvbGxhcHNpYmxlRm9vdGVyKCkge1xuICAgIGlmICh0aGlzLnNjcm9sbEVsICYmIHRoaXMuY29udGVudFNjcm9sbENhbGxiYWNrKSB7XG4gICAgICB0aGlzLnNjcm9sbEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuY29udGVudFNjcm9sbENhbGxiYWNrKTtcbiAgICAgIHRoaXMuY29udGVudFNjcm9sbENhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB0cmFuc2x1Y2VudCwgY29sbGFwc2UgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgcm9sZTogXCJjb250ZW50aW5mb1wiLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBmb3Igc3R5bGluZ1xuICAgICAgICBbYGZvb3Rlci0ke21vZGV9YF06IHRydWUsXG4gICAgICAgIFtgZm9vdGVyLXRyYW5zbHVjZW50YF06IHRyYW5zbHVjZW50LFxuICAgICAgICBbYGZvb3Rlci10cmFuc2x1Y2VudC0ke21vZGV9YF06IHRyYW5zbHVjZW50LFxuICAgICAgICBbYGZvb3Rlci1jb2xsYXBzZS0ke2NvbGxhcHNlfWBdOiBjb2xsYXBzZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgfSB9LCBtb2RlID09PSAnaW9zJyAmJiB0cmFuc2x1Y2VudCAmJlxuICAgICAgaChcImRpdlwiLCB7IGNsYXNzOiBcImZvb3Rlci1iYWNrZ3JvdW5kXCIgfSksIGgoXCJzbG90XCIsIG51bGwpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4ge1xuICAgIGlvczogZm9vdGVySW9zQ3NzLFxuICAgIG1kOiBmb290ZXJNZENzc1xuICB9OyB9XG59LCBbMzYsIFwiaW9uLWZvb3RlclwiLCB7XG4gICAgXCJjb2xsYXBzZVwiOiBbMV0sXG4gICAgXCJ0cmFuc2x1Y2VudFwiOiBbNF1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tZm9vdGVyXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tZm9vdGVyXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgRm9vdGVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25Gb290ZXIgPSBGb290ZXI7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25Gb290ZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByZWFkVGFzaywgd3JpdGVUYXNrLCBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgaiBhcyBjbGFtcCwgYyBhcyBjb21wb25lbnRPblJlYWR5LCBpIGFzIGluaGVyaXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGggYXMgaG9zdENvbnRleHQgfSBmcm9tICcuL3RoZW1lLmpzJztcblxuY29uc3QgVFJBTlNJVElPTiA9ICdhbGwgMC4ycyBlYXNlLWluLW91dCc7XG5jb25zdCBjbG9uZUVsZW1lbnQgPSAodGFnTmFtZSkgPT4ge1xuICBjb25zdCBnZXRDYWNoZWRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCR7dGFnTmFtZX0uaW9uLWNsb25lZC1lbGVtZW50YCk7XG4gIGlmIChnZXRDYWNoZWRFbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRDYWNoZWRFbDtcbiAgfVxuICBjb25zdCBjbG9uZWRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGNsb25lZEVsLmNsYXNzTGlzdC5hZGQoJ2lvbi1jbG9uZWQtZWxlbWVudCcpO1xuICBjbG9uZWRFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2xvbmVkRWwpO1xuICByZXR1cm4gY2xvbmVkRWw7XG59O1xuY29uc3QgY3JlYXRlSGVhZGVySW5kZXggPSAoaGVhZGVyRWwpID0+IHtcbiAgaWYgKCFoZWFkZXJFbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0b29sYmFycyA9IGhlYWRlckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi10b29sYmFyJyk7XG4gIHJldHVybiB7XG4gICAgZWw6IGhlYWRlckVsLFxuICAgIHRvb2xiYXJzOiBBcnJheS5mcm9tKHRvb2xiYXJzKS5tYXAoKHRvb2xiYXIpID0+IHtcbiAgICAgIGNvbnN0IGlvblRpdGxlRWwgPSB0b29sYmFyLnF1ZXJ5U2VsZWN0b3IoJ2lvbi10aXRsZScpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWw6IHRvb2xiYXIsXG4gICAgICAgIGJhY2tncm91bmQ6IHRvb2xiYXIuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcudG9vbGJhci1iYWNrZ3JvdW5kJyksXG4gICAgICAgIGlvblRpdGxlRWwsXG4gICAgICAgIGlubmVyVGl0bGVFbDogKGlvblRpdGxlRWwpID8gaW9uVGl0bGVFbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJy50b29sYmFyLXRpdGxlJykgOiBudWxsLFxuICAgICAgICBpb25CdXR0b25zRWw6IEFycmF5LmZyb20odG9vbGJhci5xdWVyeVNlbGVjdG9yQWxsKCdpb24tYnV0dG9ucycpKSB8fCBbXVxuICAgICAgfTtcbiAgICB9KSB8fCBbXVxuICB9O1xufTtcbmNvbnN0IGhhbmRsZUNvbnRlbnRTY3JvbGwgPSAoc2Nyb2xsRWwsIHNjcm9sbEhlYWRlckluZGV4LCBjb250ZW50RWwpID0+IHtcbiAgcmVhZFRhc2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbEVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBzY2FsZSA9IGNsYW1wKDEsIDEgKyAoLXNjcm9sbFRvcCAvIDUwMCksIDEuMSk7XG4gICAgLy8gTmF0aXZlIHJlZnJlc2hlciBzaG91bGQgbm90IGNhdXNlIHRpdGxlcyB0byBzY2FsZVxuICAgIGNvbnN0IG5hdGl2ZVJlZnJlc2hlciA9IGNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yKCdpb24tcmVmcmVzaGVyLnJlZnJlc2hlci1uYXRpdmUnKTtcbiAgICBpZiAobmF0aXZlUmVmcmVzaGVyID09PSBudWxsKSB7XG4gICAgICB3cml0ZVRhc2soKCkgPT4ge1xuICAgICAgICBzY2FsZUxhcmdlVGl0bGVzKHNjcm9sbEhlYWRlckluZGV4LnRvb2xiYXJzLCBzY2FsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IHNldFRvb2xiYXJCYWNrZ3JvdW5kT3BhY2l0eSA9IChoZWFkZXJFbCwgb3BhY2l0eSkgPT4ge1xuICAvKipcbiAgICogRmFkaW5nIGluIHRoZSBiYWNrZHJvcCBvcGFjaXR5XG4gICAqIHNob3VsZCBoYXBwZW4gYWZ0ZXIgdGhlIGxhcmdlIHRpdGxlXG4gICAqIGhhcyBjb2xsYXBzZWQsIHNvIGl0IGlzIGhhbmRsZWRcbiAgICogYnkgaGFuZGxlSGVhZGVyRmFkZSgpXG4gICAqL1xuICBpZiAoaGVhZGVyRWwuY29sbGFwc2UgPT09ICdmYWRlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGVhZGVyRWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJy0tb3BhY2l0eS1zY2FsZScpO1xuICB9XG4gIGVsc2Uge1xuICAgIGhlYWRlckVsLnN0eWxlLnNldFByb3BlcnR5KCctLW9wYWNpdHktc2NhbGUnLCBvcGFjaXR5LnRvU3RyaW5nKCkpO1xuICB9XG59O1xuY29uc3QgaGFuZGxlVG9vbGJhckJvcmRlckludGVyc2VjdGlvbiA9IChldiwgbWFpbkhlYWRlckluZGV4LCBzY3JvbGxUb3ApID0+IHtcbiAgaWYgKCFldlswXS5pc0ludGVyc2VjdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogVGhlcmUgaXMgYSBidWcgaW4gU2FmYXJpIHdoZXJlIG92ZXJmbG93IHNjcm9sbGluZyBvbiBhIG5vbi1ib2R5IGVsZW1lbnRcbiAgICogZG9lcyBub3QgYWx3YXlzIHJlc2V0IHRoZSBzY3JvbGxUb3AgcG9zaXRpb24gdG8gMCB3aGVuIGxldHRpbmcgZ28uIEl0IHdpbGxcbiAgICogc2V0IHRvIDEgb25jZSB0aGUgcnViYmVyIGJhbmQgZWZmZWN0IGhhcyBlbmRlZC4gVGhpcyBjYXVzZXMgdGhlIGJhY2tncm91bmQgdG9cbiAgICogYXBwZWFyIHNsaWdodGx5IG9uIGNlcnRhaW4gYXBwIHNldHVwcy5cbiAgICpcbiAgICogQWRkaXRpb25hbGx5LCB3ZSBjaGVjayBpZiB1c2VyIGlzIHJ1YmJlciBiYW5kaW5nIChzY3JvbGxpbmcgaXMgbmVnYXRpdmUpXG4gICAqIGFzIHRoaXMgY2FuIG1lYW4gdGhleSBhcmUgdXNpbmcgcHVsbCB0byByZWZyZXNoLiBPbmNlIHRoZSByZWZyZXNoZXIgc3RhcnRzLFxuICAgKiB0aGUgY29udGVudCBpcyB0cmFuc2Zvcm1lZCB3aGljaCBjYW4gY2F1c2UgdGhlIGludGVyc2VjdGlvbiBvYnNlcnZlciB0byBlcnJvbmVvdXNseVxuICAgKiBmaXJlIGhlcmUgYXMgd2VsbC5cbiAgICovXG4gIGNvbnN0IHNjYWxlID0gKGV2WzBdLmludGVyc2VjdGlvblJhdGlvID4gMC45IHx8IHNjcm9sbFRvcCA8PSAwKSA/IDAgOiAoKDEgLSBldlswXS5pbnRlcnNlY3Rpb25SYXRpbykgKiAxMDApIC8gNzU7XG4gIHNldFRvb2xiYXJCYWNrZ3JvdW5kT3BhY2l0eShtYWluSGVhZGVySW5kZXguZWwsIChzY2FsZSA9PT0gMSkgPyB1bmRlZmluZWQgOiBzY2FsZSk7XG59O1xuLyoqXG4gKiBJZiB0b29sYmFycyBhcmUgaW50ZXJzZWN0aW5nLCBoaWRlIHRoZSBzY3JvbGxhYmxlIHRvb2xiYXIgY29udGVudFxuICogYW5kIHNob3cgdGhlIHByaW1hcnkgdG9vbGJhciBjb250ZW50LiBJZiB0aGUgdG9vbGJhcnMgYXJlIG5vdCBpbnRlcnNlY3RpbmcsXG4gKiBoaWRlIHRoZSBwcmltYXJ5IHRvb2xiYXIgY29udGVudCBhbmQgc2hvdyB0aGUgc2Nyb2xsYWJsZSB0b29sYmFyIGNvbnRlbnRcbiAqL1xuY29uc3QgaGFuZGxlVG9vbGJhckludGVyc2VjdGlvbiA9IChldiwgbWFpbkhlYWRlckluZGV4LCBzY3JvbGxIZWFkZXJJbmRleCwgc2Nyb2xsRWwpID0+IHtcbiAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxFbC5zY3JvbGxUb3A7XG4gICAgaGFuZGxlVG9vbGJhckJvcmRlckludGVyc2VjdGlvbihldiwgbWFpbkhlYWRlckluZGV4LCBzY3JvbGxUb3ApO1xuICAgIGNvbnN0IGV2ZW50ID0gZXZbMF07XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gZXZlbnQuaW50ZXJzZWN0aW9uUmVjdDtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25BcmVhID0gaW50ZXJzZWN0aW9uLndpZHRoICogaW50ZXJzZWN0aW9uLmhlaWdodDtcbiAgICBjb25zdCByb290QXJlYSA9IGV2ZW50LnJvb3RCb3VuZHMud2lkdGggKiBldmVudC5yb290Qm91bmRzLmhlaWdodDtcbiAgICBjb25zdCBpc1BhZ2VIaWRkZW4gPSBpbnRlcnNlY3Rpb25BcmVhID09PSAwICYmIHJvb3RBcmVhID09PSAwO1xuICAgIGNvbnN0IGxlZnREaWZmID0gTWF0aC5hYnMoaW50ZXJzZWN0aW9uLmxlZnQgLSBldmVudC5ib3VuZGluZ0NsaWVudFJlY3QubGVmdCk7XG4gICAgY29uc3QgcmlnaHREaWZmID0gTWF0aC5hYnMoaW50ZXJzZWN0aW9uLnJpZ2h0IC0gZXZlbnQuYm91bmRpbmdDbGllbnRSZWN0LnJpZ2h0KTtcbiAgICBjb25zdCBpc1BhZ2VUcmFuc2l0aW9uaW5nID0gaW50ZXJzZWN0aW9uQXJlYSA+IDAgJiYgKGxlZnREaWZmID49IDUgfHwgcmlnaHREaWZmID49IDUpO1xuICAgIGlmIChpc1BhZ2VIaWRkZW4gfHwgaXNQYWdlVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgIHNldEhlYWRlckFjdGl2ZShtYWluSGVhZGVySW5kZXgsIGZhbHNlKTtcbiAgICAgIHNldEhlYWRlckFjdGl2ZShzY3JvbGxIZWFkZXJJbmRleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBpcyBhIGJ1ZyB3aXRoIEludGVyc2VjdGlvbk9ic2VydmVyIG9uIFNhZmFyaVxuICAgICAgICogd2hlcmUgYGV2ZW50LmlzSW50ZXJzZWN0aW5nID09PSBmYWxzZWAgd2hlbiBjYW5jZWxsaW5nXG4gICAgICAgKiBhIHN3aXBlIHRvIGdvIGJhY2sgZ2VzdHVyZS4gQ2hlY2tpbmcgdGhlIGludGVyc2VjdGlvblxuICAgICAgICogeCwgeSwgd2lkdGgsIGFuZCBoZWlnaHQgcHJvdmlkZXMgYSB3b3JrYXJvdW5kLiBUaGlzIGJ1Z1xuICAgICAgICogZG9lcyBub3QgaGFwcGVuIHdoZW4gdXNpbmcgU2FmYXJpICsgV2ViIEFuaW1hdGlvbnMsXG4gICAgICAgKiBvbmx5IFNhZmFyaSArIENTUyBBbmltYXRpb25zLlxuICAgICAgICovXG4gICAgICBjb25zdCBoYXNWYWxpZEludGVyc2VjdGlvbiA9IChpbnRlcnNlY3Rpb24ueCA9PT0gMCAmJiBpbnRlcnNlY3Rpb24ueSA9PT0gMCkgfHwgKGludGVyc2VjdGlvbi53aWR0aCAhPT0gMCAmJiBpbnRlcnNlY3Rpb24uaGVpZ2h0ICE9PSAwKTtcbiAgICAgIGlmIChoYXNWYWxpZEludGVyc2VjdGlvbiAmJiBzY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgIHNldEhlYWRlckFjdGl2ZShtYWluSGVhZGVySW5kZXgpO1xuICAgICAgICBzZXRIZWFkZXJBY3RpdmUoc2Nyb2xsSGVhZGVySW5kZXgsIGZhbHNlKTtcbiAgICAgICAgc2V0VG9vbGJhckJhY2tncm91bmRPcGFjaXR5KG1haW5IZWFkZXJJbmRleC5lbCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBzZXRIZWFkZXJBY3RpdmUgPSAoaGVhZGVySW5kZXgsIGFjdGl2ZSA9IHRydWUpID0+IHtcbiAgaWYgKGFjdGl2ZSkge1xuICAgIGhlYWRlckluZGV4LmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZScpO1xuICB9XG4gIGVsc2Uge1xuICAgIGhlYWRlckluZGV4LmVsLmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZScpO1xuICB9XG59O1xuY29uc3Qgc2NhbGVMYXJnZVRpdGxlcyA9ICh0b29sYmFycyA9IFtdLCBzY2FsZSA9IDEsIHRyYW5zaXRpb24gPSBmYWxzZSkgPT4ge1xuICB0b29sYmFycy5mb3JFYWNoKHRvb2xiYXIgPT4ge1xuICAgIGNvbnN0IGlvblRpdGxlID0gdG9vbGJhci5pb25UaXRsZUVsO1xuICAgIGNvbnN0IHRpdGxlRGl2ID0gdG9vbGJhci5pbm5lclRpdGxlRWw7XG4gICAgaWYgKCFpb25UaXRsZSB8fCBpb25UaXRsZS5zaXplICE9PSAnbGFyZ2UnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpdGxlRGl2LnN0eWxlLnRyYW5zaXRpb24gPSAodHJhbnNpdGlvbikgPyBUUkFOU0lUSU9OIDogJyc7XG4gICAgdGl0bGVEaXYuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlM2QoJHtzY2FsZX0sICR7c2NhbGV9LCAxKWA7XG4gIH0pO1xufTtcbmNvbnN0IGhhbmRsZUhlYWRlckZhZGUgPSAoc2Nyb2xsRWwsIGJhc2VFbCwgY29uZGVuc2VIZWFkZXIpID0+IHtcbiAgcmVhZFRhc2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbEVsLnNjcm9sbFRvcDtcbiAgICBjb25zdCBiYXNlRWxIZWlnaHQgPSBiYXNlRWwuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IGZhZGVTdGFydCA9IChjb25kZW5zZUhlYWRlcikgPyBjb25kZW5zZUhlYWRlci5jbGllbnRIZWlnaHQgOiAwO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSB1c2luZyBmYWRlIGhlYWRlciB3aXRoIGEgY29uZGVuc2VcbiAgICAgKiBoZWFkZXIsIHRoZW4gdGhlIHRvb2xiYXIgYmFja2dyb3VuZHMgc2hvdWxkXG4gICAgICogbm90IGJlZ2luIHRvIGZhZGUgaW4gdW50aWwgdGhlIGNvbmRlbnNlXG4gICAgICogaGVhZGVyIGhhcyBmdWxseSBjb2xsYXBzZWQuXG4gICAgICpcbiAgICAgKiBBZGRpdGlvbmFsbHksIHRoZSBtYWluIGNvbnRlbnQgc2hvdWxkIG5vdFxuICAgICAqIG92ZXJmbG93IG91dCBvZiB0aGUgY29udGFpbmVyIHVudGlsIHRoZVxuICAgICAqIGNvbmRlbnNlIGhlYWRlciBoYXMgZnVsbHkgY29sbGFwc2VkLiBXaGVuXG4gICAgICogdXNpbmcganVzdCB0aGUgY29uZGVuc2UgaGVhZGVyIHRoZSBjb250ZW50XG4gICAgICogc2hvdWxkIG92ZXJmbG93IG91dCBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqL1xuICAgIGlmICgoY29uZGVuc2VIZWFkZXIgIT09IG51bGwpICYmIChzY3JvbGxUb3AgPCBmYWRlU3RhcnQpKSB7XG4gICAgICBiYXNlRWwuc3R5bGUuc2V0UHJvcGVydHkoJy0tb3BhY2l0eS1zY2FsZScsICcwJyk7XG4gICAgICBzY3JvbGxFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnY2xpcC1wYXRoJywgYGluc2V0KCR7YmFzZUVsSGVpZ2h0fXB4IDBweCAwcHggMHB4KWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZVRvU3RhcnQgPSBzY3JvbGxUb3AgLSBmYWRlU3RhcnQ7XG4gICAgY29uc3QgZmFkZUR1cmF0aW9uID0gMTA7XG4gICAgY29uc3Qgc2NhbGUgPSBjbGFtcCgwLCAoZGlzdGFuY2VUb1N0YXJ0IC8gZmFkZUR1cmF0aW9uKSwgMSk7XG4gICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgIHNjcm9sbEVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjbGlwLXBhdGgnKTtcbiAgICAgIGJhc2VFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1vcGFjaXR5LXNjYWxlJywgc2NhbGUudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgaGVhZGVySW9zQ3NzID0gXCJpb24taGVhZGVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtb3JkZXI6LTE7b3JkZXI6LTE7d2lkdGg6MTAwJTt6LWluZGV4OjEwfWlvbi1oZWFkZXIgaW9uLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZXtwYWRkaW5nLXRvcDp2YXIoLS1pb24tc2FmZS1hcmVhLXRvcCwgMCl9LmhlYWRlci1pb3MgaW9uLXRvb2xiYXI6bGFzdC1vZi10eXBley0tYm9yZGVyLXdpZHRoOjAgMCAwLjU1cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoMCkpIG9yIChiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMCkpKXsuaGVhZGVyLWJhY2tncm91bmR7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6c2F0dXJhdGUoMTgwJSkgYmx1cigyMHB4KTtiYWNrZHJvcC1maWx0ZXI6c2F0dXJhdGUoMTgwJSkgYmx1cigyMHB4KX0uaGVhZGVyLXRyYW5zbHVjZW50LWlvcyBpb24tdG9vbGJhcnstLW9wYWNpdHk6Ljh9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZSAuaGVhZGVyLWJhY2tncm91bmR7LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6Ymx1cigyMHB4KTtiYWNrZHJvcC1maWx0ZXI6Ymx1cigyMHB4KX19LmhlYWRlci1pb3MuaW9uLW5vLWJvcmRlciBpb24tdG9vbGJhcjpsYXN0LW9mLXR5cGV7LS1ib3JkZXItd2lkdGg6MH0uaGVhZGVyLWNvbGxhcHNlLWZhZGUgaW9uLXRvb2xiYXJ7LS1vcGFjaXR5LXNjYWxlOmluaGVyaXR9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZXt6LWluZGV4Ojl9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhcntwb3NpdGlvbjotd2Via2l0LXN0aWNreTtwb3NpdGlvbjpzdGlja3k7dG9wOjB9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhcjpmaXJzdC1vZi10eXBle3BhZGRpbmctdG9wOjdweDt6LWluZGV4OjF9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhcnstLWJhY2tncm91bmQ6dmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpO3otaW5kZXg6MH0uaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlIGlvbi10b29sYmFyOmxhc3Qtb2YtdHlwZXstLWJvcmRlci13aWR0aDowcHh9LmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhciBpb24tc2VhcmNoYmFye2hlaWdodDo0OHB4O3BhZGRpbmctdG9wOjBweDtwYWRkaW5nLWJvdHRvbToxM3B4fS5oZWFkZXItY29sbGFwc2UtbWFpbnstLW9wYWNpdHktc2NhbGU6MX0uaGVhZGVyLWNvbGxhcHNlLW1haW4gaW9uLXRvb2xiYXJ7LS1vcGFjaXR5LXNjYWxlOmluaGVyaXR9LmhlYWRlci1jb2xsYXBzZS1tYWluIGlvbi10b29sYmFyLmluLXRvb2xiYXIgaW9uLXRpdGxlLC5oZWFkZXItY29sbGFwc2UtbWFpbiBpb24tdG9vbGJhci5pbi10b29sYmFyIGlvbi1idXR0b25zey13ZWJraXQtdHJhbnNpdGlvbjphbGwgMC4ycyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAwLjJzIGVhc2UtaW4tb3V0fS5oZWFkZXItY29sbGFwc2UtY29uZGVuc2UtaW5hY3RpdmU6bm90KC5oZWFkZXItY29sbGFwc2UtY29uZGVuc2UpIGlvbi10b29sYmFyLmluLXRvb2xiYXIgaW9uLXRpdGxlLC5oZWFkZXItY29sbGFwc2UtY29uZGVuc2UtaW5hY3RpdmU6bm90KC5oZWFkZXItY29sbGFwc2UtY29uZGVuc2UpIGlvbi10b29sYmFyLmluLXRvb2xiYXIgaW9uLWJ1dHRvbnMuYnV0dG9ucy1jb2xsYXBzZXtvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZX0uaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlLmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhci5pbi10b29sYmFyIGlvbi10aXRsZSwuaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlLmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZSBpb24tdG9vbGJhci5pbi10b29sYmFyIGlvbi1idXR0b25zLmJ1dHRvbnMtY29sbGFwc2V7dmlzaWJpbGl0eTpoaWRkZW59XCI7XG5cbmNvbnN0IGhlYWRlck1kQ3NzID0gXCJpb24taGVhZGVye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtb3JkZXI6LTE7b3JkZXI6LTE7d2lkdGg6MTAwJTt6LWluZGV4OjEwfWlvbi1oZWFkZXIgaW9uLXRvb2xiYXI6Zmlyc3Qtb2YtdHlwZXtwYWRkaW5nLXRvcDp2YXIoLS1pb24tc2FmZS1hcmVhLXRvcCwgMCl9LmhlYWRlci1tZDo6YWZ0ZXJ7bGVmdDowO2JvdHRvbTotNXB4O2JhY2tncm91bmQtcG9zaXRpb246bGVmdCAwIHRvcCAtMnB4O3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjVweDtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQUhCQU1BQUFEekR0QnhBQUFBRDFCTVZFVUFBQUFBQUFBQUFBQUFBQUFBQUFCUER1ZU5BQUFBQlhSU1RsTVVDUzBnQkloL1RYRUFBQUFhU1VSQlZBalhZeENFQWdZNFVJSUNCbU1vZ01zZ0ZMdEFBUUNOU3dYWktPZFB4Z0FBQUFCSlJVNUVya0pnZ2c9PSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7Y29udGVudDpcXFwiXFxcIn1bZGlyPXJ0bF0gLmhlYWRlci1tZDo6YWZ0ZXIsOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pIC5oZWFkZXItbWQ6OmFmdGVye2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6MH1bZGlyPXJ0bF0gLmhlYWRlci1tZDo6YWZ0ZXIsOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pIC5oZWFkZXItbWQ6OmFmdGVye2JhY2tncm91bmQtcG9zaXRpb246cmlnaHQgMCB0b3AgLTJweH0uaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNle2Rpc3BsYXk6bm9uZX0uaGVhZGVyLW1kLmlvbi1uby1ib3JkZXI6OmFmdGVye2Rpc3BsYXk6bm9uZX1cIjtcblxuY29uc3QgSGVhZGVyID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IHt9O1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGhlYWRlciB3aWxsIGJlIHRyYW5zbHVjZW50LlxuICAgICAqIE9ubHkgYXBwbGllcyB3aGVuIHRoZSBtb2RlIGlzIGBcImlvc1wiYCBhbmQgdGhlIGRldmljZSBzdXBwb3J0c1xuICAgICAqIFtgYmFja2Ryb3AtZmlsdGVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2JhY2tkcm9wLWZpbHRlciNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gb3JkZXIgdG8gc2Nyb2xsIGNvbnRlbnQgYmVoaW5kIHRoZSBoZWFkZXIsIHRoZSBgZnVsbHNjcmVlbmBcbiAgICAgKiBhdHRyaWJ1dGUgbmVlZHMgdG8gYmUgc2V0IG9uIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIHRoaXMudHJhbnNsdWNlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHVwRmFkZUhlYWRlciA9IGFzeW5jIChjb250ZW50RWwsIGNvbmRlbnNlSGVhZGVyKSA9PiB7XG4gICAgICBpZiAoIWNvbnRlbnRFbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdpb24taGVhZGVyIHJlcXVpcmVzIGEgY29udGVudCB0byBjb2xsYXBzZS4gTWFrZSBzdXJlIHRoZXJlIGlzIGFuIGlvbi1jb250ZW50LicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNvbXBvbmVudE9uUmVhZHkoY29udGVudEVsLCByZXNvbHZlKSk7XG4gICAgICBjb25zdCBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWwgPSBhd2FpdCBjb250ZW50RWwuZ2V0U2Nyb2xsRWxlbWVudCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGUgZmFkaW5nIG9mIHRvb2xiYXJzIG9uIHNjcm9sbFxuICAgICAgICovXG4gICAgICB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjayA9ICgpID0+IHsgaGFuZGxlSGVhZGVyRmFkZSh0aGlzLnNjcm9sbEVsLCB0aGlzLmVsLCBjb25kZW5zZUhlYWRlcik7IH07XG4gICAgICBzY3JvbGxFbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjayk7XG4gICAgICBoYW5kbGVIZWFkZXJGYWRlKHRoaXMuc2Nyb2xsRWwsIHRoaXMuZWwsIGNvbmRlbnNlSGVhZGVyKTtcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IGluaGVyaXRBdHRyaWJ1dGVzKHRoaXMuZWwsIFsncm9sZSddKTtcbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHRoaXMuY2hlY2tDb2xsYXBzaWJsZUhlYWRlcigpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmNoZWNrQ29sbGFwc2libGVIZWFkZXIoKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmRlc3Ryb3lDb2xsYXBzaWJsZUhlYWRlcigpO1xuICB9XG4gIGFzeW5jIGNoZWNrQ29sbGFwc2libGVIZWFkZXIoKSB7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgaWYgKG1vZGUgIT09ICdpb3MnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29sbGFwc2UgfSA9IHRoaXM7XG4gICAgY29uc3QgaGFzQ29uZGVuc2UgPSBjb2xsYXBzZSA9PT0gJ2NvbmRlbnNlJztcbiAgICBjb25zdCBoYXNGYWRlID0gY29sbGFwc2UgPT09ICdmYWRlJztcbiAgICB0aGlzLmRlc3Ryb3lDb2xsYXBzaWJsZUhlYWRlcigpO1xuICAgIGlmIChoYXNDb25kZW5zZSkge1xuICAgICAgY29uc3QgcGFnZUVsID0gdGhpcy5lbC5jbG9zZXN0KCdpb24tYXBwLGlvbi1wYWdlLC5pb24tcGFnZSxwYWdlLWlubmVyJyk7XG4gICAgICBjb25zdCBjb250ZW50RWwgPSAocGFnZUVsKSA/IHBhZ2VFbC5xdWVyeVNlbGVjdG9yKCdpb24tY29udGVudCcpIDogbnVsbDtcbiAgICAgIC8vIENsb25lZCBlbGVtZW50cyBhcmUgYWx3YXlzIG5lZWRlZCBpbiBpT1MgdHJhbnNpdGlvblxuICAgICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBjbG9uZUVsZW1lbnQoJ2lvbi10aXRsZScpO1xuICAgICAgICB0aXRsZS5zaXplID0gJ2xhcmdlJztcbiAgICAgICAgY2xvbmVFbGVtZW50KCdpb24tYmFjay1idXR0b24nKTtcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cENvbmRlbnNlSGVhZGVyKGNvbnRlbnRFbCwgcGFnZUVsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzRmFkZSkge1xuICAgICAgY29uc3QgcGFnZUVsID0gdGhpcy5lbC5jbG9zZXN0KCdpb24tYXBwLGlvbi1wYWdlLC5pb24tcGFnZSxwYWdlLWlubmVyJyk7XG4gICAgICBjb25zdCBjb250ZW50RWwgPSAocGFnZUVsKSA/IHBhZ2VFbC5xdWVyeVNlbGVjdG9yKCdpb24tY29udGVudCcpIDogbnVsbDtcbiAgICAgIGNvbnN0IGNvbmRlbnNlSGVhZGVyID0gKGNvbnRlbnRFbCkgPyBjb250ZW50RWwucXVlcnlTZWxlY3RvcignaW9uLWhlYWRlcltjb2xsYXBzZT1cImNvbmRlbnNlXCJdJykgOiBudWxsO1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cEZhZGVIZWFkZXIoY29udGVudEVsLCBjb25kZW5zZUhlYWRlcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lDb2xsYXBzaWJsZUhlYWRlcigpIHtcbiAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5zY3JvbGxFbCAmJiB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjaykge1xuICAgICAgdGhpcy5zY3JvbGxFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjayk7XG4gICAgICB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29sbGFwc2libGVNYWluSGVhZGVyKSB7XG4gICAgICB0aGlzLmNvbGxhcHNpYmxlTWFpbkhlYWRlci5jbGFzc0xpc3QucmVtb3ZlKCdoZWFkZXItY29sbGFwc2UtbWFpbicpO1xuICAgICAgdGhpcy5jb2xsYXBzaWJsZU1haW5IZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldHVwQ29uZGVuc2VIZWFkZXIoY29udGVudEVsLCBwYWdlRWwpIHtcbiAgICBpZiAoIWNvbnRlbnRFbCB8fCAhcGFnZUVsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdpb24taGVhZGVyIHJlcXVpcmVzIGEgY29udGVudCB0byBjb2xsYXBzZSwgbWFrZSBzdXJlIHRoZXJlIGlzIGFuIGlvbi1jb250ZW50LicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNvbXBvbmVudE9uUmVhZHkoY29udGVudEVsLCByZXNvbHZlKSk7XG4gICAgdGhpcy5zY3JvbGxFbCA9IGF3YWl0IGNvbnRlbnRFbC5nZXRTY3JvbGxFbGVtZW50KCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHBhZ2VFbC5xdWVyeVNlbGVjdG9yQWxsKCdpb24taGVhZGVyJyk7XG4gICAgdGhpcy5jb2xsYXBzaWJsZU1haW5IZWFkZXIgPSBBcnJheS5mcm9tKGhlYWRlcnMpLmZpbmQoKGhlYWRlcikgPT4gaGVhZGVyLmNvbGxhcHNlICE9PSAnY29uZGVuc2UnKTtcbiAgICBpZiAoIXRoaXMuY29sbGFwc2libGVNYWluSGVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1haW5IZWFkZXJJbmRleCA9IGNyZWF0ZUhlYWRlckluZGV4KHRoaXMuY29sbGFwc2libGVNYWluSGVhZGVyKTtcbiAgICBjb25zdCBzY3JvbGxIZWFkZXJJbmRleCA9IGNyZWF0ZUhlYWRlckluZGV4KHRoaXMuZWwpO1xuICAgIGlmICghbWFpbkhlYWRlckluZGV4IHx8ICFzY3JvbGxIZWFkZXJJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRIZWFkZXJBY3RpdmUobWFpbkhlYWRlckluZGV4LCBmYWxzZSk7XG4gICAgc2V0VG9vbGJhckJhY2tncm91bmRPcGFjaXR5KG1haW5IZWFkZXJJbmRleC5lbCwgMCk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGludGVyYWN0aW9uIGJldHdlZW4gdG9vbGJhciBjb2xsYXBzZSBhbmRcbiAgICAgKiBzaG93aW5nL2hpZGluZyBjb250ZW50IGluIHRoZSBwcmltYXJ5IGlvbi1oZWFkZXJcbiAgICAgKiBhcyB3ZWxsIGFzIHByb2dyZXNzaXZlbHkgc2hvd2luZy9oaWRpbmcgdGhlIG1haW4gaGVhZGVyXG4gICAgICogYm9yZGVyIGFzIHRoZSB0b3AtbW9zdCB0b29sYmFyIGNvbGxhcHNlcyBvciBleHBhbmRzLlxuICAgICAqL1xuICAgIGNvbnN0IHRvb2xiYXJJbnRlcnNlY3Rpb24gPSAoZXYpID0+IHsgaGFuZGxlVG9vbGJhckludGVyc2VjdGlvbihldiwgbWFpbkhlYWRlckluZGV4LCBzY3JvbGxIZWFkZXJJbmRleCwgdGhpcy5zY3JvbGxFbCk7IH07XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcih0b29sYmFySW50ZXJzZWN0aW9uLCB7IHJvb3Q6IGNvbnRlbnRFbCwgdGhyZXNob2xkOiBbMC4yNSwgMC4zLCAwLjQsIDAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxXSB9KTtcbiAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoc2Nyb2xsSGVhZGVySW5kZXgudG9vbGJhcnNbc2Nyb2xsSGVhZGVySW5kZXgudG9vbGJhcnMubGVuZ3RoIC0gMV0uZWwpO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzY2FsaW5nIG9mIGxhcmdlIGlPUyB0aXRsZXMgYW5kXG4gICAgICogc2hvd2luZy9oaWRpbmcgYm9yZGVyIG9uIGxhc3QgdG9vbGJhclxuICAgICAqIGluIHByaW1hcnkgaGVhZGVyXG4gICAgICovXG4gICAgdGhpcy5jb250ZW50U2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiB7IGhhbmRsZUNvbnRlbnRTY3JvbGwodGhpcy5zY3JvbGxFbCwgc2Nyb2xsSGVhZGVySW5kZXgsIGNvbnRlbnRFbCk7IH07XG4gICAgdGhpcy5zY3JvbGxFbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmNvbnRlbnRTY3JvbGxDYWxsYmFjayk7XG4gICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlTWFpbkhlYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2libGVNYWluSGVhZGVyLmNsYXNzTGlzdC5hZGQoJ2hlYWRlci1jb2xsYXBzZS1tYWluJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdHJhbnNsdWNlbnQsIGluaGVyaXRlZEF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgY29sbGFwc2UgPSB0aGlzLmNvbGxhcHNlIHx8ICdub25lJztcbiAgICAvLyBiYW5uZXIgcm9sZSBtdXN0IGJlIGF0IHRvcCBsZXZlbCwgc28gcmVtb3ZlIHJvbGUgaWYgaW5zaWRlIGEgbWVudVxuICAgIGNvbnN0IHJvbGVUeXBlID0gaG9zdENvbnRleHQoJ2lvbi1tZW51JywgdGhpcy5lbCkgPyAnbm9uZScgOiAnYmFubmVyJztcbiAgICByZXR1cm4gKGgoSG9zdCwgT2JqZWN0LmFzc2lnbih7IHJvbGU6IHJvbGVUeXBlLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBmb3Igc3R5bGluZ1xuICAgICAgICBbYGhlYWRlci0ke21vZGV9YF06IHRydWUsXG4gICAgICAgIFtgaGVhZGVyLXRyYW5zbHVjZW50YF06IHRoaXMudHJhbnNsdWNlbnQsXG4gICAgICAgIFtgaGVhZGVyLWNvbGxhcHNlLSR7Y29sbGFwc2V9YF06IHRydWUsXG4gICAgICAgIFtgaGVhZGVyLXRyYW5zbHVjZW50LSR7bW9kZX1gXTogdGhpcy50cmFuc2x1Y2VudCxcbiAgICAgIH0gfSwgaW5oZXJpdGVkQXR0cmlidXRlcyksIG1vZGUgPT09ICdpb3MnICYmIHRyYW5zbHVjZW50ICYmXG4gICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaGVhZGVyLWJhY2tncm91bmRcIiB9KSwgaChcInNsb3RcIiwgbnVsbCkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBoZWFkZXJJb3NDc3MsXG4gICAgbWQ6IGhlYWRlck1kQ3NzXG4gIH07IH1cbn0sIFszNiwgXCJpb24taGVhZGVyXCIsIHtcbiAgICBcImNvbGxhcHNlXCI6IFsxXSxcbiAgICBcInRyYW5zbHVjZW50XCI6IFs0XVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1oZWFkZXJcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1oZWFkZXJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBIZWFkZXIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvbkhlYWRlciA9IEhlYWRlcjtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkhlYWRlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVDb2xvckNsYXNzZXMsIGggYXMgaG9zdENvbnRleHQgfSBmcm9tICcuL3RoZW1lLmpzJztcblxuY29uc3QgbGFiZWxJb3NDc3MgPSBcIi5pdGVtLnNjLWlvbi1sYWJlbC1pb3MtaCwuaXRlbSAuc2MtaW9uLWxhYmVsLWlvcy1oey0tY29sb3I6aW5pdGlhbDtkaXNwbGF5OmJsb2NrO2NvbG9yOnZhcigtLWNvbG9yKTtmb250LWZhbWlseTp2YXIoLS1pb24tZm9udC1mYW1pbHksIGluaGVyaXQpO2ZvbnQtc2l6ZTppbmhlcml0O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9Lmlvbi1jb2xvci5zYy1pb24tbGFiZWwtaW9zLWh7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfS5pb24tdGV4dC13cmFwLnNjLWlvbi1sYWJlbC1pb3MtaCxbdGV4dC13cmFwXS5zYy1pb24tbGFiZWwtaW9zLWh7d2hpdGUtc3BhY2U6bm9ybWFsfS5pdGVtLWludGVyYWN0aXZlLWRpc2FibGVkLnNjLWlvbi1sYWJlbC1pb3MtaDpub3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSwuaXRlbS1pbnRlcmFjdGl2ZS1kaXNhYmxlZDpub3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSAuc2MtaW9uLWxhYmVsLWlvcy1oe2N1cnNvcjpkZWZhdWx0O29wYWNpdHk6MC4zO3BvaW50ZXItZXZlbnRzOm5vbmV9Lml0ZW0taW5wdXQuc2MtaW9uLWxhYmVsLWlvcy1oLC5pdGVtLWlucHV0IC5zYy1pb24tbGFiZWwtaW9zLWh7LW1zLWZsZXg6aW5pdGlhbDtmbGV4OmluaXRpYWw7bWF4LXdpZHRoOjIwMHB4O3BvaW50ZXItZXZlbnRzOm5vbmV9Lml0ZW0tdGV4dGFyZWEuc2MtaW9uLWxhYmVsLWlvcy1oLC5pdGVtLXRleHRhcmVhIC5zYy1pb24tbGFiZWwtaW9zLWh7LW1zLWZsZXgtaXRlbS1hbGlnbjpiYXNlbGluZTthbGlnbi1zZWxmOmJhc2VsaW5lfS5sYWJlbC1maXhlZC5zYy1pb24tbGFiZWwtaW9zLWh7LW1zLWZsZXg6MCAwIDEwMHB4O2ZsZXg6MCAwIDEwMHB4O3dpZHRoOjEwMHB4O21pbi13aWR0aDoxMDBweDttYXgtd2lkdGg6MjAwcHh9LmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLWlvcy1oLC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtaW9zLWh7bWFyZ2luLWJvdHRvbTowOy1tcy1mbGV4LWl0ZW0tYWxpZ246c3RyZXRjaDthbGlnbi1zZWxmOnN0cmV0Y2g7d2lkdGg6YXV0bzttYXgtd2lkdGg6MTAwJX0ubGFiZWwtbm8tYW5pbWF0ZS5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtaW9zLWh7LXdlYmtpdC10cmFuc2l0aW9uOm5vbmU7dHJhbnNpdGlvbjpub25lfS5zYy1pb24tbGFiZWwtaW9zLXMgaDEsLnNjLWlvbi1sYWJlbC1pb3MtcyBoMiwuc2MtaW9uLWxhYmVsLWlvcy1zIGgzLC5zYy1pb24tbGFiZWwtaW9zLXMgaDQsLnNjLWlvbi1sYWJlbC1pb3MtcyBoNSwuc2MtaW9uLWxhYmVsLWlvcy1zIGg2e3RleHQtb3ZlcmZsb3c6aW5oZXJpdDtvdmVyZmxvdzppbmhlcml0fS5pb24tdGV4dC13cmFwLnNjLWlvbi1sYWJlbC1pb3MtaCxbdGV4dC13cmFwXS5zYy1pb24tbGFiZWwtaW9zLWh7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS41fS5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1pb3MtaHttYXJnaW4tYm90dG9tOjRweDtmb250LXNpemU6MTRweH0ubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLWlvcy1oe21hcmdpbi1ib3R0b206MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAgMjlweCwgIDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAgMjlweCwgIDApOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcDt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAxNTBtcyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOi13ZWJraXQtdHJhbnNmb3JtIDE1MG1zIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246dHJhbnNmb3JtIDE1MG1zIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246dHJhbnNmb3JtIDE1MG1zIGVhc2UtaW4tb3V0LCAtd2Via2l0LXRyYW5zZm9ybSAxNTBtcyBlYXNlLWluLW91dH1bZGlyPXJ0bF0uc2MtaW9uLWxhYmVsLWlvcy1oIC1uby1jb21iaW5hdG9yLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCxbZGlyPXJ0bF0gLnNjLWlvbi1sYWJlbC1pb3MtaCAtbm8tY29tYmluYXRvci5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtaW9zLWgsW2Rpcj1ydGxdLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCxbZGlyPXJ0bF0gLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaHstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wO3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfS5pdGVtLXRleHRhcmVhLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCwuaXRlbS10ZXh0YXJlYSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLWlvcy1oey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsICAyOHB4LCAgMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsICAyOHB4LCAgMCl9Lml0ZW0taGFzLWZvY3VzLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCwuaXRlbS1oYXMtZm9jdXMgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCwuaXRlbS1oYXMtcGxhY2Vob2xkZXIuc2MtaW9uLWxhYmVsLWlvcy1oOm5vdCguaXRlbS1pbnB1dCkubGFiZWwtZmxvYXRpbmcsLml0ZW0taGFzLXBsYWNlaG9sZGVyOm5vdCguaXRlbS1pbnB1dCkgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1pb3MtaCwuaXRlbS1oYXMtdmFsdWUubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLWlvcy1oLC5pdGVtLWhhcy12YWx1ZSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLWlvcy1oey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsICAwLCAgMCkgc2NhbGUoMC44Mik7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsICAwLCAgMCkgc2NhbGUoMC44Mil9LnNjLWlvbi1sYWJlbC1pb3MtcyBoMXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6M3B4O21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToyMnB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH0uc2MtaW9uLWxhYmVsLWlvcy1zIGgye21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxN3B4O2ZvbnQtd2VpZ2h0Om5vcm1hbH0uc2MtaW9uLWxhYmVsLWlvcy1zIGgzLC5zYy1pb24tbGFiZWwtaW9zLXMgaDQsLnNjLWlvbi1sYWJlbC1pb3MtcyBoNSwuc2MtaW9uLWxhYmVsLWlvcy1zIGg2e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206M3B4O2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtsaW5lLWhlaWdodDpub3JtYWx9LnNjLWlvbi1sYWJlbC1pb3MtcyBwe21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LW92ZXJmbG93OmluaGVyaXQ7b3ZlcmZsb3c6aW5oZXJpdH0uc2MtaW9uLWxhYmVsLWlvcy1zPnB7Y29sb3I6cmdiYSh2YXIoLS1pb24tdGV4dC1jb2xvci1yZ2IsIDAsIDAsIDApLCAwLjQpfS5zYy1pb24tbGFiZWwtaW9zLWguaW4taXRlbS1jb2xvci5zYy1pb24tbGFiZWwtaW9zLXM+cHtjb2xvcjppbmhlcml0fS5zYy1pb24tbGFiZWwtaW9zLXMgaDI6bGFzdC1jaGlsZCwuc2MtaW9uLWxhYmVsLWlvcy1zIGgzOmxhc3QtY2hpbGQsLnNjLWlvbi1sYWJlbC1pb3MtcyBoNDpsYXN0LWNoaWxkLC5zYy1pb24tbGFiZWwtaW9zLXMgaDU6bGFzdC1jaGlsZCwuc2MtaW9uLWxhYmVsLWlvcy1zIGg2Omxhc3QtY2hpbGQsLnNjLWlvbi1sYWJlbC1pb3MtcyBwOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTowfVwiO1xuXG5jb25zdCBsYWJlbE1kQ3NzID0gXCIuaXRlbS5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbSAuc2MtaW9uLWxhYmVsLW1kLWh7LS1jb2xvcjppbml0aWFsO2Rpc3BsYXk6YmxvY2s7Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7Zm9udC1zaXplOmluaGVyaXQ7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uaW9uLWNvbG9yLnNjLWlvbi1sYWJlbC1tZC1oe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX0uaW9uLXRleHQtd3JhcC5zYy1pb24tbGFiZWwtbWQtaCxbdGV4dC13cmFwXS5zYy1pb24tbGFiZWwtbWQtaHt3aGl0ZS1zcGFjZTpub3JtYWx9Lml0ZW0taW50ZXJhY3RpdmUtZGlzYWJsZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pdGVtLW11bHRpcGxlLWlucHV0cyksLml0ZW0taW50ZXJhY3RpdmUtZGlzYWJsZWQ6bm90KC5pdGVtLW11bHRpcGxlLWlucHV0cykgLnNjLWlvbi1sYWJlbC1tZC1oe2N1cnNvcjpkZWZhdWx0O29wYWNpdHk6MC4zO3BvaW50ZXItZXZlbnRzOm5vbmV9Lml0ZW0taW5wdXQuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0taW5wdXQgLnNjLWlvbi1sYWJlbC1tZC1oey1tcy1mbGV4OmluaXRpYWw7ZmxleDppbml0aWFsO21heC13aWR0aDoyMDBweDtwb2ludGVyLWV2ZW50czpub25lfS5pdGVtLXRleHRhcmVhLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLXRleHRhcmVhIC5zYy1pb24tbGFiZWwtbWQtaHstbXMtZmxleC1pdGVtLWFsaWduOmJhc2VsaW5lO2FsaWduLXNlbGY6YmFzZWxpbmV9LmxhYmVsLWZpeGVkLnNjLWlvbi1sYWJlbC1tZC1oey1tcy1mbGV4OjAgMCAxMDBweDtmbGV4OjAgMCAxMDBweDt3aWR0aDoxMDBweDttaW4td2lkdGg6MTAwcHg7bWF4LXdpZHRoOjIwMHB4fS5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1tZC1oLC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaHttYXJnaW4tYm90dG9tOjA7LW1zLWZsZXgtaXRlbS1hbGlnbjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaDt3aWR0aDphdXRvO21heC13aWR0aDoxMDAlfS5sYWJlbC1uby1hbmltYXRlLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oey13ZWJraXQtdHJhbnNpdGlvbjpub25lO3RyYW5zaXRpb246bm9uZX0uc2MtaW9uLWxhYmVsLW1kLXMgaDEsLnNjLWlvbi1sYWJlbC1tZC1zIGgyLC5zYy1pb24tbGFiZWwtbWQtcyBoMywuc2MtaW9uLWxhYmVsLW1kLXMgaDQsLnNjLWlvbi1sYWJlbC1tZC1zIGg1LC5zYy1pb24tbGFiZWwtbWQtcyBoNnt0ZXh0LW92ZXJmbG93OmluaGVyaXQ7b3ZlcmZsb3c6aW5oZXJpdH0uaW9uLXRleHQtd3JhcC5zYy1pb24tbGFiZWwtbWQtaCxbdGV4dC13cmFwXS5zYy1pb24tbGFiZWwtbWQtaHtsaW5lLWhlaWdodDoxLjV9LmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWgsLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oe21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNmb3JtLW9yaWdpbjp0b3AgbGVmdH0ubGFiZWwtc3RhY2tlZC5sYWJlbC1ydGwuc2MtaW9uLWxhYmVsLW1kLWgsLmxhYmVsLWZsb2F0aW5nLmxhYmVsLXJ0bC5zYy1pb24tbGFiZWwtbWQtaHstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46dG9wIHJpZ2h0O3RyYW5zZm9ybS1vcmlnaW46dG9wIHJpZ2h0fS5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1tZC1oey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoNTAlKSBzY2FsZSgwLjc1KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg1MCUpIHNjYWxlKDAuNzUpOy13ZWJraXQtdHJhbnNpdGlvbjpjb2xvciAxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO3RyYW5zaXRpb246Y29sb3IgMTUwbXMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKX0ubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWh7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg5NiUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDk2JSk7LXdlYmtpdC10cmFuc2l0aW9uOmNvbG9yIDE1MG1zIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSksIC13ZWJraXQtdHJhbnNmb3JtIDE1MG1zIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7dHJhbnNpdGlvbjpjb2xvciAxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpLCAtd2Via2l0LXRyYW5zZm9ybSAxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO3RyYW5zaXRpb246Y29sb3IgMTUwbXMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKSwgdHJhbnNmb3JtIDE1MG1zIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7dHJhbnNpdGlvbjpjb2xvciAxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpLCB0cmFuc2Zvcm0gMTUwbXMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKSwgLXdlYmtpdC10cmFuc2Zvcm0gMTUwbXMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKX0uaW9uLWZvY3VzZWQubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLmlvbi1mb2N1c2VkIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1oYXMtZm9jdXMubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0taGFzLWZvY3VzIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1oYXMtcGxhY2Vob2xkZXIuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pdGVtLWlucHV0KS5sYWJlbC1mbG9hdGluZywuaXRlbS1oYXMtcGxhY2Vob2xkZXI6bm90KC5pdGVtLWlucHV0KSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0taGFzLXZhbHVlLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWhhcy12YWx1ZSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWh7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSg1MCUpIHNjYWxlKDAuNzUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDUwJSkgc2NhbGUoMC43NSl9Lml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pb24tZm9jdXNlZCAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLWZvY3VzLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cyAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXBsYWNlaG9sZGVyLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaXRlbS1pbnB1dCkubGFiZWwtZmxvYXRpbmcsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXBsYWNlaG9sZGVyOm5vdCguaXRlbS1pbnB1dCkgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZS5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtdmFsdWUgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTZweCkgc2NhbGUoMC43NSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTZweCkgc2NhbGUoMC43NSk7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOi13ZWJraXQtbWluLWNvbnRlbnQ7bWF4LXdpZHRoOi1tb3otbWluLWNvbnRlbnQ7bWF4LXdpZHRoOm1pbi1jb250ZW50O2JhY2tncm91bmQtY29sb3I6dmFyKC0taW9uLWl0ZW0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKTtvdmVyZmxvdzp2aXNpYmxlO3otaW5kZXg6M30uaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmJlZm9yZSwuaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmJlZm9yZSwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLWZvY3VzLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtcGxhY2Vob2xkZXIuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pdGVtLWlucHV0KS5sYWJlbC1mbG9hdGluZzo6YmVmb3JlLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlcjpub3QoLml0ZW0taW5wdXQpIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YmVmb3JlLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlci5zYy1pb24tbGFiZWwtbWQtaDpub3QoLml0ZW0taW5wdXQpLmxhYmVsLWZsb2F0aW5nOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtcGxhY2Vob2xkZXI6bm90KC5pdGVtLWlucHV0KSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVyLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZS5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YmVmb3JlLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmJlZm9yZSwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtdmFsdWUubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVyLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjRweDtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWlvbi1pdGVtLWJhY2tncm91bmQsIHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKSk7Y29udGVudDpcXFwiXFxcIn0uaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmJlZm9yZSwuaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLWZvY3VzLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLWZvY3VzIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YmVmb3JlLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlci5zYy1pb24tbGFiZWwtbWQtaDpub3QoLml0ZW0taW5wdXQpLmxhYmVsLWZsb2F0aW5nOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXBsYWNlaG9sZGVyOm5vdCguaXRlbS1pbnB1dCkgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXZhbHVlLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjpiZWZvcmUsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXZhbHVlIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YmVmb3Jle2xlZnQ6Y2FsYygtMSAqIDRweCl9Lml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVyLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cyAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVyLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlci5zYy1pb24tbGFiZWwtbWQtaDpub3QoLml0ZW0taW5wdXQpLmxhYmVsLWZsb2F0aW5nOjphZnRlciwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtcGxhY2Vob2xkZXI6bm90KC5pdGVtLWlucHV0KSAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6OmFmdGVyLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZS5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YWZ0ZXIsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXZhbHVlIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDo6YWZ0ZXJ7cmlnaHQ6Y2FsYygtMSAqIDRweCl9Lml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLml0ZW0taGFzLXN0YXJ0LXNsb3QubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLml0ZW0taGFzLXN0YXJ0LXNsb3QgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pdGVtLWhhcy1zdGFydC1zbG90LmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pdGVtLWhhcy1zdGFydC1zbG90IC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtcGxhY2Vob2xkZXIuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pdGVtLWlucHV0KS5pdGVtLWhhcy1zdGFydC1zbG90LmxhYmVsLWZsb2F0aW5nLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlcjpub3QoLml0ZW0taW5wdXQpLml0ZW0taGFzLXN0YXJ0LXNsb3QgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZS5pdGVtLWhhcy1zdGFydC1zbG90LmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy12YWx1ZS5pdGVtLWhhcy1zdGFydC1zbG90IC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0zMnB4KSB0cmFuc2xhdGVZKC02cHgpIHNjYWxlKDAuNzUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0zMnB4KSB0cmFuc2xhdGVZKC02cHgpIHNjYWxlKDAuNzUpfS5pdGVtLWZpbGwtb3V0bGluZS5pb24tZm9jdXNlZC5pdGVtLWhhcy1zdGFydC1zbG90LmxhYmVsLWZsb2F0aW5nLmxhYmVsLXJ0bC5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1maWxsLW91dGxpbmUuaW9uLWZvY3VzZWQuaXRlbS1oYXMtc3RhcnQtc2xvdCAubGFiZWwtZmxvYXRpbmcubGFiZWwtcnRsLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pdGVtLWhhcy1zdGFydC1zbG90LmxhYmVsLWZsb2F0aW5nLmxhYmVsLXJ0bC5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMuaXRlbS1oYXMtc3RhcnQtc2xvdCAubGFiZWwtZmxvYXRpbmcubGFiZWwtcnRsLnNjLWlvbi1sYWJlbC1tZC1oLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlci5zYy1pb24tbGFiZWwtbWQtaDpub3QoLml0ZW0taW5wdXQpLml0ZW0taGFzLXN0YXJ0LXNsb3QubGFiZWwtZmxvYXRpbmcubGFiZWwtcnRsLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1wbGFjZWhvbGRlcjpub3QoLml0ZW0taW5wdXQpLml0ZW0taGFzLXN0YXJ0LXNsb3QgLmxhYmVsLWZsb2F0aW5nLmxhYmVsLXJ0bC5zYy1pb24tbGFiZWwtbWQtaCwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtdmFsdWUuaXRlbS1oYXMtc3RhcnQtc2xvdC5sYWJlbC1mbG9hdGluZy5sYWJlbC1ydGwuc2MtaW9uLWxhYmVsLW1kLWgsLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLXZhbHVlLml0ZW0taGFzLXN0YXJ0LXNsb3QgLmxhYmVsLWZsb2F0aW5nLmxhYmVsLXJ0bC5zYy1pb24tbGFiZWwtbWQtaHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKGNhbGMoLTEgKiAtMzJweCkpIHRyYW5zbGF0ZVkoLTZweCkgc2NhbGUoMC43NSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoY2FsYygtMSAqIC0zMnB4KSkgdHJhbnNsYXRlWSgtNnB4KSBzY2FsZSgwLjc1KX0uaW9uLWZvY3VzZWQubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLmlvbi1mb2N1c2VkIC5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaW9uLWZvY3VzZWQubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pb24tZm9jdXNlZCAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWhhcy1mb2N1cy5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaXRlbS1oYXMtZm9jdXMgLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWhhcy1mb2N1cy5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0taGFzLWZvY3VzIC5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvcil7Y29sb3I6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpfS5pb24tZm9jdXNlZC5pb24tY29sb3IubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLmlvbi1mb2N1c2VkLmlvbi1jb2xvciAubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLmlvbi1mb2N1c2VkLmlvbi1jb2xvci5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLmlvbi1mb2N1c2VkLmlvbi1jb2xvciAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWhhcy1mb2N1cy5pb24tY29sb3IubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0taGFzLWZvY3VzLmlvbi1jb2xvciAubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0taGFzLWZvY3VzLmlvbi1jb2xvci5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0taGFzLWZvY3VzLmlvbi1jb2xvciAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Lml0ZW0tZmlsbC1zb2xpZC5pb24tZm9jdXNlZC5pb24tY29sb3IubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0tZmlsbC1zb2xpZC5pb24tZm9jdXNlZC5pb24tY29sb3IgLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtc29saWQuaW9uLWZvY3VzZWQuaW9uLWNvbG9yLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaXRlbS1maWxsLXNvbGlkLmlvbi1mb2N1c2VkLmlvbi1jb2xvciAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtb3V0bGluZS5pb24tZm9jdXNlZC5pb24tY29sb3IubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmlvbi1jb2xvciAubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmlvbi1jb2xvci5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkLmlvbi1jb2xvciAubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtc29saWQuaXRlbS1oYXMtZm9jdXMuaW9uLWNvbG9yLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtc29saWQuaXRlbS1oYXMtZm9jdXMuaW9uLWNvbG9yIC5sYWJlbC1zdGFja2VkLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaXRlbS1maWxsLXNvbGlkLml0ZW0taGFzLWZvY3VzLmlvbi1jb2xvci5sYWJlbC1mbG9hdGluZy5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLml0ZW0tZmlsbC1zb2xpZC5pdGVtLWhhcy1mb2N1cy5pb24tY29sb3IgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaXRlbS1maWxsLW91dGxpbmUuaXRlbS1oYXMtZm9jdXMuaW9uLWNvbG9yLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pb24tY29sb3IgLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pb24tY29sb3IubGFiZWwtZmxvYXRpbmcuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWhhcy1mb2N1cy5pb24tY29sb3IgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItYmFzZSl9Lmlvbi1pbnZhbGlkLmlvbi10b3VjaGVkLmxhYmVsLXN0YWNrZWQuc2MtaW9uLWxhYmVsLW1kLWg6bm90KC5pb24tY29sb3IpLC5pb24taW52YWxpZC5pb24tdG91Y2hlZCAubGFiZWwtc3RhY2tlZC5zYy1pb24tbGFiZWwtbWQtaDpub3QoLmlvbi1jb2xvciksLmlvbi1pbnZhbGlkLmlvbi10b3VjaGVkLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKSwuaW9uLWludmFsaWQuaW9uLXRvdWNoZWQgLmxhYmVsLWZsb2F0aW5nLnNjLWlvbi1sYWJlbC1tZC1oOm5vdCguaW9uLWNvbG9yKXtjb2xvcjp2YXIoLS1oaWdobGlnaHQtY29sb3ItaW52YWxpZCl9LnNjLWlvbi1sYWJlbC1tZC1zIGgxe21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToyNHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH0uc2MtaW9uLWxhYmVsLW1kLXMgaDJ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MTZweDtmb250LXdlaWdodDpub3JtYWx9LnNjLWlvbi1sYWJlbC1tZC1zIGgzLC5zYy1pb24tbGFiZWwtbWQtcyBoNCwuc2MtaW9uLWxhYmVsLW1kLXMgaDUsLnNjLWlvbi1sYWJlbC1tZC1zIGg2e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6bm9ybWFsO2xpbmUtaGVpZ2h0Om5vcm1hbH0uc2MtaW9uLWxhYmVsLW1kLXMgcHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoyMHB4O3RleHQtb3ZlcmZsb3c6aW5oZXJpdDtvdmVyZmxvdzppbmhlcml0fS5zYy1pb24tbGFiZWwtbWQtcz5we2NvbG9yOnZhcigtLWlvbi1jb2xvci1zdGVwLTYwMCwgIzY2NjY2Nil9LnNjLWlvbi1sYWJlbC1tZC1oLmluLWl0ZW0tY29sb3Iuc2MtaW9uLWxhYmVsLW1kLXM+cHtjb2xvcjppbmhlcml0fVwiO1xuXG5jb25zdCBMYWJlbCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLmlvbkNvbG9yID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Db2xvclwiLCA3KTtcbiAgICB0aGlzLmlvblN0eWxlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25TdHlsZVwiLCA3KTtcbiAgICB0aGlzLmluUmFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLm5vQW5pbWF0ZSA9IGZhbHNlO1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW5SYW5nZSA9ICEhdGhpcy5lbC5jbG9zZXN0KCdpb24tcmFuZ2UnKTtcbiAgICB0aGlzLm5vQW5pbWF0ZSA9ICh0aGlzLnBvc2l0aW9uID09PSAnZmxvYXRpbmcnKTtcbiAgICB0aGlzLmVtaXRTdHlsZSgpO1xuICAgIHRoaXMuZW1pdENvbG9yKCk7XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICBpZiAodGhpcy5ub0FuaW1hdGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm5vQW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9XG4gIGNvbG9yQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmVtaXRDb2xvcigpO1xuICB9XG4gIHBvc2l0aW9uQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmVtaXRTdHlsZSgpO1xuICB9XG4gIGVtaXRDb2xvcigpIHtcbiAgICBjb25zdCB7IGNvbG9yIH0gPSB0aGlzO1xuICAgIHRoaXMuaW9uQ29sb3IuZW1pdCh7XG4gICAgICAnaXRlbS1sYWJlbC1jb2xvcic6IGNvbG9yICE9PSB1bmRlZmluZWQsXG4gICAgICBbYGlvbi1jb2xvci0ke2NvbG9yfWBdOiBjb2xvciAhPT0gdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgZW1pdFN0eWxlKCkge1xuICAgIGNvbnN0IHsgaW5SYW5nZSwgcG9zaXRpb24gfSA9IHRoaXM7XG4gICAgLy8gSWYgdGhlIGxhYmVsIGlzIGluc2lkZSBvZiBhIHJhbmdlIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBvdmVycmlkZSB0aGUgY2xhc3NlcyBhZGRlZCBieSB0aGUgbGFiZWwgdGhhdFxuICAgIC8vIGlzIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSBpdGVtXG4gICAgaWYgKCFpblJhbmdlKSB7XG4gICAgICB0aGlzLmlvblN0eWxlLmVtaXQoe1xuICAgICAgICAnbGFiZWwnOiB0cnVlLFxuICAgICAgICBbYGxhYmVsLSR7cG9zaXRpb259YF06IHBvc2l0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXModGhpcy5jb2xvciwge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICdpbi1pdGVtLWNvbG9yJzogaG9zdENvbnRleHQoJ2lvbi1pdGVtLmlvbi1jb2xvcicsIHRoaXMuZWwpLFxuICAgICAgICBbYGxhYmVsLSR7cG9zaXRpb259YF06IHBvc2l0aW9uICE9PSB1bmRlZmluZWQsXG4gICAgICAgIFtgbGFiZWwtbm8tYW5pbWF0ZWBdOiAodGhpcy5ub0FuaW1hdGUpLFxuICAgICAgICAnbGFiZWwtcnRsJzogZG9jdW1lbnQuZGlyID09PSAncnRsJ1xuICAgICAgfSkgfSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcImNvbG9yXCI6IFtcImNvbG9yQ2hhbmdlZFwiXSxcbiAgICBcInBvc2l0aW9uXCI6IFtcInBvc2l0aW9uQ2hhbmdlZFwiXVxuICB9OyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBsYWJlbElvc0NzcyxcbiAgICBtZDogbGFiZWxNZENzc1xuICB9OyB9XG59LCBbMzQsIFwiaW9uLWxhYmVsXCIsIHtcbiAgICBcImNvbG9yXCI6IFs1MTNdLFxuICAgIFwicG9zaXRpb25cIjogWzFdLFxuICAgIFwibm9BbmltYXRlXCI6IFszMl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWxhYmVsXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tbGFiZWxcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBMYWJlbCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuZXhwb3J0IHsgTGFiZWwgYXMgTCwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgTCBhcyBMYWJlbCwgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICcuL2xhYmVsLmpzJztcblxuY29uc3QgSW9uTGFiZWwgPSBMYWJlbDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkxhYmVsLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgaCwgSG9zdCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcblxuY29uc3QgbGlzdElvc0NzcyA9IFwiaW9uLWxpc3R7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7ZGlzcGxheTpibG9jaztjb250YWluOmNvbnRlbnQ7bGlzdC1zdHlsZS10eXBlOm5vbmV9aW9uLWxpc3QubGlzdC1pbnNldHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO292ZXJmbG93OmhpZGRlbn0ubGlzdC1pb3N7YmFja2dyb3VuZDp2YXIoLS1pb24taXRlbS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpfS5saXN0LWlvcy5saXN0LWluc2V0e21hcmdpbi1sZWZ0OjE2cHg7bWFyZ2luLXJpZ2h0OjE2cHg7bWFyZ2luLXRvcDoxNnB4O21hcmdpbi1ib3R0b206MTZweDtib3JkZXItcmFkaXVzOjEwcHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsubGlzdC1pb3MubGlzdC1pbnNldHttYXJnaW4tbGVmdDp1bnNldDttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6MTZweDttYXJnaW4taW5saW5lLXN0YXJ0OjE2cHg7LXdlYmtpdC1tYXJnaW4tZW5kOjE2cHg7bWFyZ2luLWlubGluZS1lbmQ6MTZweH19Lmxpc3QtaW9zLmxpc3QtaW5zZXQgaW9uLWl0ZW17LS1ib3JkZXItd2lkdGg6MCAwIDFweCAwOy0taW5uZXItYm9yZGVyLXdpZHRoOjB9Lmxpc3QtaW9zLmxpc3QtaW5zZXQgaW9uLWl0ZW06bGFzdC1jaGlsZHstLWJvcmRlci13aWR0aDowOy0taW5uZXItYm9yZGVyLXdpZHRoOjB9Lmxpc3QtaW9zLmxpc3QtaW5zZXQraW9uLWxpc3QubGlzdC1pbnNldHttYXJnaW4tdG9wOjB9Lmxpc3QtaW9zLWxpbmVzLW5vbmUgLml0ZW17LS1ib3JkZXItd2lkdGg6MDstLWlubmVyLWJvcmRlci13aWR0aDowfS5saXN0LWlvcy1saW5lcy1mdWxsIC5pdGVtLC5saXN0LWlvcyAuaXRlbS1saW5lcy1mdWxsey0tYm9yZGVyLXdpZHRoOjAgMCAwLjU1cHggMH0ubGlzdC1pb3MtbGluZXMtZnVsbCAuaXRlbXstLWlubmVyLWJvcmRlci13aWR0aDowfS5saXN0LWlvcy1saW5lcy1pbnNldCAuaXRlbSwubGlzdC1pb3MgLml0ZW0tbGluZXMtaW5zZXR7LS1pbm5lci1ib3JkZXItd2lkdGg6MCAwIDAuNTVweCAwfS5saXN0LWlvcyAuaXRlbS1saW5lcy1pbnNldHstLWJvcmRlci13aWR0aDowfS5saXN0LWlvcyAuaXRlbS1saW5lcy1mdWxsey0taW5uZXItYm9yZGVyLXdpZHRoOjB9Lmxpc3QtaW9zIC5pdGVtLWxpbmVzLW5vbmV7LS1ib3JkZXItd2lkdGg6MDstLWlubmVyLWJvcmRlci13aWR0aDowfWlvbi1jYXJkIC5saXN0LWlvc3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9XCI7XG5cbmNvbnN0IGxpc3RNZENzcyA9IFwiaW9uLWxpc3R7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7ZGlzcGxheTpibG9jaztjb250YWluOmNvbnRlbnQ7bGlzdC1zdHlsZS10eXBlOm5vbmV9aW9uLWxpc3QubGlzdC1pbnNldHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO292ZXJmbG93OmhpZGRlbn0ubGlzdC1tZHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO3BhZGRpbmctdG9wOjhweDtwYWRkaW5nLWJvdHRvbTo4cHg7YmFja2dyb3VuZDp2YXIoLS1pb24taXRlbS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpfS5saXN0LW1kPi5pbnB1dDpsYXN0LWNoaWxkOjphZnRlcntsZWZ0OjB9W2Rpcj1ydGxdIC5saXN0LW1kPi5pbnB1dDpsYXN0LWNoaWxkOjphZnRlciw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgLmxpc3QtbWQ+LmlucHV0Omxhc3QtY2hpbGQ6OmFmdGVye2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6MH0ubGlzdC1tZC5saXN0LWluc2V0e21hcmdpbi1sZWZ0OjE2cHg7bWFyZ2luLXJpZ2h0OjE2cHg7bWFyZ2luLXRvcDoxNnB4O21hcmdpbi1ib3R0b206MTZweDtib3JkZXItcmFkaXVzOjJweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5saXN0LW1kLmxpc3QtaW5zZXR7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjE2cHg7bWFyZ2luLWlubGluZS1zdGFydDoxNnB4Oy13ZWJraXQtbWFyZ2luLWVuZDoxNnB4O21hcmdpbi1pbmxpbmUtZW5kOjE2cHh9fS5saXN0LW1kLmxpc3QtaW5zZXQgaW9uLWl0ZW06Zmlyc3QtY2hpbGR7LS1ib3JkZXItcmFkaXVzOjJweCAycHggMCAwOy0tYm9yZGVyLXdpZHRoOjAgMCAxcHggMH0ubGlzdC1tZC5saXN0LWluc2V0IGlvbi1pdGVtOmxhc3QtY2hpbGR7LS1ib3JkZXItcmFkaXVzOjAgMCAycHgsIDJweDstLWJvcmRlci13aWR0aDowfS5saXN0LW1kLmxpc3QtaW5zZXQgLml0ZW0taW50ZXJhY3RpdmV7LS1wYWRkaW5nLXN0YXJ0OjA7LS1wYWRkaW5nLWVuZDowfS5saXN0LW1kLmxpc3QtaW5zZXQraW9uLWxpc3QubGlzdC1pbnNldHttYXJnaW4tdG9wOjB9Lmxpc3QtbWQtbGluZXMtbm9uZSAuaXRlbXstLWJvcmRlci13aWR0aDowOy0taW5uZXItYm9yZGVyLXdpZHRoOjB9Lmxpc3QtbWQtbGluZXMtZnVsbCAuaXRlbSwubGlzdC1tZCAuaXRlbS1saW5lcy1mdWxsey0tYm9yZGVyLXdpZHRoOjAgMCAxcHggMH0ubGlzdC1tZC1saW5lcy1mdWxsIC5pdGVtey0taW5uZXItYm9yZGVyLXdpZHRoOjB9Lmxpc3QtbWQtbGluZXMtaW5zZXQgLml0ZW0sLmxpc3QtbWQgLml0ZW0tbGluZXMtaW5zZXR7LS1pbm5lci1ib3JkZXItd2lkdGg6MCAwIDFweCAwfS5saXN0LW1kIC5pdGVtLWxpbmVzLWluc2V0ey0tYm9yZGVyLXdpZHRoOjB9Lmxpc3QtbWQgLml0ZW0tbGluZXMtZnVsbHstLWlubmVyLWJvcmRlci13aWR0aDowfS5saXN0LW1kIC5pdGVtLWxpbmVzLW5vbmV7LS1ib3JkZXItd2lkdGg6MDstLWlubmVyLWJvcmRlci13aWR0aDowfWlvbi1jYXJkIC5saXN0LW1ke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MH1cIjtcblxuY29uc3QgTGlzdCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IHdpbGwgaGF2ZSBtYXJnaW4gYXJvdW5kIGl0IGFuZCByb3VuZGVkIGNvcm5lcnMuXG4gICAgICovXG4gICAgdGhpcy5pbnNldCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBJZiBgaW9uLWl0ZW0tc2xpZGluZ2AgYXJlIHVzZWQgaW5zaWRlIHRoZSBsaXN0LCB0aGlzIG1ldGhvZCBjbG9zZXNcbiAgICogYW55IG9wZW4gc2xpZGluZyBpdGVtLlxuICAgKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBhY3R1YWwgYGlvbi1pdGVtLXNsaWRpbmdgIGlzIGNsb3NlZC5cbiAgICovXG4gIGFzeW5jIGNsb3NlU2xpZGluZ0l0ZW1zKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1pdGVtLXNsaWRpbmcnKTtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmNsb3NlT3BlbmVkKSB7XG4gICAgICByZXR1cm4gaXRlbS5jbG9zZU9wZW5lZCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIGNvbnN0IHsgbGluZXMsIGluc2V0IH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgLy8gVXNlZCBpbnRlcm5hbGx5IGZvciBzdHlsaW5nXG4gICAgICAgIFtgbGlzdC0ke21vZGV9YF06IHRydWUsXG4gICAgICAgICdsaXN0LWluc2V0JzogaW5zZXQsXG4gICAgICAgIFtgbGlzdC1saW5lcy0ke2xpbmVzfWBdOiBsaW5lcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBbYGxpc3QtJHttb2RlfS1saW5lcy0ke2xpbmVzfWBdOiBsaW5lcyAhPT0gdW5kZWZpbmVkXG4gICAgICB9IH0pKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBsaXN0SW9zQ3NzLFxuICAgIG1kOiBsaXN0TWRDc3NcbiAgfTsgfVxufSwgWzMyLCBcImlvbi1saXN0XCIsIHtcbiAgICBcImxpbmVzXCI6IFsxXSxcbiAgICBcImluc2V0XCI6IFs0XSxcbiAgICBcImNsb3NlU2xpZGluZ0l0ZW1zXCI6IFs2NF1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWxpc3RcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1saXN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgTGlzdCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuZXhwb3J0IHsgTGlzdCBhcyBMLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBMIGFzIExpc3QsIGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxIH0gZnJvbSAnLi9saXN0LmpzJztcblxuY29uc3QgSW9uTGlzdCA9IExpc3Q7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25MaXN0LCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgaCwgSG9zdCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS5qcyc7XG5cbmNvbnN0IGxpc3RIZWFkZXJJb3NDc3MgPSBcIjpob3N0ey0tYm9yZGVyLXN0eWxlOnNvbGlkOy0tYm9yZGVyLXdpZHRoOjA7LS1pbm5lci1ib3JkZXItd2lkdGg6MDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjt3aWR0aDoxMDAlO21pbi1oZWlnaHQ6NDBweDtib3JkZXItd2lkdGg6dmFyKC0tYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNvbG9yKTtvdmVyZmxvdzpoaWRkZW59Omhvc3QoLmlvbi1jb2xvcil7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItYmFzZSk7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX0ubGlzdC1oZWFkZXItaW5uZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtaXRlbS1hbGlnbjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaDttaW4taGVpZ2h0OmluaGVyaXQ7Ym9yZGVyLXdpZHRoOnZhcigtLWlubmVyLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7b3ZlcmZsb3c6aW5oZXJpdDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9OjpzbG90dGVkKGlvbi1sYWJlbCl7LW1zLWZsZXg6MSAxIGF1dG87ZmxleDoxIDEgYXV0b306aG9zdCgubGlzdC1oZWFkZXItbGluZXMtaW5zZXQpLDpob3N0KC5saXN0LWhlYWRlci1saW5lcy1ub25lKXstLWJvcmRlci13aWR0aDowfTpob3N0KC5saXN0LWhlYWRlci1saW5lcy1mdWxsKSw6aG9zdCgubGlzdC1oZWFkZXItbGluZXMtbm9uZSl7LS1pbm5lci1ib3JkZXItd2lkdGg6MH06aG9zdHstLWJhY2tncm91bmQ6dHJhbnNwYXJlbnQ7LS1jb2xvcjp2YXIoLS1pb24tY29sb3Itc3RlcC04NTAsICMyNjI2MjYpOy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1pdGVtLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMjUwLCAjYzhjN2NjKSkpO3BhZGRpbmctbGVmdDpjYWxjKHZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCwgMHB4KSArIDIwcHgpO3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWFsaWduOmVuZDthbGlnbi1pdGVtczpmbGV4LWVuZDtmb250LXNpemU6MjJweDtmb250LXdlaWdodDo3MDA7bGV0dGVyLXNwYWNpbmc6MH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0e3BhZGRpbmctbGVmdDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6Y2FsYyh2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkgKyAyMHB4KTtwYWRkaW5nLWlubGluZS1zdGFydDpjYWxjKHZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCwgMHB4KSArIDIwcHgpfX06OnNsb3R0ZWQoaW9uLWJ1dHRvbiksOjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLXRvcDoyOXB4O21hcmdpbi1ib3R0b206NnB4fTo6c2xvdHRlZChpb24tYnV0dG9uKXttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXJpZ2h0OjNweDtoZWlnaHQ6MS40ZW19QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWJ1dHRvbil7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjNweDttYXJnaW4taW5saW5lLXN0YXJ0OjNweDstd2Via2l0LW1hcmdpbi1lbmQ6M3B4O21hcmdpbi1pbmxpbmUtZW5kOjNweH19Omhvc3QoLmxpc3QtaGVhZGVyLWxpbmVzLWZ1bGwpey0tYm9yZGVyLXdpZHRoOjAgMCAwLjU1cHggMH06aG9zdCgubGlzdC1oZWFkZXItbGluZXMtaW5zZXQpey0taW5uZXItYm9yZGVyLXdpZHRoOjAgMCAwLjU1cHggMH1cIjtcblxuY29uc3QgbGlzdEhlYWRlck1kQ3NzID0gXCI6aG9zdHstLWJvcmRlci1zdHlsZTpzb2xpZDstLWJvcmRlci13aWR0aDowOy0taW5uZXItYm9yZGVyLXdpZHRoOjA7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47d2lkdGg6MTAwJTttaW4taGVpZ2h0OjQwcHg7Ym9yZGVyLXdpZHRoOnZhcigtLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcik7b3ZlcmZsb3c6aGlkZGVufTpob3N0KC5pb24tY29sb3Ipe2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpO2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Lmxpc3QtaGVhZGVyLWlubmVye2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4OjE7ZmxleDoxOy1tcy1mbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LWl0ZW0tYWxpZ246c3RyZXRjaDthbGlnbi1zZWxmOnN0cmV0Y2g7bWluLWhlaWdodDppbmhlcml0O2JvcmRlci13aWR0aDp2YXIoLS1pbm5lci1ib3JkZXItd2lkdGgpO2JvcmRlci1zdHlsZTp2YXIoLS1ib3JkZXItc3R5bGUpO2JvcmRlci1jb2xvcjp2YXIoLS1ib3JkZXItY29sb3IpO292ZXJmbG93OmluaGVyaXQ7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fTo6c2xvdHRlZChpb24tbGFiZWwpey1tcy1mbGV4OjEgMSBhdXRvO2ZsZXg6MSAxIGF1dG99Omhvc3QoLmxpc3QtaGVhZGVyLWxpbmVzLWluc2V0KSw6aG9zdCgubGlzdC1oZWFkZXItbGluZXMtbm9uZSl7LS1ib3JkZXItd2lkdGg6MH06aG9zdCgubGlzdC1oZWFkZXItbGluZXMtZnVsbCksOmhvc3QoLmxpc3QtaGVhZGVyLWxpbmVzLW5vbmUpey0taW5uZXItYm9yZGVyLXdpZHRoOjB9Omhvc3R7LS1iYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy0tY29sb3I6dmFyKC0taW9uLXRleHQtY29sb3IsICMwMDApOy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1pdGVtLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCByZ2JhKDAsIDAsIDAsIDAuMTMpKSkpO3BhZGRpbmctbGVmdDpjYWxjKHZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCwgMCkgKyAxNnB4KTttaW4taGVpZ2h0OjQ1cHg7Zm9udC1zaXplOjE0cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0LCAwKSArIDE2cHgpO3BhZGRpbmctaW5saW5lLXN0YXJ0OmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0LCAwKSArIDE2cHgpfX06aG9zdCgubGlzdC1oZWFkZXItbGluZXMtZnVsbCl7LS1ib3JkZXItd2lkdGg6MCAwIDFweCAwfTpob3N0KC5saXN0LWhlYWRlci1saW5lcy1pbnNldCl7LS1pbm5lci1ib3JkZXItd2lkdGg6MCAwIDFweCAwfVwiO1xuXG5jb25zdCBMaXN0SGVhZGVyID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsaW5lcyB9ID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICBbYGxpc3QtaGVhZGVyLWxpbmVzLSR7bGluZXN9YF06IGxpbmVzICE9PSB1bmRlZmluZWQsXG4gICAgICB9KSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibGlzdC1oZWFkZXItaW5uZXJcIiB9LCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4ge1xuICAgIGlvczogbGlzdEhlYWRlcklvc0NzcyxcbiAgICBtZDogbGlzdEhlYWRlck1kQ3NzXG4gIH07IH1cbn0sIFszMywgXCJpb24tbGlzdC1oZWFkZXJcIiwge1xuICAgIFwiY29sb3JcIjogWzUxM10sXG4gICAgXCJsaW5lc1wiOiBbMV1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWxpc3QtaGVhZGVyXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tbGlzdC1oZWFkZXJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBMaXN0SGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5leHBvcnQgeyBMaXN0SGVhZGVyIGFzIEwsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IEwgYXMgTGlzdEhlYWRlciwgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICcuL2xpc3QtaGVhZGVyLmpzJztcblxuY29uc3QgSW9uTGlzdEhlYWRlciA9IExpc3RIZWFkZXI7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25MaXN0SGVhZGVyLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgaCwgSG9zdCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS5qcyc7XG5cbmNvbnN0IHRleHRDc3MgPSBcIjpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX1cIjtcblxuY29uc3QgVGV4dCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXModGhpcy5jb2xvciwge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICB9KSB9LCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB0ZXh0Q3NzOyB9XG59LCBbMSwgXCJpb24tdGV4dFwiLCB7XG4gICAgXCJjb2xvclwiOiBbNTEzXVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi10ZXh0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tdGV4dFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFRleHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvblRleHQgPSBUZXh0O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQkMTtcblxuZXhwb3J0IHsgSW9uVGV4dCwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVDb2xvckNsYXNzZXMgfSBmcm9tICcuL3RoZW1lLmpzJztcblxuY29uc3QgdGl0bGVJb3NDc3MgPSBcIjpob3N0ey0tY29sb3I6aW5pdGlhbDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7Y29sb3I6dmFyKC0tY29sb3IpfTpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX0udG9vbGJhci10aXRsZXtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3BvaW50ZXItZXZlbnRzOmF1dG99Omhvc3QoLnRpdGxlLXNtYWxsKSAudG9vbGJhci10aXRsZXt3aGl0ZS1zcGFjZTpub3JtYWx9Omhvc3R7bGVmdDowO3RvcDowO3BhZGRpbmctbGVmdDo5MHB4O3BhZGRpbmctcmlnaHQ6OTBweDtwYWRkaW5nLXRvcDp2YXIoLS1wYWRkaW5nLXRvcCk7cGFkZGluZy1ib3R0b206dmFyKC0tcGFkZGluZy1ib3R0b20pO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTtmb250LXNpemU6MTdweDtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6MH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0e3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDo5MHB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjkwcHg7LXdlYmtpdC1wYWRkaW5nLWVuZDo5MHB4O3BhZGRpbmctaW5saW5lLWVuZDo5MHB4fX06aG9zdCgudGl0bGUtc21hbGwpe3BhZGRpbmctbGVmdDo5cHg7cGFkZGluZy1yaWdodDo5cHg7cGFkZGluZy10b3A6NnB4O3BhZGRpbmctYm90dG9tOjE2cHg7cG9zaXRpb246cmVsYXRpdmU7Zm9udC1zaXplOjEzcHg7Zm9udC13ZWlnaHQ6bm9ybWFsfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3QoLnRpdGxlLXNtYWxsKXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6OXB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjlweDstd2Via2l0LXBhZGRpbmctZW5kOjlweDtwYWRkaW5nLWlubGluZS1lbmQ6OXB4fX06aG9zdCgudGl0bGUtbGFyZ2Upe3BhZGRpbmctbGVmdDoxNnB4O3BhZGRpbmctcmlnaHQ6MTZweDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmxlZnQgY2VudGVyO3RyYW5zZm9ybS1vcmlnaW46bGVmdCBjZW50ZXI7Ym90dG9tOjA7LW1zLWZsZXgtYWxpZ246ZW5kO2FsaWduLWl0ZW1zOmZsZXgtZW5kO21pbi13aWR0aDoxMDAlO3BhZGRpbmctYm90dG9tOjZweDtmb250LXNpemU6MzRweDtmb250LXdlaWdodDo3MDA7dGV4dC1hbGlnbjpzdGFydH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC50aXRsZS1sYXJnZSl7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDstd2Via2l0LXBhZGRpbmctZW5kOjE2cHg7cGFkZGluZy1pbmxpbmUtZW5kOjE2cHh9fTpob3N0KC50aXRsZS1sYXJnZS50aXRsZS1ydGwpey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpyaWdodCBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCBjZW50ZXJ9Omhvc3QoLnRpdGxlLWxhcmdlLmlvbi1jbG9uZWQtZWxlbWVudCl7LS1jb2xvcjp2YXIoLS1pb24tdGV4dC1jb2xvciwgIzAwMCl9Omhvc3QoLnRpdGxlLWxhcmdlKSAudG9vbGJhci10aXRsZXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46aW5oZXJpdDt0cmFuc2Zvcm0tb3JpZ2luOmluaGVyaXR9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRpdGxlLWxhcmdlKSAudG9vbGJhci10aXRsZSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGl0bGUtbGFyZ2UgLnRvb2xiYXItdGl0bGV7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNhbGMoMTAwJSAtIGluaGVyaXQpO3RyYW5zZm9ybS1vcmlnaW46Y2FsYygxMDAlIC0gaW5oZXJpdCl9XCI7XG5cbmNvbnN0IHRpdGxlTWRDc3MgPSBcIjpob3N0ey0tY29sb3I6aW5pdGlhbDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7Y29sb3I6dmFyKC0tY29sb3IpfTpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX0udG9vbGJhci10aXRsZXtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO3BvaW50ZXItZXZlbnRzOmF1dG99Omhvc3QoLnRpdGxlLXNtYWxsKSAudG9vbGJhci10aXRsZXt3aGl0ZS1zcGFjZTpub3JtYWx9Omhvc3R7cGFkZGluZy1sZWZ0OjIwcHg7cGFkZGluZy1yaWdodDoyMHB4O3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDtmb250LXNpemU6MjBweDtmb250LXdlaWdodDo1MDA7bGV0dGVyLXNwYWNpbmc6MC4wMTI1ZW19QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6MjBweDtwYWRkaW5nLWlubGluZS1zdGFydDoyMHB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6MjBweDtwYWRkaW5nLWlubGluZS1lbmQ6MjBweH19Omhvc3QoLnRpdGxlLXNtYWxsKXt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2ZvbnQtc2l6ZToxNXB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH1cIjtcblxuY29uc3QgVG9vbGJhclRpdGxlID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmlvblN0eWxlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25TdHlsZVwiLCA3KTtcbiAgfVxuICBzaXplQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmVtaXRTdHlsZSgpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuZW1pdFN0eWxlKCk7XG4gIH1cbiAgZW1pdFN0eWxlKCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICB0aGlzLmlvblN0eWxlLmVtaXQoe1xuICAgICAgW2B0aXRsZS0ke3NpemV9YF06IHRydWVcbiAgICB9KTtcbiAgfVxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAodGhpcy5zaXplICE9PSB1bmRlZmluZWQpID8gdGhpcy5zaXplIDogJ2RlZmF1bHQnO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IGNyZWF0ZUNvbG9yQ2xhc3Nlcyh0aGlzLmNvbG9yLCB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgW2B0aXRsZS0ke3NpemV9YF06IHRydWUsXG4gICAgICAgICd0aXRsZS1ydGwnOiBkb2N1bWVudC5kaXIgPT09ICdydGwnXG4gICAgICB9KSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidG9vbGJhci10aXRsZVwiIH0sIGgoXCJzbG90XCIsIG51bGwpKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInNpemVcIjogW1wic2l6ZUNoYW5nZWRcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4ge1xuICAgIGlvczogdGl0bGVJb3NDc3MsXG4gICAgbWQ6IHRpdGxlTWRDc3NcbiAgfTsgfVxufSwgWzMzLCBcImlvbi10aXRsZVwiLCB7XG4gICAgXCJjb2xvclwiOiBbNTEzXSxcbiAgICBcInNpemVcIjogWzFdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRpdGxlXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tdGl0bGVcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUb29sYmFyVGl0bGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvblRpdGxlID0gVG9vbGJhclRpdGxlO1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQkMTtcblxuZXhwb3J0IHsgSW9uVGl0bGUsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBmb3JjZVVwZGF0ZSwgaCwgSG9zdCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzLCBoIGFzIGhvc3RDb250ZXh0IH0gZnJvbSAnLi90aGVtZS5qcyc7XG5cbmNvbnN0IHRvb2xiYXJJb3NDc3MgPSBcIjpob3N0ey0tYm9yZGVyLXdpZHRoOjA7LS1ib3JkZXItc3R5bGU6c29saWQ7LS1vcGFjaXR5OjE7LS1vcGFjaXR5LXNjYWxlOjE7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7cGFkZGluZy1sZWZ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7cGFkZGluZy1yaWdodDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KTtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7Y29udGFpbjpjb250ZW50O3otaW5kZXg6MTA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KX19Omhvc3QoLmlvbi1jb2xvcil7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yKSAudG9vbGJhci1iYWNrZ3JvdW5ke2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfS50b29sYmFyLWNvbnRhaW5lcntwYWRkaW5nLWxlZnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1yaWdodDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy10b3A6dmFyKC0tcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLXBhZGRpbmctYm90dG9tKTtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvdzstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjt3aWR0aDoxMDAlO21pbi1oZWlnaHQ6dmFyKC0tbWluLWhlaWdodCk7Y29udGFpbjpjb250ZW50O292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjEwOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey50b29sYmFyLWNvbnRhaW5lcntwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7LXdlYmtpdC1wYWRkaW5nLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLXBhZGRpbmctZW5kKX19LnRvb2xiYXItYmFja2dyb3VuZHtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO2JvcmRlci13aWR0aDp2YXIoLS1ib3JkZXItd2lkdGgpO2JvcmRlci1zdHlsZTp2YXIoLS1ib3JkZXItc3R5bGUpO2JvcmRlci1jb2xvcjp2YXIoLS1ib3JkZXItY29sb3IpO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29udGFpbjpzdHJpY3Q7b3BhY2l0eTpjYWxjKHZhcigtLW9wYWNpdHkpICogdmFyKC0tb3BhY2l0eS1zY2FsZSkpO3otaW5kZXg6LTE7cG9pbnRlci1ldmVudHM6bm9uZX06OnNsb3R0ZWQoaW9uLXByb2dyZXNzLWJhcil7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGV9Omhvc3R7LS1iYWNrZ3JvdW5kOnZhcigtLWlvbi10b29sYmFyLWJhY2tncm91bmQsIHZhcigtLWlvbi1jb2xvci1zdGVwLTUwLCAjZjdmN2Y3KSk7LS1jb2xvcjp2YXIoLS1pb24tdG9vbGJhci1jb2xvciwgdmFyKC0taW9uLXRleHQtY29sb3IsICMwMDApKTstLWJvcmRlci1jb2xvcjp2YXIoLS1pb24tdG9vbGJhci1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1jb2xvci1zdGVwLTE1MCwgcmdiYSgwLCAwLCAwLCAwLjIpKSkpOy0tcGFkZGluZy10b3A6M3B4Oy0tcGFkZGluZy1ib3R0b206M3B4Oy0tcGFkZGluZy1zdGFydDo0cHg7LS1wYWRkaW5nLWVuZDo0cHg7LS1taW4taGVpZ2h0OjQ0cHh9LnRvb2xiYXItY29udGVudHstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1vcmRlcjo0O29yZGVyOjQ7bWluLXdpZHRoOjB9Omhvc3QoLnRvb2xiYXItc2VnbWVudCkgLnRvb2xiYXItY29udGVudHtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4fTpob3N0KC50b29sYmFyLXNlYXJjaGJhcikgLnRvb2xiYXItY29udGFpbmVye3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MH06aG9zdCgudG9vbGJhci1zZWFyY2hiYXIpIDo6c2xvdHRlZCgqKXstbXMtZmxleC1pdGVtLWFsaWduOnN0YXJ0O2FsaWduLXNlbGY6c3RhcnR9Omhvc3QoLnRvb2xiYXItc2VhcmNoYmFyKSA6OnNsb3R0ZWQoaW9uLWNoaXApe21hcmdpbi10b3A6M3B4fTpob3N0KC50b29sYmFyLXNlYXJjaGJhcikgOjpzbG90dGVkKGlvbi1iYWNrLWJ1dHRvbil7aGVpZ2h0OjM4cHh9OjpzbG90dGVkKGlvbi1idXR0b25zKXttaW4taGVpZ2h0OjM4cHh9OjpzbG90dGVkKFtzbG90PXN0YXJ0XSl7LW1zLWZsZXgtb3JkZXI6MjtvcmRlcjoyfTo6c2xvdHRlZChbc2xvdD1zZWNvbmRhcnldKXstbXMtZmxleC1vcmRlcjozO29yZGVyOjN9OjpzbG90dGVkKFtzbG90PXByaW1hcnldKXstbXMtZmxleC1vcmRlcjo1O29yZGVyOjU7dGV4dC1hbGlnbjplbmR9OjpzbG90dGVkKFtzbG90PWVuZF0pey1tcy1mbGV4LW9yZGVyOjY7b3JkZXI6Njt0ZXh0LWFsaWduOmVuZH06aG9zdCgudG9vbGJhci10aXRsZS1sYXJnZSkgLnRvb2xiYXItY29udGFpbmVyey1tcy1mbGV4LXdyYXA6d3JhcDtmbGV4LXdyYXA6d3JhcDstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0fTpob3N0KC50b29sYmFyLXRpdGxlLWxhcmdlKSAudG9vbGJhci1jb250ZW50IGlvbi10aXRsZXstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1vcmRlcjo4O29yZGVyOjg7bWluLXdpZHRoOjEwMCV9XCI7XG5cbmNvbnN0IHRvb2xiYXJNZENzcyA9IFwiOmhvc3R7LS1ib3JkZXItd2lkdGg6MDstLWJvcmRlci1zdHlsZTpzb2xpZDstLW9wYWNpdHk6MTstLW9wYWNpdHktc2NhbGU6MTstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDtwYWRkaW5nLWxlZnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtjb2xvcjp2YXIoLS1jb2xvcik7Zm9udC1mYW1pbHk6dmFyKC0taW9uLWZvbnQtZmFtaWx5LCBpbmhlcml0KTtjb250YWluOmNvbnRlbnQ7ei1pbmRleDoxMDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpfX06aG9zdCguaW9uLWNvbG9yKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpIC50b29sYmFyLWJhY2tncm91bmR7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItYmFzZSl9LnRvb2xiYXItY29udGFpbmVye3BhZGRpbmctbGVmdDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLXRvcDp2YXIoLS1wYWRkaW5nLXRvcCk7cGFkZGluZy1ib3R0b206dmFyKC0tcGFkZGluZy1ib3R0b20pO2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93Oy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3dpZHRoOjEwMCU7bWluLWhlaWdodDp2YXIoLS1taW4taGVpZ2h0KTtjb250YWluOmNvbnRlbnQ7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6MTA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7LnRvb2xiYXItY29udGFpbmVye3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0udG9vbGJhci1iYWNrZ3JvdW5ke2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7Ym9yZGVyLXdpZHRoOnZhcigtLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb250YWluOnN0cmljdDtvcGFjaXR5OmNhbGModmFyKC0tb3BhY2l0eSkgKiB2YXIoLS1vcGFjaXR5LXNjYWxlKSk7ei1pbmRleDotMTtwb2ludGVyLWV2ZW50czpub25lfTo6c2xvdHRlZChpb24tcHJvZ3Jlc3MtYmFyKXtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZX06aG9zdHstLWJhY2tncm91bmQ6dmFyKC0taW9uLXRvb2xiYXItYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKTstLWNvbG9yOnZhcigtLWlvbi10b29sYmFyLWNvbG9yLCB2YXIoLS1pb24tdGV4dC1jb2xvciwgIzQyNDI0MikpOy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi10b29sYmFyLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCAjYzFjNGNkKSkpOy0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjA7LS1wYWRkaW5nLWVuZDowOy0tbWluLWhlaWdodDo1NnB4fS50b29sYmFyLWNvbnRlbnR7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtb3JkZXI6MztvcmRlcjozO21pbi13aWR0aDowO21heC13aWR0aDoxMDAlfTo6c2xvdHRlZChpb24tc2VnbWVudCl7bWluLWhlaWdodDp2YXIoLS1taW4taGVpZ2h0KX06OnNsb3R0ZWQoLmJ1dHRvbnMtZmlyc3Qtc2xvdCl7bWFyZ2luLWxlZnQ6NHB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKC5idXR0b25zLWZpcnN0LXNsb3Qpe21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjRweDttYXJnaW4taW5saW5lLXN0YXJ0OjRweH19OjpzbG90dGVkKC5idXR0b25zLWxhc3Qtc2xvdCl7bWFyZ2luLXJpZ2h0OjRweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZCguYnV0dG9ucy1sYXN0LXNsb3Qpe21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1lbmQ6NHB4O21hcmdpbi1pbmxpbmUtZW5kOjRweH19OjpzbG90dGVkKFtzbG90PXN0YXJ0XSl7LW1zLWZsZXgtb3JkZXI6MjtvcmRlcjoyfTo6c2xvdHRlZChbc2xvdD1zZWNvbmRhcnldKXstbXMtZmxleC1vcmRlcjo0O29yZGVyOjR9OjpzbG90dGVkKFtzbG90PXByaW1hcnldKXstbXMtZmxleC1vcmRlcjo1O29yZGVyOjU7dGV4dC1hbGlnbjplbmR9OjpzbG90dGVkKFtzbG90PWVuZF0pey1tcy1mbGV4LW9yZGVyOjY7b3JkZXI6Njt0ZXh0LWFsaWduOmVuZH1cIjtcblxuY29uc3QgVG9vbGJhciA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5jaGlsZHJlblN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zdCBidXR0b25zID0gQXJyYXkuZnJvbSh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1idXR0b25zJykpO1xuICAgIGNvbnN0IGZpcnN0QnV0dG9ucyA9IGJ1dHRvbnMuZmluZChidXR0b24gPT4ge1xuICAgICAgcmV0dXJuIGJ1dHRvbi5zbG90ID09PSAnc3RhcnQnO1xuICAgIH0pO1xuICAgIGlmIChmaXJzdEJ1dHRvbnMpIHtcbiAgICAgIGZpcnN0QnV0dG9ucy5jbGFzc0xpc3QuYWRkKCdidXR0b25zLWZpcnN0LXNsb3QnKTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uc1JldmVyc2VkID0gYnV0dG9ucy5yZXZlcnNlKCk7XG4gICAgY29uc3QgbGFzdEJ1dHRvbnMgPSBidXR0b25zUmV2ZXJzZWQuZmluZChidXR0b24gPT4gYnV0dG9uLnNsb3QgPT09ICdlbmQnKSB8fFxuICAgICAgYnV0dG9uc1JldmVyc2VkLmZpbmQoYnV0dG9uID0+IGJ1dHRvbi5zbG90ID09PSAncHJpbWFyeScpIHx8XG4gICAgICBidXR0b25zUmV2ZXJzZWQuZmluZChidXR0b24gPT4gYnV0dG9uLnNsb3QgPT09ICdzZWNvbmRhcnknKTtcbiAgICBpZiAobGFzdEJ1dHRvbnMpIHtcbiAgICAgIGxhc3RCdXR0b25zLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbnMtbGFzdC1zbG90Jyk7XG4gICAgfVxuICB9XG4gIGNoaWxkcmVuU3R5bGUoZXYpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCB0YWdOYW1lID0gZXYudGFyZ2V0LnRhZ05hbWU7XG4gICAgY29uc3QgdXBkYXRlZFN0eWxlcyA9IGV2LmRldGFpbDtcbiAgICBjb25zdCBuZXdTdHlsZXMgPSB7fTtcbiAgICBjb25zdCBjaGlsZFN0eWxlcyA9IHRoaXMuY2hpbGRyZW5TdHlsZXMuZ2V0KHRhZ05hbWUpIHx8IHt9O1xuICAgIGxldCBoYXNTdHlsZUNoYW5nZSA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRTdHlsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkS2V5ID0gYHRvb2xiYXItJHtrZXl9YDtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdXBkYXRlZFN0eWxlc1trZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjaGlsZFN0eWxlc1tjaGlsZEtleV0pIHtcbiAgICAgICAgaGFzU3R5bGVDaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgIG5ld1N0eWxlc1tjaGlsZEtleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYXNTdHlsZUNoYW5nZSkge1xuICAgICAgdGhpcy5jaGlsZHJlblN0eWxlcy5zZXQodGFnTmFtZSwgbmV3U3R5bGVzKTtcbiAgICAgIGZvcmNlVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgY2hpbGRTdHlsZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuU3R5bGVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGlsZFN0eWxlcywgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoaWxkU3R5bGVzKSwgY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICAnaW4tdG9vbGJhcic6IGhvc3RDb250ZXh0KCdpb24tdG9vbGJhcicsIHRoaXMuZWwpLFxuICAgICAgfSkpIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJ0b29sYmFyLWJhY2tncm91bmRcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRvb2xiYXItY29udGFpbmVyXCIgfSwgaChcInNsb3RcIiwgeyBuYW1lOiBcInN0YXJ0XCIgfSksIGgoXCJzbG90XCIsIHsgbmFtZTogXCJzZWNvbmRhcnlcIiB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRvb2xiYXItY29udGVudFwiIH0sIGgoXCJzbG90XCIsIG51bGwpKSwgaChcInNsb3RcIiwgeyBuYW1lOiBcInByaW1hcnlcIiB9KSwgaChcInNsb3RcIiwgeyBuYW1lOiBcImVuZFwiIH0pKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHtcbiAgICBpb3M6IHRvb2xiYXJJb3NDc3MsXG4gICAgbWQ6IHRvb2xiYXJNZENzc1xuICB9OyB9XG59LCBbMzMsIFwiaW9uLXRvb2xiYXJcIiwge1xuICAgIFwiY29sb3JcIjogWzUxM11cbiAgfSwgW1swLCBcImlvblN0eWxlXCIsIFwiY2hpbGRyZW5TdHlsZVwiXV1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRvb2xiYXJcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi10b29sYmFyXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgVG9vbGJhcik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uVG9vbGJhciA9IFRvb2xiYXI7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25Ub29sYmFyLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgY3JlYXRlRXZlbnQsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBoIGFzIGhhc1NoYWRvd0RvbSwgaSBhcyBpbmhlcml0QXR0cmlidXRlcyB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBvIGFzIG9wZW5VUkwsIGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzLCBoIGFzIGhvc3RDb250ZXh0IH0gZnJvbSAnLi90aGVtZS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMSB9IGZyb20gJy4vcmlwcGxlLWVmZmVjdC5qcyc7XG5cbmNvbnN0IGJ1dHRvbklvc0NzcyA9IFwiOmhvc3R7LS1vdmVyZmxvdzpoaWRkZW47LS1yaXBwbGUtY29sb3I6Y3VycmVudENvbG9yOy0tYm9yZGVyLXdpZHRoOmluaXRpYWw7LS1ib3JkZXItY29sb3I6aW5pdGlhbDstLWJvcmRlci1zdHlsZTppbml0aWFsOy0tY29sb3ItYWN0aXZhdGVkOnZhcigtLWNvbG9yKTstLWNvbG9yLWZvY3VzZWQ6dmFyKC0tY29sb3IpOy0tY29sb3ItaG92ZXI6dmFyKC0tY29sb3IpOy0tYm94LXNoYWRvdzpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmF1dG87Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3ZlcnRpY2FsLWFsaWduOnRvcDt2ZXJ0aWNhbC1hbGlnbjotd2Via2l0LWJhc2VsaW5lLW1pZGRsZTstd2Via2l0LWZvbnQta2VybmluZzpub25lO2ZvbnQta2VybmluZzpub25lfTpob3N0KC5idXR0b24tZGlzYWJsZWQpe2N1cnNvcjpkZWZhdWx0O29wYWNpdHk6MC41O3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QoLmJ1dHRvbi1zb2xpZCl7LS1iYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKTstLWNvbG9yOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LWNvbnRyYXN0LCAjZmZmKX06aG9zdCguYnV0dG9uLW91dGxpbmUpey0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKTstLWJhY2tncm91bmQ6dHJhbnNwYXJlbnQ7LS1jb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZil9Omhvc3QoLmJ1dHRvbi1jbGVhcil7LS1ib3JkZXItd2lkdGg6MDstLWJhY2tncm91bmQ6dHJhbnNwYXJlbnQ7LS1jb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZil9Omhvc3QoLmJ1dHRvbi1ibG9jayl7ZGlzcGxheTpibG9ja306aG9zdCguYnV0dG9uLWJsb2NrKSAuYnV0dG9uLW5hdGl2ZXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtjbGVhcjpib3RoO2NvbnRhaW46Y29udGVudH06aG9zdCguYnV0dG9uLWJsb2NrKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7Y2xlYXI6Ym90aH06aG9zdCguYnV0dG9uLWZ1bGwpe2Rpc3BsYXk6YmxvY2t9Omhvc3QoLmJ1dHRvbi1mdWxsKSAuYnV0dG9uLW5hdGl2ZXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtjb250YWluOmNvbnRlbnR9Omhvc3QoLmJ1dHRvbi1mdWxsOm5vdCguYnV0dG9uLXJvdW5kKSkgLmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci1sZWZ0LXdpZHRoOjB9LmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OnZhcigtLXBhZGRpbmctc3RhcnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOnZhcigtLXBhZGRpbmctdG9wKTtwYWRkaW5nLWJvdHRvbTp2YXIoLS1wYWRkaW5nLWJvdHRvbSk7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7LXdlYmtpdC10cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO3RyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7Ym9yZGVyLXdpZHRoOnZhcigtLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7b3V0bGluZTpub25lO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7bGluZS1oZWlnaHQ6MTstd2Via2l0LWJveC1zaGFkb3c6dmFyKC0tYm94LXNoYWRvdyk7Ym94LXNoYWRvdzp2YXIoLS1ib3gtc2hhZG93KTtjb250YWluOmxheW91dCBzdHlsZTtjdXJzb3I6cG9pbnRlcjtvcGFjaXR5OnZhcigtLW9wYWNpdHkpO292ZXJmbG93OnZhcigtLW92ZXJmbG93KTt6LWluZGV4OjA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZX1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5idXR0b24tbmF0aXZle3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0uYnV0dG9uLW5hdGl2ZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uYnV0dG9uLWlubmVye2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWZsb3c6cm93IG5vd3JhcDtmbGV4LWZsb3c6cm93IG5vd3JhcDstbXMtZmxleC1uZWdhdGl2ZTowO2ZsZXgtc2hyaW5rOjA7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ei1pbmRleDoxfTo6c2xvdHRlZChpb24taWNvbil7Zm9udC1zaXplOjEuNGVtO3BvaW50ZXItZXZlbnRzOm5vbmV9OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9c3RhcnRdKXttYXJnaW4tbGVmdDotMC4zZW07bWFyZ2luLXJpZ2h0OjAuM2VtO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1zdGFydF0pe21hcmdpbi1sZWZ0OnVuc2V0O21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDotMC4zZW07bWFyZ2luLWlubGluZS1zdGFydDotMC4zZW07LXdlYmtpdC1tYXJnaW4tZW5kOjAuM2VtO21hcmdpbi1pbmxpbmUtZW5kOjAuM2VtfX06OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1lbmRdKXttYXJnaW4tbGVmdDowLjNlbTttYXJnaW4tcmlnaHQ6LTAuMmVtO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1lbmRdKXttYXJnaW4tbGVmdDp1bnNldDttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6MC4zZW07bWFyZ2luLWlubGluZS1zdGFydDowLjNlbTstd2Via2l0LW1hcmdpbi1lbmQ6LTAuMmVtO21hcmdpbi1pbmxpbmUtZW5kOi0wLjJlbX19OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9aWNvbi1vbmx5XSl7Zm9udC1zaXplOjEuOGVtfWlvbi1yaXBwbGUtZWZmZWN0e2NvbG9yOnZhcigtLXJpcHBsZS1jb2xvcil9LmJ1dHRvbi1uYXRpdmU6OmFmdGVye2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7b3BhY2l0eTowfTpob3N0KC5pb24tYWN0aXZhdGVkKXtjb2xvcjp2YXIoLS1jb2xvci1hY3RpdmF0ZWQpfTpob3N0KC5pb24tYWN0aXZhdGVkKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWFjdGl2YXRlZCk7b3BhY2l0eTp2YXIoLS1iYWNrZ3JvdW5kLWFjdGl2YXRlZC1vcGFjaXR5KX06aG9zdCguaW9uLWZvY3VzZWQpe2NvbG9yOnZhcigtLWNvbG9yLWZvY3VzZWQpfTpob3N0KC5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KDpob3Zlcil7Y29sb3I6dmFyKC0tY29sb3ItaG92ZXIpfTpob3N0KDpob3ZlcikgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1ob3Zlcik7b3BhY2l0eTp2YXIoLS1iYWNrZ3JvdW5kLWhvdmVyLW9wYWNpdHkpfX06aG9zdCguYnV0dG9uLXNvbGlkLmlvbi1jb2xvcikgLmJ1dHRvbi1uYXRpdmV7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItYmFzZSk7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguYnV0dG9uLW91dGxpbmUuaW9uLWNvbG9yKSAuYnV0dG9uLW5hdGl2ZXtib3JkZXItY29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpfTpob3N0KC5idXR0b24tY2xlYXIuaW9uLWNvbG9yKSAuYnV0dG9uLW5hdGl2ZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguaW4tdG9vbGJhcjpub3QoLmlvbi1jb2xvcik6bm90KC5pbi10b29sYmFyLWNvbG9yKSkgLmJ1dHRvbi1uYXRpdmV7Y29sb3I6dmFyKC0taW9uLXRvb2xiYXItY29sb3IsIHZhcigtLWNvbG9yKSl9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lLmluLXRvb2xiYXI6bm90KC5pb24tY29sb3IpOm5vdCguaW4tdG9vbGJhci1jb2xvcikpIC5idXR0b24tbmF0aXZle2JvcmRlci1jb2xvcjp2YXIoLS1pb24tdG9vbGJhci1jb2xvciwgdmFyKC0tY29sb3IsIHZhcigtLWJvcmRlci1jb2xvcikpKX06aG9zdCguYnV0dG9uLXNvbGlkLmluLXRvb2xiYXI6bm90KC5pb24tY29sb3IpOm5vdCguaW4tdG9vbGJhci1jb2xvcikpIC5idXR0b24tbmF0aXZle2JhY2tncm91bmQ6dmFyKC0taW9uLXRvb2xiYXItY29sb3IsIHZhcigtLWJhY2tncm91bmQpKTtjb2xvcjp2YXIoLS1pb24tdG9vbGJhci1iYWNrZ3JvdW5kLCB2YXIoLS1jb2xvcikpfTpob3N0ey0tYm9yZGVyLXJhZGl1czoxMHB4Oy0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjFlbTstLXBhZGRpbmctZW5kOjFlbTstLXRyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciwgb3BhY2l0eSAxMDBtcyBsaW5lYXI7bWFyZ2luLWxlZnQ6MnB4O21hcmdpbi1yaWdodDoycHg7bWFyZ2luLXRvcDo0cHg7bWFyZ2luLWJvdHRvbTo0cHg7aGVpZ2h0OjIuOGVtO2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjUwMDtsZXR0ZXItc3BhY2luZzotMC4wM2VtfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjJweDttYXJnaW4taW5saW5lLXN0YXJ0OjJweDstd2Via2l0LW1hcmdpbi1lbmQ6MnB4O21hcmdpbi1pbmxpbmUtZW5kOjJweH19Omhvc3QoLmJ1dHRvbi1zb2xpZCl7LS1iYWNrZ3JvdW5kLWFjdGl2YXRlZDp2YXIoLS1pb24tY29sb3ItcHJpbWFyeS1zaGFkZSwgIzMxNzFlMCk7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dmFyKC0taW9uLWNvbG9yLXByaW1hcnktc2hhZGUsICMzMTcxZTApOy0tYmFja2dyb3VuZC1ob3Zlcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeS10aW50LCAjNGM4ZGZmKTstLWJhY2tncm91bmQtYWN0aXZhdGVkLW9wYWNpdHk6MTstLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5OjE7LS1iYWNrZ3JvdW5kLWhvdmVyLW9wYWNpdHk6MX06aG9zdCguYnV0dG9uLW91dGxpbmUpey0tYm9yZGVyLXJhZGl1czoxMHB4Oy0tYm9yZGVyLXdpZHRoOjFweDstLWJvcmRlci1zdHlsZTpzb2xpZDstLWJhY2tncm91bmQtYWN0aXZhdGVkOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKTstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7LS1iYWNrZ3JvdW5kLWhvdmVyOnRyYW5zcGFyZW50Oy0tYmFja2dyb3VuZC1mb2N1c2VkLW9wYWNpdHk6LjE7LS1jb2xvci1hY3RpdmF0ZWQ6dmFyKC0taW9uLWNvbG9yLXByaW1hcnktY29udHJhc3QsICNmZmYpfTpob3N0KC5idXR0b24tY2xlYXIpey0tYmFja2dyb3VuZC1hY3RpdmF0ZWQ6dHJhbnNwYXJlbnQ7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpOy0tYmFja2dyb3VuZC1ob3Zlcjp0cmFuc3BhcmVudDstLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5Oi4xO2ZvbnQtc2l6ZToxN3B4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzowfTpob3N0KC5idXR0b24tbGFyZ2Upey0tYm9yZGVyLXJhZGl1czoxMnB4Oy0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctc3RhcnQ6MWVtOy0tcGFkZGluZy1lbmQ6MWVtOy0tcGFkZGluZy1ib3R0b206MDtoZWlnaHQ6Mi44ZW07Zm9udC1zaXplOjIwcHh9Omhvc3QoLmJ1dHRvbi1zbWFsbCl7LS1ib3JkZXItcmFkaXVzOjZweDstLXBhZGRpbmctdG9wOjA7LS1wYWRkaW5nLXN0YXJ0OjAuOWVtOy0tcGFkZGluZy1lbmQ6MC45ZW07LS1wYWRkaW5nLWJvdHRvbTowO2hlaWdodDoyLjFlbTtmb250LXNpemU6MTNweH06aG9zdCguYnV0dG9uLXJvdW5kKXstLWJvcmRlci1yYWRpdXM6NjRweDstLXBhZGRpbmctdG9wOjA7LS1wYWRkaW5nLXN0YXJ0OjI2cHg7LS1wYWRkaW5nLWVuZDoyNnB4Oy0tcGFkZGluZy1ib3R0b206MH06aG9zdCguYnV0dG9uLXN0cm9uZyl7Zm9udC13ZWlnaHQ6NjAwfTpob3N0KC5idXR0b24tY2xlYXIuaW9uLWFjdGl2YXRlZCl7b3BhY2l0eTowLjR9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lLmlvbi1hY3RpdmF0ZWQuaW9uLWNvbG9yKSAuYnV0dG9uLW5hdGl2ZXtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5idXR0b24tb3V0bGluZS5pb24tYWN0aXZhdGVkLmlvbi1jb2xvcikgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfTpob3N0KC5idXR0b24tc29saWQuaW9uLWNvbG9yLmlvbi1hY3RpdmF0ZWQpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1zaGFkZSl9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lLmlvbi1mb2N1c2VkLmlvbi1jb2xvcikgLmJ1dHRvbi1uYXRpdmUsOmhvc3QoLmJ1dHRvbi1jbGVhci5pb24tZm9jdXNlZC5pb24tY29sb3IpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguYnV0dG9uLW91dGxpbmUuaW9uLWZvY3VzZWQuaW9uLWNvbG9yKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXIsOmhvc3QoLmJ1dHRvbi1jbGVhci5pb24tZm9jdXNlZC5pb24tY29sb3IpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguYnV0dG9uLXNvbGlkLmlvbi1jb2xvci5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLXNoYWRlKX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KC5idXR0b24tY2xlYXI6aG92ZXIpLDpob3N0KC5idXR0b24tb3V0bGluZTpob3Zlcil7b3BhY2l0eTowLjZ9Omhvc3QoLmJ1dHRvbi1jbGVhci5pb24tY29sb3I6aG92ZXIpIC5idXR0b24tbmF0aXZlLDpob3N0KC5idXR0b24tb3V0bGluZS5pb24tY29sb3I6aG92ZXIpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguYnV0dG9uLWNsZWFyLmlvbi1jb2xvcjpob3ZlcikgLmJ1dHRvbi1uYXRpdmU6OmFmdGVyLDpob3N0KC5idXR0b24tb3V0bGluZS5pb24tY29sb3I6aG92ZXIpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fTpob3N0KC5idXR0b24tc29saWQuaW9uLWNvbG9yOmhvdmVyKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItdGludCl9Omhvc3QoOmhvdmVyLmJ1dHRvbi1zb2xpZC5pbi10b29sYmFyOm5vdCguaW9uLWNvbG9yKTpub3QoLmluLXRvb2xiYXItY29sb3IpKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDojZmZmO29wYWNpdHk6MC4xfX1cIjtcblxuY29uc3QgYnV0dG9uTWRDc3MgPSBcIjpob3N0ey0tb3ZlcmZsb3c6aGlkZGVuOy0tcmlwcGxlLWNvbG9yOmN1cnJlbnRDb2xvcjstLWJvcmRlci13aWR0aDppbml0aWFsOy0tYm9yZGVyLWNvbG9yOmluaXRpYWw7LS1ib3JkZXItc3R5bGU6aW5pdGlhbDstLWNvbG9yLWFjdGl2YXRlZDp2YXIoLS1jb2xvcik7LS1jb2xvci1mb2N1c2VkOnZhcigtLWNvbG9yKTstLWNvbG9yLWhvdmVyOnZhcigtLWNvbG9yKTstLWJveC1zaGFkb3c6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDphdXRvO2NvbG9yOnZhcigtLWNvbG9yKTtmb250LWZhbWlseTp2YXIoLS1pb24tZm9udC1mYW1pbHksIGluaGVyaXQpO3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjp0b3A7dmVydGljYWwtYWxpZ246LXdlYmtpdC1iYXNlbGluZS1taWRkbGU7LXdlYmtpdC1mb250LWtlcm5pbmc6bm9uZTtmb250LWtlcm5pbmc6bm9uZX06aG9zdCguYnV0dG9uLWRpc2FibGVkKXtjdXJzb3I6ZGVmYXVsdDtvcGFjaXR5OjAuNTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0KC5idXR0b24tc29saWQpey0tYmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7LS1jb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeS1jb250cmFzdCwgI2ZmZil9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lKXstLWJvcmRlci1jb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7LS1iYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy0tY29sb3I6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpfTpob3N0KC5idXR0b24tY2xlYXIpey0tYm9yZGVyLXdpZHRoOjA7LS1iYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy0tY29sb3I6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpfTpob3N0KC5idXR0b24tYmxvY2spe2Rpc3BsYXk6YmxvY2t9Omhvc3QoLmJ1dHRvbi1ibG9jaykgLmJ1dHRvbi1uYXRpdmV7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aDtjb250YWluOmNvbnRlbnR9Omhvc3QoLmJ1dHRvbi1ibG9jaykgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2NsZWFyOmJvdGh9Omhvc3QoLmJ1dHRvbi1mdWxsKXtkaXNwbGF5OmJsb2NrfTpob3N0KC5idXR0b24tZnVsbCkgLmJ1dHRvbi1uYXRpdmV7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7Y29udGFpbjpjb250ZW50fTpob3N0KC5idXR0b24tZnVsbDpub3QoLmJ1dHRvbi1yb3VuZCkpIC5idXR0b24tbmF0aXZle2JvcmRlci1yYWRpdXM6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtib3JkZXItbGVmdC13aWR0aDowfS5idXR0b24tbmF0aXZle2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyLXJhZGl1cyk7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLXRvcDp2YXIoLS1wYWRkaW5nLXRvcCk7cGFkZGluZy1ib3R0b206dmFyKC0tcGFkZGluZy1ib3R0b20pO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXQ7bGV0dGVyLXNwYWNpbmc6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LWluZGVudDppbmhlcml0O3RleHQtb3ZlcmZsb3c6aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O3RleHQtYWxpZ246aW5oZXJpdDt3aGl0ZS1zcGFjZTppbmhlcml0O2NvbG9yOmluaGVyaXQ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlOy13ZWJraXQtdHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTt0cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO2JvcmRlci13aWR0aDp2YXIoLS1ib3JkZXItd2lkdGgpO2JvcmRlci1zdHlsZTp2YXIoLS1ib3JkZXItc3R5bGUpO2JvcmRlci1jb2xvcjp2YXIoLS1ib3JkZXItY29sb3IpO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2xpbmUtaGVpZ2h0OjE7LXdlYmtpdC1ib3gtc2hhZG93OnZhcigtLWJveC1zaGFkb3cpO2JveC1zaGFkb3c6dmFyKC0tYm94LXNoYWRvdyk7Y29udGFpbjpsYXlvdXQgc3R5bGU7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTp2YXIoLS1vcGFjaXR5KTtvdmVyZmxvdzp2YXIoLS1vdmVyZmxvdyk7ei1pbmRleDowOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZTthcHBlYXJhbmNlOm5vbmV9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuYnV0dG9uLW5hdGl2ZXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7LXdlYmtpdC1wYWRkaW5nLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLXBhZGRpbmctZW5kKX19LmJ1dHRvbi1uYXRpdmU6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9LmJ1dHRvbi1pbm5lcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1mbG93OnJvdyBub3dyYXA7ZmxleC1mbG93OnJvdyBub3dyYXA7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MX06OnNsb3R0ZWQoaW9uLWljb24pe2ZvbnQtc2l6ZToxLjRlbTtwb2ludGVyLWV2ZW50czpub25lfTo6c2xvdHRlZChpb24taWNvbltzbG90PXN0YXJ0XSl7bWFyZ2luLWxlZnQ6LTAuM2VtO21hcmdpbi1yaWdodDowLjNlbTttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9c3RhcnRdKXttYXJnaW4tbGVmdDp1bnNldDttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6LTAuM2VtO21hcmdpbi1pbmxpbmUtc3RhcnQ6LTAuM2VtOy13ZWJraXQtbWFyZ2luLWVuZDowLjNlbTttYXJnaW4taW5saW5lLWVuZDowLjNlbX19OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6MC4zZW07bWFyZ2luLXJpZ2h0Oi0wLjJlbTttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjAuM2VtO21hcmdpbi1pbmxpbmUtc3RhcnQ6MC4zZW07LXdlYmtpdC1tYXJnaW4tZW5kOi0wLjJlbTttYXJnaW4taW5saW5lLWVuZDotMC4yZW19fTo6c2xvdHRlZChpb24taWNvbltzbG90PWljb24tb25seV0pe2ZvbnQtc2l6ZToxLjhlbX1pb24tcmlwcGxlLWVmZmVjdHtjb2xvcjp2YXIoLS1yaXBwbGUtY29sb3IpfS5idXR0b24tbmF0aXZlOjphZnRlcntsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OlxcXCJcXFwiO29wYWNpdHk6MH06aG9zdCguaW9uLWFjdGl2YXRlZCl7Y29sb3I6dmFyKC0tY29sb3ItYWN0aXZhdGVkKX06aG9zdCguaW9uLWFjdGl2YXRlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1hY3RpdmF0ZWQpO29wYWNpdHk6dmFyKC0tYmFja2dyb3VuZC1hY3RpdmF0ZWQtb3BhY2l0eSl9Omhvc3QoLmlvbi1mb2N1c2VkKXtjb2xvcjp2YXIoLS1jb2xvci1mb2N1c2VkKX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtZm9jdXNlZCk7b3BhY2l0eTp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eSl9QG1lZGlhIChhbnktaG92ZXI6IGhvdmVyKXs6aG9zdCg6aG92ZXIpe2NvbG9yOnZhcigtLWNvbG9yLWhvdmVyKX06aG9zdCg6aG92ZXIpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtaG92ZXIpO29wYWNpdHk6dmFyKC0tYmFja2dyb3VuZC1ob3Zlci1vcGFjaXR5KX19Omhvc3QoLmJ1dHRvbi1zb2xpZC5pb24tY29sb3IpIC5idXR0b24tbmF0aXZle2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpO2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lLmlvbi1jb2xvcikgLmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLWNvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguYnV0dG9uLWNsZWFyLmlvbi1jb2xvcikgLmJ1dHRvbi1uYXRpdmV7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtjb2xvcjp2YXIoLS1pb24tY29sb3ItYmFzZSl9Omhvc3QoLmluLXRvb2xiYXI6bm90KC5pb24tY29sb3IpOm5vdCguaW4tdG9vbGJhci1jb2xvcikpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWlvbi10b29sYmFyLWNvbG9yLCB2YXIoLS1jb2xvcikpfTpob3N0KC5idXR0b24tb3V0bGluZS5pbi10b29sYmFyOm5vdCguaW9uLWNvbG9yKTpub3QoLmluLXRvb2xiYXItY29sb3IpKSAuYnV0dG9uLW5hdGl2ZXtib3JkZXItY29sb3I6dmFyKC0taW9uLXRvb2xiYXItY29sb3IsIHZhcigtLWNvbG9yLCB2YXIoLS1ib3JkZXItY29sb3IpKSl9Omhvc3QoLmJ1dHRvbi1zb2xpZC5pbi10b29sYmFyOm5vdCguaW9uLWNvbG9yKTpub3QoLmluLXRvb2xiYXItY29sb3IpKSAuYnV0dG9uLW5hdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWlvbi10b29sYmFyLWNvbG9yLCB2YXIoLS1iYWNrZ3JvdW5kKSk7Y29sb3I6dmFyKC0taW9uLXRvb2xiYXItYmFja2dyb3VuZCwgdmFyKC0tY29sb3IpKX06aG9zdHstLWJvcmRlci1yYWRpdXM6NHB4Oy0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjEuMWVtOy0tcGFkZGluZy1lbmQ6MS4xZW07LS10cmFuc2l0aW9uOmJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LCAwLCAuMiwgMSksXFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3IgMTVtcyBsaW5lYXIsXFxuICAgICAgICAgICAgICAgIGNvbG9yIDE1bXMgbGluZWFyO21hcmdpbi1sZWZ0OjJweDttYXJnaW4tcmlnaHQ6MnB4O21hcmdpbi10b3A6NHB4O21hcmdpbi1ib3R0b206NHB4O2hlaWdodDozNnB4O2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMDtsZXR0ZXItc3BhY2luZzowLjA2ZW07dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjJweDttYXJnaW4taW5saW5lLXN0YXJ0OjJweDstd2Via2l0LW1hcmdpbi1lbmQ6MnB4O21hcmdpbi1pbmxpbmUtZW5kOjJweH19Omhvc3QoLmJ1dHRvbi1zb2xpZCl7LS1iYWNrZ3JvdW5kLWFjdGl2YXRlZDp0cmFuc3BhcmVudDstLWJhY2tncm91bmQtaG92ZXI6dmFyKC0taW9uLWNvbG9yLXByaW1hcnktY29udHJhc3QsICNmZmYpOy0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LWNvbnRyYXN0LCAjZmZmKTstLWJhY2tncm91bmQtYWN0aXZhdGVkLW9wYWNpdHk6MDstLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5Oi4yNDstLWJhY2tncm91bmQtaG92ZXItb3BhY2l0eTouMDg7LS1ib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKX06aG9zdCguYnV0dG9uLXNvbGlkLmlvbi1hY3RpdmF0ZWQpey0tYm94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMil9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lKXstLWJvcmRlci13aWR0aDoycHg7LS1ib3JkZXItc3R5bGU6c29saWQ7LS1ib3gtc2hhZG93Om5vbmU7LS1iYWNrZ3JvdW5kLWFjdGl2YXRlZDp0cmFuc3BhcmVudDstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7LS1iYWNrZ3JvdW5kLWhvdmVyOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKTstLWJhY2tncm91bmQtYWN0aXZhdGVkLW9wYWNpdHk6MDstLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5Oi4xMjstLWJhY2tncm91bmQtaG92ZXItb3BhY2l0eTouMDR9Omhvc3QoLmJ1dHRvbi1vdXRsaW5lLmlvbi1hY3RpdmF0ZWQuaW9uLWNvbG9yKSAuYnV0dG9uLW5hdGl2ZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fTpob3N0KC5idXR0b24tY2xlYXIpey0tYmFja2dyb3VuZC1hY3RpdmF0ZWQ6dHJhbnNwYXJlbnQ7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpOy0tYmFja2dyb3VuZC1ob3Zlcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZik7LS1iYWNrZ3JvdW5kLWFjdGl2YXRlZC1vcGFjaXR5OjA7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eTouMTI7LS1iYWNrZ3JvdW5kLWhvdmVyLW9wYWNpdHk6LjA0fTpob3N0KC5idXR0b24tcm91bmQpey0tYm9yZGVyLXJhZGl1czo2NHB4Oy0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctc3RhcnQ6MjZweDstLXBhZGRpbmctZW5kOjI2cHg7LS1wYWRkaW5nLWJvdHRvbTowfTpob3N0KC5idXR0b24tbGFyZ2Upey0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctc3RhcnQ6MWVtOy0tcGFkZGluZy1lbmQ6MWVtOy0tcGFkZGluZy1ib3R0b206MDtoZWlnaHQ6Mi44ZW07Zm9udC1zaXplOjIwcHh9Omhvc3QoLmJ1dHRvbi1zbWFsbCl7LS1wYWRkaW5nLXRvcDowOy0tcGFkZGluZy1zdGFydDowLjllbTstLXBhZGRpbmctZW5kOjAuOWVtOy0tcGFkZGluZy1ib3R0b206MDtoZWlnaHQ6Mi4xZW07Zm9udC1zaXplOjEzcHh9Omhvc3QoLmJ1dHRvbi1zdHJvbmcpe2ZvbnQtd2VpZ2h0OmJvbGR9OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9aWNvbi1vbmx5XSl7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MH06aG9zdCguYnV0dG9uLXNvbGlkLmlvbi1jb2xvci5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguYnV0dG9uLWNsZWFyLmlvbi1jb2xvci5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVyLDpob3N0KC5idXR0b24tb3V0bGluZS5pb24tY29sb3IuaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KC5idXR0b24tc29saWQuaW9uLWNvbG9yOmhvdmVyKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5idXR0b24tY2xlYXIuaW9uLWNvbG9yOmhvdmVyKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXIsOmhvc3QoLmJ1dHRvbi1vdXRsaW5lLmlvbi1jb2xvcjpob3ZlcikgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfX1cIjtcblxuY29uc3QgQnV0dG9uID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmlvbkZvY3VzID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25Gb2N1c1wiLCA3KTtcbiAgICB0aGlzLmlvbkJsdXIgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbkJsdXJcIiwgNyk7XG4gICAgdGhpcy5pbkl0ZW0gPSBmYWxzZTtcbiAgICB0aGlzLmluTGlzdEhlYWRlciA9IGZhbHNlO1xuICAgIHRoaXMuaW5Ub29sYmFyID0gZmFsc2U7XG4gICAgdGhpcy5pbmhlcml0ZWRBdHRyaWJ1dGVzID0ge307XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgYnV0dG9uLlxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uVHlwZSA9ICdidXR0b24nO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBhIHJvdXRlciwgaXQgc3BlY2lmaWVzIHRoZSB0cmFuc2l0aW9uIGRpcmVjdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG9cbiAgICAgKiBhbm90aGVyIHBhZ2UgdXNpbmcgYGhyZWZgLlxuICAgICAqL1xuICAgIHRoaXMucm91dGVyRGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgYWN0aXZhdGVzIGEgYnV0dG9uIHdpdGggYSBoZWF2aWVyIGZvbnQgd2VpZ2h0LlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb25nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAnYnV0dG9uJztcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2KSA9PiB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSAnYnV0dG9uJykge1xuICAgICAgICBvcGVuVVJMKHRoaXMuaHJlZiwgZXYsIHRoaXMucm91dGVyRGlyZWN0aW9uLCB0aGlzLnJvdXRlckFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChoYXNTaGFkb3dEb20odGhpcy5lbCkpIHtcbiAgICAgICAgLy8gdGhpcyBidXR0b24gd2FudHMgdG8gc3BlY2lmaWNhbGx5IHN1Ym1pdCBhIGZvcm1cbiAgICAgICAgLy8gY2xpbWIgdXAgdGhlIGRvbSB0byBzZWUgaWYgd2UncmUgaW4gYSA8Zm9ybT5cbiAgICAgICAgLy8gYW5kIGlmIHNvLCB0aGVuIHVzZSBKUyB0byBzdWJtaXQgaXRcbiAgICAgICAgY29uc3QgZm9ybSA9IHRoaXMuZWwuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICBpZiAoZm9ybSkge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY29uc3QgZmFrZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgIGZha2VCdXR0b24udHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgICBmYWtlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChmYWtlQnV0dG9uKTtcbiAgICAgICAgICBmYWtlQnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgZmFrZUJ1dHRvbi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkZvY3VzID0gKCkgPT4ge1xuICAgICAgdGhpcy5pb25Gb2N1cy5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLm9uQmx1ciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaW9uQmx1ci5lbWl0KCk7XG4gICAgfTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLmluVG9vbGJhciA9ICEhdGhpcy5lbC5jbG9zZXN0KCdpb24tYnV0dG9ucycpO1xuICAgIHRoaXMuaW5MaXN0SGVhZGVyID0gISF0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1saXN0LWhlYWRlcicpO1xuICAgIHRoaXMuaW5JdGVtID0gISF0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1pdGVtJykgfHwgISF0aGlzLmVsLmNsb3Nlc3QoJ2lvbi1pdGVtLWRpdmlkZXInKTtcbiAgICB0aGlzLmluaGVyaXRlZEF0dHJpYnV0ZXMgPSBpbmhlcml0QXR0cmlidXRlcyh0aGlzLmVsLCBbJ2FyaWEtbGFiZWwnXSk7XG4gIH1cbiAgZ2V0IGhhc0ljb25Pbmx5KCkge1xuICAgIHJldHVybiAhIXRoaXMuZWwucXVlcnlTZWxlY3RvcignW3Nsb3Q9XCJpY29uLW9ubHlcIl0nKTtcbiAgfVxuICBnZXQgcmlwcGxlVHlwZSgpIHtcbiAgICBjb25zdCBoYXNDbGVhckZpbGwgPSB0aGlzLmZpbGwgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmZpbGwgPT09ICdjbGVhcic7XG4gICAgLy8gSWYgdGhlIGJ1dHRvbiBpcyBpbiBhIHRvb2xiYXIsIGhhcyBhIGNsZWFyIGZpbGwgKHdoaWNoIGlzIHRoZSBkZWZhdWx0KVxuICAgIC8vIGFuZCBvbmx5IGhhcyBhbiBpY29uIHdlIHVzZSB0aGUgdW5ib3VuZGVkIFwiY2lyY3VsYXJcIiByaXBwbGUgZWZmZWN0XG4gICAgaWYgKGhhc0NsZWFyRmlsbCAmJiB0aGlzLmhhc0ljb25Pbmx5ICYmIHRoaXMuaW5Ub29sYmFyKSB7XG4gICAgICByZXR1cm4gJ3VuYm91bmRlZCc7XG4gICAgfVxuICAgIHJldHVybiAnYm91bmRlZCc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIGNvbnN0IHsgYnV0dG9uVHlwZSwgdHlwZSwgZGlzYWJsZWQsIHJlbCwgdGFyZ2V0LCBzaXplLCBocmVmLCBjb2xvciwgZXhwYW5kLCBoYXNJY29uT25seSwgc2hhcGUsIHN0cm9uZywgaW5oZXJpdGVkQXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBjb25zdCBmaW5hbFNpemUgPSBzaXplID09PSB1bmRlZmluZWQgJiYgdGhpcy5pbkl0ZW0gPyAnc21hbGwnIDogc2l6ZTtcbiAgICBjb25zdCBUYWdUeXBlID0gaHJlZiA9PT0gdW5kZWZpbmVkID8gJ2J1dHRvbicgOiAnYSc7XG4gICAgY29uc3QgYXR0cnMgPSAoVGFnVHlwZSA9PT0gJ2J1dHRvbicpXG4gICAgICA/IHsgdHlwZSB9XG4gICAgICA6IHtcbiAgICAgICAgZG93bmxvYWQ6IHRoaXMuZG93bmxvYWQsXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHJlbCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9O1xuICAgIGxldCBmaWxsID0gdGhpcy5maWxsO1xuICAgIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbGwgPSB0aGlzLmluVG9vbGJhciB8fCB0aGlzLmluTGlzdEhlYWRlciA/ICdjbGVhcicgOiAnc29saWQnO1xuICAgIH1cbiAgICByZXR1cm4gKGgoSG9zdCwgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsLCBjbGFzczogY3JlYXRlQ29sb3JDbGFzc2VzKGNvbG9yLCB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgW2J1dHRvblR5cGVdOiB0cnVlLFxuICAgICAgICBbYCR7YnV0dG9uVHlwZX0tJHtleHBhbmR9YF06IGV4cGFuZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBbYCR7YnV0dG9uVHlwZX0tJHtmaW5hbFNpemV9YF06IGZpbmFsU2l6ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBbYCR7YnV0dG9uVHlwZX0tJHtzaGFwZX1gXTogc2hhcGUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgW2Ake2J1dHRvblR5cGV9LSR7ZmlsbH1gXTogdHJ1ZSxcbiAgICAgICAgW2Ake2J1dHRvblR5cGV9LXN0cm9uZ2BdOiBzdHJvbmcsXG4gICAgICAgICdpbi10b29sYmFyJzogaG9zdENvbnRleHQoJ2lvbi10b29sYmFyJywgdGhpcy5lbCksXG4gICAgICAgICdpbi10b29sYmFyLWNvbG9yJzogaG9zdENvbnRleHQoJ2lvbi10b29sYmFyW2NvbG9yXScsIHRoaXMuZWwpLFxuICAgICAgICAnYnV0dG9uLWhhcy1pY29uLW9ubHknOiBoYXNJY29uT25seSxcbiAgICAgICAgJ2J1dHRvbi1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAnaW9uLWFjdGl2YXRhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2lvbi1mb2N1c2FibGUnOiB0cnVlLFxuICAgICAgfSkgfSwgaChUYWdUeXBlLCBPYmplY3QuYXNzaWduKHt9LCBhdHRycywgeyBjbGFzczogXCJidXR0b24tbmF0aXZlXCIsIHBhcnQ6IFwibmF0aXZlXCIsIGRpc2FibGVkOiBkaXNhYmxlZCwgb25Gb2N1czogdGhpcy5vbkZvY3VzLCBvbkJsdXI6IHRoaXMub25CbHVyIH0sIGluaGVyaXRlZEF0dHJpYnV0ZXMpLCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImJ1dHRvbi1pbm5lclwiIH0sIGgoXCJzbG90XCIsIHsgbmFtZTogXCJpY29uLW9ubHlcIiB9KSwgaChcInNsb3RcIiwgeyBuYW1lOiBcInN0YXJ0XCIgfSksIGgoXCJzbG90XCIsIG51bGwpLCBoKFwic2xvdFwiLCB7IG5hbWU6IFwiZW5kXCIgfSkpLCBtb2RlID09PSAnbWQnICYmIGgoXCJpb24tcmlwcGxlLWVmZmVjdFwiLCB7IHR5cGU6IHRoaXMucmlwcGxlVHlwZSB9KSkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBidXR0b25Jb3NDc3MsXG4gICAgbWQ6IGJ1dHRvbk1kQ3NzXG4gIH07IH1cbn0sIFszMywgXCJpb24tYnV0dG9uXCIsIHtcbiAgICBcImNvbG9yXCI6IFs1MTNdLFxuICAgIFwiYnV0dG9uVHlwZVwiOiBbMTAyNSwgXCJidXR0b24tdHlwZVwiXSxcbiAgICBcImRpc2FibGVkXCI6IFs1MTZdLFxuICAgIFwiZXhwYW5kXCI6IFs1MTNdLFxuICAgIFwiZmlsbFwiOiBbMTUzN10sXG4gICAgXCJyb3V0ZXJEaXJlY3Rpb25cIjogWzEsIFwicm91dGVyLWRpcmVjdGlvblwiXSxcbiAgICBcInJvdXRlckFuaW1hdGlvblwiOiBbMTZdLFxuICAgIFwiZG93bmxvYWRcIjogWzFdLFxuICAgIFwiaHJlZlwiOiBbMV0sXG4gICAgXCJyZWxcIjogWzFdLFxuICAgIFwic2hhcGVcIjogWzUxM10sXG4gICAgXCJzaXplXCI6IFs1MTNdLFxuICAgIFwic3Ryb25nXCI6IFs0XSxcbiAgICBcInRhcmdldFwiOiBbMV0sXG4gICAgXCJ0eXBlXCI6IFsxXVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tYnV0dG9uXCIsIFwiaW9uLXJpcHBsZS1lZmZlY3RcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1idXR0b25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBCdXR0b24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlvbi1yaXBwbGUtZWZmZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDEoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5leHBvcnQgeyBCdXR0b24gYXMgQiwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgQiBhcyBCdXR0b24sIGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxIH0gZnJvbSAnLi9idXR0b24uanMnO1xuXG5jb25zdCBJb25CdXR0b24gPSBCdXR0b247XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25CdXR0b24sIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgbyBhcyBvcGVuVVJMLCBjIGFzIGNyZWF0ZUNvbG9yQ2xhc3NlcyB9IGZyb20gJy4vdGhlbWUuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDIgfSBmcm9tICcuL3JpcHBsZS1lZmZlY3QuanMnO1xuXG5jb25zdCBjYXJkSW9zQ3NzID0gXCI6aG9zdHstLWlvbi1zYWZlLWFyZWEtbGVmdDowcHg7LS1pb24tc2FmZS1hcmVhLXJpZ2h0OjBweDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7b3ZlcmZsb3c6aGlkZGVufTpob3N0KC5pb24tY29sb3Ipe2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpO2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmNhcmQtZGlzYWJsZWQpe2N1cnNvcjpkZWZhdWx0O29wYWNpdHk6MC4zO3BvaW50ZXItZXZlbnRzOm5vbmV9LmNhcmQtbmF0aXZle2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXQ7bGV0dGVyLXNwYWNpbmc6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LWluZGVudDppbmhlcml0O3RleHQtb3ZlcmZsb3c6aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O3RleHQtYWxpZ246aW5oZXJpdDt3aGl0ZS1zcGFjZTppbmhlcml0O2NvbG9yOmluaGVyaXQ7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO21pbi1oZWlnaHQ6dmFyKC0tbWluLWhlaWdodCk7LXdlYmtpdC10cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO3RyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7Ym9yZGVyLXdpZHRoOnZhcigtLWJvcmRlci13aWR0aCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWJvcmRlci1jb2xvcik7b3V0bGluZTpub25lO2JhY2tncm91bmQ6aW5oZXJpdH0uY2FyZC1uYXRpdmU6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjB9YnV0dG9uLGF7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lOy13ZWJraXQtdXNlci1kcmFnOm5vbmV9aW9uLXJpcHBsZS1lZmZlY3R7Y29sb3I6dmFyKC0tcmlwcGxlLWNvbG9yKX06aG9zdHstLWJhY2tncm91bmQ6dmFyKC0taW9uLWNhcmQtYmFja2dyb3VuZCwgdmFyKC0taW9uLWl0ZW0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKSk7LS1jb2xvcjp2YXIoLS1pb24tY2FyZC1jb2xvciwgdmFyKC0taW9uLWl0ZW0tY29sb3IsIHZhcigtLWlvbi1jb2xvci1zdGVwLTYwMCwgIzY2NjY2NikpKTttYXJnaW4tbGVmdDoxNnB4O21hcmdpbi1yaWdodDoxNnB4O21hcmdpbi10b3A6MjRweDttYXJnaW4tYm90dG9tOjI0cHg7Ym9yZGVyLXJhZGl1czo4cHg7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gNTAwbXMgY3ViaWMtYmV6aWVyKDAuMTIsIDAuNzIsIDAuMjksIDEpO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gNTAwbXMgY3ViaWMtYmV6aWVyKDAuMTIsIDAuNzIsIDAuMjksIDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwMG1zIGN1YmljLWJlemllcigwLjEyLCAwLjcyLCAwLjI5LCAxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSA1MDBtcyBjdWJpYy1iZXppZXIoMC4xMiwgMC43MiwgMC4yOSwgMSksIC13ZWJraXQtdHJhbnNmb3JtIDUwMG1zIGN1YmljLWJlemllcigwLjEyLCAwLjcyLCAwLjI5LCAxKTtmb250LXNpemU6MTRweDstd2Via2l0LWJveC1zaGFkb3c6MCA0cHggMTZweCByZ2JhKDAsIDAsIDAsIDAuMTIpO2JveC1zaGFkb3c6MCA0cHggMTZweCByZ2JhKDAsIDAsIDAsIDAuMTIpfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjE2cHg7bWFyZ2luLWlubGluZS1zdGFydDoxNnB4Oy13ZWJraXQtbWFyZ2luLWVuZDoxNnB4O21hcmdpbi1pbmxpbmUtZW5kOjE2cHh9fTpob3N0KC5pb24tYWN0aXZhdGVkKXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDAuOTcsIDAuOTcsIDEpO3RyYW5zZm9ybTpzY2FsZTNkKDAuOTcsIDAuOTcsIDEpfVwiO1xuXG5jb25zdCBjYXJkTWRDc3MgPSBcIjpob3N0ey0taW9uLXNhZmUtYXJlYS1sZWZ0OjBweDstLWlvbi1zYWZlLWFyZWEtcmlnaHQ6MHB4Oy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcik7Zm9udC1mYW1pbHk6dmFyKC0taW9uLWZvbnQtZmFtaWx5LCBpbmhlcml0KTtvdmVyZmxvdzpoaWRkZW59Omhvc3QoLmlvbi1jb2xvcil7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItYmFzZSk7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguY2FyZC1kaXNhYmxlZCl7Y3Vyc29yOmRlZmF1bHQ7b3BhY2l0eTowLjM7cG9pbnRlci1ldmVudHM6bm9uZX0uY2FyZC1uYXRpdmV7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7bWluLWhlaWdodDp2YXIoLS1taW4taGVpZ2h0KTstd2Via2l0LXRyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7dHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTtib3JkZXItd2lkdGg6dmFyKC0tYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDppbmhlcml0fS5jYXJkLW5hdGl2ZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH1idXR0b24sYXtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX1pb24tcmlwcGxlLWVmZmVjdHtjb2xvcjp2YXIoLS1yaXBwbGUtY29sb3IpfTpob3N0ey0tYmFja2dyb3VuZDp2YXIoLS1pb24tY2FyZC1iYWNrZ3JvdW5kLCB2YXIoLS1pb24taXRlbS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpKTstLWNvbG9yOnZhcigtLWlvbi1jYXJkLWNvbG9yLCB2YXIoLS1pb24taXRlbS1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtNTUwLCAjNzM3MzczKSkpO21hcmdpbi1sZWZ0OjEwcHg7bWFyZ2luLXJpZ2h0OjEwcHg7bWFyZ2luLXRvcDoxMHB4O21hcmdpbi1ib3R0b206MTBweDtib3JkZXItcmFkaXVzOjRweDtmb250LXNpemU6MTRweDstd2Via2l0LWJveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDJweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDJweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjEwcHg7bWFyZ2luLWlubGluZS1zdGFydDoxMHB4Oy13ZWJraXQtbWFyZ2luLWVuZDoxMHB4O21hcmdpbi1pbmxpbmUtZW5kOjEwcHh9fVwiO1xuXG5jb25zdCBDYXJkID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGEgYnV0dG9uIHRhZyB3aWxsIGJlIHJlbmRlcmVkIGFuZCB0aGUgY2FyZCB3aWxsIGJlIHRhcHBhYmxlLlxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGJ1dHRvbi4gT25seSB1c2VkIHdoZW4gYW4gYG9uY2xpY2tgIG9yIGBidXR0b25gIHByb3BlcnR5IGlzIHByZXNlbnQuXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gJ2J1dHRvbic7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGUgY2FyZC5cbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyBhIHJvdXRlciwgaXQgc3BlY2lmaWVzIHRoZSB0cmFuc2l0aW9uIGRpcmVjdGlvbiB3aGVuIG5hdmlnYXRpbmcgdG9cbiAgICAgKiBhbm90aGVyIHBhZ2UgdXNpbmcgYGhyZWZgLlxuICAgICAqL1xuICAgIHRoaXMucm91dGVyRGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuICB9XG4gIGlzQ2xpY2thYmxlKCkge1xuICAgIHJldHVybiAodGhpcy5ocmVmICE9PSB1bmRlZmluZWQgfHwgdGhpcy5idXR0b24pO1xuICB9XG4gIHJlbmRlckNhcmQobW9kZSkge1xuICAgIGNvbnN0IGNsaWNrYWJsZSA9IHRoaXMuaXNDbGlja2FibGUoKTtcbiAgICBpZiAoIWNsaWNrYWJsZSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaChcInNsb3RcIiwgbnVsbClcbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHsgaHJlZiwgcm91dGVyQW5pbWF0aW9uLCByb3V0ZXJEaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgVGFnVHlwZSA9IGNsaWNrYWJsZSA/IChocmVmID09PSB1bmRlZmluZWQgPyAnYnV0dG9uJyA6ICdhJykgOiAnZGl2JztcbiAgICBjb25zdCBhdHRycyA9IChUYWdUeXBlID09PSAnYnV0dG9uJylcbiAgICAgID8geyB0eXBlOiB0aGlzLnR5cGUgfVxuICAgICAgOiB7XG4gICAgICAgIGRvd25sb2FkOiB0aGlzLmRvd25sb2FkLFxuICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgIHJlbDogdGhpcy5yZWwsXG4gICAgICAgIHRhcmdldDogdGhpcy50YXJnZXRcbiAgICAgIH07XG4gICAgcmV0dXJuIChoKFRhZ1R5cGUsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJzLCB7IGNsYXNzOiBcImNhcmQtbmF0aXZlXCIsIHBhcnQ6IFwibmF0aXZlXCIsIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLCBvbkNsaWNrOiAoZXYpID0+IG9wZW5VUkwoaHJlZiwgZXYsIHJvdXRlckRpcmVjdGlvbiwgcm91dGVyQW5pbWF0aW9uKSB9KSwgaChcInNsb3RcIiwgbnVsbCksIGNsaWNrYWJsZSAmJiBtb2RlID09PSAnbWQnICYmIGgoXCJpb24tcmlwcGxlLWVmZmVjdFwiLCBudWxsKSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICAnY2FyZC1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICdpb24tYWN0aXZhdGFibGUnOiB0aGlzLmlzQ2xpY2thYmxlKClcbiAgICAgIH0pIH0sIHRoaXMucmVuZGVyQ2FyZChtb2RlKSkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiBjYXJkSW9zQ3NzLFxuICAgIG1kOiBjYXJkTWRDc3NcbiAgfTsgfVxufSwgWzMzLCBcImlvbi1jYXJkXCIsIHtcbiAgICBcImNvbG9yXCI6IFs1MTNdLFxuICAgIFwiYnV0dG9uXCI6IFs0XSxcbiAgICBcInR5cGVcIjogWzFdLFxuICAgIFwiZGlzYWJsZWRcIjogWzRdLFxuICAgIFwiZG93bmxvYWRcIjogWzFdLFxuICAgIFwiaHJlZlwiOiBbMV0sXG4gICAgXCJyZWxcIjogWzFdLFxuICAgIFwicm91dGVyRGlyZWN0aW9uXCI6IFsxLCBcInJvdXRlci1kaXJlY3Rpb25cIl0sXG4gICAgXCJyb3V0ZXJBbmltYXRpb25cIjogWzE2XSxcbiAgICBcInRhcmdldFwiOiBbMV1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tY2FyZFwiLCBcImlvbi1yaXBwbGUtZWZmZWN0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tY2FyZFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIENhcmQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlvbi1yaXBwbGUtZWZmZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDIoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25DYXJkID0gQ2FyZDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkNhcmQsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG4vKiBJb25pY29ucyB2Ni4wLjAsIEVTIE1vZHVsZXMgKi9cbmNvbnN0IGFycm93QmFja1NoYXJwID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+QXJyb3cgQmFjazwvdGl0bGU+PHBhdGggc3Ryb2tlLWxpbmVjYXA9J3NxdWFyZScgc3Ryb2tlLW1pdGVybGltaXQ9JzEwJyBzdHJva2Utd2lkdGg9JzQ4JyBkPSdNMjQ0IDQwMEwxMDAgMjU2bDE0NC0xNDRNMTIwIDI1NmgyOTInIGNsYXNzPSdpb25pY29uLWZpbGwtbm9uZScvPjwvc3ZnPlwiO1xuY29uc3QgYXJyb3dEb3duID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+QXJyb3cgRG93bjwvdGl0bGU+PHBhdGggc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJyBzdHJva2Utd2lkdGg9JzQ4JyBkPSdNMTEyIDI2OGwxNDQgMTQ0IDE0NC0xNDRNMjU2IDM5MlYxMDAnIGNsYXNzPSdpb25pY29uLWZpbGwtbm9uZScvPjwvc3ZnPlwiO1xuY29uc3QgY2FyZXRCYWNrU2hhcnAgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5DYXJldCBCYWNrPC90aXRsZT48cGF0aCBkPSdNMzY4IDY0TDE0NCAyNTZsMjI0IDE5MlY2NHonLz48L3N2Zz5cIjtcbmNvbnN0IGNhcmV0RG93blNoYXJwID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+Q2FyZXQgRG93bjwvdGl0bGU+PHBhdGggZD0nTTY0IDE0NGwxOTIgMjI0IDE5Mi0yMjRINjR6Jy8+PC9zdmc+XCI7XG5jb25zdCBjYXJldFVwU2hhcnAgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5DYXJldCBVcDwvdGl0bGU+PHBhdGggZD0nTTQ0OCAzNjhMMjU2IDE0NCA2NCAzNjhoMzg0eicvPjwvc3ZnPlwiO1xuY29uc3QgY2hldnJvbkJhY2sgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5DaGV2cm9uIEJhY2s8L3RpdGxlPjxwYXRoIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCcgc3Ryb2tlLXdpZHRoPSc0OCcgZD0nTTMyOCAxMTJMMTg0IDI1NmwxNDQgMTQ0JyBjbGFzcz0naW9uaWNvbi1maWxsLW5vbmUnLz48L3N2Zz5cIjtcbmNvbnN0IGNoZXZyb25Eb3duID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+Q2hldnJvbiBEb3duPC90aXRsZT48cGF0aCBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnIHN0cm9rZS13aWR0aD0nNDgnIGQ9J00xMTIgMTg0bDE0NCAxNDQgMTQ0LTE0NCcgY2xhc3M9J2lvbmljb24tZmlsbC1ub25lJy8+PC9zdmc+XCI7XG5jb25zdCBjaGV2cm9uRm9yd2FyZCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIGNsYXNzPSdpb25pY29uJyB2aWV3Qm94PScwIDAgNTEyIDUxMic+PHRpdGxlPkNoZXZyb24gRm9yd2FyZDwvdGl0bGU+PHBhdGggc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJyBzdHJva2Utd2lkdGg9JzQ4JyBkPSdNMTg0IDExMmwxNDQgMTQ0LTE0NCAxNDQnIGNsYXNzPSdpb25pY29uLWZpbGwtbm9uZScvPjwvc3ZnPlwiO1xuY29uc3QgY2hldnJvbkZvcndhcmRPdXRsaW5lID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+Q2hldnJvbiBGb3J3YXJkPC90aXRsZT48cGF0aCBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnIHN0cm9rZS13aWR0aD0nNDgnIGQ9J00xODQgMTEybDE0NCAxNDQtMTQ0IDE0NCcgY2xhc3M9J2lvbmljb24tZmlsbC1ub25lJy8+PC9zdmc+XCI7XG5jb25zdCBjbG9zZSA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIGNsYXNzPSdpb25pY29uJyB2aWV3Qm94PScwIDAgNTEyIDUxMic+PHRpdGxlPkNsb3NlPC90aXRsZT48cGF0aCBkPSdNMjg5Ljk0IDI1Nmw5NS05NUEyNCAyNCAwIDAwMzUxIDEyN2wtOTUgOTUtOTUtOTVhMjQgMjQgMCAwMC0zNCAzNGw5NSA5NS05NSA5NWEyNCAyNCAwIDEwMzQgMzRsOTUtOTUgOTUgOTVhMjQgMjQgMCAwMDM0LTM0eicvPjwvc3ZnPlwiO1xuY29uc3QgY2xvc2VDaXJjbGUgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5DbG9zZSBDaXJjbGU8L3RpdGxlPjxwYXRoIGQ9J00yNTYgNDhDMTQxLjMxIDQ4IDQ4IDE0MS4zMSA0OCAyNTZzOTMuMzEgMjA4IDIwOCAyMDggMjA4LTkzLjMxIDIwOC0yMDhTMzcwLjY5IDQ4IDI1NiA0OHptNzUuMzEgMjYwLjY5YTE2IDE2IDAgMTEtMjIuNjIgMjIuNjJMMjU2IDI3OC42M2wtNTIuNjkgNTIuNjhhMTYgMTYgMCAwMS0yMi42Mi0yMi42MkwyMzMuMzcgMjU2bC01Mi42OC01Mi42OWExNiAxNiAwIDAxMjIuNjItMjIuNjJMMjU2IDIzMy4zN2w1Mi42OS01Mi42OGExNiAxNiAwIDAxMjIuNjIgMjIuNjJMMjc4LjYzIDI1NnonLz48L3N2Zz5cIjtcbmNvbnN0IGNsb3NlU2hhcnAgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5DbG9zZTwvdGl0bGU+PHBhdGggZD0nTTQwMCAxNDUuNDlMMzY2LjUxIDExMiAyNTYgMjIyLjUxIDE0NS40OSAxMTIgMTEyIDE0NS40OSAyMjIuNTEgMjU2IDExMiAzNjYuNTEgMTQ1LjQ5IDQwMCAyNTYgMjg5LjQ5IDM2Ni41MSA0MDAgNDAwIDM2Ni41MSAyODkuNDkgMjU2IDQwMCAxNDUuNDl6Jy8+PC9zdmc+XCI7XG5jb25zdCBlbGxpcHNpc0hvcml6b250YWwgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5FbGxpcHNpcyBIb3Jpem9udGFsPC90aXRsZT48Y2lyY2xlIGN4PScyNTYnIGN5PScyNTYnIHI9JzQ4Jy8+PGNpcmNsZSBjeD0nNDE2JyBjeT0nMjU2JyByPSc0OCcvPjxjaXJjbGUgY3g9Jzk2JyBjeT0nMjU2JyByPSc0OCcvPjwvc3ZnPlwiO1xuY29uc3QgbWVudU91dGxpbmUgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5NZW51PC90aXRsZT48cGF0aCBzdHJva2UtbGluZWNhcD0ncm91bmQnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgZD0nTTgwIDE2MGgzNTJNODAgMjU2aDM1Mk04MCAzNTJoMzUyJyBjbGFzcz0naW9uaWNvbi1maWxsLW5vbmUgaW9uaWNvbi1zdHJva2Utd2lkdGgnLz48L3N2Zz5cIjtcbmNvbnN0IG1lbnVTaGFycCA9IFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIGNsYXNzPSdpb25pY29uJyB2aWV3Qm94PScwIDAgNTEyIDUxMic+PHRpdGxlPk1lbnU8L3RpdGxlPjxwYXRoIGQ9J002NCAzODRoMzg0di00Mi42N0g2NHptMC0xMDYuNjdoMzg0di00Mi42Nkg2NHpNNjQgMTI4djQyLjY3aDM4NFYxMjh6Jy8+PC9zdmc+XCI7XG5jb25zdCByZW9yZGVyVGhyZWVPdXRsaW5lID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+UmVvcmRlciBUaHJlZTwvdGl0bGU+PHBhdGggc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbGluZWpvaW49J3JvdW5kJyBkPSdNOTYgMjU2aDMyME05NiAxNzZoMzIwTTk2IDMzNmgzMjAnIGNsYXNzPSdpb25pY29uLWZpbGwtbm9uZSBpb25pY29uLXN0cm9rZS13aWR0aCcvPjwvc3ZnPlwiO1xuY29uc3QgcmVvcmRlclR3b1NoYXJwID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+UmVvcmRlciBUd288L3RpdGxlPjxwYXRoIHN0cm9rZS1saW5lY2FwPSdzcXVhcmUnIHN0cm9rZS1saW5lam9pbj0ncm91bmQnIHN0cm9rZS13aWR0aD0nNDQnIGQ9J00xMTggMzA0aDI3Nk0xMTggMjA4aDI3NicgY2xhc3M9J2lvbmljb24tZmlsbC1ub25lJy8+PC9zdmc+XCI7XG5jb25zdCBzZWFyY2hPdXRsaW5lID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgY2xhc3M9J2lvbmljb24nIHZpZXdCb3g9JzAgMCA1MTIgNTEyJz48dGl0bGU+U2VhcmNoPC90aXRsZT48cGF0aCBkPSdNMjIxLjA5IDY0YTE1Ny4wOSAxNTcuMDkgMCAxMDE1Ny4wOSAxNTcuMDlBMTU3LjEgMTU3LjEgMCAwMDIyMS4wOSA2NHonIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgY2xhc3M9J2lvbmljb24tZmlsbC1ub25lIGlvbmljb24tc3Ryb2tlLXdpZHRoJy8+PHBhdGggc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBzdHJva2UtbWl0ZXJsaW1pdD0nMTAnIGQ9J00zMzguMjkgMzM4LjI5TDQ0OCA0NDgnIGNsYXNzPSdpb25pY29uLWZpbGwtbm9uZSBpb25pY29uLXN0cm9rZS13aWR0aCcvPjwvc3ZnPlwiO1xuY29uc3Qgc2VhcmNoU2hhcnAgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naW9uaWNvbicgdmlld0JveD0nMCAwIDUxMiA1MTInPjx0aXRsZT5TZWFyY2g8L3RpdGxlPjxwYXRoIGQ9J000NjQgNDI4TDMzOS45MiAzMDMuOWExNjAuNDggMTYwLjQ4IDAgMDAzMC43Mi05NC41OEMzNzAuNjQgMTIwLjM3IDI5OC4yNyA0OCAyMDkuMzIgNDhTNDggMTIwLjM3IDQ4IDIwOS4zMnM3Mi4zNyAxNjEuMzIgMTYxLjMyIDE2MS4zMmExNjAuNDggMTYwLjQ4IDAgMDA5NC41OC0zMC43Mkw0MjggNDY0ek0yMDkuMzIgMzE5LjY5YTExMC4zOCAxMTAuMzggMCAxMTExMC4zNy0xMTAuMzcgMTEwLjUgMTEwLjUgMCAwMS0xMTAuMzcgMTEwLjM3eicvPjwvc3ZnPlwiO1xuXG5leHBvcnQgeyBjaGV2cm9uQmFjayBhcyBhLCBhcnJvd0JhY2tTaGFycCBhcyBiLCBjaGV2cm9uRG93biBhcyBjLCBjaGV2cm9uRm9yd2FyZE91dGxpbmUgYXMgZCwgZWxsaXBzaXNIb3Jpem9udGFsIGFzIGUsIGNoZXZyb25Gb3J3YXJkIGFzIGYsIGNhcmV0VXBTaGFycCBhcyBnLCBjYXJldERvd25TaGFycCBhcyBoLCBjbG9zZSBhcyBpLCBtZW51U2hhcnAgYXMgaiwgY2FyZXRCYWNrU2hhcnAgYXMgaywgYXJyb3dEb3duIGFzIGwsIG1lbnVPdXRsaW5lIGFzIG0sIHJlb3JkZXJUd29TaGFycCBhcyBuLCBjbG9zZUNpcmNsZSBhcyBvLCBjbG9zZVNoYXJwIGFzIHAsIHNlYXJjaFNoYXJwIGFzIHEsIHJlb3JkZXJUaHJlZU91dGxpbmUgYXMgciwgc2VhcmNoT3V0bGluZSBhcyBzIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgZm9yY2VVcGRhdGUsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBmIGFzIGNoZXZyb25Gb3J3YXJkIH0gZnJvbSAnLi9pbmRleDYuanMnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgciBhcyByYWYgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVDb2xvckNsYXNzZXMsIGggYXMgaG9zdENvbnRleHQsIG8gYXMgb3BlblVSTCB9IGZyb20gJy4vdGhlbWUuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDMgfSBmcm9tICcuL2ljb24uanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDIgfSBmcm9tICcuL25vdGUuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICcuL3JpcHBsZS1lZmZlY3QuanMnO1xuXG5jb25zdCBpdGVtSW9zQ3NzID0gXCI6aG9zdHstLWJvcmRlci1yYWRpdXM6MHB4Oy0tYm9yZGVyLXdpZHRoOjBweDstLWJvcmRlci1zdHlsZTpzb2xpZDstLXBhZGRpbmctdG9wOjBweDstLXBhZGRpbmctYm90dG9tOjBweDstLXBhZGRpbmctZW5kOjBweDstLXBhZGRpbmctc3RhcnQ6MHB4Oy0taW5uZXItYm9yZGVyLXdpZHRoOjBweDstLWlubmVyLXBhZGRpbmctdG9wOjBweDstLWlubmVyLXBhZGRpbmctYm90dG9tOjBweDstLWlubmVyLXBhZGRpbmctc3RhcnQ6MHB4Oy0taW5uZXItcGFkZGluZy1lbmQ6MHB4Oy0taW5uZXItYm94LXNoYWRvdzpub25lOy0tc2hvdy1mdWxsLWhpZ2hsaWdodDowOy0tc2hvdy1pbnNldC1oaWdobGlnaHQ6MDstLWRldGFpbC1pY29uLWNvbG9yOmluaXRpYWw7LS1kZXRhaWwtaWNvbi1mb250LXNpemU6MjBweDstLWRldGFpbC1pY29uLW9wYWNpdHk6MC4yNTstLWNvbG9yLWFjdGl2YXRlZDp2YXIoLS1jb2xvcik7LS1jb2xvci1mb2N1c2VkOnZhcigtLWNvbG9yKTstLWNvbG9yLWhvdmVyOnZhcigtLWNvbG9yKTstLXJpcHBsZS1jb2xvcjpjdXJyZW50Q29sb3I7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtvdXRsaW5lOm5vbmU7Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7dGV4dC1hbGlnbjppbml0aWFsO3RleHQtZGVjb3JhdGlvbjpub25lO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9Omhvc3QoLmlvbi1jb2xvcjpub3QoLml0ZW0tZmlsbC1zb2xpZCk6bm90KC5pdGVtLWZpbGwtb3V0bGluZSkpIC5pdGVtLW5hdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKTtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3I6bm90KC5pdGVtLWZpbGwtc29saWQpOm5vdCguaXRlbS1maWxsLW91dGxpbmUpKSAuaXRlbS1uYXRpdmUsOmhvc3QoLmlvbi1jb2xvcjpub3QoLml0ZW0tZmlsbC1zb2xpZCk6bm90KC5pdGVtLWZpbGwtb3V0bGluZSkpIC5pdGVtLWlubmVye2JvcmRlci1jb2xvcjp2YXIoLS1pb24tY29sb3Itc2hhZGUpfTpob3N0KC5pb24tYWN0aXZhdGVkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0tY29sb3ItYWN0aXZhdGVkKX06aG9zdCguaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtYWN0aXZhdGVkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtYWN0aXZhdGVkLW9wYWNpdHkpfTpob3N0KC5pb24tY29sb3IuaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0tY29sb3ItZm9jdXNlZCl9Omhvc3QoLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX06aG9zdCguaW9uLWNvbG9yLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KC5pb24tYWN0aXZhdGFibGU6bm90KC5pb24tZm9jdXNlZCk6aG92ZXIpIC5pdGVtLW5hdGl2ZXtjb2xvcjp2YXIoLS1jb2xvci1ob3Zlcil9Omhvc3QoLmlvbi1hY3RpdmF0YWJsZTpub3QoLmlvbi1mb2N1c2VkKTpob3ZlcikgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtaG92ZXIpO29wYWNpdHk6dmFyKC0tYmFja2dyb3VuZC1ob3Zlci1vcGFjaXR5KX06aG9zdCguaW9uLWNvbG9yLmlvbi1hY3RpdmF0YWJsZTpub3QoLmlvbi1mb2N1c2VkKTpob3ZlcikgLml0ZW0tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1jb2xvci5pb24tYWN0aXZhdGFibGU6bm90KC5pb24tZm9jdXNlZCk6aG92ZXIpIC5pdGVtLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfX06aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS1kaXNhYmxlZDpub3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSl7Y3Vyc29yOmRlZmF1bHQ7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdCguaXRlbS1kaXNhYmxlZCl7Y3Vyc29yOmRlZmF1bHQ7b3BhY2l0eTowLjM7cG9pbnRlci1ldmVudHM6bm9uZX0uaXRlbS1uYXRpdmV7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctcmlnaHQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOnZhcigtLXBhZGRpbmctdG9wKTtwYWRkaW5nLWJvdHRvbTp2YXIoLS1wYWRkaW5nLWJvdHRvbSk7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtcGFjazppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O3dpZHRoOjEwMCU7bWluLWhlaWdodDp2YXIoLS1taW4taGVpZ2h0KTstd2Via2l0LXRyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7dHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTtib3JkZXItd2lkdGg6dmFyKC0tYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtvdmVyZmxvdzppbmhlcml0Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDt6LWluZGV4OjF9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1uYXRpdmV7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctaW5saW5lLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCl9fS5pdGVtLW5hdGl2ZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uaXRlbS1uYXRpdmU6OmFmdGVye2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTt0cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO3otaW5kZXg6LTF9YnV0dG9uLGF7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lOy13ZWJraXQtdXNlci1kcmFnOm5vbmV9Lml0ZW0taW5uZXJ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLXJpZ2h0OmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSk7cGFkZGluZy10b3A6dmFyKC0taW5uZXItcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLWlubmVyLXBhZGRpbmctYm90dG9tKTtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1pdGVtLWFsaWduOnN0cmV0Y2g7YWxpZ24tc2VsZjpzdHJldGNoO21pbi1oZWlnaHQ6aW5oZXJpdDtib3JkZXItd2lkdGg6dmFyKC0taW5uZXItYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTstd2Via2l0LWJveC1zaGFkb3c6dmFyKC0taW5uZXItYm94LXNoYWRvdyk7Ym94LXNoYWRvdzp2YXIoLS1pbm5lci1ib3gtc2hhZG93KTtvdmVyZmxvdzppbmhlcml0Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5pdGVtLWlubmVye3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSk7cGFkZGluZy1pbmxpbmUtZW5kOmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSl9fS5pdGVtLWJvdHRvbXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctcmlnaHQ6dmFyKC0taW5uZXItcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1ib3R0b217cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctaW5saW5lLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW5uZXItcGFkZGluZy1lbmQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1pbm5lci1wYWRkaW5nLWVuZCl9fS5pdGVtLWRldGFpbC1pY29ue2NvbG9yOnZhcigtLWRldGFpbC1pY29uLWNvbG9yKTtmb250LXNpemU6dmFyKC0tZGV0YWlsLWljb24tZm9udC1zaXplKTtvcGFjaXR5OnZhcigtLWRldGFpbC1pY29uLW9wYWNpdHkpfTo6c2xvdHRlZChpb24taWNvbil7Zm9udC1zaXplOjEuNmVtfTo6c2xvdHRlZChpb24tYnV0dG9uKXstLW1hcmdpbi10b3A6MDstLW1hcmdpbi1ib3R0b206MDstLW1hcmdpbi1zdGFydDowOy0tbWFyZ2luLWVuZDowO3otaW5kZXg6MX06OnNsb3R0ZWQoaW9uLWxhYmVsOm5vdChbc2xvdD1lbmRdKSl7LW1zLWZsZXg6MTtmbGV4OjF9Omhvc3QoLml0ZW0taW5wdXQpey1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmlucHV0LXdyYXBwZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtaXRlbS1hbGlnbjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmluaGVyaXQ7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKXstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpzdGFydH06aG9zdCguaXRlbS1sYWJlbC1zdGFja2VkKSAuaW5wdXQtd3JhcHBlciw6aG9zdCguaXRlbS1sYWJlbC1mbG9hdGluZykgLmlucHV0LXdyYXBwZXJ7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Lml0ZW0taGlnaGxpZ2h0LC5pdGVtLWlubmVyLWhpZ2hsaWdodHtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtib3JkZXItcmFkaXVzOmluaGVyaXQ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoMCk7dHJhbnNmb3JtOnNjYWxlWCgwKTstd2Via2l0LXRyYW5zaXRpb246Ym9yZGVyLWJvdHRvbS13aWR0aCAyMDBtcywgLXdlYmtpdC10cmFuc2Zvcm0gMjAwbXM7dHJhbnNpdGlvbjpib3JkZXItYm90dG9tLXdpZHRoIDIwMG1zLCAtd2Via2l0LXRyYW5zZm9ybSAyMDBtczt0cmFuc2l0aW9uOnRyYW5zZm9ybSAyMDBtcywgYm9yZGVyLWJvdHRvbS13aWR0aCAyMDBtczt0cmFuc2l0aW9uOnRyYW5zZm9ybSAyMDBtcywgYm9yZGVyLWJvdHRvbS13aWR0aCAyMDBtcywgLXdlYmtpdC10cmFuc2Zvcm0gMjAwbXM7ei1pbmRleDoyOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb2ludGVyLWV2ZW50czpub25lfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1uYXRpdmV7Y2FyZXQtY29sb3I6dmFyKC0taGlnaGxpZ2h0LWJhY2tncm91bmQpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1c2VkKSw6aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cyksOmhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLXRvdWNoZWQuaW9uLWludmFsaWQpey0tZnVsbC1oaWdobGlnaHQtaGVpZ2h0OmNhbGModmFyKC0taGlnaGxpZ2h0LWhlaWdodCkgKiB2YXIoLS1zaG93LWZ1bGwtaGlnaGxpZ2h0KSk7LS1pbnNldC1oaWdobGlnaHQtaGVpZ2h0OmNhbGModmFyKC0taGlnaGxpZ2h0LWhlaWdodCkgKiB2YXIoLS1zaG93LWluc2V0LWhpZ2hsaWdodCkpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1c2VkKSw6aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cyl7LS1oaWdobGlnaHQtYmFja2dyb3VuZDp2YXIoLS1oaWdobGlnaHQtY29sb3ItZm9jdXNlZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLXZhbGlkKXstLWhpZ2hsaWdodC1iYWNrZ3JvdW5kOnZhcigtLWhpZ2hsaWdodC1jb2xvci12YWxpZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLWludmFsaWQpey0taGlnaGxpZ2h0LWJhY2tncm91bmQ6dmFyKC0taGlnaGxpZ2h0LWNvbG9yLWludmFsaWQpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1pbnZhbGlkKSA6OnNsb3R0ZWQoW3Nsb3Q9aGVscGVyXSl7ZGlzcGxheTpub25lfTo6c2xvdHRlZChbc2xvdD1lcnJvcl0pe2Rpc3BsYXk6bm9uZTtjb2xvcjp2YXIoLS1oaWdobGlnaHQtY29sb3ItaW52YWxpZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLWludmFsaWQpIDo6c2xvdHRlZChbc2xvdD1lcnJvcl0pe2Rpc3BsYXk6YmxvY2t9Omhvc3QoOm5vdCguaXRlbS1sYWJlbCkpIDo6c2xvdHRlZChpb24tc2VsZWN0KXstLXBhZGRpbmctc3RhcnQ6MDttYXgtd2lkdGg6bm9uZX06aG9zdCguaXRlbS1sYWJlbC1zdGFja2VkKSA6OnNsb3R0ZWQoaW9uLXNlbGVjdCksOmhvc3QoLml0ZW0tbGFiZWwtZmxvYXRpbmcpIDo6c2xvdHRlZChpb24tc2VsZWN0KXstLXBhZGRpbmctdG9wOjhweDstLXBhZGRpbmctYm90dG9tOjhweDstLXBhZGRpbmctc3RhcnQ6MDstbXMtZmxleC1pdGVtLWFsaWduOnN0cmV0Y2g7YWxpZ24tc2VsZjpzdHJldGNoO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCV9Omhvc3QoOm5vdCguaXRlbS1sYWJlbCkpIDo6c2xvdHRlZChpb24tZGF0ZXRpbWUpey0tcGFkZGluZy1zdGFydDowfTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpIDo6c2xvdHRlZChpb24tZGF0ZXRpbWUpLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKSA6OnNsb3R0ZWQoaW9uLWRhdGV0aW1lKXstLXBhZGRpbmctc3RhcnQ6MDt3aWR0aDoxMDAlfTpob3N0KC5pdGVtLW11bHRpcGxlLWlucHV0cykgOjpzbG90dGVkKGlvbi1jaGVja2JveCksOmhvc3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSA6OnNsb3R0ZWQoaW9uLWRhdGV0aW1lKSw6aG9zdCguaXRlbS1tdWx0aXBsZS1pbnB1dHMpIDo6c2xvdHRlZChpb24tcmFkaW8pLDpob3N0KC5pdGVtLW11bHRpcGxlLWlucHV0cykgOjpzbG90dGVkKGlvbi1zZWxlY3Qpe3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0KC5pdGVtLXRleHRhcmVhKXstbXMtZmxleC1hbGlnbjpzdHJldGNoO2FsaWduLWl0ZW1zOnN0cmV0Y2h9OjpzbG90dGVkKGlvbi1yZW9yZGVyW3Nsb3RdKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfWlvbi1yaXBwbGUtZWZmZWN0e2NvbG9yOnZhcigtLXJpcHBsZS1jb2xvcil9Omhvc3QoLml0ZW0tZmlsbC1zb2xpZCkgOjpzbG90dGVkKFtzbG90PXN0YXJ0XSksOmhvc3QoLml0ZW0tZmlsbC1zb2xpZCkgOjpzbG90dGVkKFtzbG90PWVuZF0pLDpob3N0KC5pdGVtLWZpbGwtb3V0bGluZSkgOjpzbG90dGVkKFtzbG90PXN0YXJ0XSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSA6OnNsb3R0ZWQoW3Nsb3Q9ZW5kXSl7LW1zLWZsZXgtaXRlbS1hbGlnbjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXJ9OjpzbG90dGVkKFtzbG90PWhlbHBlcl0pLDo6c2xvdHRlZChbc2xvdD1lcnJvcl0pLC5pdGVtLWNvdW50ZXJ7cGFkZGluZy10b3A6NXB4O2ZvbnQtc2l6ZToxMnB4O3otaW5kZXg6MX0uaXRlbS1jb3VudGVye21hcmdpbi1sZWZ0OmF1dG87LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDt3aGl0ZS1zcGFjZTpub3dyYXB9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1jb3VudGVye21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OmF1dG87bWFyZ2luLWlubGluZS1zdGFydDphdXRvfX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7Lml0ZW0taGlnaGxpZ2h0LC5pdGVtLWlubmVyLWhpZ2hsaWdodHstd2Via2l0LXRyYW5zaXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmV9fTpob3N0ey0tbWluLWhlaWdodDo0NHB4Oy0tdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDIwMG1zIGxpbmVhciwgb3BhY2l0eSAyMDBtcyBsaW5lYXI7LS1wYWRkaW5nLXN0YXJ0OjIwcHg7LS1pbm5lci1wYWRkaW5nLWVuZDoxMHB4Oy0taW5uZXItYm9yZGVyLXdpZHRoOjBweCAwcHggMC41NXB4IDBweDstLWJhY2tncm91bmQ6dmFyKC0taW9uLWl0ZW0tYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKTstLWJhY2tncm91bmQtYWN0aXZhdGVkOiMwMDA7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6IzAwMDstLWJhY2tncm91bmQtaG92ZXI6Y3VycmVudENvbG9yOy0tYmFja2dyb3VuZC1hY3RpdmF0ZWQtb3BhY2l0eTouMTI7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eTouMTU7LS1iYWNrZ3JvdW5kLWhvdmVyLW9wYWNpdHk6LjA0Oy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1pdGVtLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMjUwLCAjYzhjN2NjKSkpOy0tY29sb3I6dmFyKC0taW9uLWl0ZW0tY29sb3IsIHZhcigtLWlvbi10ZXh0LWNvbG9yLCAjMDAwKSk7LS1oaWdobGlnaHQtaGVpZ2h0OjBweDstLWhpZ2hsaWdodC1jb2xvci1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKTstLWhpZ2hsaWdodC1jb2xvci12YWxpZDp2YXIoLS1pb24tY29sb3Itc3VjY2VzcywgIzJkZDM2Zik7LS1oaWdobGlnaHQtY29sb3ItaW52YWxpZDp2YXIoLS1pb24tY29sb3ItZGFuZ2VyLCAjZWI0NDVhKTstLWJvdHRvbS1wYWRkaW5nLXN0YXJ0OjBweDtmb250LXNpemU6MTdweH06aG9zdCguaW9uLWFjdGl2YXRlZCl7LS10cmFuc2l0aW9uOm5vbmV9Omhvc3QoLmlvbi1jb2xvci5pb24tZm9jdXNlZCkgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOiMwMDA7b3BhY2l0eTowLjE1fTpob3N0KC5pb24tY29sb3IuaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOiMwMDA7b3BhY2l0eTowLjEyfTpob3N0KC5pdGVtLWludGVyYWN0aXZlKXstLXNob3ctZnVsbC1oaWdobGlnaHQ6MDstLXNob3ctaW5zZXQtaGlnaGxpZ2h0OjF9Omhvc3QoLml0ZW0tbGluZXMtZnVsbCl7LS1ib3JkZXItd2lkdGg6MHB4IDBweCAwLjU1cHggMHB4Oy0tc2hvdy1mdWxsLWhpZ2hsaWdodDoxOy0tc2hvdy1pbnNldC1oaWdobGlnaHQ6MH06aG9zdCguaXRlbS1saW5lcy1pbnNldCl7LS1pbm5lci1ib3JkZXItd2lkdGg6MHB4IDBweCAwLjU1cHggMHB4Oy0tc2hvdy1mdWxsLWhpZ2hsaWdodDowOy0tc2hvdy1pbnNldC1oaWdobGlnaHQ6MX06aG9zdCguaXRlbS1saW5lcy1pbnNldCksOmhvc3QoLml0ZW0tbGluZXMtbm9uZSl7LS1ib3JkZXItd2lkdGg6MHB4Oy0tc2hvdy1mdWxsLWhpZ2hsaWdodDowfTpob3N0KC5pdGVtLWxpbmVzLWZ1bGwpLDpob3N0KC5pdGVtLWxpbmVzLW5vbmUpey0taW5uZXItYm9yZGVyLXdpZHRoOjBweDstLXNob3ctaW5zZXQtaGlnaGxpZ2h0OjB9Lml0ZW0taGlnaGxpZ2h0LC5pdGVtLWlubmVyLWhpZ2hsaWdodHstd2Via2l0LXRyYW5zaXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmV9Omhvc3QoLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1pbm5lci1oaWdobGlnaHQsOmhvc3QoLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1oaWdobGlnaHR7Ym9yZGVyLXRvcDpub25lO2JvcmRlci1yaWdodDpub25lO2JvcmRlci1sZWZ0Om5vbmV9OjpzbG90dGVkKFtzbG90PXN0YXJ0XSl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MjBweDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChbc2xvdD1zdGFydF0pe21hcmdpbi1sZWZ0OnVuc2V0O21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDowO21hcmdpbi1pbmxpbmUtc3RhcnQ6MDstd2Via2l0LW1hcmdpbi1lbmQ6MjBweDttYXJnaW4taW5saW5lLWVuZDoyMHB4fX06OnNsb3R0ZWQoW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6MTBweDttYXJnaW4tcmlnaHQ6MTBweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChbc2xvdD1lbmRdKXttYXJnaW4tbGVmdDp1bnNldDttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tc3RhcnQ6MTBweDttYXJnaW4taW5saW5lLXN0YXJ0OjEwcHg7LXdlYmtpdC1tYXJnaW4tZW5kOjEwcHg7bWFyZ2luLWlubGluZS1lbmQ6MTBweH19OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9c3RhcnRdKSw6OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1lbmRdKXttYXJnaW4tdG9wOjdweDttYXJnaW4tYm90dG9tOjdweH06OnNsb3R0ZWQoaW9uLXRvZ2dsZVtzbG90PXN0YXJ0XSksOjpzbG90dGVkKGlvbi10b2dnbGVbc2xvdD1lbmRdKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9Omhvc3QoLml0ZW0tbGFiZWwtc3RhY2tlZCkgOjpzbG90dGVkKFtzbG90PWVuZF0pLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKSA6OnNsb3R0ZWQoW3Nsb3Q9ZW5kXSl7bWFyZ2luLXRvcDo3cHg7bWFyZ2luLWJvdHRvbTo3cHh9OjpzbG90dGVkKC5idXR0b24tc21hbGwpey0tcGFkZGluZy10b3A6MHB4Oy0tcGFkZGluZy1ib3R0b206MHB4Oy0tcGFkZGluZy1zdGFydDouNWVtOy0tcGFkZGluZy1lbmQ6LjVlbTtoZWlnaHQ6MjRweDtmb250LXNpemU6MTNweH06OnNsb3R0ZWQoaW9uLWF2YXRhcil7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH06OnNsb3R0ZWQoaW9uLXRodW1ibmFpbCl7d2lkdGg6NTZweDtoZWlnaHQ6NTZweH06OnNsb3R0ZWQoaW9uLWF2YXRhcltzbG90PWVuZF0pLDo6c2xvdHRlZChpb24tdGh1bWJuYWlsW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6MTBweDttYXJnaW4tcmlnaHQ6MTBweDttYXJnaW4tdG9wOjEwcHg7bWFyZ2luLWJvdHRvbToxMHB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKGlvbi1hdmF0YXJbc2xvdD1lbmRdKSw6OnNsb3R0ZWQoaW9uLXRodW1ibmFpbFtzbG90PWVuZF0pe21hcmdpbi1sZWZ0OnVuc2V0O21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDoxMHB4O21hcmdpbi1pbmxpbmUtc3RhcnQ6MTBweDstd2Via2l0LW1hcmdpbi1lbmQ6MTBweDttYXJnaW4taW5saW5lLWVuZDoxMHB4fX06aG9zdCguaXRlbS1yYWRpbykgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLml0ZW0tdG9nZ2xlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tbGVmdDowcHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdCguaXRlbS1yYWRpbykgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLml0ZW0tdG9nZ2xlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tbGVmdDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDowcHg7bWFyZ2luLWlubGluZS1zdGFydDowcHh9fTo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjhweDttYXJnaW4tdG9wOjEwcHg7bWFyZ2luLWJvdHRvbToxMHB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLWxlZnQ6dW5zZXQ7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjA7bWFyZ2luLWlubGluZS1zdGFydDowOy13ZWJraXQtbWFyZ2luLWVuZDo4cHg7bWFyZ2luLWlubGluZS1lbmQ6OHB4fX06aG9zdCguaXRlbS1sYWJlbC1mbG9hdGluZyksOmhvc3QoLml0ZW0tbGFiZWwtc3RhY2tlZCl7LS1taW4taGVpZ2h0OjY4cHh9Omhvc3QoLml0ZW0tbGFiZWwtc3RhY2tlZCkgOjpzbG90dGVkKGlvbi1zZWxlY3QpLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKSA6OnNsb3R0ZWQoaW9uLXNlbGVjdCl7LS1wYWRkaW5nLXRvcDo4cHg7LS1wYWRkaW5nLWJvdHRvbTo4cHg7LS1wYWRkaW5nLXN0YXJ0OjBweH06aG9zdCguaXRlbS1sYWJlbC1maXhlZCkgOjpzbG90dGVkKGlvbi1zZWxlY3QpLDpob3N0KC5pdGVtLWxhYmVsLWZpeGVkKSA6OnNsb3R0ZWQoaW9uLWRhdGV0aW1lKXstLXBhZGRpbmctc3RhcnQ6MH1cIjtcblxuY29uc3QgaXRlbU1kQ3NzID0gXCI6aG9zdHstLWJvcmRlci1yYWRpdXM6MHB4Oy0tYm9yZGVyLXdpZHRoOjBweDstLWJvcmRlci1zdHlsZTpzb2xpZDstLXBhZGRpbmctdG9wOjBweDstLXBhZGRpbmctYm90dG9tOjBweDstLXBhZGRpbmctZW5kOjBweDstLXBhZGRpbmctc3RhcnQ6MHB4Oy0taW5uZXItYm9yZGVyLXdpZHRoOjBweDstLWlubmVyLXBhZGRpbmctdG9wOjBweDstLWlubmVyLXBhZGRpbmctYm90dG9tOjBweDstLWlubmVyLXBhZGRpbmctc3RhcnQ6MHB4Oy0taW5uZXItcGFkZGluZy1lbmQ6MHB4Oy0taW5uZXItYm94LXNoYWRvdzpub25lOy0tc2hvdy1mdWxsLWhpZ2hsaWdodDowOy0tc2hvdy1pbnNldC1oaWdobGlnaHQ6MDstLWRldGFpbC1pY29uLWNvbG9yOmluaXRpYWw7LS1kZXRhaWwtaWNvbi1mb250LXNpemU6MjBweDstLWRldGFpbC1pY29uLW9wYWNpdHk6MC4yNTstLWNvbG9yLWFjdGl2YXRlZDp2YXIoLS1jb2xvcik7LS1jb2xvci1mb2N1c2VkOnZhcigtLWNvbG9yKTstLWNvbG9yLWhvdmVyOnZhcigtLWNvbG9yKTstLXJpcHBsZS1jb2xvcjpjdXJyZW50Q29sb3I7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6anVzdGlmeTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtvdXRsaW5lOm5vbmU7Y29sb3I6dmFyKC0tY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWlvbi1mb250LWZhbWlseSwgaW5oZXJpdCk7dGV4dC1hbGlnbjppbml0aWFsO3RleHQtZGVjb3JhdGlvbjpub25lO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9Omhvc3QoLmlvbi1jb2xvcjpub3QoLml0ZW0tZmlsbC1zb2xpZCk6bm90KC5pdGVtLWZpbGwtb3V0bGluZSkpIC5pdGVtLW5hdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKTtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3I6bm90KC5pdGVtLWZpbGwtc29saWQpOm5vdCguaXRlbS1maWxsLW91dGxpbmUpKSAuaXRlbS1uYXRpdmUsOmhvc3QoLmlvbi1jb2xvcjpub3QoLml0ZW0tZmlsbC1zb2xpZCk6bm90KC5pdGVtLWZpbGwtb3V0bGluZSkpIC5pdGVtLWlubmVye2JvcmRlci1jb2xvcjp2YXIoLS1pb24tY29sb3Itc2hhZGUpfTpob3N0KC5pb24tYWN0aXZhdGVkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0tY29sb3ItYWN0aXZhdGVkKX06aG9zdCguaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtYWN0aXZhdGVkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtYWN0aXZhdGVkLW9wYWNpdHkpfTpob3N0KC5pb24tY29sb3IuaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0tY29sb3ItZm9jdXNlZCl9Omhvc3QoLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX06aG9zdCguaW9uLWNvbG9yLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmV7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KC5pb24tYWN0aXZhdGFibGU6bm90KC5pb24tZm9jdXNlZCk6aG92ZXIpIC5pdGVtLW5hdGl2ZXtjb2xvcjp2YXIoLS1jb2xvci1ob3Zlcil9Omhvc3QoLmlvbi1hY3RpdmF0YWJsZTpub3QoLmlvbi1mb2N1c2VkKTpob3ZlcikgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtaG92ZXIpO29wYWNpdHk6dmFyKC0tYmFja2dyb3VuZC1ob3Zlci1vcGFjaXR5KX06aG9zdCguaW9uLWNvbG9yLmlvbi1hY3RpdmF0YWJsZTpub3QoLmlvbi1mb2N1c2VkKTpob3ZlcikgLml0ZW0tbmF0aXZle2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1jb2xvci5pb24tYWN0aXZhdGFibGU6bm90KC5pb24tZm9jdXNlZCk6aG92ZXIpIC5pdGVtLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfX06aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS1kaXNhYmxlZDpub3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSl7Y3Vyc29yOmRlZmF1bHQ7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdCguaXRlbS1kaXNhYmxlZCl7Y3Vyc29yOmRlZmF1bHQ7b3BhY2l0eTowLjM7cG9pbnRlci1ldmVudHM6bm9uZX0uaXRlbS1uYXRpdmV7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctcmlnaHQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOnZhcigtLXBhZGRpbmctdG9wKTtwYWRkaW5nLWJvdHRvbTp2YXIoLS1wYWRkaW5nLWJvdHRvbSk7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtcGFjazppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O3dpZHRoOjEwMCU7bWluLWhlaWdodDp2YXIoLS1taW4taGVpZ2h0KTstd2Via2l0LXRyYW5zaXRpb246dmFyKC0tdHJhbnNpdGlvbik7dHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTtib3JkZXItd2lkdGg6dmFyKC0tYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtvdmVyZmxvdzppbmhlcml0Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDt6LWluZGV4OjF9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1uYXRpdmV7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctaW5saW5lLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCl9fS5pdGVtLW5hdGl2ZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uaXRlbS1uYXRpdmU6OmFmdGVye2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjp2YXIoLS10cmFuc2l0aW9uKTt0cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO3otaW5kZXg6LTF9YnV0dG9uLGF7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lOy13ZWJraXQtdXNlci1kcmFnOm5vbmV9Lml0ZW0taW5uZXJ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLXJpZ2h0OmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSk7cGFkZGluZy10b3A6dmFyKC0taW5uZXItcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLWlubmVyLXBhZGRpbmctYm90dG9tKTtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1pdGVtLWFsaWduOnN0cmV0Y2g7YWxpZ24tc2VsZjpzdHJldGNoO21pbi1oZWlnaHQ6aW5oZXJpdDtib3JkZXItd2lkdGg6dmFyKC0taW5uZXItYm9yZGVyLXdpZHRoKTtib3JkZXItc3R5bGU6dmFyKC0tYm9yZGVyLXN0eWxlKTtib3JkZXItY29sb3I6dmFyKC0tYm9yZGVyLWNvbG9yKTstd2Via2l0LWJveC1zaGFkb3c6dmFyKC0taW5uZXItYm94LXNoYWRvdyk7Ym94LXNoYWRvdzp2YXIoLS1pbm5lci1ib3gtc2hhZG93KTtvdmVyZmxvdzppbmhlcml0Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5pdGVtLWlubmVye3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pbm5lci1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSk7cGFkZGluZy1pbmxpbmUtZW5kOmNhbGModmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCwgMHB4KSArIHZhcigtLWlubmVyLXBhZGRpbmctZW5kKSl9fS5pdGVtLWJvdHRvbXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctcmlnaHQ6dmFyKC0taW5uZXItcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1wYWNrOmp1c3RpZnk7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1ib3R0b217cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpO3BhZGRpbmctaW5saW5lLXN0YXJ0OmNhbGModmFyKC0tcGFkZGluZy1zdGFydCkgKyB2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQsIDBweCkpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW5uZXItcGFkZGluZy1lbmQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1pbm5lci1wYWRkaW5nLWVuZCl9fS5pdGVtLWRldGFpbC1pY29ue2NvbG9yOnZhcigtLWRldGFpbC1pY29uLWNvbG9yKTtmb250LXNpemU6dmFyKC0tZGV0YWlsLWljb24tZm9udC1zaXplKTtvcGFjaXR5OnZhcigtLWRldGFpbC1pY29uLW9wYWNpdHkpfTo6c2xvdHRlZChpb24taWNvbil7Zm9udC1zaXplOjEuNmVtfTo6c2xvdHRlZChpb24tYnV0dG9uKXstLW1hcmdpbi10b3A6MDstLW1hcmdpbi1ib3R0b206MDstLW1hcmdpbi1zdGFydDowOy0tbWFyZ2luLWVuZDowO3otaW5kZXg6MX06OnNsb3R0ZWQoaW9uLWxhYmVsOm5vdChbc2xvdD1lbmRdKSl7LW1zLWZsZXg6MTtmbGV4OjF9Omhvc3QoLml0ZW0taW5wdXQpey1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmlucHV0LXdyYXBwZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtaXRlbS1hbGlnbjpzdHJldGNoO2FsaWduLXNlbGY6c3RyZXRjaDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmluaGVyaXQ7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKXstbXMtZmxleC1hbGlnbjpzdGFydDthbGlnbi1pdGVtczpzdGFydH06aG9zdCguaXRlbS1sYWJlbC1zdGFja2VkKSAuaW5wdXQtd3JhcHBlciw6aG9zdCguaXRlbS1sYWJlbC1mbG9hdGluZykgLmlucHV0LXdyYXBwZXJ7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Lml0ZW0taGlnaGxpZ2h0LC5pdGVtLWlubmVyLWhpZ2hsaWdodHtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtib3JkZXItcmFkaXVzOmluaGVyaXQ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoMCk7dHJhbnNmb3JtOnNjYWxlWCgwKTstd2Via2l0LXRyYW5zaXRpb246Ym9yZGVyLWJvdHRvbS13aWR0aCAyMDBtcywgLXdlYmtpdC10cmFuc2Zvcm0gMjAwbXM7dHJhbnNpdGlvbjpib3JkZXItYm90dG9tLXdpZHRoIDIwMG1zLCAtd2Via2l0LXRyYW5zZm9ybSAyMDBtczt0cmFuc2l0aW9uOnRyYW5zZm9ybSAyMDBtcywgYm9yZGVyLWJvdHRvbS13aWR0aCAyMDBtczt0cmFuc2l0aW9uOnRyYW5zZm9ybSAyMDBtcywgYm9yZGVyLWJvdHRvbS13aWR0aCAyMDBtcywgLXdlYmtpdC10cmFuc2Zvcm0gMjAwbXM7ei1pbmRleDoyOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb2ludGVyLWV2ZW50czpub25lfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1uYXRpdmV7Y2FyZXQtY29sb3I6dmFyKC0taGlnaGxpZ2h0LWJhY2tncm91bmQpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1c2VkKSw6aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cyksOmhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLXRvdWNoZWQuaW9uLWludmFsaWQpey0tZnVsbC1oaWdobGlnaHQtaGVpZ2h0OmNhbGModmFyKC0taGlnaGxpZ2h0LWhlaWdodCkgKiB2YXIoLS1zaG93LWZ1bGwtaGlnaGxpZ2h0KSk7LS1pbnNldC1oaWdobGlnaHQtaGVpZ2h0OmNhbGModmFyKC0taGlnaGxpZ2h0LWhlaWdodCkgKiB2YXIoLS1zaG93LWluc2V0LWhpZ2hsaWdodCkpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1c2VkKSw6aG9zdCguaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cyl7LS1oaWdobGlnaHQtYmFja2dyb3VuZDp2YXIoLS1oaWdobGlnaHQtY29sb3ItZm9jdXNlZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLXZhbGlkKXstLWhpZ2hsaWdodC1iYWNrZ3JvdW5kOnZhcigtLWhpZ2hsaWdodC1jb2xvci12YWxpZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLWludmFsaWQpey0taGlnaGxpZ2h0LWJhY2tncm91bmQ6dmFyKC0taGlnaGxpZ2h0LWNvbG9yLWludmFsaWQpfTpob3N0KC5pdGVtLWludGVyYWN0aXZlLmlvbi1pbnZhbGlkKSA6OnNsb3R0ZWQoW3Nsb3Q9aGVscGVyXSl7ZGlzcGxheTpub25lfTo6c2xvdHRlZChbc2xvdD1lcnJvcl0pe2Rpc3BsYXk6bm9uZTtjb2xvcjp2YXIoLS1oaWdobGlnaHQtY29sb3ItaW52YWxpZCl9Omhvc3QoLml0ZW0taW50ZXJhY3RpdmUuaW9uLWludmFsaWQpIDo6c2xvdHRlZChbc2xvdD1lcnJvcl0pe2Rpc3BsYXk6YmxvY2t9Omhvc3QoOm5vdCguaXRlbS1sYWJlbCkpIDo6c2xvdHRlZChpb24tc2VsZWN0KXstLXBhZGRpbmctc3RhcnQ6MDttYXgtd2lkdGg6bm9uZX06aG9zdCguaXRlbS1sYWJlbC1zdGFja2VkKSA6OnNsb3R0ZWQoaW9uLXNlbGVjdCksOmhvc3QoLml0ZW0tbGFiZWwtZmxvYXRpbmcpIDo6c2xvdHRlZChpb24tc2VsZWN0KXstLXBhZGRpbmctdG9wOjhweDstLXBhZGRpbmctYm90dG9tOjhweDstLXBhZGRpbmctc3RhcnQ6MDstbXMtZmxleC1pdGVtLWFsaWduOnN0cmV0Y2g7YWxpZ24tc2VsZjpzdHJldGNoO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCV9Omhvc3QoOm5vdCguaXRlbS1sYWJlbCkpIDo6c2xvdHRlZChpb24tZGF0ZXRpbWUpey0tcGFkZGluZy1zdGFydDowfTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpIDo6c2xvdHRlZChpb24tZGF0ZXRpbWUpLDpob3N0KC5pdGVtLWxhYmVsLWZsb2F0aW5nKSA6OnNsb3R0ZWQoaW9uLWRhdGV0aW1lKXstLXBhZGRpbmctc3RhcnQ6MDt3aWR0aDoxMDAlfTpob3N0KC5pdGVtLW11bHRpcGxlLWlucHV0cykgOjpzbG90dGVkKGlvbi1jaGVja2JveCksOmhvc3QoLml0ZW0tbXVsdGlwbGUtaW5wdXRzKSA6OnNsb3R0ZWQoaW9uLWRhdGV0aW1lKSw6aG9zdCguaXRlbS1tdWx0aXBsZS1pbnB1dHMpIDo6c2xvdHRlZChpb24tcmFkaW8pLDpob3N0KC5pdGVtLW11bHRpcGxlLWlucHV0cykgOjpzbG90dGVkKGlvbi1zZWxlY3Qpe3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0KC5pdGVtLXRleHRhcmVhKXstbXMtZmxleC1hbGlnbjpzdHJldGNoO2FsaWduLWl0ZW1zOnN0cmV0Y2h9OjpzbG90dGVkKGlvbi1yZW9yZGVyW3Nsb3RdKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfWlvbi1yaXBwbGUtZWZmZWN0e2NvbG9yOnZhcigtLXJpcHBsZS1jb2xvcil9Omhvc3QoLml0ZW0tZmlsbC1zb2xpZCkgOjpzbG90dGVkKFtzbG90PXN0YXJ0XSksOmhvc3QoLml0ZW0tZmlsbC1zb2xpZCkgOjpzbG90dGVkKFtzbG90PWVuZF0pLDpob3N0KC5pdGVtLWZpbGwtb3V0bGluZSkgOjpzbG90dGVkKFtzbG90PXN0YXJ0XSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSA6OnNsb3R0ZWQoW3Nsb3Q9ZW5kXSl7LW1zLWZsZXgtaXRlbS1hbGlnbjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXJ9OjpzbG90dGVkKFtzbG90PWhlbHBlcl0pLDo6c2xvdHRlZChbc2xvdD1lcnJvcl0pLC5pdGVtLWNvdW50ZXJ7cGFkZGluZy10b3A6NXB4O2ZvbnQtc2l6ZToxMnB4O3otaW5kZXg6MX0uaXRlbS1jb3VudGVye21hcmdpbi1sZWZ0OmF1dG87LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDt3aGl0ZS1zcGFjZTpub3dyYXB9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuaXRlbS1jb3VudGVye21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OmF1dG87bWFyZ2luLWlubGluZS1zdGFydDphdXRvfX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7Lml0ZW0taGlnaGxpZ2h0LC5pdGVtLWlubmVyLWhpZ2hsaWdodHstd2Via2l0LXRyYW5zaXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmV9fTpob3N0ey0tbWluLWhlaWdodDo0OHB4Oy0tYmFja2dyb3VuZDp2YXIoLS1pb24taXRlbS1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpOy0tYmFja2dyb3VuZC1hY3RpdmF0ZWQ6dHJhbnNwYXJlbnQ7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6Y3VycmVudENvbG9yOy0tYmFja2dyb3VuZC1ob3ZlcjpjdXJyZW50Q29sb3I7LS1iYWNrZ3JvdW5kLWFjdGl2YXRlZC1vcGFjaXR5OjA7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eTouMTI7LS1iYWNrZ3JvdW5kLWhvdmVyLW9wYWNpdHk6LjA0Oy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1pdGVtLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCByZ2JhKDAsIDAsIDAsIDAuMTMpKSkpOy0tY29sb3I6dmFyKC0taW9uLWl0ZW0tY29sb3IsIHZhcigtLWlvbi10ZXh0LWNvbG9yLCAjMDAwKSk7LS10cmFuc2l0aW9uOm9wYWNpdHkgMTVtcyBsaW5lYXIsIGJhY2tncm91bmQtY29sb3IgMTVtcyBsaW5lYXI7LS1wYWRkaW5nLXN0YXJ0OjE2cHg7LS1pbm5lci1wYWRkaW5nLWVuZDoxNnB4Oy0taW5uZXItYm9yZGVyLXdpZHRoOjAgMCAxcHggMDstLWhpZ2hsaWdodC1oZWlnaHQ6MXB4Oy0taGlnaGxpZ2h0LWNvbG9yLWZvY3VzZWQ6dmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpOy0taGlnaGxpZ2h0LWNvbG9yLXZhbGlkOnZhcigtLWlvbi1jb2xvci1zdWNjZXNzLCAjMmRkMzZmKTstLWhpZ2hsaWdodC1jb2xvci1pbnZhbGlkOnZhcigtLWlvbi1jb2xvci1kYW5nZXIsICNlYjQ0NWEpO2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDt0ZXh0LXRyYW5zZm9ybTpub25lfTpob3N0KC5pdGVtLWZpbGwtb3V0bGluZSl7LS1oaWdobGlnaHQtaGVpZ2h0OjJweH06aG9zdCguaXRlbS1maWxsLW5vbmUuaXRlbS1pbnRlcmFjdGl2ZS5pb24tZm9jdXMpIC5pdGVtLWhpZ2hsaWdodCw6aG9zdCguaXRlbS1maWxsLW5vbmUuaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cykgLml0ZW0taGlnaGxpZ2h0LDpob3N0KC5pdGVtLWZpbGwtbm9uZS5pdGVtLWludGVyYWN0aXZlLmlvbi10b3VjaGVkLmlvbi1pbnZhbGlkKSAuaXRlbS1oaWdobGlnaHR7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVYKDEpO3RyYW5zZm9ybTpzY2FsZVgoMSk7Ym9yZGVyLXdpZHRoOjAgMCB2YXIoLS1mdWxsLWhpZ2hsaWdodC1oZWlnaHQpIDA7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWhpZ2hsaWdodC1iYWNrZ3JvdW5kKX06aG9zdCguaXRlbS1maWxsLW5vbmUuaXRlbS1pbnRlcmFjdGl2ZS5pb24tZm9jdXMpIC5pdGVtLW5hdGl2ZSw6aG9zdCguaXRlbS1maWxsLW5vbmUuaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cykgLml0ZW0tbmF0aXZlLDpob3N0KC5pdGVtLWZpbGwtbm9uZS5pdGVtLWludGVyYWN0aXZlLmlvbi10b3VjaGVkLmlvbi1pbnZhbGlkKSAuaXRlbS1uYXRpdmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjp2YXIoLS1oaWdobGlnaHQtYmFja2dyb3VuZCl9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taW50ZXJhY3RpdmUuaW9uLWZvY3VzKSAuaXRlbS1oaWdobGlnaHQsOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taW50ZXJhY3RpdmUuaXRlbS1oYXMtZm9jdXMpIC5pdGVtLWhpZ2hsaWdodHstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoMSk7dHJhbnNmb3JtOnNjYWxlWCgxKX06aG9zdCguaXRlbS1maWxsLW91dGxpbmUuaXRlbS1pbnRlcmFjdGl2ZS5pb24tZm9jdXMpIC5pdGVtLWhpZ2hsaWdodCw6aG9zdCguaXRlbS1maWxsLW91dGxpbmUuaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cykgLml0ZW0taGlnaGxpZ2h0LDpob3N0KC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWludGVyYWN0aXZlLmlvbi10b3VjaGVkLmlvbi1pbnZhbGlkKSAuaXRlbS1oaWdobGlnaHR7Ym9yZGVyLXdpZHRoOnZhcigtLWZ1bGwtaGlnaGxpZ2h0LWhlaWdodCk7Ym9yZGVyLXN0eWxlOnZhcigtLWJvcmRlci1zdHlsZSk7Ym9yZGVyLWNvbG9yOnZhcigtLWhpZ2hsaWdodC1iYWNrZ3JvdW5kKX06aG9zdCguaXRlbS1maWxsLW91dGxpbmUuaXRlbS1pbnRlcmFjdGl2ZS5pb24tdG91Y2hlZC5pb24taW52YWxpZCkgLml0ZW0tbmF0aXZle2JvcmRlci1jb2xvcjp2YXIoLS1oaWdobGlnaHQtYmFja2dyb3VuZCl9Omhvc3QoLml0ZW0tZmlsbC1zb2xpZC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1cykgLml0ZW0taGlnaGxpZ2h0LDpob3N0KC5pdGVtLWZpbGwtc29saWQuaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cykgLml0ZW0taGlnaGxpZ2h0LDpob3N0KC5pdGVtLWZpbGwtc29saWQuaXRlbS1pbnRlcmFjdGl2ZS5pb24tdG91Y2hlZC5pb24taW52YWxpZCkgLml0ZW0taGlnaGxpZ2h0ey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgxKTt0cmFuc2Zvcm06c2NhbGVYKDEpO2JvcmRlci13aWR0aDowIDAgdmFyKC0tZnVsbC1oaWdobGlnaHQtaGVpZ2h0KSAwO2JvcmRlci1zdHlsZTp2YXIoLS1ib3JkZXItc3R5bGUpO2JvcmRlci1jb2xvcjp2YXIoLS1oaWdobGlnaHQtYmFja2dyb3VuZCl9Omhvc3QoLml0ZW0tZmlsbC1zb2xpZC5pdGVtLWludGVyYWN0aXZlLmlvbi1mb2N1cykgLml0ZW0tbmF0aXZlLDpob3N0KC5pdGVtLWZpbGwtc29saWQuaXRlbS1pbnRlcmFjdGl2ZS5pdGVtLWhhcy1mb2N1cykgLml0ZW0tbmF0aXZlLDpob3N0KC5pdGVtLWZpbGwtc29saWQuaXRlbS1pbnRlcmFjdGl2ZS5pb24tdG91Y2hlZC5pb24taW52YWxpZCkgLml0ZW0tbmF0aXZle2JvcmRlci1ib3R0b20tY29sb3I6dmFyKC0taGlnaGxpZ2h0LWJhY2tncm91bmQpfTpob3N0KC5pb24tY29sb3IuaW9uLWFjdGl2YXRlZCkgLml0ZW0tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fTpob3N0KC5pdGVtLWhhcy1mb2N1cykgLml0ZW0tbmF0aXZle2NhcmV0LWNvbG9yOnZhcigtLWhpZ2hsaWdodC1jb2xvci1mb2N1c2VkKX06aG9zdCguaXRlbS1pbnRlcmFjdGl2ZSl7LS1ib3JkZXItd2lkdGg6MCAwIDFweCAwOy0taW5uZXItYm9yZGVyLXdpZHRoOjA7LS1zaG93LWZ1bGwtaGlnaGxpZ2h0OjE7LS1zaG93LWluc2V0LWhpZ2hsaWdodDowfTpob3N0KC5pdGVtLWxpbmVzLWZ1bGwpey0tYm9yZGVyLXdpZHRoOjAgMCAxcHggMDstLXNob3ctZnVsbC1oaWdobGlnaHQ6MTstLXNob3ctaW5zZXQtaGlnaGxpZ2h0OjB9Omhvc3QoLml0ZW0tbGluZXMtaW5zZXQpey0taW5uZXItYm9yZGVyLXdpZHRoOjAgMCAxcHggMDstLXNob3ctZnVsbC1oaWdobGlnaHQ6MDstLXNob3ctaW5zZXQtaGlnaGxpZ2h0OjF9Omhvc3QoLml0ZW0tbGluZXMtaW5zZXQpLDpob3N0KC5pdGVtLWxpbmVzLW5vbmUpey0tYm9yZGVyLXdpZHRoOjA7LS1zaG93LWZ1bGwtaGlnaGxpZ2h0OjB9Omhvc3QoLml0ZW0tbGluZXMtZnVsbCksOmhvc3QoLml0ZW0tbGluZXMtbm9uZSl7LS1pbm5lci1ib3JkZXItd2lkdGg6MDstLXNob3ctaW5zZXQtaGlnaGxpZ2h0OjB9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSAuaXRlbS1oaWdobGlnaHR7LS1wb3NpdGlvbi1vZmZzZXQ6Y2FsYygtMSAqIHZhcigtLWJvcmRlci13aWR0aCkpO2xlZnQ6dmFyKC0tcG9zaXRpb24tb2Zmc2V0KTt0b3A6dmFyKC0tcG9zaXRpb24tb2Zmc2V0KTt3aWR0aDpjYWxjKDEwMCUgKyAyICogdmFyKC0tYm9yZGVyLXdpZHRoKSk7aGVpZ2h0OmNhbGMoMTAwJSArIDIgKiB2YXIoLS1ib3JkZXItd2lkdGgpKTstd2Via2l0LXRyYW5zaXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmV9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSAuaXRlbS1oaWdobGlnaHQsOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLml0ZW0tZmlsbC1vdXRsaW5lIC5pdGVtLWhpZ2hsaWdodHtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OnZhcigtLXBvc2l0aW9uLW9mZnNldCl9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmUsOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1uYXRpdmV7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fTpob3N0KC5pdGVtLW11bHRpLWxpbmUpIDo6c2xvdHRlZChbc2xvdD1zdGFydF0pLDpob3N0KC5pdGVtLW11bHRpLWxpbmUpIDo6c2xvdHRlZChbc2xvdD1lbmRdKXttYXJnaW4tdG9wOjE2cHg7bWFyZ2luLWJvdHRvbToxNnB4Oy1tcy1mbGV4LWl0ZW0tYWxpZ246c3RhcnQ7YWxpZ24tc2VsZjpmbGV4LXN0YXJ0fTo6c2xvdHRlZChbc2xvdD1zdGFydF0pe21hcmdpbi1yaWdodDozMnB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKFtzbG90PXN0YXJ0XSl7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLWVuZDozMnB4O21hcmdpbi1pbmxpbmUtZW5kOjMycHh9fTo6c2xvdHRlZChbc2xvdD1lbmRdKXttYXJnaW4tbGVmdDozMnB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKFtzbG90PWVuZF0pe21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjMycHg7bWFyZ2luLWlubGluZS1zdGFydDozMnB4fX06aG9zdCguaXRlbS1maWxsLXNvbGlkKSA6OnNsb3R0ZWQoW3Nsb3Q9c3RhcnRdKSw6aG9zdCguaXRlbS1maWxsLXNvbGlkKSA6OnNsb3R0ZWQoW3Nsb3Q9ZW5kXSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSA6OnNsb3R0ZWQoW3Nsb3Q9c3RhcnRdKSw6aG9zdCguaXRlbS1maWxsLW91dGxpbmUpIDo6c2xvdHRlZChbc2xvdD1lbmRdKXstbXMtZmxleC1pdGVtLWFsaWduOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcn06OnNsb3R0ZWQoaW9uLWljb24pe2NvbG9yOnJnYmEodmFyKC0taW9uLXRleHQtY29sb3ItcmdiLCAwLCAwLCAwKSwgMC41NCk7Zm9udC1zaXplOjI0cHh9Omhvc3QoLmlvbi1jb2xvcjpub3QoLml0ZW0tZmlsbC1zb2xpZCk6bm90KC5pdGVtLWZpbGwtb3V0bGluZSkpIDo6c2xvdHRlZChpb24taWNvbil7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06OnNsb3R0ZWQoaW9uLWljb25bc2xvdF0pe21hcmdpbi10b3A6MTJweDttYXJnaW4tYm90dG9tOjEycHh9OjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9c3RhcnRdKXttYXJnaW4tcmlnaHQ6MzJweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24taWNvbltzbG90PXN0YXJ0XSl7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLWVuZDozMnB4O21hcmdpbi1pbmxpbmUtZW5kOjMycHh9fTo6c2xvdHRlZChpb24taWNvbltzbG90PWVuZF0pe21hcmdpbi1sZWZ0OjE2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1lbmRdKXttYXJnaW4tbGVmdDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDoxNnB4O21hcmdpbi1pbmxpbmUtc3RhcnQ6MTZweH19Omhvc3QoLml0ZW0tZmlsbC1zb2xpZCkgOjpzbG90dGVkKGlvbi1pY29uW3Nsb3Q9c3RhcnRdKSw6aG9zdCguaXRlbS1maWxsLW91dGxpbmUpIDo6c2xvdHRlZChpb24taWNvbltzbG90PXN0YXJ0XSl7bWFyZ2luLXJpZ2h0OjhweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC5pdGVtLWZpbGwtc29saWQpIDo6c2xvdHRlZChpb24taWNvbltzbG90PXN0YXJ0XSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSA6OnNsb3R0ZWQoaW9uLWljb25bc2xvdD1zdGFydF0pe21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1lbmQ6OHB4O21hcmdpbi1pbmxpbmUtZW5kOjhweH19OjpzbG90dGVkKGlvbi10b2dnbGVbc2xvdD1zdGFydF0pLDo6c2xvdHRlZChpb24tdG9nZ2xlW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfTo6c2xvdHRlZChpb24tbm90ZSl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowOy1tcy1mbGV4LWl0ZW0tYWxpZ246c3RhcnQ7YWxpZ24tc2VsZjpmbGV4LXN0YXJ0O2ZvbnQtc2l6ZToxMXB4fTo6c2xvdHRlZChpb24tbm90ZVtzbG90XTpub3QoW3Nsb3Q9aGVscGVyXSk6bm90KFtzbG90PWVycm9yXSkpe3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLXRvcDoxOHB4O3BhZGRpbmctYm90dG9tOjEwcHh9OjpzbG90dGVkKGlvbi1ub3RlW3Nsb3Q9c3RhcnRdKXtwYWRkaW5nLXJpZ2h0OjE2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLW5vdGVbc2xvdD1zdGFydF0pe3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLWVuZDoxNnB4O3BhZGRpbmctaW5saW5lLWVuZDoxNnB4fX06OnNsb3R0ZWQoaW9uLW5vdGVbc2xvdD1lbmRdKXtwYWRkaW5nLWxlZnQ6MTZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24tbm90ZVtzbG90PWVuZF0pe3BhZGRpbmctbGVmdDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6MTZweDtwYWRkaW5nLWlubGluZS1zdGFydDoxNnB4fX06OnNsb3R0ZWQoaW9uLWF2YXRhcil7d2lkdGg6NDBweDtoZWlnaHQ6NDBweH06OnNsb3R0ZWQoaW9uLXRodW1ibmFpbCl7d2lkdGg6NTZweDtoZWlnaHQ6NTZweH06OnNsb3R0ZWQoaW9uLWF2YXRhciksOjpzbG90dGVkKGlvbi10aHVtYm5haWwpe21hcmdpbi10b3A6OHB4O21hcmdpbi1ib3R0b206OHB4fTo6c2xvdHRlZChpb24tYXZhdGFyW3Nsb3Q9c3RhcnRdKSw6OnNsb3R0ZWQoaW9uLXRodW1ibmFpbFtzbG90PXN0YXJ0XSl7bWFyZ2luLXJpZ2h0OjE2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWF2YXRhcltzbG90PXN0YXJ0XSksOjpzbG90dGVkKGlvbi10aHVtYm5haWxbc2xvdD1zdGFydF0pe21hcmdpbi1yaWdodDp1bnNldDstd2Via2l0LW1hcmdpbi1lbmQ6MTZweDttYXJnaW4taW5saW5lLWVuZDoxNnB4fX06OnNsb3R0ZWQoaW9uLWF2YXRhcltzbG90PWVuZF0pLDo6c2xvdHRlZChpb24tdGh1bWJuYWlsW3Nsb3Q9ZW5kXSl7bWFyZ2luLWxlZnQ6MTZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24tYXZhdGFyW3Nsb3Q9ZW5kXSksOjpzbG90dGVkKGlvbi10aHVtYm5haWxbc2xvdD1lbmRdKXttYXJnaW4tbGVmdDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDoxNnB4O21hcmdpbi1pbmxpbmUtc3RhcnQ6MTZweH19OjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjEwcHg7bWFyZ2luLWJvdHRvbToxMHB4fTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpIDo6c2xvdHRlZChbc2xvdD1lbmRdKSw6aG9zdCguaXRlbS1sYWJlbC1mbG9hdGluZykgOjpzbG90dGVkKFtzbG90PWVuZF0pe21hcmdpbi10b3A6N3B4O21hcmdpbi1ib3R0b206N3B4fTpob3N0KC5pdGVtLWxhYmVsLWZpeGVkKSA6OnNsb3R0ZWQoaW9uLXNlbGVjdCksOmhvc3QoLml0ZW0tbGFiZWwtZml4ZWQpIDo6c2xvdHRlZChpb24tZGF0ZXRpbWUpey0tcGFkZGluZy1zdGFydDo4cHh9Omhvc3QoLml0ZW0tdG9nZ2xlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKSw6aG9zdCguaXRlbS1yYWRpbykgOjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLWxlZnQ6MH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC5pdGVtLXRvZ2dsZSkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLml0ZW0tcmFkaW8pIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjA7bWFyZ2luLWlubGluZS1zdGFydDowfX06OnNsb3R0ZWQoLmJ1dHRvbi1zbWFsbCl7LS1wYWRkaW5nLXRvcDowOy0tcGFkZGluZy1ib3R0b206MDstLXBhZGRpbmctc3RhcnQ6LjZlbTstLXBhZGRpbmctZW5kOi42ZW07aGVpZ2h0OjI1cHg7Zm9udC1zaXplOjEycHh9Omhvc3QoLml0ZW0tbGFiZWwtZmxvYXRpbmcpLDpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpey0tbWluLWhlaWdodDo1NXB4fTpob3N0KC5pdGVtLWxhYmVsLXN0YWNrZWQpIDo6c2xvdHRlZChpb24tc2VsZWN0KSw6aG9zdCguaXRlbS1sYWJlbC1mbG9hdGluZykgOjpzbG90dGVkKGlvbi1zZWxlY3Qpey0tcGFkZGluZy10b3A6OHB4Oy0tcGFkZGluZy1ib3R0b206OHB4Oy0tcGFkZGluZy1zdGFydDowfTpob3N0KC5pb24tZm9jdXNlZDpub3QoLmlvbi1jb2xvcikpIDo6c2xvdHRlZCgubGFiZWwtc3RhY2tlZCksOmhvc3QoLmlvbi1mb2N1c2VkOm5vdCguaW9uLWNvbG9yKSkgOjpzbG90dGVkKC5sYWJlbC1mbG9hdGluZyksOmhvc3QoLml0ZW0taGFzLWZvY3VzOm5vdCguaW9uLWNvbG9yKSkgOjpzbG90dGVkKC5sYWJlbC1zdGFja2VkKSw6aG9zdCguaXRlbS1oYXMtZm9jdXM6bm90KC5pb24tY29sb3IpKSA6OnNsb3R0ZWQoLmxhYmVsLWZsb2F0aW5nKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZil9Omhvc3QoLmlvbi1jb2xvcil7LS1oaWdobGlnaHQtY29sb3ItZm9jdXNlZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pdGVtLWxhYmVsLWNvbG9yKXstLWhpZ2hsaWdodC1jb2xvci1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguaXRlbS1maWxsLXNvbGlkLmlvbi1jb2xvciksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLmlvbi1jb2xvcil7LS1oaWdobGlnaHQtY29sb3ItZm9jdXNlZDp2YXIoLS1pb24tY29sb3ItYmFzZSl9Omhvc3QoLml0ZW0tZmlsbC1zb2xpZCl7LS1iYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1zdGVwLTUwLCAjZjJmMmYyKTstLWJhY2tncm91bmQtaG92ZXI6dmFyKC0taW9uLWNvbG9yLXN0ZXAtMTAwLCAjZTZlNmU2KTstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tY29sb3Itc3RlcC0xNTAsICNkOWQ5ZDkpOy0tYm9yZGVyLXdpZHRoOjAgMCAxcHggMDstLWlubmVyLWJvcmRlci13aWR0aDowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NHB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjRweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCguaXRlbS1maWxsLXNvbGlkKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkuaXRlbS1maWxsLXNvbGlke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NHB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjRweDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MH06aG9zdCguaXRlbS1maWxsLXNvbGlkKSAuaXRlbS1uYXRpdmV7LS1ib3JkZXItY29sb3I6dmFyKC0taW9uLWNvbG9yLXN0ZXAtNTAwLCBncmF5KX06aG9zdCguaXRlbS1maWxsLXNvbGlkLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmUsOmhvc3QoLml0ZW0tZmlsbC1zb2xpZC5pdGVtLWhhcy1mb2N1cykgLml0ZW0tbmF0aXZley0tYmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQpfTpob3N0KC5pdGVtLWZpbGwtc29saWQuaXRlbS1zaGFwZS1yb3VuZCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czoxNnB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjE2cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLml0ZW0tZmlsbC1zb2xpZC5pdGVtLXNoYXBlLXJvdW5kKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkuaXRlbS1maWxsLXNvbGlkLml0ZW0tc2hhcGUtcm91bmR7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czoxNnB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjE2cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9QG1lZGlhIChhbnktaG92ZXI6IGhvdmVyKXs6aG9zdCguaXRlbS1maWxsLXNvbGlkOmhvdmVyKSAuaXRlbS1uYXRpdmV7LS1iYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtaG92ZXIpOy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1jb2xvci1zdGVwLTc1MCwgIzQwNDA0MCl9fTpob3N0KC5pdGVtLWZpbGwtb3V0bGluZSl7LS1yaXBwbGUtY29sb3I6dHJhbnNwYXJlbnQ7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dHJhbnNwYXJlbnQ7LS1iYWNrZ3JvdW5kLWhvdmVyOnRyYW5zcGFyZW50Oy0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1jb2xvci1zdGVwLTUwMCwgZ3JheSk7LS1ib3JkZXItd2lkdGg6MXB4O2JvcmRlcjpub25lO292ZXJmbG93OnZpc2libGV9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lKSAuaXRlbS1uYXRpdmV7LS1uYXRpdmUtcGFkZGluZy1sZWZ0OjE2cHg7Ym9yZGVyLXJhZGl1czo0cHh9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0tc2hhcGUtcm91bmQpIC5pdGVtLW5hdGl2ZXstLWlubmVyLXBhZGRpbmctc3RhcnQ6MTZweDtib3JkZXItcmFkaXVzOjI4cHh9Omhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0tc2hhcGUtcm91bmQpIC5pdGVtLWJvdHRvbXtwYWRkaW5nLWxlZnQ6MzJweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLXNoYXBlLXJvdW5kKSAuaXRlbS1ib3R0b217cGFkZGluZy1sZWZ0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDozMnB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjMycHh9fTpob3N0KC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWxhYmVsLWZsb2F0aW5nLmlvbi1mb2N1c2VkKSAuaXRlbS1uYXRpdmUgOjpzbG90dGVkKGlvbi1pbnB1dDpub3QoOmZpcnN0LWNoaWxkKSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0tbGFiZWwtZmxvYXRpbmcuaW9uLWZvY3VzZWQpIC5pdGVtLW5hdGl2ZSA6OnNsb3R0ZWQoaW9uLXRleHRhcmVhOm5vdCg6Zmlyc3QtY2hpbGQpKSw6aG9zdCguaXRlbS1maWxsLW91dGxpbmUuaXRlbS1sYWJlbC1mbG9hdGluZy5pdGVtLWhhcy1mb2N1cykgLml0ZW0tbmF0aXZlIDo6c2xvdHRlZChpb24taW5wdXQ6bm90KDpmaXJzdC1jaGlsZCkpLDpob3N0KC5pdGVtLWZpbGwtb3V0bGluZS5pdGVtLWxhYmVsLWZsb2F0aW5nLml0ZW0taGFzLWZvY3VzKSAuaXRlbS1uYXRpdmUgOjpzbG90dGVkKGlvbi10ZXh0YXJlYTpub3QoOmZpcnN0LWNoaWxkKSksOmhvc3QoLml0ZW0tZmlsbC1vdXRsaW5lLml0ZW0tbGFiZWwtZmxvYXRpbmcuaXRlbS1oYXMtdmFsdWUpIC5pdGVtLW5hdGl2ZSA6OnNsb3R0ZWQoaW9uLWlucHV0Om5vdCg6Zmlyc3QtY2hpbGQpKSw6aG9zdCguaXRlbS1maWxsLW91dGxpbmUuaXRlbS1sYWJlbC1mbG9hdGluZy5pdGVtLWhhcy12YWx1ZSkgLml0ZW0tbmF0aXZlIDo6c2xvdHRlZChpb24tdGV4dGFyZWE6bm90KDpmaXJzdC1jaGlsZCkpey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTE0cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xNHB4KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpezpob3N0KC5pdGVtLWZpbGwtb3V0bGluZTpob3ZlcikgLml0ZW0tbmF0aXZley0tYm9yZGVyLWNvbG9yOnZhcigtLWlvbi1jb2xvci1zdGVwLTc1MCwgIzQwNDA0MCl9fS5pdGVtLWNvdW50ZXJ7Y29sb3I6cmdiYSgwLCAwLCAwLCAwLjYpO2xldHRlci1zcGFjaW5nOjAuMDMzMzMzMzMzM2VtfVwiO1xuXG5jb25zdCBJdGVtID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmxhYmVsQ29sb3JTdHlsZXMgPSB7fTtcbiAgICB0aGlzLml0ZW1TdHlsZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tdWx0aXBsZUlucHV0cyA9IGZhbHNlO1xuICAgIHRoaXMuZm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGEgYnV0dG9uIHRhZyB3aWxsIGJlIHJlbmRlcmVkIGFuZCB0aGUgaXRlbSB3aWxsIGJlIHRhcHBhYmxlLlxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGljb24gdG8gdXNlIHdoZW4gYGRldGFpbGAgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKi9cbiAgICB0aGlzLmRldGFpbEljb24gPSBjaGV2cm9uRm9yd2FyZDtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoZSBpdGVtLlxuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGEgY2hhcmFjdGVyIGNvdW50ZXIgd2lsbCBkaXNwbGF5IHRoZSByYXRpbyBvZiBjaGFyYWN0ZXJzIHVzZWQgYW5kIHRoZSB0b3RhbCBjaGFyYWN0ZXIgbGltaXQuIE9ubHkgYXBwbGllcyB3aGVuIHRoZSBgbWF4bGVuZ3RoYCBwcm9wZXJ0eSBpcyBzZXQgb24gdGhlIGlubmVyIGBpb24taW5wdXRgIG9yIGBpb24tdGV4dGFyZWFgLlxuICAgICAqL1xuICAgIHRoaXMuY291bnRlciA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgYSByb3V0ZXIsIGl0IHNwZWNpZmllcyB0aGUgdHJhbnNpdGlvbiBkaXJlY3Rpb24gd2hlbiBuYXZpZ2F0aW5nIHRvXG4gICAgICogYW5vdGhlciBwYWdlIHVzaW5nIGBocmVmYC5cbiAgICAgKi9cbiAgICB0aGlzLnJvdXRlckRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgYnV0dG9uLiBPbmx5IHVzZWQgd2hlbiBhbiBgb25jbGlja2Agb3IgYGJ1dHRvbmAgcHJvcGVydHkgaXMgcHJlc2VudC5cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAnYnV0dG9uJztcbiAgfVxuICBoYW5kbGVJb25DaGFuZ2UoZXYpIHtcbiAgICBpZiAodGhpcy5jb3VudGVyICYmIGV2LnRhcmdldCA9PT0gdGhpcy5nZXRGaXJzdElucHV0KCkpIHtcbiAgICAgIHRoaXMudXBkYXRlQ291bnRlck91dHB1dChldi50YXJnZXQpO1xuICAgIH1cbiAgfVxuICBsYWJlbENvbG9yQ2hhbmdlZChldikge1xuICAgIGNvbnN0IHsgY29sb3IgfSA9IHRoaXM7XG4gICAgLy8gVGhlcmUgd2lsbCBiZSBhIGNvbmZsaWN0IHdpdGggaXRlbSBjb2xvciBpZlxuICAgIC8vIHdlIGFwcGx5IHRoZSBsYWJlbCBjb2xvciB0byBpdGVtLCBzbyB3ZSBpZ25vcmVcbiAgICAvLyB0aGUgbGFiZWwgY29sb3IgaWYgdGhlIHVzZXIgc2V0cyBhIGNvbG9yIG9uIGl0ZW1cbiAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sYWJlbENvbG9yU3R5bGVzID0gZXYuZGV0YWlsO1xuICAgIH1cbiAgfVxuICBpdGVtU3R5bGUoZXYpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCB0YWdOYW1lID0gZXYudGFyZ2V0LnRhZ05hbWU7XG4gICAgY29uc3QgdXBkYXRlZFN0eWxlcyA9IGV2LmRldGFpbDtcbiAgICBjb25zdCBuZXdTdHlsZXMgPSB7fTtcbiAgICBjb25zdCBjaGlsZFN0eWxlcyA9IHRoaXMuaXRlbVN0eWxlcy5nZXQodGFnTmFtZSkgfHwge307XG4gICAgbGV0IGhhc1N0eWxlQ2hhbmdlID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXModXBkYXRlZFN0eWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZWRTdHlsZXNba2V5XSkge1xuICAgICAgICBjb25zdCBpdGVtS2V5ID0gYGl0ZW0tJHtrZXl9YDtcbiAgICAgICAgaWYgKCFjaGlsZFN0eWxlc1tpdGVtS2V5XSkge1xuICAgICAgICAgIGhhc1N0eWxlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdTdHlsZXNbaXRlbUtleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaGFzU3R5bGVDaGFuZ2UgJiYgT2JqZWN0LmtleXMobmV3U3R5bGVzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGNoaWxkU3R5bGVzKS5sZW5ndGgpIHtcbiAgICAgIGhhc1N0eWxlQ2hhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc1N0eWxlQ2hhbmdlKSB7XG4gICAgICB0aGlzLml0ZW1TdHlsZXMuc2V0KHRhZ05hbWUsIG5ld1N0eWxlcyk7XG4gICAgICBmb3JjZVVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuY291bnRlcikge1xuICAgICAgdGhpcy51cGRhdGVDb3VudGVyT3V0cHV0KHRoaXMuZ2V0Rmlyc3RJbnB1dCgpKTtcbiAgICB9XG4gICAgdGhpcy5oYXNTdGFydEVsKCk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIERvIG5vdCB1c2UgQExpc3RlbiBoZXJlIHRvIGF2b2lkIG1ha2luZyBhbGwgaXRlbXNcbiAgICAvLyBhcHBlYXIgYXMgY2xpY2thYmxlIHRvIHNjcmVlbiByZWFkZXJzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lvbmljLXRlYW0vaW9uaWMtZnJhbWV3b3JrL2lzc3Vlcy8yMjAxMVxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXRGaXJzdElucHV0KCk7XG4gICAgaWYgKGlucHV0ICYmICF0aGlzLmNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lciA9IChldikgPT4gdGhpcy5kZWxlZ2F0ZUZvY3VzKGV2LCBpbnB1dCk7XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGlja0xpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldEZpcnN0SW5wdXQoKTtcbiAgICBpZiAoaW5wdXQgJiYgdGhpcy5jbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbGlja0xpc3RlbmVyKTtcbiAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRNdWx0aXBsZUlucHV0cygpO1xuICAgICAgdGhpcy5mb2N1c2FibGUgPSB0aGlzLmlzRm9jdXNhYmxlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gSWYgdGhlIGl0ZW0gY29udGFpbnMgbXVsdGlwbGUgY2xpY2thYmxlIGVsZW1lbnRzIGFuZC9vciBpbnB1dHMsIHRoZW4gdGhlIGl0ZW1cbiAgLy8gc2hvdWxkIG5vdCBoYXZlIGEgY2xpY2thYmxlIGlucHV0IGNvdmVyIG92ZXIgdGhlIGVudGlyZSBpdGVtIHRvIHByZXZlbnRcbiAgLy8gaW50ZXJmZXJpbmcgd2l0aCB0aGVpciBpbmRpdmlkdWFsIGNsaWNrIGV2ZW50c1xuICBzZXRNdWx0aXBsZUlucHV0cygpIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIGhhdmUgYSBjbGlja2FibGUgY292ZXIgdGhhdCBpcyByZWxhdGl2ZSB0byB0aGUgZW50aXJlIGl0ZW1cbiAgICBjb25zdCBjb3ZlcnMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1jaGVja2JveCwgaW9uLWRhdGV0aW1lLCBpb24tc2VsZWN0LCBpb24tcmFkaW8nKTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIGNhbiBhY2NlcHQgZm9jdXMgYWxvbmdzaWRlIHRoZSBwcmV2aW91cyBlbGVtZW50c1xuICAgIC8vIHRoZXJlZm9yZSBpZiB0aGVzZSBlbGVtZW50cyBhcmUgYWxzbyBhIGNoaWxkIG9mIGl0ZW0sIHdlIGRvbid0IHdhbnQgdGhlXG4gICAgLy8gaW5wdXQgY292ZXIgb24gdG9wIG9mIHRob3NlIGludGVyZmVyaW5nIHdpdGggdGhlaXIgY2xpY2tzXG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdpb24taW5wdXQsIGlvbi1yYW5nZSwgaW9uLXNlYXJjaGJhciwgaW9uLXNlZ21lbnQsIGlvbi10ZXh0YXJlYSwgaW9uLXRvZ2dsZScpO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgZWxlbWVudHMgc2hvdWxkIGFsc28gc3RheSBjbGlja2FibGUgd2hlbiBhbiBpbnB1dCB3aXRoIGNvdmVyIGlzIHByZXNlbnRcbiAgICBjb25zdCBjbGlja2FibGVzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdpb24tYW5jaG9yLCBpb24tYnV0dG9uLCBhLCBidXR0b24nKTtcbiAgICAvLyBDaGVjayBmb3IgbXVsdGlwbGUgaW5wdXRzIHRvIGNoYW5nZSB0aGUgcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvdmVyIHRvIHJlbGF0aXZlXG4gICAgLy8gZm9yIGFsbCBvZiB0aGUgY292ZXJlZCBpbnB1dHMgYWJvdmVcbiAgICB0aGlzLm11bHRpcGxlSW5wdXRzID0gY292ZXJzLmxlbmd0aCArIGlucHV0cy5sZW5ndGggPiAxXG4gICAgICB8fCBjb3ZlcnMubGVuZ3RoICsgY2xpY2thYmxlcy5sZW5ndGggPiAxXG4gICAgICB8fCBjb3ZlcnMubGVuZ3RoID4gMCAmJiB0aGlzLmlzQ2xpY2thYmxlKCk7XG4gIH1cbiAgLy8gSWYgdGhlIGl0ZW0gY29udGFpbnMgYW4gaW5wdXQgaW5jbHVkaW5nIGEgY2hlY2tib3gsIGRhdGV0aW1lLCBzZWxlY3QsIG9yIHJhZGlvXG4gIC8vIHRoZW4gdGhlIGl0ZW0gd2lsbCBoYXZlIGEgY2xpY2thYmxlIGlucHV0IGNvdmVyIHRoYXQgY292ZXJzIHRoZSBpdGVtXG4gIC8vIHRoYXQgc2hvdWxkIGdldCB0aGUgaG92ZXIsIGZvY3VzZWQgYW5kIGFjdGl2YXRlZCBzdGF0ZXMgVU5MRVNTIGl0IGhhcyBtdWx0aXBsZVxuICAvLyBpbnB1dHMsIHRoZW4gdGhvc2UgbmVlZCB0byBpbmRpdmlkdWFsbHkgZ2V0IGVhY2ggY2xpY2tcbiAgaGFzQ292ZXIoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdpb24tY2hlY2tib3gsIGlvbi1kYXRldGltZSwgaW9uLXNlbGVjdCwgaW9uLXJhZGlvJyk7XG4gICAgcmV0dXJuIGlucHV0cy5sZW5ndGggPT09IDEgJiYgIXRoaXMubXVsdGlwbGVJbnB1dHM7XG4gIH1cbiAgLy8gSWYgdGhlIGl0ZW0gaGFzIGFuIGhyZWYgb3IgYnV0dG9uIHByb3BlcnR5IGl0IHdpbGwgcmVuZGVyIGEgbmF0aXZlXG4gIC8vIGFuY2hvciBvciBidXR0b24gdGhhdCBpcyBjbGlja2FibGVcbiAgaXNDbGlja2FibGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLmhyZWYgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmJ1dHRvbik7XG4gIH1cbiAgY2FuQWN0aXZhdGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLmlzQ2xpY2thYmxlKCkgfHwgdGhpcy5oYXNDb3ZlcigpKTtcbiAgfVxuICBpc0ZvY3VzYWJsZSgpIHtcbiAgICBjb25zdCBmb2N1c2FibGVDaGlsZCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignLmlvbi1mb2N1c2FibGUnKTtcbiAgICByZXR1cm4gKHRoaXMuY2FuQWN0aXZhdGUoKSB8fCBmb2N1c2FibGVDaGlsZCAhPT0gbnVsbCk7XG4gIH1cbiAgZ2V0Rmlyc3RJbnB1dCgpIHtcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1pbnB1dCwgaW9uLXRleHRhcmVhJyk7XG4gICAgcmV0dXJuIGlucHV0c1swXTtcbiAgfVxuICAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgV2ViS2l0IGR1ZSB0byBhIGRlbGVnYXRlc0ZvY3VzIGJ1ZyB3aGVyZVxuICAvLyBjbGlja2luZyBvbiB0aGUgbGVmdCBwYWRkaW5nIG9mIGFuIGl0ZW0gaXMgbm90IGZvY3VzaW5nIHRoZSBpbnB1dFxuICAvLyBidXQgaXMgb3BlbmluZyB0aGUga2V5Ym9hcmQuIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIG5lZWRlZCB3aXRoXG4gIC8vIGlPUyAxNC5cbiAgZGVsZWdhdGVGb2N1cyhldiwgaW5wdXQpIHtcbiAgICBjb25zdCBjbGlja2VkSXRlbSA9IGV2LnRhcmdldC50YWdOYW1lID09PSAnSU9OLUlURU0nO1xuICAgIGxldCBmaXJzdEFjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIElmIHRoZSBmaXJzdCBpbnB1dCBpcyB0aGUgc2FtZSBhcyB0aGUgYWN0aXZlIGVsZW1lbnQgd2UgbmVlZFxuICAgIC8vIHRvIGZvY3VzIHRoZSBmaXJzdCBpbnB1dCBhZ2FpbiwgYnV0IGlmIHRoZSBhY3RpdmUgZWxlbWVudFxuICAgIC8vIGlzIGFub3RoZXIgaW5wdXQgaW5zaWRlIG9mIHRoZSBpdGVtIHdlIHNob3VsZG4ndCBzd2l0Y2ggZm9jdXNcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgZmlyc3RBY3RpdmUgPSBpbnB1dC5xdWVyeVNlbGVjdG9yKCdpbnB1dCwgdGV4dGFyZWEnKSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLy8gT25seSBmb2N1cyB0aGUgZmlyc3QgaW5wdXQgaWYgd2UgY2xpY2tlZCBvbiBhbiBpb24taXRlbVxuICAgIC8vIGFuZCB0aGUgZmlyc3QgaW5wdXQgZXhpc3RzXG4gICAgaWYgKGNsaWNrZWRJdGVtICYmIChmaXJzdEFjdGl2ZSB8fCAhdGhpcy5tdWx0aXBsZUlucHV0cykpIHtcbiAgICAgIGlucHV0LmZpcmVGb2N1c0V2ZW50cyA9IGZhbHNlO1xuICAgICAgaW5wdXQuc2V0Qmx1cigpO1xuICAgICAgaW5wdXQuc2V0Rm9jdXMoKTtcbiAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlucHV0LmZpcmVGb2N1c0V2ZW50cyA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ291bnRlck91dHB1dChpbnB1dEVsKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGhpcy5jb3VudGVyICYmICF0aGlzLm11bHRpcGxlSW5wdXRzICYmIChpbnB1dEVsID09PSBudWxsIHx8IGlucHV0RWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0RWwubWF4bGVuZ3RoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSAoX2IgPSAoX2EgPSBpbnB1dEVsID09PSBudWxsIHx8IGlucHV0RWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0RWwudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJzAnO1xuICAgICAgdGhpcy5jb3VudGVyU3RyaW5nID0gYCR7bGVuZ3RofSAvICR7aW5wdXRFbC5tYXhsZW5ndGh9YDtcbiAgICB9XG4gIH1cbiAgaGFzU3RhcnRFbCgpIHtcbiAgICBjb25zdCBzdGFydEVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdbc2xvdD1cInN0YXJ0XCJdJyk7XG4gICAgaWYgKHN0YXJ0RWwgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgnaXRlbS1oYXMtc3RhcnQtc2xvdCcpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb3VudGVyU3RyaW5nLCBkZXRhaWwsIGRldGFpbEljb24sIGRvd25sb2FkLCBmaWxsLCBsYWJlbENvbG9yU3R5bGVzLCBsaW5lcywgZGlzYWJsZWQsIGhyZWYsIHJlbCwgc2hhcGUsIHRhcmdldCwgcm91dGVyQW5pbWF0aW9uLCByb3V0ZXJEaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgY2hpbGRTdHlsZXMgPSB7fTtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICBjb25zdCBjbGlja2FibGUgPSB0aGlzLmlzQ2xpY2thYmxlKCk7XG4gICAgY29uc3QgY2FuQWN0aXZhdGUgPSB0aGlzLmNhbkFjdGl2YXRlKCk7XG4gICAgY29uc3QgVGFnVHlwZSA9IGNsaWNrYWJsZSA/IChocmVmID09PSB1bmRlZmluZWQgPyAnYnV0dG9uJyA6ICdhJykgOiAnZGl2JztcbiAgICBjb25zdCBhdHRycyA9IChUYWdUeXBlID09PSAnYnV0dG9uJylcbiAgICAgID8geyB0eXBlOiB0aGlzLnR5cGUgfVxuICAgICAgOiB7XG4gICAgICAgIGRvd25sb2FkLFxuICAgICAgICBocmVmLFxuICAgICAgICByZWwsXG4gICAgICAgIHRhcmdldFxuICAgICAgfTtcbiAgICAvLyBPbmx5IHNldCBvbkNsaWNrIGlmIHRoZSBpdGVtIGlzIGNsaWNrYWJsZSB0byBwcmV2ZW50IHNjcmVlblxuICAgIC8vIHJlYWRlcnMgZnJvbSByZWFkaW5nIGFsbCBpdGVtcyBhcyBjbGlja2FibGVcbiAgICBjb25zdCBjbGlja0ZuID0gY2xpY2thYmxlID8ge1xuICAgICAgb25DbGljazogKGV2KSA9PiB7IG9wZW5VUkwoaHJlZiwgZXYsIHJvdXRlckRpcmVjdGlvbiwgcm91dGVyQW5pbWF0aW9uKTsgfVxuICAgIH0gOiB7fTtcbiAgICBjb25zdCBzaG93RGV0YWlsID0gZGV0YWlsICE9PSB1bmRlZmluZWQgPyBkZXRhaWwgOiBtb2RlID09PSAnaW9zJyAmJiBjbGlja2FibGU7XG4gICAgdGhpcy5pdGVtU3R5bGVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGlsZFN0eWxlcywgdmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFyaWFEaXNhYmxlZCA9IChkaXNhYmxlZCB8fCBjaGlsZFN0eWxlc1snaXRlbS1pbnRlcmFjdGl2ZS1kaXNhYmxlZCddKSA/ICd0cnVlJyA6IG51bGw7XG4gICAgY29uc3QgZmlsbFZhbHVlID0gZmlsbCB8fCAnbm9uZSc7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgXCJhcmlhLWRpc2FibGVkXCI6IGFyaWFEaXNhYmxlZCwgY2xhc3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGlsZFN0eWxlcyksIGxhYmVsQ29sb3JTdHlsZXMpLCBjcmVhdGVDb2xvckNsYXNzZXModGhpcy5jb2xvciwge1xuICAgICAgICAnaXRlbSc6IHRydWUsXG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgW2BpdGVtLWxpbmVzLSR7bGluZXN9YF06IGxpbmVzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIFtgaXRlbS1maWxsLSR7ZmlsbFZhbHVlfWBdOiB0cnVlLFxuICAgICAgICBbYGl0ZW0tc2hhcGUtJHtzaGFwZX1gXTogc2hhcGUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgJ2l0ZW0tZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAgICAgJ2luLWxpc3QnOiBob3N0Q29udGV4dCgnaW9uLWxpc3QnLCB0aGlzLmVsKSxcbiAgICAgICAgJ2l0ZW0tbXVsdGlwbGUtaW5wdXRzJzogdGhpcy5tdWx0aXBsZUlucHV0cyxcbiAgICAgICAgJ2lvbi1hY3RpdmF0YWJsZSc6IGNhbkFjdGl2YXRlLFxuICAgICAgICAnaW9uLWZvY3VzYWJsZSc6IHRoaXMuZm9jdXNhYmxlLFxuICAgICAgICAnaXRlbS1ydGwnOiBkb2N1bWVudC5kaXIgPT09ICdydGwnXG4gICAgICB9KSkgfSwgaChUYWdUeXBlLCBPYmplY3QuYXNzaWduKHt9LCBhdHRycywgeyBjbGFzczogXCJpdGVtLW5hdGl2ZVwiLCBwYXJ0OiBcIm5hdGl2ZVwiLCBkaXNhYmxlZDogZGlzYWJsZWQgfSwgY2xpY2tGbiksIGgoXCJzbG90XCIsIHsgbmFtZTogXCJzdGFydFwiIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaXRlbS1pbm5lclwiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC13cmFwcGVyXCIgfSwgaChcInNsb3RcIiwgbnVsbCkpLCBoKFwic2xvdFwiLCB7IG5hbWU6IFwiZW5kXCIgfSksIHNob3dEZXRhaWwgJiYgaChcImlvbi1pY29uXCIsIHsgaWNvbjogZGV0YWlsSWNvbiwgbGF6eTogZmFsc2UsIGNsYXNzOiBcIml0ZW0tZGV0YWlsLWljb25cIiwgcGFydDogXCJkZXRhaWwtaWNvblwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBcImZsaXAtcnRsXCI6IGRldGFpbEljb24gPT09IGNoZXZyb25Gb3J3YXJkIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaXRlbS1pbm5lci1oaWdobGlnaHRcIiB9KSksIGNhbkFjdGl2YXRlICYmIG1vZGUgPT09ICdtZCcgJiYgaChcImlvbi1yaXBwbGUtZWZmZWN0XCIsIG51bGwpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaXRlbS1oaWdobGlnaHRcIiB9KSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpdGVtLWJvdHRvbVwiIH0sIGgoXCJzbG90XCIsIHsgbmFtZTogXCJlcnJvclwiIH0pLCBoKFwic2xvdFwiLCB7IG5hbWU6IFwiaGVscGVyXCIgfSksIGNvdW50ZXJTdHJpbmcgJiYgaChcImlvbi1ub3RlXCIsIHsgY2xhc3M6IFwiaXRlbS1jb3VudGVyXCIgfSwgY291bnRlclN0cmluZykpKSk7XG4gIH1cbiAgc3RhdGljIGdldCBkZWxlZ2F0ZXNGb2N1cygpIHsgcmV0dXJuIHRydWU7IH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4ge1xuICAgIGlvczogaXRlbUlvc0NzcyxcbiAgICBtZDogaXRlbU1kQ3NzXG4gIH07IH1cbn0sIFs0OSwgXCJpb24taXRlbVwiLCB7XG4gICAgXCJjb2xvclwiOiBbNTEzXSxcbiAgICBcImJ1dHRvblwiOiBbNF0sXG4gICAgXCJkZXRhaWxcIjogWzRdLFxuICAgIFwiZGV0YWlsSWNvblwiOiBbMSwgXCJkZXRhaWwtaWNvblwiXSxcbiAgICBcImRpc2FibGVkXCI6IFs0XSxcbiAgICBcImRvd25sb2FkXCI6IFsxXSxcbiAgICBcImZpbGxcIjogWzFdLFxuICAgIFwic2hhcGVcIjogWzFdLFxuICAgIFwiaHJlZlwiOiBbMV0sXG4gICAgXCJyZWxcIjogWzFdLFxuICAgIFwibGluZXNcIjogWzFdLFxuICAgIFwiY291bnRlclwiOiBbNF0sXG4gICAgXCJyb3V0ZXJBbmltYXRpb25cIjogWzE2XSxcbiAgICBcInJvdXRlckRpcmVjdGlvblwiOiBbMSwgXCJyb3V0ZXItZGlyZWN0aW9uXCJdLFxuICAgIFwidGFyZ2V0XCI6IFsxXSxcbiAgICBcInR5cGVcIjogWzFdLFxuICAgIFwibXVsdGlwbGVJbnB1dHNcIjogWzMyXSxcbiAgICBcImZvY3VzYWJsZVwiOiBbMzJdLFxuICAgIFwiY291bnRlclN0cmluZ1wiOiBbMzJdXG4gIH0sIFtbMCwgXCJpb25DaGFuZ2VcIiwgXCJoYW5kbGVJb25DaGFuZ2VcIl0sIFswLCBcImlvbkNvbG9yXCIsIFwibGFiZWxDb2xvckNoYW5nZWRcIl0sIFswLCBcImlvblN0eWxlXCIsIFwiaXRlbVN0eWxlXCJdXV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWl0ZW1cIiwgXCJpb24taWNvblwiLCBcImlvbi1ub3RlXCIsIFwiaW9uLXJpcHBsZS1lZmZlY3RcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1pdGVtXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgSXRlbSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW9uLWljb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkMygpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlvbi1ub3RlXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDIoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpb24tcmlwcGxlLWVmZmVjdFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuZXhwb3J0IHsgSXRlbSBhcyBJLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBJIGFzIEl0ZW0sIGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxIH0gZnJvbSAnLi9pdGVtLmpzJztcblxuY29uc3QgSW9uSXRlbSA9IEl0ZW07XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25JdGVtLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuLyoqXG4gKiBCYXNlZCBvbjpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNDgwMDkveS1jb29yZGluYXRlLWZvci1hLWdpdmVuLXgtY3ViaWMtYmV6aWVyXG4gKiBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzI2ODQ2L2lzLXRoZXJlLWFuLWV4cGxpY2l0LWZvcm0tZm9yLWN1YmljLWIlQzMlQTl6aWVyLWN1cnZlc1xuICogVE9ETzogUmVkdWNlIHJvdW5kaW5nIGVycm9yXG4gKi9cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKiBHaXZlbiBhIGN1YmljLWJlemllciBjdXJ2ZSwgZ2V0IHRoZSB4IHZhbHVlICh0aW1lKSBnaXZlblxuICogdGhlIHkgdmFsdWUgKHByb2dyZXNzaW9uKS5cbiAqIEV4OiBjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSk7XG4gKiBQMDogKDAsIDApXG4gKiBQMTogKDAuMzIsIDAuNzIpXG4gKiBQMjogKDAsIDEpXG4gKiBQMzogKDEsIDEpXG4gKlxuICogSWYgeW91IGdpdmUgYSBjdWJpYyBiZXppZXIgY3VydmUgdGhhdCBuZXZlciByZWFjaGVzIHRoZVxuICogcHJvdmlkZWQgcHJvZ3Jlc3Npb24sIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gKi9cbmNvbnN0IGdldFRpbWVHaXZlblByb2dyZXNzaW9uID0gKHAwLCBwMSwgcDIsIHAzLCBwcm9ncmVzc2lvbikgPT4ge1xuICByZXR1cm4gc29sdmVDdWJpY0JlemllcihwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgcHJvZ3Jlc3Npb24pLm1hcCh0VmFsdWUgPT4ge1xuICAgIHJldHVybiBzb2x2ZUN1YmljUGFyYW1ldHJpY0VxdWF0aW9uKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB0VmFsdWUpO1xuICB9KTtcbn07XG4vKipcbiAqIFNvbHZlIGEgY3ViaWMgZXF1YXRpb24gaW4gb25lIGRpbWVuc2lvbiAodGltZSlcbiAqL1xuY29uc3Qgc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbiA9IChwMCwgcDEsIHAyLCBwMywgdCkgPT4ge1xuICBjb25zdCBwYXJ0QSA9ICgzICogcDEpICogTWF0aC5wb3codCAtIDEsIDIpO1xuICBjb25zdCBwYXJ0QiA9ICgtMyAqIHAyICogdCkgKyAoMyAqIHAyKSArIChwMyAqIHQpO1xuICBjb25zdCBwYXJ0QyA9IHAwICogTWF0aC5wb3codCAtIDEsIDMpO1xuICByZXR1cm4gdCAqIChwYXJ0QSArICh0ICogcGFydEIpKSAtIHBhcnRDO1xufTtcbi8qKlxuICogRmluZCB0aGUgYHRgIHZhbHVlIGZvciBhIGN1YmljIGJlemllciB1c2luZyBDYXJkYW5vJ3MgZm9ybXVsYVxuICovXG5jb25zdCBzb2x2ZUN1YmljQmV6aWVyID0gKHAwLCBwMSwgcDIsIHAzLCByZWZQb2ludCkgPT4ge1xuICBwMCAtPSByZWZQb2ludDtcbiAgcDEgLT0gcmVmUG9pbnQ7XG4gIHAyIC09IHJlZlBvaW50O1xuICBwMyAtPSByZWZQb2ludDtcbiAgY29uc3Qgcm9vdHMgPSBzb2x2ZUN1YmljRXF1YXRpb24ocDMgLSAzICogcDIgKyAzICogcDEgLSBwMCwgMyAqIHAyIC0gNiAqIHAxICsgMyAqIHAwLCAzICogcDEgLSAzICogcDAsIHAwKTtcbiAgcmV0dXJuIHJvb3RzLmZpbHRlcihyb290ID0+IHJvb3QgPj0gMCAmJiByb290IDw9IDEpO1xufTtcbmNvbnN0IHNvbHZlUXVhZHJhdGljRXF1YXRpb24gPSAoYSwgYiwgYykgPT4ge1xuICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSksXG4gICAgICAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpXG4gICAgXTtcbiAgfVxufTtcbmNvbnN0IHNvbHZlQ3ViaWNFcXVhdGlvbiA9IChhLCBiLCBjLCBkKSA9PiB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIHNvbHZlUXVhZHJhdGljRXF1YXRpb24oYiwgYywgZCk7XG4gIH1cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcbiAgY29uc3QgcCA9ICgzICogYyAtIGIgKiBiKSAvIDM7XG4gIGNvbnN0IHEgPSAoMiAqIGIgKiBiICogYiAtIDkgKiBiICogYyArIDI3ICogZCkgLyAyNztcbiAgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGgucG93KC1xLCAxIC8gMyldO1xuICB9XG4gIGVsc2UgaWYgKHEgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGguc3FydCgtcCksIC1NYXRoLnNxcnQoLXApXTtcbiAgfVxuICBjb25zdCBkaXNjcmltaW5hbnQgPSBNYXRoLnBvdyhxIC8gMiwgMikgKyBNYXRoLnBvdyhwIC8gMywgMyk7XG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGgucG93KHEgLyAyLCAxIC8gMikgLSBiIC8gM107XG4gIH1cbiAgZWxzZSBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHJldHVybiBbTWF0aC5wb3coLShxIC8gMikgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSwgMSAvIDMpIC0gTWF0aC5wb3coKHEgLyAyKSArIE1hdGguc3FydChkaXNjcmltaW5hbnQpLCAxIC8gMykgLSBiIC8gM107XG4gIH1cbiAgY29uc3QgciA9IE1hdGguc3FydChNYXRoLnBvdygtKHAgLyAzKSwgMykpO1xuICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoLShxIC8gKDIgKiBNYXRoLnNxcnQoTWF0aC5wb3coLShwIC8gMyksIDMpKSkpKTtcbiAgY29uc3QgcyA9IDIgKiBNYXRoLnBvdyhyLCAxIC8gMyk7XG4gIHJldHVybiBbXG4gICAgcyAqIE1hdGguY29zKHBoaSAvIDMpIC0gYiAvIDMsXG4gICAgcyAqIE1hdGguY29zKChwaGkgKyAyICogTWF0aC5QSSkgLyAzKSAtIGIgLyAzLFxuICAgIHMgKiBNYXRoLmNvcygocGhpICsgNCAqIE1hdGguUEkpIC8gMykgLSBiIC8gM1xuICBdO1xufTtcblxuZXhwb3J0IHsgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gYXMgZyB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGMgYXMgY29tcG9uZW50T25SZWFkeSB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmNvbnN0IGF0dGFjaENvbXBvbmVudCA9IGFzeW5jIChkZWxlZ2F0ZSwgY29udGFpbmVyLCBjb21wb25lbnQsIGNzc0NsYXNzZXMsIGNvbXBvbmVudFByb3BzLCBpbmxpbmUpID0+IHtcbiAgaWYgKGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGRlbGVnYXRlLmF0dGFjaFZpZXdUb0RvbShjb250YWluZXIsIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIGNzc0NsYXNzZXMpO1xuICB9XG4gIGlmICghaW5saW5lICYmIHR5cGVvZiBjb21wb25lbnQgIT09ICdzdHJpbmcnICYmICEoY29tcG9uZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcmFtZXdvcmsgZGVsZWdhdGUgaXMgbWlzc2luZycpO1xuICB9XG4gIGNvbnN0IGVsID0gKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgJiYgY29udGFpbmVyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpXG4gICAgOiBjb21wb25lbnQ7XG4gIGlmIChjc3NDbGFzc2VzKSB7XG4gICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIH1cbiAgaWYgKGNvbXBvbmVudFByb3BzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbCwgY29tcG9uZW50UHJvcHMpO1xuICB9XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShlbCwgcmVzb2x2ZSkpO1xuICByZXR1cm4gZWw7XG59O1xuY29uc3QgZGV0YWNoQ29tcG9uZW50ID0gKGRlbGVnYXRlLCBlbGVtZW50KSA9PiB7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gZGVsZWdhdGUucmVtb3ZlVmlld0Zyb21Eb20oY29udGFpbmVyLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuY29uc3QgQ29yZURlbGVnYXRlID0gKCkgPT4ge1xuICBsZXQgQmFzZUNvbXBvbmVudDtcbiAgbGV0IFJlZmVyZW5jZTtcbiAgY29uc3QgYXR0YWNoVmlld1RvRG9tID0gYXN5bmMgKHBhcmVudEVsZW1lbnQsIHVzZXJDb21wb25lbnQsIHVzZXJDb21wb25lbnRQcm9wcyA9IHt9LCBjc3NDbGFzc2VzID0gW10pID0+IHtcbiAgICBCYXNlQ29tcG9uZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBJZiBwYXNzaW5nIGluIGEgY29tcG9uZW50IHZpYSB0aGUgYGNvbXBvbmVudGAgcHJvcHNcbiAgICAgKiB3ZSBuZWVkIHRvIGFwcGVuZCBpdCBpbnNpZGUgb2Ygb3VyIG92ZXJsYXkgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGlmICh1c2VyQ29tcG9uZW50KSB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHBhc3NpbmcgaW4gdGhlIHRhZyBuYW1lLCBjcmVhdGVcbiAgICAgICAqIHRoZSBlbGVtZW50IG90aGVyd2lzZSBqdXN0IGdldCBhIHJlZmVyZW5jZVxuICAgICAgICogdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZWwgPSAodHlwZW9mIHVzZXJDb21wb25lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICA/IEJhc2VDb21wb25lbnQub3duZXJEb2N1bWVudCAmJiBCYXNlQ29tcG9uZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh1c2VyQ29tcG9uZW50KVxuICAgICAgICA6IHVzZXJDb21wb25lbnQ7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbnkgY3NzIGNsYXNzZXMgcGFzc2VkIGluXG4gICAgICAgKiB2aWEgdGhlIGNzc0NsYXNzZXMgcHJvcCBvbiB0aGUgb3ZlcmxheS5cbiAgICAgICAqL1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbnkgcHJvcHMgcGFzc2VkIGluXG4gICAgICAgKiB2aWEgdGhlIGNvbXBvbmVudFByb3BzIHByb3Agb24gdGhlIG92ZXJsYXkuXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5hc3NpZ24oZWwsIHVzZXJDb21wb25lbnRQcm9wcyk7XG4gICAgICAvKipcbiAgICAgICAqIEZpbmFsbHksIGFwcGVuZCB0aGUgY29tcG9uZW50XG4gICAgICAgKiBpbnNpZGUgb2YgdGhlIG92ZXJsYXkgY29tcG9uZW50LlxuICAgICAgICovXG4gICAgICBCYXNlQ29tcG9uZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShlbCwgcmVzb2x2ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCYXNlQ29tcG9uZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvbXBvbmVudCwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBwYXJlbnRcbiAgICAgIC8vIGVsZW1lbnQgdG8gYXBwbHkgdGhlIGNzcyBjbGFzc2VzIHRvLlxuICAgICAgY29uc3QgZWwgPSBCYXNlQ29tcG9uZW50Lm93bmVyRG9jdW1lbnQgJiYgQmFzZUNvbXBvbmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgICAvLyBNb3ZlIGVhY2ggY2hpbGQgZnJvbSB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdG8gdGhlIG5ldyBwYXJlbnQgZWxlbWVudC5cbiAgICAgIGVsLmFwcGVuZCguLi5CYXNlQ29tcG9uZW50LmNoaWxkcmVuKTtcbiAgICAgIC8vIEFwcGVuZCB0aGUgbmV3IHBhcmVudCBlbGVtZW50IHRvIHRoZSBvcmlnaW5hbCBwYXJlbnQgZWxlbWVudC5cbiAgICAgIEJhc2VDb21wb25lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvb3Qgb2YgdGhlIGFwcCBhbmRcbiAgICAgKiBhZGQgdGhlIG92ZXJsYXkgdGhlcmUuXG4gICAgICovXG4gICAgY29uc3QgYXBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLWFwcCcpIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGxhY2Vob2xkZXIgY29tbWVudCBzbyB0aGF0XG4gICAgICogd2UgY2FuIHJldHVybiB0aGlzIGNvbXBvbmVudCB0byB3aGVyZVxuICAgICAqIGl0IHdhcyBwcmV2aW91c2x5LlxuICAgICAqL1xuICAgIFJlZmVyZW5jZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ2lvbmljIHRlbGVwb3J0Jyk7XG4gICAgQmFzZUNvbXBvbmVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShSZWZlcmVuY2UsIEJhc2VDb21wb25lbnQpO1xuICAgIGFwcC5hcHBlbmRDaGlsZChCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFzZUNvbXBvbmVudDtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlVmlld0Zyb21Eb20gPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGNvbXBvbmVudCB0byB3aGVyZSBpdCB3YXMgcHJldmlvdXNseSBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGlmIChCYXNlQ29tcG9uZW50ICYmIFJlZmVyZW5jZSkge1xuICAgICAgUmVmZXJlbmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKEJhc2VDb21wb25lbnQsIFJlZmVyZW5jZSk7XG4gICAgICBSZWZlcmVuY2UucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcmV0dXJuIHsgYXR0YWNoVmlld1RvRG9tLCByZW1vdmVWaWV3RnJvbURvbSB9O1xufTtcblxuZXhwb3J0IHsgQ29yZURlbGVnYXRlIGFzIEMsIGF0dGFjaENvbXBvbmVudCBhcyBhLCBkZXRhY2hDb21wb25lbnQgYXMgZCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlLCBjIGFzIGNvbmZpZyB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gfSBmcm9tICcuL2N1YmljLWJlemllci5qcyc7XG5pbXBvcnQgeyBhIGFzIGF0dGFjaENvbXBvbmVudCwgZCBhcyBkZXRhY2hDb21wb25lbnQgfSBmcm9tICcuL2ZyYW1ld29yay1kZWxlZ2F0ZS5qcyc7XG5pbXBvcnQgeyBzIGFzIHNoYWxsb3dFcXVhbFN0cmluZ01hcCB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyB0IGFzIHRyYW5zaXRpb24gfSBmcm9tICcuL2luZGV4NC5qcyc7XG5cbmNvbnN0IHJvdXRlT3V0bGV0Q3NzID0gXCI6aG9zdHtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTtjb250YWluOmxheW91dCBzaXplIHN0eWxlO292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjB9XCI7XG5cbmNvbnN0IFJvdXRlck91dGxldCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pb25OYXZXaWxsTG9hZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uTmF2V2lsbExvYWRcIiwgNyk7XG4gICAgdGhpcy5pb25OYXZXaWxsQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25OYXZXaWxsQ2hhbmdlXCIsIDMpO1xuICAgIHRoaXMuaW9uTmF2RGlkQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25OYXZEaWRDaGFuZ2VcIiwgMyk7XG4gICAgdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGUgZGV0ZXJtaW5lcyB3aGljaCBwbGF0Zm9ybSBzdHlsZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgcm91dGVyLW91dGxldCBzaG91bGQgYW5pbWF0ZSB0aGUgdHJhbnNpdGlvbiBvZiBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICB9XG4gIHN3aXBlSGFuZGxlckNoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuZ2VzdHVyZSkge1xuICAgICAgdGhpcy5nZXN0dXJlLmVuYWJsZSh0aGlzLnN3aXBlSGFuZGxlciAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3Qgb25TdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zd2lwZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5zd2lwZUhhbmRsZXIub25TdGFydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXN0dXJlID0gKGF3YWl0IGltcG9ydCgnLi9zd2lwZS1iYWNrLmpzJykpLmNyZWF0ZVN3aXBlQmFja0dlc3R1cmUodGhpcy5lbCwgKCkgPT4gIXRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyAmJiAhIXRoaXMuc3dpcGVIYW5kbGVyICYmIHRoaXMuc3dpcGVIYW5kbGVyLmNhblN0YXJ0KCksICgpID0+IG9uU3RhcnQoKSwgc3RlcCA9PiB0aGlzLmFuaSAmJiB0aGlzLmFuaS5wcm9ncmVzc1N0ZXAoc3RlcCksIChzaG91bGRDb21wbGV0ZSwgc3RlcCwgZHVyKSA9PiB7XG4gICAgICBpZiAodGhpcy5hbmkpIHtcbiAgICAgICAgdGhpcy5hbmkub25GaW5pc2goKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0aGlzLnN3aXBlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zd2lwZUhhbmRsZXIub25FbmQoc2hvdWxkQ29tcGxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBvbmVUaW1lQ2FsbGJhY2s6IHRydWUgfSk7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHJvdW5kaW5nIGVycm9ycyBpbiBKU1xuICAgICAgICBsZXQgbmV3U3RlcFZhbHVlID0gKHNob3VsZENvbXBsZXRlKSA/IC0wLjAwMSA6IDAuMDAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW5pbWF0aW9uIHdpbGwgYmUgcmV2ZXJzZWQgaGVyZSwgc28gbmVlZCB0b1xuICAgICAgICAgKiByZXZlcnNlIHRoZSBlYXNpbmcgY3VydmUgYXMgd2VsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBBZGRpdGlvbmFsbHksIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHRpbWUgcmVsYXRpdmVcbiAgICAgICAgICogdG8gdGhlIG5ldyBlYXNpbmcgY3VydmUsIGFzIGBzdGVwVmFsdWVgIGlzIGdvaW5nIHRvIGJlIGdpdmVuXG4gICAgICAgICAqIGluIHRlcm1zIG9mIGEgbGluZWFyIGN1cnZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgIHRoaXMuYW5pLmVhc2luZygnY3ViaWMtYmV6aWVyKDEsIDAsIDAuNjgsIDAuMjgpJyk7XG4gICAgICAgICAgbmV3U3RlcFZhbHVlICs9IGdldFRpbWVHaXZlblByb2dyZXNzaW9uKFswLCAwXSwgWzEsIDBdLCBbMC42OCwgMC4yOF0sIFsxLCAxXSwgc3RlcClbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3U3RlcFZhbHVlICs9IGdldFRpbWVHaXZlblByb2dyZXNzaW9uKFswLCAwXSwgWzAuMzIsIDAuNzJdLCBbMCwgMV0sIFsxLCAxXSwgc3RlcClbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmkucHJvZ3Jlc3NFbmQoc2hvdWxkQ29tcGxldGUgPyAxIDogMCwgbmV3U3RlcFZhbHVlLCBkdXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3dpcGVIYW5kbGVyQ2hhbmdlZCgpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW9uTmF2V2lsbExvYWQuZW1pdCgpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmdlc3R1cmUpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmdlc3R1cmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgY29tbWl0KGVudGVyaW5nRWwsIGxlYXZpbmdFbCwgb3B0cykge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubG9jaygpO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNoYW5nZWQgPSBhd2FpdCB0aGlzLnRyYW5zaXRpb24oZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHVubG9jaygpO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgc2V0Um91dGVJZChpZCwgcGFyYW1zLCBkaXJlY3Rpb24sIGFuaW1hdGlvbikge1xuICAgIGNvbnN0IGNoYW5nZWQgPSBhd2FpdCB0aGlzLnNldFJvb3QoaWQsIHBhcmFtcywge1xuICAgICAgZHVyYXRpb246IGRpcmVjdGlvbiA9PT0gJ3Jvb3QnID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uID09PSAnYmFjaycgPyAnYmFjaycgOiAnZm9yd2FyZCcsXG4gICAgICBhbmltYXRpb25CdWlsZGVyOiBhbmltYXRpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZCxcbiAgICAgIGVsZW1lbnQ6IHRoaXMuYWN0aXZlRWxcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZ2V0Um91dGVJZCgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZUVsO1xuICAgIHJldHVybiBhY3RpdmUgPyB7XG4gICAgICBpZDogYWN0aXZlLnRhZ05hbWUsXG4gICAgICBlbGVtZW50OiBhY3RpdmUsXG4gICAgICBwYXJhbXM6IHRoaXMuYWN0aXZlUGFyYW1zLFxuICAgIH0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgc2V0Um9vdChjb21wb25lbnQsIHBhcmFtcywgb3B0cykge1xuICAgIGlmICh0aGlzLmFjdGl2ZUNvbXBvbmVudCA9PT0gY29tcG9uZW50ICYmIHNoYWxsb3dFcXVhbFN0cmluZ01hcChwYXJhbXMsIHRoaXMuYWN0aXZlUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhdHRhY2ggZW50ZXJpbmcgdmlldyB0byBET01cbiAgICBjb25zdCBsZWF2aW5nRWwgPSB0aGlzLmFjdGl2ZUVsO1xuICAgIGNvbnN0IGVudGVyaW5nRWwgPSBhd2FpdCBhdHRhY2hDb21wb25lbnQodGhpcy5kZWxlZ2F0ZSwgdGhpcy5lbCwgY29tcG9uZW50LCBbJ2lvbi1wYWdlJywgJ2lvbi1wYWdlLWludmlzaWJsZSddLCBwYXJhbXMpO1xuICAgIHRoaXMuYWN0aXZlQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuYWN0aXZlRWwgPSBlbnRlcmluZ0VsO1xuICAgIHRoaXMuYWN0aXZlUGFyYW1zID0gcGFyYW1zO1xuICAgIC8vIGNvbW1pdCBhbmltYXRpb25cbiAgICBhd2FpdCB0aGlzLmNvbW1pdChlbnRlcmluZ0VsLCBsZWF2aW5nRWwsIG9wdHMpO1xuICAgIGF3YWl0IGRldGFjaENvbXBvbmVudCh0aGlzLmRlbGVnYXRlLCBsZWF2aW5nRWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIHRyYW5zaXRpb24oZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzID0ge30pIHtcbiAgICBpZiAobGVhdmluZ0VsID09PSBlbnRlcmluZ0VsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVtaXQgbmF2IHdpbGwgY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5pb25OYXZXaWxsQ2hhbmdlLmVtaXQoKTtcbiAgICBjb25zdCB7IGVsLCBtb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1hdGVkID0gdGhpcy5hbmltYXRlZCAmJiBjb25maWcuZ2V0Qm9vbGVhbignYW5pbWF0ZWQnLCB0cnVlKTtcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gb3B0cy5hbmltYXRpb25CdWlsZGVyIHx8IHRoaXMuYW5pbWF0aW9uIHx8IGNvbmZpZy5nZXQoJ25hdkFuaW1hdGlvbicpO1xuICAgIGF3YWl0IHRyYW5zaXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbW9kZSxcbiAgICAgIGFuaW1hdGVkLFxuICAgICAgZW50ZXJpbmdFbCxcbiAgICAgIGxlYXZpbmdFbCwgYmFzZUVsOiBlbCwgcHJvZ3Jlc3NDYWxsYmFjazogKG9wdHMucHJvZ3Jlc3NBbmltYXRpb25cbiAgICAgICAgPyBhbmkgPT4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJlY2F1c2UgdGhpcyBwcm9ncmVzcyBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgKiBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGdlc3R1cmUgdG8gc3RhcnQgYW5kIGVuZCBiZWZvcmVcbiAgICAgICAgICAgKiB0aGUgYW5pbWF0aW9uIGlzIGV2ZXIgc2V0LiBJbiB0aGF0IHNjZW5hcmlvLCB3ZSBzaG91bGRcbiAgICAgICAgICAgKiBpbW1lZGlhdGVseSBjYWxsIHByb2dyZXNzRW5kIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gcHJvbWlzZVxuICAgICAgICAgICAqIHJlc29sdmVzIGFuZCB0aGUgZ2VzdHVyZSBkb2VzIG5vdCBnZXQgbG9ja2VkIHVwLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChhbmkgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgYW5pLm9uRmluaXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN3aXBlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpcGVIYW5kbGVyLm9uRW5kKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyBvbmVUaW1lQ2FsbGJhY2s6IHRydWUgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBsYXlpbmcgYW5pbWF0aW9uIHRvIGJlZ2lubmluZ1xuICAgICAgICAgICAgICogd2l0aCBhIGR1cmF0aW9uIG9mIDAgcHJldmVudHNcbiAgICAgICAgICAgICAqIGFueSBmbGlja2VyaW5nIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICogaXMgbGF0ZXIgY2xlYW5lZCB1cC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW5pLnByb2dyZXNzRW5kKDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5pID0gYW5pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCkgfSwgb3B0cyksIHsgYW5pbWF0aW9uQnVpbGRlciB9KSk7XG4gICAgLy8gZW1pdCBuYXYgY2hhbmdlZCBldmVudFxuICAgIHRoaXMuaW9uTmF2RGlkQ2hhbmdlLmVtaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBsb2NrKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLndhaXRQcm9taXNlO1xuICAgIGxldCByZXNvbHZlO1xuICAgIHRoaXMud2FpdFByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgICBpZiAocCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhd2FpdCBwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChoKFwic2xvdFwiLCBudWxsKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwic3dpcGVIYW5kbGVyXCI6IFtcInN3aXBlSGFuZGxlckNoYW5nZWRcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gcm91dGVPdXRsZXRDc3M7IH1cbn0sIFsxLCBcImlvbi1yb3V0ZXItb3V0bGV0XCIsIHtcbiAgICBcIm1vZGVcIjogWzEwMjVdLFxuICAgIFwiZGVsZWdhdGVcIjogWzE2XSxcbiAgICBcImFuaW1hdGVkXCI6IFs0XSxcbiAgICBcImFuaW1hdGlvblwiOiBbMTZdLFxuICAgIFwic3dpcGVIYW5kbGVyXCI6IFsxNl0sXG4gICAgXCJjb21taXRcIjogWzY0XSxcbiAgICBcInNldFJvdXRlSWRcIjogWzY0XSxcbiAgICBcImdldFJvdXRlSWRcIjogWzY0XVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1yb3V0ZXItb3V0bGV0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tcm91dGVyLW91dGxldFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFJvdXRlck91dGxldCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uUm91dGVyT3V0bGV0ID0gUm91dGVyT3V0bGV0O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQkMTtcblxuZXhwb3J0IHsgSW9uUm91dGVyT3V0bGV0LCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgY3JlYXRlRXZlbnQsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZUNvbG9yQ2xhc3NlcyB9IGZyb20gJy4vdGhlbWUuanMnO1xuXG5jb25zdCB0YWJCYXJJb3NDc3MgPSBcIjpob3N0e3BhZGRpbmctbGVmdDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOmF1dG87cGFkZGluZy1ib3R0b206dmFyKC0taW9uLXNhZmUtYXJlYS1ib3R0b20sIDApO2JvcmRlci10b3A6dmFyKC0tYm9yZGVyKTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNvbG9yKTt0ZXh0LWFsaWduOmNlbnRlcjtjb250YWluOnN0cmljdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7ei1pbmRleDoxMDstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudDtib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnR9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpfX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pey0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1zaGFkZSk7LS1jb2xvci1zZWxlY3RlZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpLDpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7Y29sb3I6cmdiYSh2YXIoLS1pb24tY29sb3ItY29udHJhc3QtcmdiKSwgMC43KX06aG9zdCguaW9uLWNvbG9yKSw6aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCksOmhvc3QoLnRhYi1iYXItdHJhbnNsdWNlbnQpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCl7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQpfTpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9Omhvc3QoW3Nsb3Q9dG9wXSl7cGFkZGluZy10b3A6dmFyKC0taW9uLXNhZmUtYXJlYS10b3AsIDApO3BhZGRpbmctYm90dG9tOjA7Ym9yZGVyLXRvcDowO2JvcmRlci1ib3R0b206dmFyKC0tYm9yZGVyKX06aG9zdCgudGFiLWJhci1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0ey0tYmFja2dyb3VuZDp2YXIoLS1pb24tdGFiLWJhci1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tY29sb3Itc3RlcC01MCwgI2Y3ZjdmNykpOy0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi10YWItYmFyLWJhY2tncm91bmQtZm9jdXNlZCwgI2UwZTBlMCk7LS1ib3JkZXI6MC41NXB4IHNvbGlkIHZhcigtLWlvbi10YWItYmFyLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCByZ2JhKDAsIDAsIDAsIDAuMikpKSk7LS1jb2xvcjp2YXIoLS1pb24tdGFiLWJhci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtNDAwLCAjOTk5OTk5KSk7LS1jb2xvci1zZWxlY3RlZDp2YXIoLS1pb24tdGFiLWJhci1jb2xvci1zZWxlY3RlZCwgdmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpKTtoZWlnaHQ6NTBweH1Ac3VwcG9ydHMgKCgtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cigwKSkgb3IgKGJhY2tkcm9wLWZpbHRlcjogYmx1cigwKSkpezpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KXstLWJhY2tncm91bmQ6cmdiYSh2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpLCAwLjgpOy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDIxMCUpIGJsdXIoMjBweCk7YmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDIxMCUpIGJsdXIoMjBweCl9Omhvc3QoLmlvbi1jb2xvci50YWItYmFyLXRyYW5zbHVjZW50KXtiYWNrZ3JvdW5kOnJnYmEodmFyKC0taW9uLWNvbG9yLWJhc2UtcmdiKSwgMC44KX06aG9zdCgudGFiLWJhci10cmFuc2x1Y2VudCkgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uLmlvbi1mb2N1c2VkKXtiYWNrZ3JvdW5kOnJnYmEodmFyKC0taW9uLWJhY2tncm91bmQtY29sb3ItcmdiLCAyNTUsIDI1NSwgMjU1KSwgMC42KX19XCI7XG5cbmNvbnN0IHRhYkJhck1kQ3NzID0gXCI6aG9zdHtwYWRkaW5nLWxlZnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDphdXRvO3BhZGRpbmctYm90dG9tOnZhcigtLWlvbi1zYWZlLWFyZWEtYm90dG9tLCAwKTtib3JkZXItdG9wOnZhcigtLWJvcmRlcik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcik7dGV4dC1hbGlnbjpjZW50ZXI7Y29udGFpbjpzdHJpY3Q7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3otaW5kZXg6MTA7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnQ7Ym94LXNpemluZzpjb250ZW50LWJveCAhaW1wb3J0YW50fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KX19Omhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tY29sb3Itc2hhZGUpOy0tY29sb3Itc2VsZWN0ZWQ6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoLnRhYi1zZWxlY3RlZCl7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yKSw6aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2NvbG9yOnJnYmEodmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0LXJnYiksIDAuNyl9Omhvc3QoLmlvbi1jb2xvciksOmhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXtiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24uaW9uLWZvY3VzZWQpLDpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24uaW9uLWZvY3VzZWQpe2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKX06aG9zdCgudGFiLWJhci10cmFuc2x1Y2VudCkgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fTpob3N0KFtzbG90PXRvcF0pe3BhZGRpbmctdG9wOnZhcigtLWlvbi1zYWZlLWFyZWEtdG9wLCAwKTtwYWRkaW5nLWJvdHRvbTowO2JvcmRlci10b3A6MDtib3JkZXItYm90dG9tOnZhcigtLWJvcmRlcil9Omhvc3QoLnRhYi1iYXItaGlkZGVuKXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudH06aG9zdHstLWJhY2tncm91bmQ6dmFyKC0taW9uLXRhYi1iYXItYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKTstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tdGFiLWJhci1iYWNrZ3JvdW5kLWZvY3VzZWQsICNlMGUwZTApOy0tYm9yZGVyOjFweCBzb2xpZCB2YXIoLS1pb24tdGFiLWJhci1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1jb2xvci1zdGVwLTE1MCwgcmdiYSgwLCAwLCAwLCAwLjA3KSkpKTstLWNvbG9yOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLCB2YXIoLS1pb24tY29sb3Itc3RlcC02MDAsICM2NjY2NjYpKTstLWNvbG9yLXNlbGVjdGVkOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLXNlbGVjdGVkLCB2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZikpO2hlaWdodDo1NnB4fVwiO1xuXG5jb25zdCBUYWJCYXIgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uVGFiQmFyQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uVGFiQmFyQ2hhbmdlZFwiLCA3KTtcbiAgICB0aGlzLmtleWJvYXJkVmlzaWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHRhYiBiYXIgd2lsbCBiZSB0cmFuc2x1Y2VudC5cbiAgICAgKiBPbmx5IGFwcGxpZXMgd2hlbiB0aGUgbW9kZSBpcyBgXCJpb3NcImAgYW5kIHRoZSBkZXZpY2Ugc3VwcG9ydHNcbiAgICAgKiBbYGJhY2tkcm9wLWZpbHRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9iYWNrZHJvcC1maWx0ZXIjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zbHVjZW50ID0gZmFsc2U7XG4gIH1cbiAgc2VsZWN0ZWRUYWJDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVGFiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW9uVGFiQmFyQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgdGFiOiB0aGlzLnNlbGVjdGVkVGFiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5zZWxlY3RlZFRhYkNoYW5nZWQoKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMua2V5Ym9hcmRXaWxsU2hvd0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVsLmdldEF0dHJpYnV0ZSgnc2xvdCcpICE9PSAndG9wJykge1xuICAgICAgICAgIHRoaXMua2V5Ym9hcmRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5rZXlib2FyZFZpc2libGUgPSBmYWxzZSwgNTApO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxTaG93JywgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5Ym9hcmRXaWxsSGlkZScsIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxTaG93JywgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5Ym9hcmRXaWxsSGlkZScsIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIpO1xuICAgICAgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlciA9IHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbG9yLCB0cmFuc2x1Y2VudCwga2V5Ym9hcmRWaXNpYmxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IHJvbGU6IFwidGFibGlzdFwiLCBcImFyaWEtaGlkZGVuXCI6IGtleWJvYXJkVmlzaWJsZSA/ICd0cnVlJyA6IG51bGwsIGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXMoY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICAndGFiLWJhci10cmFuc2x1Y2VudCc6IHRyYW5zbHVjZW50LFxuICAgICAgICAndGFiLWJhci1oaWRkZW4nOiBrZXlib2FyZFZpc2libGUsXG4gICAgICB9KSB9LCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInNlbGVjdGVkVGFiXCI6IFtcInNlbGVjdGVkVGFiQ2hhbmdlZFwiXVxuICB9OyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiB0YWJCYXJJb3NDc3MsXG4gICAgbWQ6IHRhYkJhck1kQ3NzXG4gIH07IH1cbn0sIFszMywgXCJpb24tdGFiLWJhclwiLCB7XG4gICAgXCJjb2xvclwiOiBbNTEzXSxcbiAgICBcInNlbGVjdGVkVGFiXCI6IFsxLCBcInNlbGVjdGVkLXRhYlwiXSxcbiAgICBcInRyYW5zbHVjZW50XCI6IFs0XSxcbiAgICBcImtleWJvYXJkVmlzaWJsZVwiOiBbMzJdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRhYi1iYXJcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi10YWItYmFyXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgVGFiQmFyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25UYWJCYXIgPSBUYWJCYXI7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25UYWJCYXIsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCByZWFkVGFzaywgd3JpdGVUYXNrLCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuXG5jb25zdCByaXBwbGVFZmZlY3RDc3MgPSBcIjpob3N0e2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRhaW46c3RyaWN0O3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QoLnVuYm91bmRlZCl7Y29udGFpbjpsYXlvdXQgc2l6ZSBzdHlsZX0ucmlwcGxlLWVmZmVjdHtib3JkZXItcmFkaXVzOjUwJTtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjtjb2xvcjppbmhlcml0O2NvbnRhaW46c3RyaWN0O29wYWNpdHk6MDstd2Via2l0LWFuaW1hdGlvbjoyMjVtcyByaXBwbGVBbmltYXRpb24gZm9yd2FyZHMsIDc1bXMgZmFkZUluQW5pbWF0aW9uIGZvcndhcmRzO2FuaW1hdGlvbjoyMjVtcyByaXBwbGVBbmltYXRpb24gZm9yd2FyZHMsIDc1bXMgZmFkZUluQW5pbWF0aW9uIGZvcndhcmRzO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSwgb3BhY2l0eTtwb2ludGVyLWV2ZW50czpub25lfS5mYWRlLW91dHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKTstd2Via2l0LWFuaW1hdGlvbjoxNTBtcyBmYWRlT3V0QW5pbWF0aW9uIGZvcndhcmRzO2FuaW1hdGlvbjoxNTBtcyBmYWRlT3V0QW5pbWF0aW9uIGZvcndhcmRzfUAtd2Via2l0LWtleWZyYW1lcyByaXBwbGVBbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKTt0cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpfX1Aa2V5ZnJhbWVzIHJpcHBsZUFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2Zvcm06c2NhbGUoMSl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpO3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSl9fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5BbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MH10b3tvcGFjaXR5OjAuMTZ9fUBrZXlmcmFtZXMgZmFkZUluQW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtvcGFjaXR5OjB9dG97b3BhY2l0eTowLjE2fX1ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dEFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eTowLjE2fXRve29wYWNpdHk6MH19QGtleWZyYW1lcyBmYWRlT3V0QW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtvcGFjaXR5OjAuMTZ9dG97b3BhY2l0eTowfX1cIjtcblxuY29uc3QgUmlwcGxlRWZmZWN0ID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0eXBlIG9mIHJpcHBsZS1lZmZlY3Q6XG4gICAgICpcbiAgICAgKiAtIGBib3VuZGVkYDogdGhlIHJpcHBsZSBlZmZlY3QgZXhwYW5kcyBmcm9tIHRoZSB1c2VyJ3MgY2xpY2sgcG9zaXRpb25cbiAgICAgKiAtIGB1bmJvdW5kZWRgOiB0aGUgcmlwcGxlIGVmZmVjdCBleHBhbmRzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYnV0dG9uIGFuZCBvdmVyZmxvd3MgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIE5PVEU6IFN1cmZhY2VzIGZvciBib3VuZGVkIHJpcHBsZXMgc2hvdWxkIGhhdmUgdGhlIG92ZXJmbG93IHByb3BlcnR5IHNldCB0byBoaWRkZW4sXG4gICAgICogd2hpbGUgc3VyZmFjZXMgZm9yIHVuYm91bmRlZCByaXBwbGVzIHNob3VsZCBoYXZlIGl0IHNldCB0byB2aXNpYmxlLlxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9ICdib3VuZGVkJztcbiAgfVxuICAvKipcbiAgICogQWRkcyB0aGUgcmlwcGxlIGVmZmVjdCB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygd2hlcmUgdGhlIHJpcHBsZSBzaG91bGQgc3RhcnQuXG4gICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHdoZXJlIHRoZSByaXBwbGUgc2hvdWxkIHN0YXJ0LlxuICAgKi9cbiAgYXN5bmMgYWRkUmlwcGxlKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZWFkVGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gdGhpcy51bmJvdW5kZWQgPyBtYXhEaW0gOiBoeXBvdGVudXNlICsgUEFERElORztcbiAgICAgICAgY29uc3QgaW5pdGlhbFNpemUgPSBNYXRoLmZsb29yKG1heERpbSAqIElOSVRJQUxfT1JJR0lOX1NDQUxFKTtcbiAgICAgICAgY29uc3QgZmluYWxTY2FsZSA9IG1heFJhZGl1cyAvIGluaXRpYWxTaXplO1xuICAgICAgICBsZXQgcG9zWCA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgIGxldCBwb3NZID0geSAtIHJlY3QudG9wO1xuICAgICAgICBpZiAodGhpcy51bmJvdW5kZWQpIHtcbiAgICAgICAgICBwb3NYID0gd2lkdGggKiAwLjU7XG4gICAgICAgICAgcG9zWSA9IGhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZVggPSBwb3NYIC0gaW5pdGlhbFNpemUgKiAwLjU7XG4gICAgICAgIGNvbnN0IHN0eWxlWSA9IHBvc1kgLSBpbml0aWFsU2l6ZSAqIDAuNTtcbiAgICAgICAgY29uc3QgbW92ZVggPSB3aWR0aCAqIDAuNSAtIHBvc1g7XG4gICAgICAgIGNvbnN0IG1vdmVZID0gaGVpZ2h0ICogMC41IC0gcG9zWTtcbiAgICAgICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmlwcGxlLWVmZmVjdCcpO1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gZGl2LnN0eWxlO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IHN0eWxlWSArICdweCc7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IHN0eWxlWCArICdweCc7XG4gICAgICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSBpbml0aWFsU2l6ZSArICdweCc7XG4gICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoJy0tZmluYWwtc2NhbGUnLCBgJHtmaW5hbFNjYWxlfWApO1xuICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KCctLXRyYW5zbGF0ZS1lbmQnLCBgJHttb3ZlWH1weCwgJHttb3ZlWX1weGApO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZWwuc2hhZG93Um9vdCB8fCB0aGlzLmVsO1xuICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbW92ZVJpcHBsZShkaXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMjI1ICsgMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICd1bmJvdW5kZWQnO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICd1bmJvdW5kZWQnOiB0aGlzLnVuYm91bmRlZFxuICAgICAgfSB9KSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gcmlwcGxlRWZmZWN0Q3NzOyB9XG59LCBbMSwgXCJpb24tcmlwcGxlLWVmZmVjdFwiLCB7XG4gICAgXCJ0eXBlXCI6IFsxXSxcbiAgICBcImFkZFJpcHBsZVwiOiBbNjRdXG4gIH1dKTtcbmNvbnN0IHJlbW92ZVJpcHBsZSA9IChyaXBwbGUpID0+IHtcbiAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtb3V0Jyk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHJpcHBsZS5yZW1vdmUoKTtcbiAgfSwgMjAwKTtcbn07XG5jb25zdCBQQURESU5HID0gMTA7XG5jb25zdCBJTklUSUFMX09SSUdJTl9TQ0FMRSA9IDAuNTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1yaXBwbGUtZWZmZWN0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tcmlwcGxlLWVmZmVjdFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFJpcHBsZUVmZmVjdCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuZXhwb3J0IHsgUmlwcGxlRWZmZWN0IGFzIFIsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYyBhcyBjb25maWcsIGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQyIH0gZnJvbSAnLi9yaXBwbGUtZWZmZWN0LmpzJztcblxuY29uc3QgdGFiQnV0dG9uSW9zQ3NzID0gXCI6aG9zdHstLXJpcHBsZS1jb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCk7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eToxOy1tcy1mbGV4OjE7ZmxleDoxOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MTAwJTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcil9LmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLXJhZGl1czppbmhlcml0O21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtwYWRkaW5nLWxlZnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1yaWdodDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy10b3A6dmFyKC0tcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLXBhZGRpbmctYm90dG9tKTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtc3R5bGU6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7dGV4dC1pbmRlbnQ6aW5oZXJpdDt0ZXh0LW92ZXJmbG93OmluaGVyaXQ7dGV4dC10cmFuc2Zvcm06aW5oZXJpdDt0ZXh0LWFsaWduOmluaGVyaXQ7d2hpdGUtc3BhY2U6aW5oZXJpdDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlcjowO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O3RleHQtZGVjb3JhdGlvbjpub25lO2N1cnNvcjpwb2ludGVyO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5idXR0b24tbmF0aXZle3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0uYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDpcXFwiXFxcIjtvcGFjaXR5OjB9LmJ1dHRvbi1pbm5lcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1mbG93OmluaGVyaXQ7ZmxleC1mbG93OmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWNvbG9yLWZvY3VzZWQpfTpob3N0KC5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpe2E6aG92ZXJ7Y29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpfX06aG9zdCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCl9Omhvc3QoLnRhYi1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0KC50YWItZGlzYWJsZWQpe3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowLjR9OjpzbG90dGVkKGlvbi1sYWJlbCksOjpzbG90dGVkKGlvbi1pY29uKXtkaXNwbGF5OmJsb2NrOy1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO21heC13aWR0aDoxMDAlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9OjpzbG90dGVkKGlvbi1sYWJlbCl7LW1zLWZsZXgtb3JkZXI6MDtvcmRlcjowfTo6c2xvdHRlZChpb24taWNvbil7LW1zLWZsZXgtb3JkZXI6LTE7b3JkZXI6LTE7aGVpZ2h0OjFlbX06aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXt3aGl0ZS1zcGFjZTpub3JtYWx9OjpzbG90dGVkKGlvbi1iYWRnZSl7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MX06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KXstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd306aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCl7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKXstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWljb24pe2Rpc3BsYXk6bm9uZX06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXtkaXNwbGF5Om5vbmV9aW9uLXJpcHBsZS1lZmZlY3R7Y29sb3I6dmFyKC0tcmlwcGxlLWNvbG9yKX06aG9zdHstLXBhZGRpbmctdG9wOjA7LS1wYWRkaW5nLWVuZDoycHg7LS1wYWRkaW5nLWJvdHRvbTowOy0tcGFkZGluZy1zdGFydDoycHg7bWF4LXdpZHRoOjI0MHB4O2ZvbnQtc2l6ZToxMHB4fTo6c2xvdHRlZChpb24tYmFkZ2Upe3BhZGRpbmctbGVmdDo2cHg7cGFkZGluZy1yaWdodDo2cHg7cGFkZGluZy10b3A6MXB4O3BhZGRpbmctYm90dG9tOjFweDtsZWZ0OmNhbGMoNTAlICsgNnB4KTt0b3A6NHB4O2hlaWdodDphdXRvO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWJhZGdlKXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6NnB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjZweDstd2Via2l0LXBhZGRpbmctZW5kOjZweDtwYWRkaW5nLWlubGluZS1lbmQ6NnB4fX1bZGlyPXJ0bF0gOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyA2cHgpfTo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjMwcHh9OjpzbG90dGVkKGlvbi1pY29uOjpiZWZvcmUpe3ZlcnRpY2FsLWFsaWduOnRvcH06OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToxcHg7bWluLWhlaWdodDoxMXB4O2ZvbnQtd2VpZ2h0OjUwMH06aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuMX06aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjF9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24taWNvbiksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1pY29uKXttaW4td2lkdGg6MjRweDtoZWlnaHQ6MjZweDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjFweDtmb250LXNpemU6MjRweH06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDpjYWxjKDUwJSArIDEycHgpfTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWxheW91dC1pY29uLWJvdHRvbSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OmNhbGMoNTAlICsgMTJweCl9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MXB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjRweH06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDpjYWxjKDUwJSArIDM1cHgpO3RvcDoxMHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tc3RhcnQgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tZW5kIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyAzNXB4KX06aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6Y2FsYyg1MCUgKyAzMHB4KTt0b3A6MTBweH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24taGlkZSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWhhcy1sYWJlbC1vbmx5IDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyAzMHB4KX06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWhhcy1pY29uLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2Upe3RvcDoxMHB4fTpob3N0KC50YWItbGF5b3V0LWxhYmVsLWhpZGUpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfVwiO1xuXG5jb25zdCB0YWJCdXR0b25NZENzcyA9IFwiOmhvc3R7LS1yaXBwbGUtY29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpOy0tYmFja2dyb3VuZC1mb2N1c2VkLW9wYWNpdHk6MTstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7b3V0bGluZTpub25lO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tY29sb3IpfS5idXR0b24tbmF0aXZle2JvcmRlci1yYWRpdXM6aW5oZXJpdDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OnZhcigtLXBhZGRpbmctc3RhcnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOnZhcigtLXBhZGRpbmctdG9wKTtwYWRkaW5nLWJvdHRvbTp2YXIoLS1wYWRkaW5nLWJvdHRvbSk7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1wYWNrOmluaGVyaXQ7anVzdGlmeS1jb250ZW50OmluaGVyaXQ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDt0ZXh0LWRlY29yYXRpb246bm9uZTtjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtdXNlci1kcmFnOm5vbmV9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuYnV0dG9uLW5hdGl2ZXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7LXdlYmtpdC1wYWRkaW5nLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLXBhZGRpbmctZW5kKX19LmJ1dHRvbi1uYXRpdmU6OmFmdGVye2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7b3BhY2l0eTowfS5idXR0b24taW5uZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtZmxvdzppbmhlcml0O2ZsZXgtZmxvdzppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1wYWNrOmluaGVyaXQ7anVzdGlmeS1jb250ZW50OmluaGVyaXQ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjF9Omhvc3QoLmlvbi1mb2N1c2VkKSAuYnV0dG9uLW5hdGl2ZXtjb2xvcjp2YXIoLS1jb2xvci1mb2N1c2VkKX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtZm9jdXNlZCk7b3BhY2l0eTp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eSl9QG1lZGlhIChhbnktaG92ZXI6IGhvdmVyKXthOmhvdmVye2NvbG9yOnZhcigtLWNvbG9yLXNlbGVjdGVkKX19Omhvc3QoLnRhYi1zZWxlY3RlZCl7Y29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpfTpob3N0KC50YWItaGlkZGVuKXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudH06aG9zdCgudGFiLWRpc2FibGVkKXtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MC40fTo6c2xvdHRlZChpb24tbGFiZWwpLDo6c2xvdHRlZChpb24taWNvbil7ZGlzcGxheTpibG9jazstbXMtZmxleC1pdGVtLWFsaWduOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcjttYXgtd2lkdGg6MTAwJTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fTo6c2xvdHRlZChpb24tbGFiZWwpey1tcy1mbGV4LW9yZGVyOjA7b3JkZXI6MH06OnNsb3R0ZWQoaW9uLWljb24pey1tcy1mbGV4LW9yZGVyOi0xO29yZGVyOi0xO2hlaWdodDoxZW19Omhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1sYWJlbCl7d2hpdGUtc3BhY2U6bm9ybWFsfTo6c2xvdHRlZChpb24tYmFkZ2Upey13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjF9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCl7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpey1tcy1mbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSl7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1pY29uKXtkaXNwbGF5Om5vbmV9Omhvc3QoLnRhYi1sYXlvdXQtbGFiZWwtaGlkZSkgOjpzbG90dGVkKGlvbi1sYWJlbCl7ZGlzcGxheTpub25lfWlvbi1yaXBwbGUtZWZmZWN0e2NvbG9yOnZhcigtLXJpcHBsZS1jb2xvcil9Omhvc3R7LS1wYWRkaW5nLXRvcDowOy0tcGFkZGluZy1lbmQ6MTJweDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjEycHg7bWF4LXdpZHRoOjE2OHB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzowLjAzZW19OjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDt0ZXh0LXRyYW5zZm9ybTpub25lfTo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjE2cHg7bWFyZ2luLWJvdHRvbToxNnB4Oy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgY2VudGVyO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcjtmb250LXNpemU6MjJweH1bZGlyPXJ0bF0gOjpzbG90dGVkKGlvbi1pY29uKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgOjpzbG90dGVkKGlvbi1pY29uKXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2FsYygxMDAlIC0gY2VudGVyKSBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpjYWxjKDEwMCUgLSBjZW50ZXIpIGNlbnRlcn06OnNsb3R0ZWQoaW9uLWJhZGdlKXtib3JkZXItcmFkaXVzOjhweDtwYWRkaW5nLWxlZnQ6MnB4O3BhZGRpbmctcmlnaHQ6MnB4O3BhZGRpbmctdG9wOjNweDtwYWRkaW5nLWJvdHRvbToycHg7bGVmdDpjYWxjKDUwJSArIDZweCk7dG9wOjhweDttaW4td2lkdGg6MTJweDtmb250LXNpemU6OHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24tYmFkZ2Upe3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDoycHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MnB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6MnB4O3BhZGRpbmctaW5saW5lLWVuZDoycHh9fVtkaXI9cnRsXSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDpjYWxjKDUwJSArIDZweCl9OjpzbG90dGVkKGlvbi1iYWRnZTplbXB0eSl7ZGlzcGxheTpibG9jazttaW4td2lkdGg6OHB4O2hlaWdodDo4cHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi10b3ApIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDo2cHg7bWFyZ2luLWJvdHRvbToycHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi10b3ApIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjZweH06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDo3MCU7dG9wOjhweH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20gOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDo3MCV9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206NnB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjZweDttYXJnaW4tYm90dG9tOjB9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6ODAlO3RvcDoxNnB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tc3RhcnQgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tZW5kIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6ODAlfTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXJpZ2h0OjZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLWVuZDo2cHg7bWFyZ2luLWlubGluZS1lbmQ6NnB4fX06aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDo2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDo2cHg7bWFyZ2luLWlubGluZS1zdGFydDo2cHh9fTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDo3MCU7dG9wOjE2cHh9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWxheW91dC1pY29uLWhpZGUgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1oYXMtbGFiZWwtb25seSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjcwJX06aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tbGFiZWwpLDpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9Omhvc3QoLnRhYi1sYXlvdXQtbGFiZWwtaGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1oYXMtaWNvbi1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXt0b3A6MTZweH06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWljb24pLDpob3N0KC50YWItaGFzLWljb24tb25seSkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO2ZvbnQtc2l6ZToyNHB4fVwiO1xuXG5jb25zdCBUYWJCdXR0b24gPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uVGFiQnV0dG9uQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblRhYkJ1dHRvbkNsaWNrXCIsIDcpO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhlIHRhYiBidXR0b24uXG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RlZCB0YWIgY29tcG9uZW50XG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMub25LZXlVcCA9IChldikgPT4ge1xuICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICB0aGlzLnNlbGVjdFRhYihldik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0VGFiKGV2KTtcbiAgICB9O1xuICB9XG4gIG9uVGFiQmFyQ2hhbmdlZChldikge1xuICAgIGNvbnN0IGRpc3BhdGNoZWRGcm9tID0gZXYudGFyZ2V0O1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZWwucGFyZW50RWxlbWVudDtcbiAgICBpZiAoKGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhwYXJlbnQpKSB8fCAoZGlzcGF0Y2hlZEZyb20gJiYgZGlzcGF0Y2hlZEZyb20uY29udGFpbnModGhpcy5lbCkpKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy50YWIgPT09IGV2LmRldGFpbC50YWI7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGlmICh0aGlzLmxheW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxheW91dCA9IGNvbmZpZy5nZXQoJ3RhYkJ1dHRvbkxheW91dCcsICdpY29uLXRvcCcpO1xuICAgIH1cbiAgfVxuICBzZWxlY3RUYWIoZXYpIHtcbiAgICBpZiAodGhpcy50YWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuaW9uVGFiQnV0dG9uQ2xpY2suZW1pdCh7XG4gICAgICAgICAgdGFiOiB0aGlzLnRhYixcbiAgICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzTGFiZWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdpb24tbGFiZWwnKTtcbiAgfVxuICBnZXQgaGFzSWNvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1pY29uJyk7XG4gIH1cbiAgZ2V0IHRhYkluZGV4KCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IGhhc1RhYkluZGV4ID0gdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgaWYgKGhhc1RhYkluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBoYXNJY29uLCBoYXNMYWJlbCwgdGFiSW5kZXgsIGhyZWYsIHJlbCwgdGFyZ2V0LCBsYXlvdXQsIHNlbGVjdGVkLCB0YWIgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICBkb3dubG9hZDogdGhpcy5kb3dubG9hZCxcbiAgICAgIGhyZWYsXG4gICAgICByZWwsXG4gICAgICB0YXJnZXRcbiAgICB9O1xuICAgIHJldHVybiAoaChIb3N0LCB7IG9uQ2xpY2s6IHRoaXMub25DbGljaywgb25LZXl1cDogdGhpcy5vbktleVVwLCByb2xlOiBcInRhYlwiLCB0YWJpbmRleDogdGFiSW5kZXgsIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCA/ICd0cnVlJyA6IG51bGwsIGlkOiB0YWIgIT09IHVuZGVmaW5lZCA/IGB0YWItYnV0dG9uLSR7dGFifWAgOiBudWxsLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICd0YWItc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgJ3RhYi1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAndGFiLWhhcy1sYWJlbCc6IGhhc0xhYmVsLFxuICAgICAgICAndGFiLWhhcy1pY29uJzogaGFzSWNvbixcbiAgICAgICAgJ3RhYi1oYXMtbGFiZWwtb25seSc6IGhhc0xhYmVsICYmICFoYXNJY29uLFxuICAgICAgICAndGFiLWhhcy1pY29uLW9ubHknOiBoYXNJY29uICYmICFoYXNMYWJlbCxcbiAgICAgICAgW2B0YWItbGF5b3V0LSR7bGF5b3V0fWBdOiB0cnVlLFxuICAgICAgICAnaW9uLWFjdGl2YXRhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2lvbi1zZWxlY3RhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2lvbi1mb2N1c2FibGUnOiB0cnVlXG4gICAgICB9IH0sIGgoXCJhXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJzLCB7IHRhYkluZGV4OiAtMSwgY2xhc3M6IFwiYnV0dG9uLW5hdGl2ZVwiLCBwYXJ0OiBcIm5hdGl2ZVwiIH0pLCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImJ1dHRvbi1pbm5lclwiIH0sIGgoXCJzbG90XCIsIG51bGwpKSwgbW9kZSA9PT0gJ21kJyAmJiBoKFwiaW9uLXJpcHBsZS1lZmZlY3RcIiwgeyB0eXBlOiBcInVuYm91bmRlZFwiIH0pKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHtcbiAgICBpb3M6IHRhYkJ1dHRvbklvc0NzcyxcbiAgICBtZDogdGFiQnV0dG9uTWRDc3NcbiAgfTsgfVxufSwgWzMzLCBcImlvbi10YWItYnV0dG9uXCIsIHtcbiAgICBcImRpc2FibGVkXCI6IFs0XSxcbiAgICBcImRvd25sb2FkXCI6IFsxXSxcbiAgICBcImhyZWZcIjogWzFdLFxuICAgIFwicmVsXCI6IFsxXSxcbiAgICBcImxheW91dFwiOiBbMTAyNV0sXG4gICAgXCJzZWxlY3RlZFwiOiBbMTAyOF0sXG4gICAgXCJ0YWJcIjogWzFdLFxuICAgIFwidGFyZ2V0XCI6IFsxXVxuICB9LCBbWzgsIFwiaW9uVGFiQmFyQ2hhbmdlZFwiLCBcIm9uVGFiQmFyQ2hhbmdlZFwiXV1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRhYi1idXR0b25cIiwgXCJpb24tcmlwcGxlLWVmZmVjdFwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLXRhYi1idXR0b25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUYWJCdXR0b24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlvbi1yaXBwbGUtZWZmZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDIoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25UYWJCdXR0b24gPSBUYWJCdXR0b247XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25UYWJCdXR0b24sIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsImNvbnN0IEJVSUxEID0ge1xuICAgIGFsbFJlbmRlckZuOiBmYWxzZSxcbiAgICBjbXBEaWRMb2FkOiB0cnVlLFxuICAgIGNtcERpZFVubG9hZDogZmFsc2UsXG4gICAgY21wRGlkVXBkYXRlOiB0cnVlLFxuICAgIGNtcERpZFJlbmRlcjogdHJ1ZSxcbiAgICBjbXBXaWxsTG9hZDogdHJ1ZSxcbiAgICBjbXBXaWxsVXBkYXRlOiB0cnVlLFxuICAgIGNtcFdpbGxSZW5kZXI6IHRydWUsXG4gICAgY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZWxlbWVudDogdHJ1ZSxcbiAgICBldmVudDogdHJ1ZSxcbiAgICBoYXNSZW5kZXJGbjogdHJ1ZSxcbiAgICBsaWZlY3ljbGU6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudDogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRCb2R5OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0OiB0cnVlLFxuICAgIG1lbWJlcjogdHJ1ZSxcbiAgICBtZXRob2Q6IHRydWUsXG4gICAgbW9kZTogdHJ1ZSxcbiAgICBvYnNlcnZlQXR0cmlidXRlOiB0cnVlLFxuICAgIHByb3A6IHRydWUsXG4gICAgcHJvcE11dGFibGU6IHRydWUsXG4gICAgcmVmbGVjdDogdHJ1ZSxcbiAgICBzY29wZWQ6IHRydWUsXG4gICAgc2hhZG93RG9tOiB0cnVlLFxuICAgIHNsb3Q6IHRydWUsXG4gICAgY3NzQW5ub3RhdGlvbnM6IHRydWUsXG4gICAgc3RhdGU6IHRydWUsXG4gICAgc3R5bGU6IHRydWUsXG4gICAgc3ZnOiB0cnVlLFxuICAgIHVwZGF0YWJsZTogdHJ1ZSxcbiAgICB2ZG9tQXR0cmlidXRlOiB0cnVlLFxuICAgIHZkb21YbGluazogdHJ1ZSxcbiAgICB2ZG9tQ2xhc3M6IHRydWUsXG4gICAgdmRvbUZ1bmN0aW9uYWw6IHRydWUsXG4gICAgdmRvbUtleTogdHJ1ZSxcbiAgICB2ZG9tTGlzdGVuZXI6IHRydWUsXG4gICAgdmRvbVJlZjogdHJ1ZSxcbiAgICB2ZG9tUHJvcE9yQXR0cjogdHJ1ZSxcbiAgICB2ZG9tUmVuZGVyOiB0cnVlLFxuICAgIHZkb21TdHlsZTogdHJ1ZSxcbiAgICB2ZG9tVGV4dDogdHJ1ZSxcbiAgICB3YXRjaENhbGxiYWNrOiB0cnVlLFxuICAgIHRhc2tRdWV1ZTogdHJ1ZSxcbiAgICBob3RNb2R1bGVSZXBsYWNlbWVudDogZmFsc2UsXG4gICAgaXNEZWJ1ZzogZmFsc2UsXG4gICAgaXNEZXY6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogZmFsc2UsXG4gICAgaHlkcmF0ZVNlcnZlclNpZGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVDbGllbnRTaWRlOiBmYWxzZSxcbiAgICBsaWZlY3ljbGVET01FdmVudHM6IGZhbHNlLFxuICAgIGxhenlMb2FkOiBmYWxzZSxcbiAgICBwcm9maWxlOiBmYWxzZSxcbiAgICBzbG90UmVsb2NhdGlvbjogdHJ1ZSxcbiAgICBhcHBlbmRDaGlsZFNsb3RGaXg6IGZhbHNlLFxuICAgIGNsb25lTm9kZUZpeDogZmFsc2UsXG4gICAgaHlkcmF0ZWRBdHRyaWJ1dGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQ2xhc3M6IHRydWUsXG4gICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgIHNjcmlwdERhdGFPcHRzOiBmYWxzZSxcbiAgICBzY29wZWRTbG90VGV4dENvbnRlbnRGaXg6IGZhbHNlLFxuICAgIHNoYWRvd0RvbVNoaW06IGZhbHNlLFxuICAgIHNsb3RDaGlsZE5vZGVzRml4OiBmYWxzZSxcbiAgICBpbnZpc2libGVQcmVoeWRyYXRpb246IHRydWUsXG4gICAgcHJvcEJvb2xlYW46IHRydWUsXG4gICAgcHJvcE51bWJlcjogdHJ1ZSxcbiAgICBwcm9wU3RyaW5nOiB0cnVlLFxuICAgIGNzc1ZhclNoaW06IGZhbHNlLFxuICAgIGNvbnN0cnVjdGFibGVDU1M6IHRydWUsXG4gICAgY21wU2hvdWxkVXBkYXRlOiB0cnVlLFxuICAgIGRldlRvb2xzOiBmYWxzZSxcbiAgICBkeW5hbWljSW1wb3J0U2hpbTogZmFsc2UsXG4gICAgc2hhZG93RGVsZWdhdGVzRm9jdXM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSxcbiAgICBhc3luY0xvYWRpbmc6IGZhbHNlLFxuICAgIGFzeW5jUXVldWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIGF0dGFjaFN0eWxlczogdHJ1ZSxcbn07XG5jb25zdCBFbnYgPSB7fTtcbmNvbnN0IE5BTUVTUEFDRSA9IC8qIGRlZmF1bHQgKi8gJ2FwcCc7XG5cbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9O1xuIiwibGV0IHNjb3BlSWQ7XG5sZXQgY29udGVudFJlZjtcbmxldCBob3N0VGFnTmFtZTtcbmxldCBjdXN0b21FcnJvcjtcbmxldCBpID0gMDtcbmxldCB1c2VOYXRpdmVTaGFkb3dEb20gPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RSZWxvY2F0ZSA9IGZhbHNlO1xubGV0IGlzU3ZnTW9kZSA9IGZhbHNlO1xubGV0IHJlbmRlcmluZ1JlZiA9IG51bGw7XG5sZXQgcXVldWVDb25nZXN0aW9uID0gMDtcbmxldCBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuMTIuMSB8IE1JVCBMaWNlbnNlZCB8IGh0dHBzOi8vc3RlbmNpbGpzLmNvbVxuICovXG5pbXBvcnQgeyBCVUlMRCwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuY29uc3QgQ1NTID0gQlVJTEQuY3NzVmFyU2hpbSA/IHdpbi5DU1MgOiBudWxsO1xuY29uc3QgZG9jID0gd2luLmRvY3VtZW50IHx8IHsgaGVhZDoge30gfTtcbmNvbnN0IEggPSAod2luLkhUTUxFbGVtZW50IHx8IGNsYXNzIHtcbn0pO1xuY29uc3QgcGx0ID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHJlc291cmNlc1VybCQ6ICcnLFxuICAgIGptcDogKGgpID0+IGgoKSxcbiAgICByYWY6IChoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCksXG4gICAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgcmVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgY2U6IChldmVudE5hbWUsIG9wdHMpID0+IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9wdHMpLFxufTtcbmNvbnN0IHNldFBsYXRmb3JtSGVscGVycyA9IChoZWxwZXJzKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIGhlbHBlcnMpO1xufTtcbmNvbnN0IHN1cHBvcnRzU2hhZG93ID0gQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBCVUlMRC5zaGFkb3dEb21cbiAgICA/IC8qQF9fUFVSRV9fKi8gKCgpID0+IChkb2MuaGVhZC5hdHRhY2hTaGFkb3cgKyAnJykuaW5kZXhPZignW25hdGl2ZScpID4gLTEpKClcbiAgICA6IHRydWU7XG5jb25zdCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICBsZXQgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zO1xufSkoKTtcbmNvbnN0IHByb21pc2VSZXNvbHZlID0gKHYpID0+IFByb21pc2UucmVzb2x2ZSh2KTtcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzID0gQlVJTEQuY29uc3RydWN0YWJsZUNTU1xuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmV3IENTU1N0eWxlU2hlZXQoKS5yZXBsYWNlID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKClcbiAgICA6IGZhbHNlO1xuY29uc3QgQ29udGV4dCA9IHt9O1xuY29uc3QgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoaW4gdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBpbml0aWFsaXplIG91ciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIG5vdyBzbyB0aGF0IHdlIGNhbiBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgbWF5XG4gICAgICAgIC8vIGhhdmUgZmlyZWQgZXZlbiBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIHJlYWR5XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IG1heSBoYXZlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICBpZiAoYXR0YWNoUGFyZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW1wb3J0YW50IHNvIHRoYXQgd2Uga25vdyB0aGUgaG9zdCBlbGVtZW50IGFjdHVhbGx5IGhhcyBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRvIG9ubHkgaGF2ZSB0aGUgb25lcyB0aGF0IEFSRSBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgQlVUIHRoZSBwYXJlbnQgZWxlbWVudCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGF0dGFjaGVkIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0aGF0IGFyZSBOT1QgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+ICEoZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldCA/IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA6IGVsbTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBob3N0TGlzdGVuZXJQcm94eShob3N0UmVmLCBtZXRob2QpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGhvc3RMaXN0ZW5lck9wdHMoZmxhZ3MpO1xuICAgICAgICAgICAgcGx0LmFlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpO1xuICAgICAgICAgICAgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCB8fCBbXSkucHVzaCgoKSA9PiBwbHQucmVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaG9zdExpc3RlbmVyUHJveHkgPSAoaG9zdFJlZiwgbWV0aG9kTmFtZSkgPT4gKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZSBpcyByZWFkeSwgbGV0J3MgY2FsbCBpdCdzIG1lbWJlciBtZXRob2QgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRsYXp5SW5zdGFuY2UkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCB8fCBbXSkucHVzaChbbWV0aG9kTmFtZSwgZXZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGhvc3RFbGVtZW50JFttZXRob2ROYW1lXShldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbn07XG5jb25zdCBnZXRIb3N0TGlzdGVuZXJUYXJnZXQgPSAoZWxtLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudCAmJiBmbGFncyAmIDQgLyogVGFyZ2V0RG9jdW1lbnQgKi8pXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdyAmJiBmbGFncyAmIDggLyogVGFyZ2V0V2luZG93ICovKVxuICAgICAgICByZXR1cm4gd2luO1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRCb2R5ICYmIGZsYWdzICYgMTYgLyogVGFyZ2V0Qm9keSAqLylcbiAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQgJiYgZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pXG4gICAgICAgIHJldHVybiBlbG0ucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWxtO1xufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaG9zdExpc3RlbmVyT3B0cyA9IChmbGFncykgPT4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnNcbiAgICA/ICh7XG4gICAgICAgIHBhc3NpdmU6IChmbGFncyAmIDEgLyogUGFzc2l2ZSAqLykgIT09IDAsXG4gICAgICAgIGNhcHR1cmU6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDAsXG4gICAgfSlcbiAgICA6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDA7XG5jb25zdCBDT05URU5UX1JFRl9JRCA9ICdyJztcbmNvbnN0IE9SR19MT0NBVElPTl9JRCA9ICdvJztcbmNvbnN0IFNMT1RfTk9ERV9JRCA9ICdzJztcbmNvbnN0IFRFWFRfTk9ERV9JRCA9ICd0JztcbmNvbnN0IEhZRFJBVEVfSUQgPSAncy1pZCc7XG5jb25zdCBIWURSQVRFRF9TVFlMRV9JRCA9ICdzdHktaWQnO1xuY29uc3QgSFlEUkFURV9DSElMRF9JRCA9ICdjLWlkJztcbmNvbnN0IEhZRFJBVEVEX0NTUyA9ICd7dmlzaWJpbGl0eTpoaWRkZW59Lmh5ZHJhdGVke3Zpc2liaWxpdHk6aW5oZXJpdH0nO1xuY29uc3QgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBjcmVhdGVUaW1lID0gKGZuTmFtZSwgdGFnTmFtZSA9ICcnKSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBjb25zdCBrZXkgPSBgc3Q6JHtmbk5hbWV9OiR7dGFnTmFtZX06JHtpKyt9YDtcbiAgICAgICAgLy8gU3RhcnRcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICAvLyBFbmRcbiAgICAgICAgcmV0dXJuICgpID0+IHBlcmZvcm1hbmNlLm1lYXN1cmUoYFtTdGVuY2lsXSAke2ZuTmFtZX0oKSA8JHt0YWdOYW1lfT5gLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdW5pcXVlVGltZSA9IChrZXksIG1lYXN1cmVUZXh0KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShrZXkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShtZWFzdXJlVGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlVGV4dCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBpZiAoIWhvc3RSZWYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmxhZ3MgPSBob3N0UmVmLiRmbGFncyQ7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyQ291bnQ6IGhvc3RSZWYuJHJlbmRlckNvdW50JCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkOiAhIShmbGFncyAmIDIgLyogaGFzUmVuZGVyZWQgKi8pLFxuICAgICAgICAgICAgaGFzQ29ubmVjdGVkOiAhIShmbGFncyAmIDEgLyogaGFzQ29ubmVjdGVkICovKSxcbiAgICAgICAgICAgIGlzV2FpdGluZ0ZvckNoaWxkcmVuOiAhIShmbGFncyAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pLFxuICAgICAgICAgICAgaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZTogISEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pLFxuICAgICAgICAgICAgaXNRdWV1ZWRGb3JVcGRhdGU6ICEhKGZsYWdzICYgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pLFxuICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaGFzTG9hZGVkQ29tcG9uZW50OiAhIShmbGFncyAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBpc1dhdGNoUmVhZHk6ICEhKGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLyksXG4gICAgICAgICAgICBpc0xpc3RlblJlYWR5OiAhIShmbGFncyAmIDI1NiAvKiBpc0xpc3RlblJlYWR5ICovKSxcbiAgICAgICAgICAgIG5lZWRzUmVyZW5kZXI6ICEhKGZsYWdzICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pLFxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVZhbHVlczogaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLFxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudDogaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkLFxuICAgICAgICBob3N0RWxlbWVudCxcbiAgICAgICAgbGF6eUluc3RhbmNlOiBob3N0UmVmLiRsYXp5SW5zdGFuY2UkLFxuICAgICAgICB2bm9kZTogaG9zdFJlZi4kdm5vZGUkLFxuICAgICAgICBtb2RlTmFtZTogaG9zdFJlZi4kbW9kZU5hbWUkLFxuICAgICAgICBvblJlYWR5UHJvbWlzZTogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLFxuICAgICAgICBvblJlYWR5UmVzb2x2ZTogaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkLFxuICAgICAgICBvbkluc3RhbmNlUHJvbWlzZTogaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkLFxuICAgICAgICBvbkluc3RhbmNlUmVzb2x2ZTogaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkLFxuICAgICAgICBvblJlbmRlclJlc29sdmU6IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQsXG4gICAgICAgIHF1ZXVlZExpc3RlbmVyczogaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCxcbiAgICAgICAgcm1MaXN0ZW5lcnM6IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCxcbiAgICAgICAgWydzLWlkJ106IGhvc3RFbGVtZW50WydzLWlkJ10sXG4gICAgICAgIFsncy1jciddOiBob3N0RWxlbWVudFsncy1jciddLFxuICAgICAgICBbJ3MtbHInXTogaG9zdEVsZW1lbnRbJ3MtbHInXSxcbiAgICAgICAgWydzLXAnXTogaG9zdEVsZW1lbnRbJ3MtcCddLFxuICAgICAgICBbJ3MtcmMnXTogaG9zdEVsZW1lbnRbJ3MtcmMnXSxcbiAgICAgICAgWydzLXNjJ106IGhvc3RFbGVtZW50WydzLXNjJ10sXG4gICAgfTtcbn07XG5jb25zdCBpbnN0YWxsRGV2VG9vbHMgPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmRldlRvb2xzKSB7XG4gICAgICAgIGNvbnN0IHN0ZW5jaWwgPSAod2luLnN0ZW5jaWwgPSB3aW4uc3RlbmNpbCB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5zcGVjdCA9IHN0ZW5jaWwuaW5zcGVjdDtcbiAgICAgICAgc3RlbmNpbC5pbnNwZWN0ID0gKHJlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIHR5cGVvZiBvcmlnaW5hbEluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW5hbEluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHJvb3RBcHBsaWVkU3R5bGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyU3R5bGUgPSAoc2NvcGVJZCwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICAgICAgc3R5bGUgPSAoc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKSk7XG4gICAgICAgIHN0eWxlLnJlcGxhY2UoY3NzVGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgfVxuICAgIHN0eWxlcy5zZXQoc2NvcGVJZCwgc3R5bGUpO1xufTtcbmNvbnN0IGFkZFN0eWxlID0gKHN0eWxlQ29udGFpbmVyTm9kZSwgY21wTWV0YSwgbW9kZSwgaG9zdEVsbSkgPT4ge1xuICAgIGxldCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmICghQlVJTEQuYXR0YWNoU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUlkO1xuICAgIH1cbiAgICAvLyBpZiBhbiBlbGVtZW50IGlzIE5PVCBjb25uZWN0ZWQgdGhlbiBnZXRSb290Tm9kZSgpIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyByb290IG5vZGVcbiAgICAvLyBzbyB0aGUgZmFsbGJhY2sgaXMgdG8gYWx3YXlzIHVzZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSByb290IG5vZGUgaW4gdGhvc2UgY2FzZXNcbiAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gPyBzdHlsZUNvbnRhaW5lck5vZGUgOiBkb2M7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUuaGVhZCB8fCBzdHlsZUNvbnRhaW5lck5vZGU7XG4gICAgICAgICAgICBsZXQgYXBwbGllZFN0eWxlcyA9IHJvb3RBcHBsaWVkU3R5bGVzLmdldChzdHlsZUNvbnRhaW5lck5vZGUpO1xuICAgICAgICAgICAgbGV0IHN0eWxlRWxtO1xuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcm9vdEFwcGxpZWRTdHlsZXMuc2V0KHN0eWxlQ29udGFpbmVyTm9kZSwgKGFwcGxpZWRTdHlsZXMgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmhvc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlRWxtID0gc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoYFske0hZRFJBVEVEX1NUWUxFX0lEfT1cIiR7c2NvcGVJZH1cIl1gKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGhhcHBlbmluZyBvbiBuYXRpdmUgc2hhZG93LWRvbSwgZG8gbm90IG5lZWRzIENTUyB2YXIgc2hpbVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtID0gcGx0LiRjc3NTaGltJC5jcmVhdGVIb3N0U3R5bGUoaG9zdEVsbSwgc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGVJZCA9IHN0eWxlRWxtWydzLXNjJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlSWQgPSBuZXdTY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgc3R5bGVJRCB0byB0aGUgYXBwbGllZFN0eWxlcyBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY3NzVmFyU2hpbSBtaWdodCBuZWVkIHRvIGFwcGx5IHNldmVyYWwgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzaGVldHMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lELCBzY29wZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlRWxtLCBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcignbGluaycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcy5hZGQoc2NvcGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELmNvbnN0cnVjdGFibGVDU1MgJiYgIXN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzID0gWy4uLnN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMsIHN0eWxlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVJZDtcbn07XG5jb25zdCBhdHRhY2hTdHlsZXMgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgY29uc3QgZW5kQXR0YWNoU3R5bGVzID0gY3JlYXRlVGltZSgnYXR0YWNoU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSBhZGRTdHlsZShCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgZWxtLnNoYWRvd1Jvb3QgPyBlbG0uc2hhZG93Um9vdCA6IGVsbS5nZXRSb290Tm9kZSgpLCBjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQsIGVsbSk7XG4gICAgaWYgKChCVUlMRC5zaGFkb3dEb20gfHwgQlVJTEQuc2NvcGVkKSAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucyAmJiBmbGFncyAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgICAgIGlmIChCVUlMRC5zY29wZWQgJiYgZmxhZ3MgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRBdHRhY2hTdHlsZXMoKTtcbn07XG5jb25zdCBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gJ3NjLScgKyAoQlVJTEQubW9kZSAmJiBtb2RlICYmIGNtcC4kZmxhZ3MkICYgMzIgLyogaGFzTW9kZSAqLyA/IGNtcC4kdGFnTmFtZSQgKyAnLScgKyBtb2RlIDogY21wLiR0YWdOYW1lJCk7XG5jb25zdCBjb252ZXJ0U2NvcGVkVG9TaGFkb3cgPSAoY3NzKSA9PiBjc3MucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csICckMXsnKTtcbi8vIFByaXZhdGVcbmNvbnN0IGNvbXB1dGVNb2RlID0gKGVsbSkgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGgpID0+IGgoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gaCgpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG4vLyBjb25zdCBzdGFjazogYW55W10gPSBbXTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgdk5vZGVDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmICgoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmICFpc0NvbXBsZXhUeXBlKGNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgY2hpbGQuJGZsYWdzJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHZub2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGNsYXNzIC8gY2xhc3NuYW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgdm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NEYXRhID0gdm5vZGVEYXRhLmNsYXNzTmFtZSB8fCB2bm9kZURhdGEuY2xhc3M7XG4gICAgICAgICAgICBpZiAoY2xhc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEYXRhLmNsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNsYXNzRGF0YSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xhc3NEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChrKSA9PiBjbGFzc0RhdGFba10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdk5vZGVDaGlsZHJlbi5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC4gTWFrZSBzdXJlOlxuLSBZb3UgYXJlIE5PVCB1c2luZyBob3N0RGF0YSgpIGFuZCA8SG9zdD4gaW4gdGhlIHNhbWUgY29tcG9uZW50LlxuLSA8SG9zdD4gaXMgdXNlZCBvbmNlLCBhbmQgaXQncyB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50IG9mIHRoZSByZW5kZXIoKSBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21GdW5jdGlvbmFsICYmIHR5cGVvZiBub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub2RlTmFtZSBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIHJldHVybiBub2RlTmFtZSh2bm9kZURhdGEgPT09IG51bGwgPyB7fSA6IHZub2RlRGF0YSwgdk5vZGVDaGlsZHJlbiwgdmRvbUZuVXRpbHMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGVOYW1lLCBudWxsKTtcbiAgICB2bm9kZS4kYXR0cnMkID0gdm5vZGVEYXRhO1xuICAgIGlmICh2Tm9kZUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdm5vZGUuJGNoaWxkcmVuJCA9IHZOb2RlQ2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0ga2V5O1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgdm5vZGUuJG5hbWUkID0gc2xvdE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBuZXdWTm9kZSA9ICh0YWcsIHRleHQpID0+IHtcbiAgICBjb25zdCB2bm9kZSA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJHRhZyQ6IHRhZyxcbiAgICAgICAgJHRleHQkOiB0ZXh0LFxuICAgICAgICAkZWxtJDogbnVsbCxcbiAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICB9O1xuICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgIHZub2RlLiRhdHRycyQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICB2bm9kZS4ka2V5JCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgSG9zdCA9IHt9O1xuY29uc3QgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbmNvbnN0IHZkb21GblV0aWxzID0ge1xuICAgIGZvckVhY2g6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLmZvckVhY2goY2IpLFxuICAgIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSksXG59O1xuY29uc3QgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gICAgdmF0dHJzOiBub2RlLiRhdHRycyQsXG4gICAgdmNoaWxkcmVuOiBub2RlLiRjaGlsZHJlbiQsXG4gICAgdmtleTogbm9kZS4ka2V5JCxcbiAgICB2bmFtZTogbm9kZS4kbmFtZSQsXG4gICAgdnRhZzogbm9kZS4kdGFnJCxcbiAgICB2dGV4dDogbm9kZS4kdGV4dCQsXG59KTtcbmNvbnN0IGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52dGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZub2RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmF0dHJzKTtcbiAgICAgICAgaWYgKG5vZGUudmtleSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLmtleSA9IG5vZGUudmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52bmFtZSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLm5hbWUgPSBub2RlLnZuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi4obm9kZS52Y2hpbGRyZW4gfHwgW10pKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICAgIHZub2RlLiRhdHRycyQgPSBub2RlLnZhdHRycztcbiAgICB2bm9kZS4kY2hpbGRyZW4kID0gbm9kZS52Y2hpbGRyZW47XG4gICAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gICAgdm5vZGUuJG5hbWUkID0gbm9kZS52bmFtZTtcbiAgICByZXR1cm4gdm5vZGU7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG9yZGVyaW5nIG9mIGF0dHJpYnV0ZXMgb24gYW4gaW5wdXQgZWxlbWVudFxuICogQHBhcmFtIGlucHV0RWxtIHRoZSBlbGVtZW50IHRvIHZhbGlkYXRlXG4gKi9cbmNvbnN0IHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzID0gKGlucHV0RWxtKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhpbnB1dEVsbSk7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wcy5pbmRleE9mKCd2YWx1ZScpO1xuICAgIGlmICh2YWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5kZXggPSBwcm9wcy5pbmRleE9mKCd0eXBlJyk7XG4gICAgY29uc3QgbWluSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHByb3BzLmluZGV4T2YoJ21heCcpO1xuICAgIGNvbnN0IHN0ZXBJbmRleCA9IHByb3BzLmluZGV4T2YoJ3N0ZXAnKTtcbiAgICBpZiAodmFsdWUgPCB0eXBlSW5kZXggfHwgdmFsdWUgPCBtaW5JbmRleCB8fCB2YWx1ZSA8IG1heEluZGV4IHx8IHZhbHVlIDwgc3RlcEluZGV4KSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCJ2YWx1ZVwiIHByb3Agb2YgPGlucHV0PiBzaG91bGQgYmUgc2V0IGFmdGVyIFwibWluXCIsIFwibWF4XCIsIFwidHlwZVwiIGFuZCBcInN0ZXBcImApO1xuICAgIH1cbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gc2V0QWNjZXNzb3IoKSBmdW5jdGlvbiBiYXNlZCBvbiBQcmVhY3QgYnlcbiAqIEphc29uIE1pbGxlciAoQGRldmVsb3BpdClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgY29tcGlsZXIgYW5kIHZkb21cbiAqL1xuY29uc3Qgc2V0QWNjZXNzb3IgPSAoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGlzU3ZnLCBmbGFncykgPT4ge1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IGlzUHJvcCA9IGlzTWVtYmVySW5FbGVtZW50KGVsbSwgbWVtYmVyTmFtZSk7XG4gICAgICAgIGxldCBsbiA9IG1lbWJlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcyAmJiBtZW1iZXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbG0uY2xhc3NMaXN0O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFuZXdDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFvbGRDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSBuZXdWYWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09ICdrZXknKVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUmVmICYmIG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUxpc3RlbmVyICYmXG4gICAgICAgICAgICAoQlVJTEQubGF6eUxvYWQgPyAhaXNQcm9wIDogIWVsbS5fX2xvb2t1cFNldHRlcl9fKG1lbWJlck5hbWUpKSAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVswXSA9PT0gJ28nICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IGlmIGl0IGV4aXN0cyBhbmQgaXQncyBub3QgYSBTVkdcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKChpc1Byb3AgfHwgKGlzQ29tcGxleCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkpICYmICFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgPyBuZXdWbm9kZS4kZWxtJC5ob3N0XG4gICAgICAgIDogbmV3Vm5vZGUuJGVsbSQ7XG4gICAgY29uc3Qgb2xkVm5vZGVBdHRycyA9IChvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkKSB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgbm8gbG9uZ2VyIHByZXNlbnQgb24gdGhlIHZub2RlIGJ5IHNldHRpbmcgdGhlbSB0byB1bmRlZmluZWRcbiAgICAgICAgZm9yIChtZW1iZXJOYW1lIGluIG9sZFZub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykpIHtcbiAgICAgICAgICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHVuZGVmaW5lZCwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgIGZvciAobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgbmV3Vm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICB9XG59O1xuY29uc3QgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID1cbiAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJClcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA/ICdzbG90LWZiJ1xuICAgICAgICAgICAgICAgIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUsIG5ld0NoKSA9PiB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBpZHhJbk9sZCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGVsbVRvTW92ZTtcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtaWdodCBoYXZlIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVLZXlUb09sZElkeFxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkU3RhcnRJZHg7IGkgPD0gb2xkRW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoW2ldICYmIG9sZENoW2ldLiRrZXkkICE9PSBudWxsICYmIG9sZENoW2ldLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsbVRvTW92ZS4kdGFnJCAhPT0gbmV3U3RhcnRWbm9kZS4kdGFnJCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIGlkeEluT2xkLCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgbmV3U3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxufTtcbmNvbnN0IGlzU2FtZVZub2RlID0gKHZub2RlMSwgdm5vZGUyKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAodm5vZGUxLiR0YWckID09PSB2bm9kZTIuJHRhZyQpIHtcbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlMS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRuYW1lJCA9PT0gdm5vZGUyLiRuYW1lJDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4ka2V5JCA9PT0gdm5vZGUyLiRrZXkkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgLy8gdGhpcyBub2RlIHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGRvbVxuICAgIC8vIGJlY2F1c2Ugb2Ygc29tZSBvdGhlciBjb21wb25lbnQncyBzbG90XG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYW4gaHRtbCBjb21tZW50IGluIHBsYWNlIG9mIHdoZXJlXG4gICAgLy8gaXQncyBvcmlnaW5hbCBsb2NhdGlvbiB3YXMgYWNjb3JkaW5nIHRvIGl0J3Mgb3JpZ2luYWwgdmRvbVxuICAgIHJldHVybiAobm9kZSAmJiBub2RlWydzLW9sJ10pIHx8IG5vZGU7XG59O1xuY29uc3QgcGFyZW50UmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiAobm9kZVsncy1vbCddID8gbm9kZVsncy1vbCddIDogbm9kZSkucGFyZW50Tm9kZTtcbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgbGV0IGRlZmF1bHRIb2xkZXI7XG4gICAgaWYgKCFCVUlMRC52ZG9tVGV4dCB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVuZGVyaW5nIGFuIHN2ZyBlbGVtZW50LCBvciBzdGlsbCByZW5kZXJpbmcgbm9kZXMgaW5zaWRlIG9mIG9uZVxuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhpcyB0byB0aGUgd2hlbiB0aGUgY29tcGlsZXIgc2VlcyB3ZSdyZSB1c2luZyBhbiBzdmcgc29tZXdoZXJlXG4gICAgICAgICAgICBpc1N2Z01vZGUgPSB0YWcgPT09ICdzdmcnID8gdHJ1ZSA6IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudCBub2RlXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90ICYmIHRhZyA9PT0gJ3Nsb3QnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgb2YgYW4gZWxlbWVudCBPUiBpdCdzIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBhbHJlYWR5IGtub3cgaXQncyBwb3NzaWJsZSBpdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIGVsZW1lbnQncyBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlJ3MgY2hpbGQgdm5vZGVzIGZvciBib3RoIHRoZSBvbGQgYW5kIG5ldyB2bm9kZXNcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2hpbGRyZW4sIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG9sZCBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgbmV3IGNoaWxkIHZub2RlcyB0byBhZGRcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSB3YXMgdGV4dCwgc28gYmUgc3VyZSB0byBjbGVhciBpdCBvdXRcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHZub2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiB0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAoZGVmYXVsdEhvbGRlciA9IGVsbVsncy1jciddKSkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIHNsb3R0ZWQgY29udGVudFxuICAgICAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSB0ZXh0IG9ubHkgdm5vZGVcbiAgICAgICAgLy8gYW5kIGFsc28gb25seSBpZiB0aGUgdGV4dCBpcyBkaWZmZXJlbnQgdGhhbiBiZWZvcmVcbiAgICAgICAgZWxtLmRhdGEgPSB0ZXh0O1xuICAgIH1cbn07XG5jb25zdCB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBpO1xuICAgIGxldCBpbGVuO1xuICAgIGxldCBqO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCBmYWxsYmFjayBub2RlXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzbG90IG5hbWUgZm9yIHRoaXMgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIHNob3cgYSBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgaWYgdGhlcmUgYXJlIG90aGVyIHNsb3RzIGluIHRoZSBsaWdodCBkb21cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNoaWxkTm9kZXNbal0ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddIHx8IHNsb3ROYW1lQXR0ciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2libGluZyBub2RlIGlzIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IE9SIGlzIGEgbmFtZWQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8gJiYgY2hpbGROb2Rlc1tqXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVsb2NhdGVOb2RlcyA9IFtdO1xuY29uc3QgcmVsb2NhdGVTbG90Q29udGVudCA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgcmVsb2NhdGVOb2RlRGF0YTtcbiAgICBsZXQgajtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgc29tZSBjaGFuZ2VzIHRvIHNsb3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgd2UgYWxzbyBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrcyBhcmUgY29ycmVjdGx5IGhpZGRlbiBvciBzaG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IG5vZGVbJ3Mtc24nXSB8fCBzbG90TmFtZUF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgd2UgbmV2ZXIgZm91bmQgYSBzbG90IGhvbWUgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0dXJucyBvdXQgd2UgZGlkLCBzbyBsZXQncyByZW1lbWJlciBpdCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3VyIGxpc3Qgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2xvdFJlZk5vZGUkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5tYXAoKHJlbG9jYXRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZSgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZmFyIHRoaXMgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgc2xvdCBob21lLCBub3Qgc2V0dGluZyBzbG90UmVmTm9kZSBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZXZlciBmaW5kIGEgaG9tZSBmb3IgdGhpcyBlbGVtZW50IHRoZW4gd2UnbGwgbmVlZCB0byBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNOb2RlTG9jYXRlZEluU2xvdCA9IChub2RlVG9SZWxvY2F0ZSwgc2xvdE5hbWVBdHRyKSA9PiB7XG4gICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gbnVsbCAmJiBzbG90TmFtZUF0dHIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKCdzbG90JykgPT09IHNsb3ROYW1lQXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5hbWVBdHRyID09PSAnJztcbn07XG5jb25zdCBjYWxsTm9kZVJlZnMgPSAodk5vZGUpID0+IHtcbiAgICBpZiAoQlVJTEQudmRvbVJlZikge1xuICAgICAgICB2Tm9kZS4kYXR0cnMkICYmIHZOb2RlLiRhdHRycyQucmVmICYmIHZOb2RlLiRhdHRycyQucmVmKG51bGwpO1xuICAgICAgICB2Tm9kZS4kY2hpbGRyZW4kICYmIHZOb2RlLiRjaGlsZHJlbiQubWFwKGNhbGxOb2RlUmVmcyk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlclZkb20gPSAoaG9zdFJlZiwgcmVuZGVyRm5SZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgaG9zdEVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3Qgb2xkVk5vZGUgPSBob3N0UmVmLiR2bm9kZSQgfHwgbmV3Vk5vZGUobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgcm9vdFZub2RlID0gaXNIb3N0KHJlbmRlckZuUmVzdWx0cykgPyByZW5kZXJGblJlc3VsdHMgOiBoKG51bGwsIG51bGwsIHJlbmRlckZuUmVzdWx0cyk7XG4gICAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gICAgLy8gPEhvc3Q+IHJ1bnRpbWUgY2hlY2tcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgQXJyYXkuaXNBcnJheShyZW5kZXJGblJlc3VsdHMpICYmIHJlbmRlckZuUmVzdWx0cy5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5tYXAoKFtwcm9wTmFtZSwgYXR0cmlidXRlXSkgPT4gKHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICByb290Vm5vZGUuJHRhZyQgPSBudWxsO1xuICAgIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogaXNIb3N0ICovO1xuICAgIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgICByb290Vm5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCA9IChCVUlMRC5zaGFkb3dEb20gPyBob3N0RWxtLnNoYWRvd1Jvb3QgfHwgaG9zdEVsbSA6IGhvc3RFbG0pO1xuICAgIGlmIChCVUlMRC5zY29wZWQgfHwgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIHNjb3BlSWQgPSBob3N0RWxtWydzLXNjJ107XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBjb250ZW50UmVmID0gaG9zdEVsbVsncy1jciddO1xuICAgICAgICB1c2VOYXRpdmVTaGFkb3dEb20gPSBzdXBwb3J0c1NoYWRvdyAmJiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSAhPT0gMDtcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBzeW5jaHJvbm91cyBwYXRjaFxuICAgIHBhdGNoKG9sZFZOb2RlLCByb290Vm5vZGUpO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAvLyB3aGlsZSB3ZSdyZSBtb3Zpbmcgbm9kZXMgYXJvdW5kIGV4aXN0aW5nIG5vZGVzLCB0ZW1wb3JhcmlseSBkaXNhYmxlXG4gICAgICAgIC8vIHRoZSBkaXNjb25uZWN0Q2FsbGJhY2sgZnJvbSB3b3JraW5nXG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIGlmIChjaGVja1Nsb3RSZWxvY2F0ZSkge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgbGV0IHJlbG9jYXRlRGF0YTtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZWxvY2F0ZTtcbiAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZVJlZjtcbiAgICAgICAgICAgIGxldCBpbnNlcnRCZWZvcmVOb2RlO1xuICAgICAgICAgICAgbGV0IHJlZk5vZGU7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlbG9jYXRlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWxvY2F0ZURhdGEgPSByZWxvY2F0ZU5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlID0gcmVsb2NhdGVEYXRhLiRub2RlVG9SZWxvY2F0ZSQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIHJlZmVyZW5jZSBub2RlIG1hcmtpbmcgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgZm9yIGxhdGVyIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsTG9jYXRpb25EZWJ1Z05vZGUobm9kZVRvUmVsb2NhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgobm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZSksIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGluc2VydCBpdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9yZ0xvY2F0aW9uTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSAmJiByZWZOb2RlWydzLXNuJ10gPT09IG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlWydzLW5yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbnNlcnRCZWZvcmVOb2RlICYmIHBhcmVudE5vZGVSZWYgIT09IG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5uZXh0U2libGluZyAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgY2hlY2tlZCB0aGF0IGl0J3Mgd29ydGggd2hpbGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoYXQgdGhlIG5vZGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBuZXh0IHNpYmxpbmcgb3IgcGFyZW50IHJlbG9jYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1obiddICYmIG5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYSBjb21wb25lbnQgaW4gdGhlIGluZGV4Lmh0bWwgdGhhdCBkb2Vzbid0IGhhdmUgaXQncyBob3N0bmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ10ucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0IGJhY2sgdG8gdGhlIGRvbSBidXQgaW4gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZVJlZi5pbnNlcnRCZWZvcmUobm9kZVRvUmVsb2NhdGUsIGluc2VydEJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lc24ndCBoYXZlIGEgc2xvdCBob21lIHRvIGdvIHRvLCBzbyBsZXQncyBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZSBtb3Zpbmcgbm9kZXMgYXJvdW5kXG4gICAgICAgIC8vIGFsbG93IHRoZSBkaXNjb25uZWN0IGNhbGxiYWNrIHRvIHdvcmsgYWdhaW5cbiAgICAgICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICByZWxvY2F0ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgfVxufTtcbi8vIHNsb3QgY29tbWVudCBkZWJ1ZyBub2RlcyBvbmx5IGNyZWF0ZWQgd2l0aCB0aGUgYC0tZGVidWdgIGZsYWdcbi8vIG90aGVyd2lzZSB0aGVzZSBub2RlcyBhcmUgdGV4dCBub2RlcyB3L291dCBjb250ZW50XG5jb25zdCBzbG90UmVmZXJlbmNlRGVidWdOb2RlID0gKHNsb3RWTm9kZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYDxzbG90JHtzbG90Vk5vZGUuJG5hbWUkID8gJyBuYW1lPVwiJyArIHNsb3RWTm9kZS4kbmFtZSQgKyAnXCInIDogJyd9PiAoaG9zdD0ke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9KWApO1xuY29uc3Qgb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZSA9IChub2RlVG9SZWxvY2F0ZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYG9yZy1sb2NhdGlvbiBmb3IgYCArXG4gICAgKG5vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZVxuICAgICAgICA/IGA8JHtub2RlVG9SZWxvY2F0ZS5sb2NhbE5hbWV9PiAoaG9zdD0ke25vZGVUb1JlbG9jYXRlWydzLWhuJ119KWBcbiAgICAgICAgOiBgWyR7bm9kZVRvUmVsb2NhdGUudGV4dENvbnRlbnR9XWApKTtcbmNvbnN0IGdldEVsZW1lbnQgPSAocmVmKSA9PiAoQlVJTEQubGF6eUxvYWQgPyBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA6IHJlZik7XG5jb25zdCBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gICAgY29uc3QgZWxtID0gZ2V0RWxlbWVudChyZWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtaXQ6IChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcIiR7bmFtZX1cIiBldmVudCB3YXMgZW1pdHRlZCwgYnV0IHRoZSBkaXNwYXRjaGVyIG5vZGUgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byB0aGUgZG9tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRFdmVudChlbG0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogISEoZmxhZ3MgJiAxIC8qIENhbmNlbGxhYmxlICovKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSAmIGRpc3BhdGNoIGEgY3VzdG9tIEV2ZW50IG9uIGEgcHJvdmlkZWQgdGFyZ2V0XG4gKiBAcGFyYW0gZWxtIHRoZSB0YXJnZXQgb2YgdGhlIEV2ZW50XG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBnaXZlIHRoZSBjdXN0b20gRXZlbnRcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGEgY3VzdG9tIEV2ZW50XG4gKiBAcmV0dXJucyB0aGUgY3VzdG9tIEV2ZW50XG4gKi9cbmNvbnN0IGVtaXRFdmVudCA9IChlbG0sIG5hbWUsIG9wdHMpID0+IHtcbiAgICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gICAgcmV0dXJuIGV2O1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10ucHVzaChuZXcgUHJvbWlzZSgocikgPT4gKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSkpO1xuICAgIH1cbn07XG5jb25zdCBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgaWYgKEJVSUxELnRhc2tRdWV1ZSAmJiBCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGhvc3RSZWYuJGZsYWdzJCAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiBCVUlMRC50YXNrUXVldWUgPyB3cml0ZVRhc2soZGlzcGF0Y2gpIDogZGlzcGF0Y2goKTtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kU2NoZWR1bGUgPSBjcmVhdGVUaW1lKCdzY2hlZHVsZVVwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsTG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFJlbmRlcicpO1xuICAgIGlmIChCVUlMRC5jbXBXaWxsUmVuZGVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjb25uZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgc2VydmVyU2lkZUNvbm5lY3RlZChlbG0pO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBvbmx5IGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICdjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICAgICAgLy8gb2ssIHNvIHR1cm5zIG91dCB0aGVyZSBhcmUgc29tZSBjaGlsZCBob3N0IGVsZW1lbnRzXG4gICAgICAgIC8vIHdhaXRpbmcgb24gdGhpcyBwYXJlbnQgZWxlbWVudCB0byBsb2FkXG4gICAgICAgIC8vIGxldCdzIGZpcmUgb2ZmIGFsbCB1cGRhdGUgY2FsbGJhY2tzIHdhaXRpbmdcbiAgICAgICAgcmMubWFwKChjYikgPT4gY2IoKSk7XG4gICAgICAgIGVsbVsncy1yYyddID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRSZW5kZXIoKTtcbiAgICBlbmRVcGRhdGUoKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUHJvbWlzZXMgPSBlbG1bJ3MtcCddO1xuICAgICAgICBjb25zdCBwb3N0VXBkYXRlID0gKCkgPT4gcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwb3N0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChjaGlsZHJlblByb21pc2VzKS50aGVuKHBvc3RVcGRhdGUpO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICAgICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIC8vIGluIG9yZGVyIGZvciBidW5kbGVycyB0byBjb3JyZWN0bHkgdHJlZXNoYWtlIHRoZSBCVUlMRCBvYmplY3RcbiAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSBCVUlMRCBpcyBub3QgZGVvcHRpbWl6ZWQgd2l0aGluIGEgdHJ5L2NhdGNoXG4gICAgLy8gaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI3RyZWVzaGFrZSB0cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgY29uc3QgYWxsUmVuZGVyRm4gPSBCVUlMRC5hbGxSZW5kZXJGbiA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBsYXp5TG9hZCA9IEJVSUxELmxhenlMb2FkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHRhc2tRdWV1ZSA9IEJVSUxELnRhc2tRdWV1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB1cGRhdGFibGUgPSBCVUlMRC51cGRhdGFibGUgPyB0cnVlIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyaW5nUmVmID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKHVwZGF0YWJsZSAmJiB0YXNrUXVldWUpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0YWJsZSB8fCBsYXp5TG9hZCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogaGFzUmVuZGVyZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmhhc1JlbmRlckZuIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tUmVuZGVyIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBjaGlsZCBub2RlcyB0byByZW5kZXIgaW50byB0aGlzIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjc3MgY2xhc3MvYXR0cnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSkudGhlbigodmFsdWUpID0+IHJlbmRlclZkb20oaG9zdFJlZiwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICAgIH1cbiAgICByZW5kZXJpbmdSZWYgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgaWYgKEJVSUxELmNtcERpZFJlbmRlcikge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQoZWxtKTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gZmlyZSBvZmYgdGhlIHVzZXIncyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIChpZiBvbmUgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgLy8gY29tcG9uZW50RGlkVXBkYXRlIHJ1bnMgQUZURVIgcmVuZGVyKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxtWydzLWhtci1sb2FkJ10gJiYgZWxtWydzLWhtci1sb2FkJ10oKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELm1ldGhvZCAmJiBCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+KDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIFwidHJ1ZVwiIHdoZW4gdGhlIGZvcmNlZCB1cGRhdGUgd2FzIHN1Y2Nlc3NmdWxseSBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwRGlkTG9hZCA9ICh3aG8pID0+IHtcbiAgICAvLyBvbiBhcHBsb2FkXG4gICAgLy8gd2UgaGF2ZSBmaW5pc2ggdGhlIGZpcnN0IGJpZyBpbml0aWFsIHJlbmRlclxuICAgIGlmIChCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICBhZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBuZXh0VGljaygoKSA9PiBlbWl0RXZlbnQod2luLCAnYXBwbG9hZCcsIHsgZGV0YWlsOiB7IG5hbWVzcGFjZTogTkFNRVNQQUNFIH0gfSkpO1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1lYXN1cmUpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7TkFNRVNQQUNFfSBpbml0aWFsIGxvYWQgKGJ5ICR7d2hvfSlgLCAnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxufTtcbmNvbnN0IHNhZmVDYWxsID0gKGluc3RhbmNlLCBtZXRob2QsIGFyZykgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2RdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCB0aGVuID0gKHByb21pc2UsIHRoZW5GbikgPT4ge1xuICAgIHJldHVybiBwcm9taXNlICYmIHByb21pc2UudGhlbiA/IHByb21pc2UudGhlbih0aGVuRm4pIDogdGhlbkZuKCk7XG59O1xuY29uc3QgZW1pdExpZmVjeWNsZUV2ZW50ID0gKGVsbSwgbGlmZWN5Y2xlTmFtZSkgPT4ge1xuICAgIGlmIChCVUlMRC5saWZlY3ljbGVET01FdmVudHMpIHtcbiAgICAgICAgZW1pdEV2ZW50KGVsbSwgJ3N0ZW5jaWxfJyArIGxpZmVjeWNsZU5hbWUsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogTkFNRVNQQUNFLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGFkZEh5ZHJhdGVkRmxhZyA9IChlbG0pID0+IEJVSUxELmh5ZHJhdGVkQ2xhc3NcbiAgICA/IGVsbS5jbGFzc0xpc3QuYWRkKCdoeWRyYXRlZCcpXG4gICAgOiBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZVxuICAgICAgICA/IGVsbS5zZXRBdHRyaWJ1dGUoJ2h5ZHJhdGVkJywgJycpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuY29uc3Qgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZEVsbS5jb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBlbmRIeWRyYXRlID0gY3JlYXRlVGltZSgnaHlkcmF0ZUNsaWVudCcsIHRhZ05hbWUpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBob3N0RWxtLnNoYWRvd1Jvb3Q7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3ROb2RlcyA9IEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290ID8gW10gOiBudWxsO1xuICAgIGNvbnN0IHZub2RlID0gKGhvc3RSZWYuJHZub2RlJCA9IG5ld1ZOb2RlKHRhZ05hbWUsIG51bGwpKTtcbiAgICBpZiAoIXBsdC4kb3JnTG9jTm9kZXMkKSB7XG4gICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZG9jLmJvZHksIChwbHQuJG9yZ0xvY05vZGVzJCA9IG5ldyBNYXAoKSkpO1xuICAgIH1cbiAgICBob3N0RWxtW0hZRFJBVEVfSURdID0gaG9zdElkO1xuICAgIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgIGNsaWVudEh5ZHJhdGUodm5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBob3N0RWxtLCBob3N0SWQpO1xuICAgIGNoaWxkUmVuZGVyTm9kZXMubWFwKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uSWQgPSBjLiRob3N0SWQkICsgJy4nICsgYy4kbm9kZUlkJDtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlID0gcGx0LiRvcmdMb2NOb2RlcyQuZ2V0KG9yZ0xvY2F0aW9uSWQpO1xuICAgICAgICBjb25zdCBub2RlID0gYy4kZWxtJDtcbiAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvcmdMb2NhdGlvbk5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbm9kZVsncy1obiddID0gdGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddWydzLW5yJ10gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShvcmdMb2NhdGlvbklkKTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2hhZG93Um9vdE5vZGVzLm1hcCgoc2hhZG93Um9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2hhZG93Um9vdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kSHlkcmF0ZSgpO1xufTtcbmNvbnN0IGNsaWVudEh5ZHJhdGUgPSAocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLCBob3N0SWQpID0+IHtcbiAgICBsZXQgY2hpbGROb2RlVHlwZTtcbiAgICBsZXQgY2hpbGRJZFNwbHQ7XG4gICAgbGV0IGNoaWxkVk5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGROb2RlVHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO1xuICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSkge1xuICAgICAgICAgICAgLy8gZ290IHRoZSBub2RlIGRhdGEgZnJvbSB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgICAgICBjaGlsZElkU3BsdCA9IGNoaWxkTm9kZVR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzBdID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICRub2RlSWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICAgICAkdGFnJDogbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAkYXR0cnMkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJG5hbWUkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldyBjaGlsZCB2bm9kZVxuICAgICAgICAgICAgICAgIC8vIHNvIGVuc3VyZSBpdHMgcGFyZW50IHZub2RlIGhhcyB0aGUgdmNoaWxkcmVuIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIG91ciBjaGlsZCB2bm9kZSB0byBhIHNwZWNpZmljIGluZGV4IG9mIHRoZSB2bm9kZSdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdyB0aGUgbmV3IHBhcmVudCB2bm9kZSBmb3IgYWxsIHRoZSBuZXh0IGNoaWxkIGNoZWNrc1xuICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZHJpbGwgZG93biwgZW5kIHRvIHN0YXJ0IHNvIHdlIGNhbiByZW1vdmUgbm9kZXNcbiAgICAgICAgZm9yIChpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5jaGlsZE5vZGVzW2ldLCBob3N0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgZHJpbGxpbmcgZG93biB0aHJvdWdoIHRoZSBzaGFkb3cgcm9vdCBub2Rlc1xuICAgICAgICAgICAgZm9yIChpID0gbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICAvLyBgJHtDT01NRU5UX1RZUEV9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzFdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMV0gPT09ICcwJykge1xuICAgICAgICAgICAgLy8gY29tbWVudCBub2RlIGZvciBlaXRoZXIgdGhlIGhvc3QgaWQgb3IgYSAwIGhvc3QgaWRcbiAgICAgICAgICAgIGNoaWxkTm9kZVR5cGUgPSBjaGlsZElkU3BsdFswXTtcbiAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzRdLFxuICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRhZyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBURVhUX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRleHQkID0gY2hpbGRWTm9kZS4kZWxtJC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZW5kZXJOb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRleHQgY29tbWVudCBzaW5jZSBpdCdzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlcyAmJiBjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRWTm9kZS4kaG9zdElkJCA9PT0gaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21tZW50IG5vZGUgaXMgc3BlY2lmY2FsbHkgZm9yIHRoaXMgaG9zdCBpZFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBTTE9UX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7U0xPVF9OT0RFX0lEfS4ke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGFnJCA9ICdzbG90JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSBjaGlsZFZOb2RlLiRuYW1lJCA9IGNoaWxkSWRTcGx0WzVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgc3VwcG9ydCBzaGFkb3dSb290IGFuZCB0aGlzIGlzIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhY3R1YWwgc2xvdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZUVsZW1lbnQoY2hpbGRWTm9kZS4kdGFnJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kbmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsb3QgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kLnNldEF0dHJpYnV0ZSgnbmFtZScsIGNoaWxkVk5vZGUuJG5hbWUkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbmV3IHNsb3QgZWxlbWVudCBiZWZvcmUgdGhlIHNsb3QgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZFZOb2RlLiRlbG0kLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2xvdCBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZE5vZGVUeXBlID09PSBDT05URU5UX1JFRl9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtDT05URU5UX1JFRl9JRH0uJHtob3N0SWR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudCByZWYgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsbVsncy1jciddID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3MtY24nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Vk5vZGUgJiYgcGFyZW50Vk5vZGUuJHRhZyQgPT09ICdzdHlsZScpIHtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShudWxsLCBub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgdm5vZGUuJGVsbSQgPSBub2RlO1xuICAgICAgICB2bm9kZS4kaW5kZXgkID0gJzAnO1xuICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW3Zub2RlXTtcbiAgICB9XG59O1xuY29uc3QgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZSA9IChub2RlLCBvcmdMb2NOb2RlcykgPT4ge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgb3JnTG9jTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IE9SR19MT0NBVElPTl9JRCkge1xuICAgICAgICAgICAgb3JnTG9jTm9kZXMuc2V0KGNoaWxkSWRTcGx0WzFdICsgJy4nICsgY2hpbGRJZFNwbHRbMl0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBrbm93IGlmIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBpc1xuICAgICAgICAgICAgLy8gdGhlIHJvb3QgbGlnaHQtZG9tIG9mIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgIG5vZGVbJ3MtZW4nXSA9IGNoaWxkSWRTcGx0WzNdO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlUHJvcGVydHlWYWx1ZSA9IChwcm9wVmFsdWUsIHByb3BUeXBlKSA9PiB7XG4gICAgLy8gZW5zdXJlIHRoaXMgdmFsdWUgaXMgb2YgdGhlIGNvcnJlY3QgcHJvcCB0eXBlXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgaWYgKEJVSUxELnByb3BCb29sZWFuICYmIHByb3BUeXBlICYgNCAvKiBCb29sZWFuICovKSB7XG4gICAgICAgICAgICAvLyBwZXIgdGhlIEhUTUwgc3BlYywgYW55IHN0cmluZyB2YWx1ZSBtZWFucyBpdCBpcyBhIGJvb2xlYW4gdHJ1ZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnV0IHdlJ2xsIGNoZWF0IGhlcmUgYW5kIHNheSB0aGF0IHRoZSBzdHJpbmcgXCJmYWxzZVwiIGlzIHRoZSBib29sZWFuIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiBwcm9wVmFsdWUgPT09ICcnIHx8ICEhcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wTnVtYmVyICYmIHByb3BUeXBlICYgMiAvKiBOdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBTdHJpbmcgKi8pIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBwYXNzZWQgYXMgYSBudW1iZXIgb3IgYm9vbGVhblxuICAgICAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgaXQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1bmRhbnQgcmV0dXJuIGhlcmUgZm9yIGJldHRlciBtaW5pZmljYXRpb25cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgLy8gbm90IHN1cmUgZXhhY3RseSB3aGF0IHR5cGUgd2Ugd2FudFxuICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hhbmdlIHRvIGEgZGlmZmVyZW50IHR5cGVcbiAgICByZXR1cm4gcHJvcFZhbHVlO1xufTtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGhvc3RFbGVtZW50JCA6IHJlZjtcbiAgICBjb25zdCBvbGRWYWwgPSBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICAgIGlmICgoIUJVSUxELmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pIHx8IG9sZFZhbCA9PT0gdW5kZWZpbmVkKSAmJiBuZXdWYWwgIT09IG9sZFZhbCkge1xuICAgICAgICAvLyBnYWR6b29rcyEgdGhlIHByb3BlcnR5J3MgdmFsdWUgaGFzIGNoYW5nZWQhIVxuICAgICAgICAvLyBzZXQgb3VyIG5ldyB2YWx1ZSFcbiAgICAgICAgaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLnNldChwcm9wTmFtZSwgbmV3VmFsKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMTAyNCAvKiBkZXZPblJlbmRlciAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgcmVuZGVyaW5nLiBUaGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIGluZmluaXRlLWxvb3BzIGFuZCBvdGhlciBidWdzLmAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDIwNDggLyogZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyBcImNvbXBvbmVudERpZExvYWQoKVwiLCB0aGlzIHRyaWdnZXJzIGV4dHJhIHJlLXJlbmRlcnMsIHRyeSB0byBzZXR1cCBvbiBcImNvbXBvbmVudFdpbGxMb2FkKClcImAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJVSUxELmxhenlMb2FkIHx8IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbWV0aG9kIG5hbWVzIG9mIHdhdGNoIGZ1bmN0aW9ucyB0byBjYWxsXG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hNZXRob2RzID0gY21wTWV0YS4kd2F0Y2hlcnMkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaW5zdGFuY2UgaXMgd2F0Y2hpbmcgZm9yIHdoZW4gdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTWV0aG9kcy5tYXAoKHdhdGNoTWV0aG9kTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIG9mZiBlYWNoIG9mIHRoZSB3YXRjaCBtZXRob2RzIHRoYXQgYXJlIHdhdGNoaW5nIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIG9sZFZhbCwgcHJvcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhpcyB2YWx1ZSBhY3R1YWxseSBjaGFuZ2VkLCBzbyB3ZSd2ZSBnb3Qgd29yayB0byBkbyFcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkLCBvdGhlcndpc2UganVzdCBjaGlsbCBvdXRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGF0IHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlLCBidXQgZG9uJ3Qgd29ycnkgYWJvdXQgcXVldWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwIG1pbGxpb25zIGN1eiB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgaXQgb25seSBydW5zIG9uY2VcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoQlVJTEQucHJvcCB8fCBCVUlMRC5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovIHx8XG4gICAgICAgICAgICAgICAgICAgICgoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIHByb3BcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBnZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGR1cmluZyBkZXYgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmLiRmbGFncyQgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgYSBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8pICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgbm90IG11dGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMTAyNCAvKiBNdXRhYmxlICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgQFByb3AoKSBcIiR7bWVtYmVyTmFtZX1cIiBvbiA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IGlzIGltbXV0YWJsZSBidXQgd2FzIG1vZGlmaWVkIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQuXFxuTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvcHJvcGVydGllcyNwcm9wLW11dGFiaWxpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmxhenlMb2FkICYmXG4gICAgICAgICAgICAgICAgQlVJTEQubWV0aG9kICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyRmxhZ3MgJiA2NCAvKiBNZXRob2QgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIG1ldGhvZFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYuJG9uSW5zdGFuY2VQcm9taXNlJC50aGVuKCgpID0+IHJlZi4kbGF6eUluc3RhbmNlJFttZW1iZXJOYW1lXSguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQlVJTEQub2JzZXJ2ZUF0dHJpYnV0ZSAmJiAoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluIGEgd2ViIGNvbXBvbmVudCBsaWZlY3ljbGUgdGhlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBydW5zIHByaW9yIHRvIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgY2FzZSB3aGVyZSBhbiBhdHRyaWJ1dGUgd2FzIHNldCBpbmxpbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBzZXRzIHRoZSBhdHRyaWJ1dGUgaW5saW5lIG9uIGEgY3VzdG9tIGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyBpdCBiZWZvcmUgaXQgaGFzIGJlZW4gdXBncmFkZWQgYXMgc2hvd24gYmVsb3c6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwhLS0gdGhpcyBjb21wb25lbnQgaGFzIF9ub3RfIGJlZW4gdXBncmFkZWQgeWV0IC0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8bXktY29tcG9uZW50IGlkPVwidGVzdFwiIHNvbWUtYXR0cmlidXRlPVwic29tZS12YWx1ZVwiPjwvbXktY29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIGdyYWIgbm9uLXVwZ3JhZGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAvLyB1cGdyYWRlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlIGlmIHdlIGRvIG5vdCB1bnNoYWRvdyBoZXJlIGFuZCB1c2UgdGhlIHZhbHVlIG9mIHRoZSBzaGFkb3dpbmcgcHJvcGVydHksIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyAgd2lsbCBiZSBjYWxsZWQgd2l0aCBgbmV3VmFsdWUgPSBcInNvbWUtdmFsdWVcImAgYW5kIHdpbGwgc2V0IHRoZSBzaGFkb3dlZCBwcm9wZXJ0eSAodGhpcy5zb21lQXR0cmlidXRlID0gXCJhbm90aGVyLXZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vICB0byB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IGlubGluZSBpLmUuIFwic29tZS12YWx1ZVwiIGZyb20gYWJvdmUgZXhhbXBsZS4gV2hlblxuICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGNvbm5lY3RlZENhbGxiYWNrIGF0dGVtcHRzIHRvIHVuc2hhZG93IGl0IHdpbGwgdXNlIFwic29tZS12YWx1ZVwiIGFzIHRoZSBpbml0aWFsIHZhbHVlIHJhdGhlciB0aGFuIFwiYW5vdGhlci12YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIHdhcyBOT1Qgc2V0IGlubGluZSBidXQgd2FzIG5vdCBzZXQgcHJvZ3JhbW1hdGljYWxseSBzaGFsbCBiZSBoYW5kbGVkL3Vuc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJ5IGNvbm5lY3RlZENhbGxiYWNrIGFzIHRoaXMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVE9ETyhTVEVOQ0lMLTE2KSB3ZSBzaG91bGQgdGhpbmsgYWJvdXQgd2hldGhlciBvciBub3Qgd2UgYWN0dWFsbHkgd2FudCB0byBiZSByZWZsZWN0aW5nIHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9wZXJ0aWVzIGhlcmUgZ2l2ZW4gdGhhdCB0aGlzIGdvZXMgYWdhaW5zdCBiZXN0IHByYWN0aWNlcyBvdXRsaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2F2b2lkLXJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcE5hbWUgZXhpc3RzIG9uIHRoZSBwcm90b3R5cGUgb2YgYENzdHJgLCB0aGlzIHVwZGF0ZSBtYXkgYmUgYSByZXN1bHQgb2YgU3RlbmNpbCB1c2luZyBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFQSXMgdG8gcmVmbGVjdCBwcm9wcyBhcyBhdHRyaWJ1dGVzLiBDYWxscyB0byBgc2V0QXR0cmlidXRlKHNvbWVFbGVtZW50LCBwcm9wTmFtZSlgIHdpbGwgcmVzdWx0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvcE5hbWVgIHRvIGJlIGNvbnZlcnRlZCB0byBhIGBET01TdHJpbmdgLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgd2Ugd2FudCBmb3Igb3RoZXIgcHJpbWl0aXZlIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBSZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5zdHlsZSkgJiZcbiAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChDc3RyLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBBd2FpdCBjcmVhdGVzIGEgbWljcm8tdGFzayBhdm9pZCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExvYWQgPSB1bmlxdWVUaW1lKGBzdDpsb2FkOiR7Y21wTWV0YS4kdGFnTmFtZSR9OiR7aG9zdFJlZi4kbW9kZU5hbWUkfWAsIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gKTtcbiAgICAgICAgICAgICAgICBDc3RyID0gYXdhaXQgQ3N0cjtcbiAgICAgICAgICAgICAgICBlbmRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKEJVSUxELmlzRGV2IHx8IEJVSUxELmlzRGVidWcpICYmICFDc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyICYmICFDc3RyLmlzUHJveGllZCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIG5ldmVyIHByb3hpZWQgdGhpcyBDb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBhZGQgdGhlIGdldHRlcnMvc2V0dGVycyB0byBpdHMgcHJvdG90eXBlIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHdlIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAyIC8qIHByb3h5U3RhdGUgKi8pO1xuICAgICAgICAgICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZSgnY3JlYXRlSW5zdGFuY2UnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAvLyBvaywgdGltZSB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCB0cmFjayBvZiB3aGVuIHdlIHN0YXJ0IGFuZCBzdG9wXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBnZXR0ZXJzL3NldHRlcnMgZG9uJ3QgaW5jb3JyZWN0bHkgc3RlcCBvbiBkYXRhXG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgbGF6eS1sb2FkZWQgY29tcG9uZW50IGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBwYXNzaW5nIHRoZSBob3N0UmVmIGlzIHZlcnkgaW1wb3J0YW50IGR1cmluZ1xuICAgICAgICAgICAgLy8gY29uc3RydWN0aW9uIGluIG9yZGVyIHRvIGRpcmVjdGx5IHdpcmUgdG9nZXRoZXIgdGhlXG4gICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgYW5kIHRoZSBsYXp5LWxvYWRlZCBpbnN0YW5jZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgQ3N0cihob3N0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzeW5jIGNvbnN0cnVjdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgQ3N0ciA9IGVsbS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBDdXN0b21FbGVtZW50UmVnaXN0cnkgdG8gbWFyayB0aGUgY29tcG9uZW50IGFzIHJlYWR5IGJlZm9yZSBzZXR0aW5nIGBpc1dhdGNoUmVhZHlgLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB3YXRjaGVycyBtYXkgZmlyZSBwcmVtYXR1cmVseSBpZiBgY3VzdG9tRWxlbWVudHMuZ2V0KClgL2BjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCgpYCByZXNvbHZlcyBfYmVmb3JlX1xuICAgICAgICAgICAgLy8gU3RlbmNpbCBoYXMgY29tcGxldGVkIGluc3RhbnRpYXRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKGNtcE1ldGEuJHRhZ05hbWUkKS50aGVuKCgpID0+IChob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbSAmJlxuICAgICAgICAgICAgICAgICAgICBCVUlMRC5zaGFkb3dEb21TaGltICYmXG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KCcuL3NoYWRvdy1jc3MuanMnKS50aGVuKChtKSA9PiBtLnNjb3BlQ3NzKHN0eWxlLCBzY29wZUlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICBlbmRSZWdpc3RlclN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgbGF6eSBpbnN0YW5jZVxuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBhbmNlc3RvckNvbXBvbmVudCAmJiBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgbG9hZCBhbmQgdGhpcyBjb21wb25lbnQgaXQgaGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBidXQgdGhlIGFuY2VzdG9yIGNvbXBvbmVudCBoYXMgTk9UIGZpcmVkIGl0cyB3aWxsIHVwZGF0ZSBsaWZlY3ljbGUgeWV0XG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3QgY29vbCBvdXIgamV0cyBhbmQgd2FpdCBmb3IgdGhlIGFuY2VzdG9yIHRvIGNvbnRpbnVlIGZpcnN0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBnZXQgZmlyZWQgb2ZmIHdoZW4gdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBmaW5hbGx5IGdldHMgYXJvdW5kIHRvIHJlbmRlcmluZyBpdHMgbGF6eSBzZWxmXG4gICAgICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddLnB1c2goc2NoZWR1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuY29uc3QgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcnVuIGlmIHdlIGhhdmUgbGlzdGVuZXJzIGJlaW5nIGF0dGFjaGVkIHRvIGEgcGFyZW50XG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IEJVSUxELm1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhLCBlbG0uZ2V0QXR0cmlidXRlKCdzLW1vZGUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlSWQgKyAnLWgnLCBzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZWxtLCBjbXBNZXRhLiR0YWdOYW1lJCwgaG9zdElkLCBob3N0UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIWhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xvdCBwb2x5ZmlsbCBpcyByZXF1aXJlZCB3ZSdsbCBuZWVkIHRvIHB1dCBzb21lIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gaGVyZSB0byBhY3QgYXMgb3JpZ2luYWwgY29udGVudCBhbmNob3JzIGFzIHdlIG1vdmUgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICgoQlVJTEQuc2xvdCB8fCBCVUlMRC5zaGFkb3dEb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRmbGFncyQgJiAoNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLyB8IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBhbmNlc3RvciBjb21wb25lbnQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgYXMgb25lIG9mIHRoZSBhY3RpdmVseSBsb2FkaW5nIGNoaWxkIGNvbXBvbmVudHMgZm9yIGl0cyBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGltYiB1cCB0aGUgYW5jZXN0b3JzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgZmluaXNoZWQgaXRzIGxpZmVjeWNsZSB1cGRhdGUgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICgoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoJ3MtaWQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCB0aGlzIGNvbXBvbmVudHMgZmlyc3QgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgY29tcG9uZW50J3MgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIChob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQgPSBhbmNlc3RvckNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMYXp5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQucHJvcCAmJiAhQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCkubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLyAmJiBlbG0uaGFzT3duUHJvcGVydHkobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaW5pdGlhbGl6ZU5leHRUaWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGVkQ2FsbGJhY2ssIHRhc2tRdWV1ZSwgaW5pdGlhbExvYWRcbiAgICAgICAgICAgICAgICAvLyBhbmd1bGFyIHNldHMgYXR0cmlidXRlIEFGVEVSIGNvbm5lY3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE4OTA5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk5NDBcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IHRoZSBmaXJzdCB0aW1lIHRoaXMgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gcmVhdHRhY2ggYW55IGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaG9zdFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSB3b3VsZCBoYXZlIGJlZW4gcmVtb3ZlZCB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmlyZSBvZmYgY29ubmVjdGVkQ2FsbGJhY2soKSBvbiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRDb25uZWN0ZWQoKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29udGVudFJlZmVyZW5jZSA9IChlbG0pID0+IHtcbiAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAvLyBhbmQgdGhpcyBob3N0IGVsZW1lbnQgd2FzIE5PVCBjcmVhdGVkIHdpdGggU1NSXG4gICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNvbnRlbnQgd2FzIGZpcnN0IHBsYWNlZCwgd2hpY2ggaXMgdXNlZnVsIGxhdGVyIG9uXG4gICAgY29uc3QgY29udGVudFJlZkVsbSA9IChlbG1bJ3MtY3InXSA9IGRvYy5jcmVhdGVDb21tZW50KEJVSUxELmlzRGVidWcgPyBgY29udGVudC1yZWYgKGhvc3Q9JHtlbG0ubG9jYWxOYW1lfSlgIDogJycpKTtcbiAgICBjb250ZW50UmVmRWxtWydzLWNuJ10gPSB0cnVlO1xuICAgIGVsbS5pbnNlcnRCZWZvcmUoY29udGVudFJlZkVsbSwgZWxtLmZpcnN0Q2hpbGQpO1xufTtcbmNvbnN0IGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHJtTGlzdGVuZXJzJC5tYXAoKHJtTGlzdGVuZXIpID0+IHJtTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIENTUyB2YXItc2hpbSB0cmFja2luZ1xuICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICBwbHQuJGNzc1NoaW0kLnJlbW92ZUhvc3QoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVW5sb2FkKSB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVubG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSAoQ3N0ciwgY29tcGFjdE1ldGEpID0+IHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY29tcGFjdE1ldGFbMV0sIHByb3h5Q3VzdG9tRWxlbWVudChDc3RyLCBjb21wYWN0TWV0YSkpO1xufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci4kd2F0Y2hlcnMkO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgICAgIF9fcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHRoaXMsIGNtcE1ldGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmNvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRhY2hTaGFkb3coKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIENzdHIuaXMgPSBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xuY29uc3QgZm9yY2VNb2RlVXBkYXRlID0gKGVsbSkgPT4ge1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBCVUlMRC5tb2RlICYmICFCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBjb25zdCBtb2RlID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCAhPT0gbW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NvcGVJZCA9IGVsbVsncy1zYyddO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsbS5jb25zdHJ1Y3Rvci5zdHlsZVttb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGZsYWdzICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBobXJTdGFydCA9IChlbG0sIGNtcE1ldGEsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAvLyByZXNldCBzdGF0ZSBmbGFncyB0byBvbmx5IGhhdmUgYmVlbiBjb25uZWN0ZWRcbiAgICBob3N0UmVmLiRmbGFncyQgPSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAvLyBUT0RPXG4gICAgLy8gZGV0YXRjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IHBhc3NpbmcgYW4gZXhhY3QgZXZlbnQgbmFtZSBpdCdsbFxuICAgIC8vIHJlbW92ZSBhbGwgb2YgdGhpcyBlbGVtZW50J3MgZXZlbnQsIHdoaWNoIGlzIGdvb2RcbiAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGlzIGNvbXBvbmVudCBmaW5pc2hlcyBobXJcbiAgICBlbG1bJ3MtaG1yLWxvYWQnXSA9ICgpID0+IHtcbiAgICAgICAgLy8gZmluaXNoZWQgaG1yIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgZGVsZXRlIGVsbVsncy1obXItbG9hZCddO1xuICAgIH07XG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuY29uc3QgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBjb25zdCBvcmdDbG9uZU5vZGUgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGU7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzU2hhZG93RG9tID0gQlVJTEQuc2hhZG93RG9tID8gc3JjTm9kZS5zaGFkb3dSb290ICYmIHN1cHBvcnRzU2hhZG93IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgICAgIGlmIChCVUlMRC5zbG90ICYmICFpc1NoYWRvd0RvbSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgc2xvdHRlZCwgbm9uU3RlbmNpbE5vZGU7XG4gICAgICAgICAgICBsZXQgc3RlbmNpbFByaXZhdGVzID0gW1xuICAgICAgICAgICAgICAgICdzLWlkJyxcbiAgICAgICAgICAgICAgICAncy1jcicsXG4gICAgICAgICAgICAgICAgJ3MtbHInLFxuICAgICAgICAgICAgICAgICdzLXJjJyxcbiAgICAgICAgICAgICAgICAncy1zYycsXG4gICAgICAgICAgICAgICAgJ3MtcCcsXG4gICAgICAgICAgICAgICAgJ3MtY24nLFxuICAgICAgICAgICAgICAgICdzLXNyJyxcbiAgICAgICAgICAgICAgICAncy1zbicsXG4gICAgICAgICAgICAgICAgJ3MtaG4nLFxuICAgICAgICAgICAgICAgICdzLW9sJyxcbiAgICAgICAgICAgICAgICAncy1ucicsXG4gICAgICAgICAgICAgICAgJ3Mtc2knLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgIG5vblN0ZW5jaWxOb2RlID0gc3RlbmNpbFByaXZhdGVzLmV2ZXJ5KChwcml2YXRlRmllbGQpID0+ICFzcmNOb2RlLmNoaWxkTm9kZXNbaV1bcHJpdmF0ZUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCAmJiBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uU3RlbmNpbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaFNsb3RBcHBlbmRDaGlsZCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IChuZXdDaGlsZFsncy1zbiddID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpKTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEFmdGVyID0gc2xvdENoaWxkTm9kZXNbc2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIGFwcGVuZEFmdGVyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9O1xufTtcbi8qKlxuICogUGF0Y2hlcyB0aGUgdGV4dCBjb250ZW50IG9mIGFuIHVubmFtZWQgc2xvdHRlZCBub2RlIGluc2lkZSBhIHNjb3BlZCBjb21wb25lbnRcbiAqIEBwYXJhbSBob3N0RWxlbWVudFByb3RvdHlwZSB0aGUgYEVsZW1lbnRgIHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBjbXBNZXRhIGNvbXBvbmVudCBydW50aW1lIG1ldGFkYXRhIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHBhdGNoZWQgb3Igbm90XG4gKi9cbmNvbnN0IHBhdGNoVGV4dENvbnRlbnQgPSAoaG9zdEVsZW1lbnRQcm90b3R5cGUsIGNtcE1ldGEpID0+IHtcbiAgICBpZiAoQlVJTEQuc2NvcGVkICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50Jyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0RWxlbWVudFByb3RvdHlwZSwgJ19fdGV4dENvbnRlbnQnLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgJ2RlZmF1bHQgc2xvdCcsIHdoaWNoIHdvdWxkIGJlIHRoZSBmaXJzdCBzbG90IGluIGEgc2hhZG93IHRyZWUgKGlmIHdlIHdlcmUgdXNpbmcgb25lKSwgd2hvc2UgbmFtZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsICcnKTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc2xvdCBub2RlIGlzIGZvdW5kLCB0aGUgdGV4dENvbnRlbnQgX21heV8gYmUgZm91bmQgaW4gdGhlIG5leHQgc2libGluZyAodGV4dCkgbm9kZSwgZGVwZW5kaW5nIG9uIGhvd1xuICAgICAgICAgICAgICAgIC8vIG5vZGVzIHdlcmUgcmVvcmRlcmVkIGR1cmluZyB0aGUgdmRvbSByZW5kZXIuIGZpcnN0IHRyeSB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tIHRoZSBzaWJsaW5nLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT09IG51bGwgfHwgc2xvdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIFRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBuZWVkIHRvIGJlIHBsYWNlZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLFxuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiBob3cgbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIHNldCB0aGUgdGV4dCBjb250ZW50IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZG4ndCBmaW5kIGEgc2xvdCwgYnV0IHRoYXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlcmUgaXNuJ3Qgb25lLiBpZiB0aGlzIGNoZWNrIHJhbiBiZWZvcmUgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkZWQsIHdlIGNvdWxkIGhhdmUgbWlzc2VkIGl0LiBjaGVjayBmb3IgYSBjb250ZW50IHJlZmVyZW5jZSBlbGVtZW50IG9uIHRoZSBzY29wZWQgY29tcG9uZW50IGFuZCBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSB0aGlzWydzLWNyJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmRWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXygnY2hpbGROb2RlcycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZEVsZW1lbnRDb3VudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGROb2RlcycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0ZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEhvc3RSZWYodGhpcykuJGZsYWdzJCAmIDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGEgc2VyaWVzIG9mIGNoaWxkIG5vZGVzIGZvciBhIHNsb3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqIEBwYXJhbSBjaGlsZE5vZGVzIHRoZSBub2RlcyB0byBzZWFyY2ggZm9yIGEgc2xvdCB3aXRoIGEgc3BlY2lmaWMgbmFtZS5cbiAqIEBwYXJhbSBzbG90TmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdCB0byBtYXRjaCBvbi5cbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBuYW1lLCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGdldEhvc3RTbG90Tm9kZSA9IChjaGlsZE5vZGVzLCBzbG90TmFtZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGZvciAoOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgY2hpbGROb2RlWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZSA9IGdldEhvc3RTbG90Tm9kZShjaGlsZE5vZGUuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbbl07XG4gICAgd2hpbGUgKChuID0gbi5uZXh0U2libGluZykgJiYgblsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xufTtcbmNvbnN0IGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxuICAgIGluc3RhbGxEZXZUb29scygpO1xuICAgIGNvbnN0IGVuZEJvb3RzdHJhcCA9IGNyZWF0ZVRpbWUoJ2Jvb3RzdHJhcExhenknKTtcbiAgICBjb25zdCBjbXBUYWdzID0gW107XG4gICAgY29uc3QgZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSB8fCBbXTtcbiAgICBjb25zdCBjdXN0b21FbGVtZW50cyA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgICBjb25zdCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgY29uc3QgbWV0YUNoYXJzZXQgPSAvKkBfX1BVUkVfXyovIGhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtjaGFyc2V0XScpO1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdHlsZSA9IC8qQF9fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICBjb25zdCBzdHlsZXMgPSAvKkBfX1BVUkVfXyovIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBbJHtIWURSQVRFRF9TVFlMRV9JRH1dYCk7XG4gICAgbGV0IGFwcExvYWRGYWxsYmFjaztcbiAgICBsZXQgaXNCb290c3RyYXBwaW5nID0gdHJ1ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIG9wdGlvbnMpO1xuICAgIHBsdC4kcmVzb3VyY2VzVXJsJCA9IG5ldyBVUkwob3B0aW9ucy5yZXNvdXJjZXNVcmwgfHwgJy4vJywgZG9jLmJhc2VVUkkpLmhyZWY7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luY1F1ZXVlKSB7XG4gICAgICAgICAgICBwbHQuJGZsYWdzJCB8PSA0IC8qIHF1ZXVlU3luYyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGFwcCBpcyBhbHJlYWR5IGh5ZHJhdGVkIHRoZXJlIGlzIG5vdCBwb2ludCB0byBkaXNhYmxlIHRoZVxuICAgICAgICAvLyBhc3luYyBxdWV1ZS4gVGhpcyB3aWxsIGltcHJvdmUgdGhlIGZpcnN0IGlucHV0IGRlbGF5XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiYgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIGZvciAoOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWdpc3RlclN0eWxlKHN0eWxlc1tpXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLCBjb252ZXJ0U2NvcGVkVG9TaGFkb3coc3R5bGVzW2ldLmlubmVySFRNTCksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgICAgICBsYXp5QnVuZGxlWzFdLm1hcCgoY29tcGFjdE1ldGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICAgICAgICAgJHRhZ05hbWUkOiBjb21wYWN0TWV0YVsxXSxcbiAgICAgICAgICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAgICAgICAgICRsaXN0ZW5lcnMkOiBjb21wYWN0TWV0YVszXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgIXN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKVxuICAgICAgICAgICAgICAgIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgICAgICBjb25zdCBIb3N0RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGlzIHVzaW5nIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSByZWFkLW9ubHkgcHJvcGVydHkgXCJzaGFkb3dSb290XCIgdG8gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIHRoZSBzaGFkb3cgcm9vdCBidWlsZCBjb25kaXRpb25hbHMgdG8gbWluaW1pemUgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBzaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoJ3NoYWRvd1Jvb3QnIGluIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaGFkb3dSb290ID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdENoaWxkTm9kZXNGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChhcHBMb2FkRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayB3aWxsIGJlIHByb2Nlc3NlZCBvbmNlIGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnRPblJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQuY2xvbmVOb2RlRml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hDbG9uZU5vZGUoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFNsb3RBcHBlbmRDaGlsZChIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlWydzLWhtciddID0gZnVuY3Rpb24gKGhtclZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUZXh0Q29udGVudChIb3N0RWxlbWVudC5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21wTWV0YS4kbGF6eUJ1bmRsZUlkJCA9IGxhenlCdW5kbGVbMF07XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgcHJveHlDb21wb25lbnQoSG9zdEVsZW1lbnQsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELmludmlzaWJsZVByZWh5ZHJhdGlvbiAmJiAoQlVJTEQuaHlkcmF0ZWRDbGFzcyB8fCBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLmlubmVySFRNTCA9IGNtcFRhZ3MgKyBIWURSQVRFRF9DU1M7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJywgJycpO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZSh2aXNpYmlsaXR5U3R5bGUsIG1ldGFDaGFyc2V0ID8gbWV0YUNoYXJzZXQubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGRlZmVycmVkIGNvbm5lY3RlZENhbGxiYWNrcyBub3cgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICBpc0Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLm1hcCgoaG9zdCkgPT4gaG9zdC5jb25uZWN0ZWRDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9maWxlKSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwLCAndGltZW91dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGFwcExvYWQgZXZlbnRcbiAgICBlbmRCb290c3RyYXAoKTtcbn07XG5jb25zdCBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFzc2V0VXJsID0gbmV3IFVSTChwYXRoLCBwbHQuJHJlc291cmNlc1VybCQpO1xuICAgIHJldHVybiBhc3NldFVybC5vcmlnaW4gIT09IHdpbi5sb2NhdGlvbi5vcmlnaW4gPyBhc3NldFVybC5ocmVmIDogYXNzZXRVcmwucGF0aG5hbWU7XG59O1xuY29uc3Qgc2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IChwbHQuJHJlc291cmNlc1VybCQgPSBwYXRoKTtcbmNvbnN0IGdldENvbm5lY3QgPSAoX3JlZiwgdGFnTmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBlbG0gPSBkb2MucXVlcnlTZWxlY3Rvcih0YWdOYW1lKTtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICAgIGVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsbS5jb21wb25lbnRPblJlYWR5ID09PSAnZnVuY3Rpb24nID8gZWxtLmNvbXBvbmVudE9uUmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChlbCkgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2goKG9yZ0xvY2F0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZVJlZi5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlbGVzcyB3aGl0ZXNwYWNlIG5vZGUgYXQgdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBub2RlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlSWQgPSBgJHtPUkdfTE9DQVRJT05fSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5cIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTSEFET1cgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICdjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5jXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0NPUEVEIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5ub2RlVmFsdWUgPSBvcmdMb2NhdGlvbk5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGVbJ3MtbnInXSAhPSBudWxsKSB7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChob3N0UmVmICE9IG51bGwgJiYgIWRvY0RhdGEuc3RhdGljQ29tcG9uZW50cy5oYXMoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkczogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluc2VydFZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gICAgaWYgKHZub2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgICAgIGhvc3RFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfSUQsIGhvc3RJZCk7XG4gICAgICAgIGlmIChob3N0RWxtWydzLWNyJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEVsbVsncy1jciddLm5vZGVWYWx1ZSA9IGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoJ2MtaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaG9zdEVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbJ3Mtc3InXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgYCR7Y29tbWVudFsncy1ob3N0LWlkJ119LiR7Y29tbWVudFsncy1ub2RlLWlkJ119LjAuJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zID0gKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZEVsbSA9IHZub2RlQ2hpbGQuJGVsbSQ7XG4gICAgaWYgKGNoaWxkRWxtID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgICBjb25zdCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gO1xuICAgIGNoaWxkRWxtWydzLWhvc3QtaWQnXSA9IGhvc3RJZDtcbiAgICBjaGlsZEVsbVsncy1ub2RlLWlkJ10gPSBub2RlSWQ7XG4gICAgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChjaGlsZEVsbVsncy1zciddKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkRWxtWydzLXNuJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlQ2hpbGQuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIHZub2RlQ2hpbGQuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlLCBjbXBEYXRhLCBob3N0SWQsIGNoaWxkRGVwdGgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHNldFBsYXRmb3JtT3B0aW9ucyA9IChvcHRzKSA9PiBPYmplY3QuYXNzaWduKHBsdCwgb3B0cyk7XG5jb25zdCBGcmFnbWVudCA9IChfLCBjaGlsZHJlbikgPT4gY2hpbGRyZW47XG5jb25zdCBob3N0UmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlKSwgaG9zdFJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkID0gcikpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkID0gcikpO1xuICAgICAgICBlbG1bJ3MtcCddID0gW107XG4gICAgICAgIGVsbVsncy1yYyddID0gW107XG4gICAgfVxuICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICByZXR1cm4gaG9zdFJlZnMuc2V0KGVsbSwgaG9zdFJlZik7XG59O1xuY29uc3QgaXNNZW1iZXJJbkVsZW1lbnQgPSAoZWxtLCBtZW1iZXJOYW1lKSA9PiBtZW1iZXJOYW1lIGluIGVsbTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKGN1c3RvbUVycm9yIHx8IGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcbmNvbnN0IFNURU5DSUxfREVWX01PREUgPSBCVUlMRC5pc1Rlc3RpbmdcbiAgICA/IFsnU1RFTkNJTDonXSAvLyBFMkUgdGVzdGluZ1xuICAgIDogW1xuICAgICAgICAnJWNzdGVuY2lsJyxcbiAgICAgICAgJ2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweCcsXG4gICAgXTtcbmNvbnN0IGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldldhcm4gPSAoLi4ubSkgPT4gY29uc29sZS53YXJuKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldkluZm8gPSAoLi4ubSkgPT4gY29uc29sZS5pbmZvKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3Qgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IChjdXN0b21FcnJvciA9IGhhbmRsZXIpO1xuY29uc3QgY21wTW9kdWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3QgbG9hZE1vZHVsZSA9IChjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyBsb2FkTW9kdWxlSW1wb3J0XG4gICAgY29uc3QgZXhwb3J0TmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBidW5kbGVJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUcnlpbmcgdG8gbGF6aWx5IGxvYWQgY29tcG9uZW50IDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gd2l0aCBzdHlsZSBtb2RlIFwiJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDogZmFsc2U7XG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICAgICAgaWYgKCFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0ZWRNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfSwgY29uc29sZUVycm9yKTtcbn07XG5jb25zdCBzdHlsZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBtb2RlUmVzb2x1dGlvbkNoYWluID0gW107XG5jb25zdCBxdWV1ZURvbVJlYWRzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXNMb3cgPSBbXTtcbmNvbnN0IHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICAgIHF1ZXVlLnB1c2goY2IpO1xuICAgIGlmICghcXVldWVQZW5kaW5nKSB7XG4gICAgICAgIHF1ZXVlUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaV0ocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbn07XG5jb25zdCBjb25zdW1lVGltZW91dCA9IChxdWV1ZSwgdGltZW91dCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdHMgPSAwO1xuICAgIHdoaWxlIChpIDwgcXVldWUubGVuZ3RoICYmICh0cyA9IHBlcmZvcm1hbmNlLm5vdygpKSA8IHRpbWVvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2krK10odHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcXVldWVDb25nZXN0aW9uKys7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBmb3JjZSBhIGJ1bmNoIG9mIG1lZGl1bSBjYWxsYmFja3MgdG8gcnVuLCBidXQgc3RpbGwgaGF2ZVxuICAgIC8vIGEgdGhyb3R0bGUgb24gaG93IG1hbnkgY2FuIHJ1biBpbiBhIGNlcnRhaW4gdGltZVxuICAgIC8vIERPTSBSRUFEUyEhIVxuICAgIGNvbnN1bWUocXVldWVEb21SZWFkcyk7XG4gICAgLy8gRE9NIFdSSVRFUyEhIVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAocGx0LiRmbGFncyQgJiA2IC8qIHF1ZXVlTWFzayAqLykgPT09IDIgLyogYXBwTG9hZGVkICovXG4gICAgICAgICAgICA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTQgKiBNYXRoLmNlaWwocXVldWVDb25nZXN0aW9uICogKDEuMCAvIDEwLjApKVxuICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXMsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlc0xvdywgdGltZW91dCk7XG4gICAgICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlQ29uZ2VzdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN1bWUocXVldWVEb21Xcml0ZXMpO1xuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5leHRUaWNrID0gLypAX19QVVJFX18qLyAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG5jb25zdCByZWFkVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbmNvbnN0IHdyaXRlVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuZXhwb3J0IHsgQnVpbGQsIENTUywgQ29udGV4dCwgRnJhZ21lbnQsIEgsIEggYXMgSFRNTEVsZW1lbnQsIEhvc3QsIFNURU5DSUxfREVWX01PREUsIGFkZEhvc3RFdmVudExpc3RlbmVycywgYm9vdHN0cmFwTGF6eSwgY21wTW9kdWxlcywgY29ubmVjdGVkQ2FsbGJhY2ssIGNvbnNvbGVEZXZFcnJvciwgY29uc29sZURldkluZm8sIGNvbnNvbGVEZXZXYXJuLCBjb25zb2xlRXJyb3IsIGNyZWF0ZUV2ZW50LCBkZWZpbmVDdXN0b21FbGVtZW50LCBkaXNjb25uZWN0ZWRDYWxsYmFjaywgZG9jLCBmb3JjZU1vZGVVcGRhdGUsIGZvcmNlVXBkYXRlLCBnZXRBc3NldFBhdGgsIGdldENvbm5lY3QsIGdldENvbnRleHQsIGdldEVsZW1lbnQsIGdldEhvc3RSZWYsIGdldE1vZGUsIGdldFJlbmRlcmluZ1JlZiwgZ2V0VmFsdWUsIGgsIGluc2VydFZkb21Bbm5vdGF0aW9ucywgaXNNZW1iZXJJbkVsZW1lbnQsIGxvYWRNb2R1bGUsIG1vZGVSZXNvbHV0aW9uQ2hhaW4sIG5leHRUaWNrLCBwYXJzZVByb3BlcnR5VmFsdWUsIHBsdCwgcG9zdFVwZGF0ZUNvbXBvbmVudCwgcHJvbWlzZVJlc29sdmUsIHByb3h5Q29tcG9uZW50LCBwcm94eUN1c3RvbUVsZW1lbnQsIHJlYWRUYXNrLCByZWdpc3Rlckhvc3QsIHJlZ2lzdGVySW5zdGFuY2UsIHJlbmRlclZkb20sIHNldEFzc2V0UGF0aCwgc2V0RXJyb3JIYW5kbGVyLCBzZXRNb2RlLCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldFBsYXRmb3JtT3B0aW9ucywgc2V0VmFsdWUsIHN0eWxlcywgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMsIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zLCBzdXBwb3J0c1NoYWRvdywgd2luLCB3cml0ZVRhc2sgfTtcbiIsImltcG9ydCB7IGdldEFzc2V0UGF0aCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcblxubGV0IENBQ0hFRF9NQVA7XG5jb25zdCBnZXRJY29uTWFwID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICghQ0FDSEVEX01BUCkge1xuICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgd2luLklvbmljb25zID0gd2luLklvbmljb25zIHx8IHt9O1xuICAgICAgQ0FDSEVEX01BUCA9IHdpbi5Jb25pY29ucy5tYXAgPSB3aW4uSW9uaWNvbnMubWFwIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIENBQ0hFRF9NQVA7XG4gIH1cbn07XG5jb25zdCBhZGRJY29ucyA9IChpY29ucykgPT4ge1xuICBjb25zdCBtYXAgPSBnZXRJY29uTWFwKCk7XG4gIE9iamVjdC5rZXlzKGljb25zKS5mb3JFYWNoKG5hbWUgPT4gbWFwLnNldChuYW1lLCBpY29uc1tuYW1lXSkpO1xufTtcbmNvbnN0IGdldFVybCA9IChpKSA9PiB7XG4gIGxldCB1cmwgPSBnZXRTcmMoaS5zcmMpO1xuICBpZiAodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICB1cmwgPSBnZXROYW1lKGkubmFtZSwgaS5pY29uLCBpLm1vZGUsIGkuaW9zLCBpLm1kKTtcbiAgaWYgKHVybCkge1xuICAgIHJldHVybiBnZXROYW1lZFVybCh1cmwpO1xuICB9XG4gIGlmIChpLmljb24pIHtcbiAgICB1cmwgPSBnZXRTcmMoaS5pY29uKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICB1cmwgPSBnZXRTcmMoaS5pY29uW2kubW9kZV0pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldE5hbWVkVXJsID0gKGljb25OYW1lKSA9PiB7XG4gIGNvbnN0IHVybCA9IGdldEljb25NYXAoKS5nZXQoaWNvbk5hbWUpO1xuICBpZiAodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICByZXR1cm4gZ2V0QXNzZXRQYXRoKGBzdmcvJHtpY29uTmFtZX0uc3ZnYCk7XG59O1xuY29uc3QgZ2V0TmFtZSA9IChpY29uTmFtZSwgaWNvbiwgbW9kZSwgaW9zLCBtZCkgPT4ge1xuICAvLyBkZWZhdWx0IHRvIFwibWRcIiBpZiBzb21laG93IHRoZSBtb2RlIHdhc24ndCBzZXRcbiAgbW9kZSA9IChtb2RlICYmIHRvTG93ZXIobW9kZSkpID09PSAnaW9zJyA/ICdpb3MnIDogJ21kJztcbiAgLy8gaWYgYW4gaWNvbiB3YXMgcGFzc2VkIGluIHVzaW5nIHRoZSBpb3Mgb3IgbWQgYXR0cmlidXRlc1xuICAvLyBzZXQgdGhlIGljb25OYW1lIHRvIHdoYXRldmVyIHdhcyBwYXNzZWQgaW5cbiAgaWYgKGlvcyAmJiBtb2RlID09PSAnaW9zJykge1xuICAgIGljb25OYW1lID0gdG9Mb3dlcihpb3MpO1xuICB9XG4gIGVsc2UgaWYgKG1kICYmIG1vZGUgPT09ICdtZCcpIHtcbiAgICBpY29uTmFtZSA9IHRvTG93ZXIobWQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICghaWNvbk5hbWUgJiYgaWNvbiAmJiAhaXNTcmMoaWNvbikpIHtcbiAgICAgIGljb25OYW1lID0gaWNvbjtcbiAgICB9XG4gICAgaWYgKGlzU3RyKGljb25OYW1lKSkge1xuICAgICAgaWNvbk5hbWUgPSB0b0xvd2VyKGljb25OYW1lKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1N0cihpY29uTmFtZSkgfHwgaWNvbk5hbWUudHJpbSgpID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIG9ubHkgYWxsb3cgYWxwaGEgY2hhcmFjdGVycyBhbmQgZGFzaFxuICBjb25zdCBpbnZhbGlkQ2hhcnMgPSBpY29uTmFtZS5yZXBsYWNlKC9bYS16XXwtfFxcZC9naSwgJycpO1xuICBpZiAoaW52YWxpZENoYXJzICE9PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpY29uTmFtZTtcbn07XG5jb25zdCBnZXRTcmMgPSAoc3JjKSA9PiB7XG4gIGlmIChpc1N0cihzcmMpKSB7XG4gICAgc3JjID0gc3JjLnRyaW0oKTtcbiAgICBpZiAoaXNTcmMoc3JjKSkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgaXNTcmMgPSAoc3RyKSA9PiBzdHIubGVuZ3RoID4gMCAmJiAvKFxcL3xcXC4pLy50ZXN0KHN0cik7XG5jb25zdCBpc1N0ciA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuY29uc3QgdG9Mb3dlciA9ICh2YWwpID0+IHZhbC50b0xvd2VyQ2FzZSgpO1xuLyoqXG4gKiBFbGVtZW50cyBpbnNpZGUgb2Ygd2ViIGNvbXBvbmVudHMgc29tZXRpbWVzIG5lZWQgdG8gaW5oZXJpdCBnbG9iYWwgYXR0cmlidXRlc1xuICogc2V0IG9uIHRoZSBob3N0LiBGb3IgZXhhbXBsZSwgdGhlIGlubmVyIGlucHV0IGluIGBpb24taW5wdXRgIHNob3VsZCBpbmhlcml0XG4gKiB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgdGhhdCBkZXZlbG9wZXJzIHNldCBkaXJlY3RseSBvbiBgaW9uLWlucHV0YC4gVGhpc1xuICogaGVscGVyIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaW4gY29tcG9uZW50V2lsbExvYWQgYW5kIGFzc2lnbmVkIHRvIGEgdmFyaWFibGVcbiAqIHRoYXQgaXMgbGF0ZXIgdXNlZCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSByZWFjdGl2ZSBhcyBjaGFuZ2luZyBhdHRyaWJ1dGVzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAqIGRvZXMgbm90IHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gKi9cbmNvbnN0IGluaGVyaXRBdHRyaWJ1dGVzID0gKGVsLCBhdHRyaWJ1dGVzID0gW10pID0+IHtcbiAgY29uc3QgYXR0cmlidXRlT2JqZWN0ID0ge307XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVPYmplY3RbYXR0cl0gPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZU9iamVjdDtcbn07XG5cbmV4cG9ydCB7IGFkZEljb25zIGFzIGEsIGluaGVyaXRBdHRyaWJ1dGVzIGFzIGIsIGdldE5hbWUgYXMgYywgZ2V0VXJsIGFzIGcsIGlzU3RyIGFzIGkgfTtcbiIsImltcG9ydCB7IEhUTUxFbGVtZW50LCBCdWlsZCwgaCwgSG9zdCwgcHJveHlDdXN0b21FbGVtZW50IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgaSBhcyBpc1N0ciwgYiBhcyBpbmhlcml0QXR0cmlidXRlcywgZyBhcyBnZXRVcmwsIGMgYXMgZ2V0TmFtZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCB2YWxpZGF0ZUNvbnRlbnQgPSAoc3ZnQ29udGVudCkgPT4ge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IHN2Z0NvbnRlbnQ7XG4gIC8vIHNldHVwIHRoaXMgd2F5IHRvIGVuc3VyZSBpdCB3b3JrcyBvbiBvdXIgYnVkZHkgSUVcbiAgZm9yIChsZXQgaSA9IGRpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGRpdi5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzdmcnKSB7XG4gICAgICBkaXYucmVtb3ZlQ2hpbGQoZGl2LmNoaWxkTm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBtdXN0IG9ubHkgaGF2ZSAxIHJvb3QgZWxlbWVudFxuICBjb25zdCBzdmdFbG0gPSBkaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIGlmIChzdmdFbG0gJiYgc3ZnRWxtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgY29uc3Qgc3ZnQ2xhc3MgPSBzdmdFbG0uZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgIHN2Z0VsbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKHN2Z0NsYXNzICsgJyBzLWlvbi1pY29uJykudHJpbSgpKTtcbiAgICAvLyByb290IGVsZW1lbnQgbXVzdCBiZSBhbiBzdmdcbiAgICAvLyBsZXRzIGRvdWJsZSBjaGVjayB3ZSd2ZSBnb3QgdmFsaWQgZWxlbWVudHNcbiAgICAvLyBkbyBub3QgYWxsb3cgc2NyaXB0c1xuICAgIGlmIChpc1ZhbGlkKHN2Z0VsbSkpIHtcbiAgICAgIHJldHVybiBkaXYuaW5uZXJIVE1MO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59O1xuY29uc3QgaXNWYWxpZCA9IChlbG0pID0+IHtcbiAgaWYgKGVsbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGlmIChlbG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbG0uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsID0gZWxtLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgICBpZiAoaXNTdHIodmFsKSAmJiB2YWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvbicpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbG0uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc1ZhbGlkKGVsbS5jaGlsZE5vZGVzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaW9uaWNvbkNvbnRlbnQgPSBuZXcgTWFwKCk7XG5jb25zdCByZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbmNvbnN0IGdldFN2Z0NvbnRlbnQgPSAodXJsLCBzYW5pdGl6ZSkgPT4ge1xuICAvLyBzZWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVxdWVzdCBmb3IgdGhpcyB1cmxcbiAgbGV0IHJlcSA9IHJlcXVlc3RzLmdldCh1cmwpO1xuICBpZiAoIXJlcSkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIHJlcXVlc3RcbiAgICAgIHJlcSA9IGZldGNoKHVybCkudGhlbigocnNwKSA9PiB7XG4gICAgICAgIGlmIChyc3Aub2spIHtcbiAgICAgICAgICByZXR1cm4gcnNwLnRleHQoKS50aGVuKChzdmdDb250ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3ZnQ29udGVudCAmJiBzYW5pdGl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3ZnQ29udGVudCA9IHZhbGlkYXRlQ29udGVudChzdmdDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlvbmljb25Db250ZW50LnNldCh1cmwsIHN2Z0NvbnRlbnQgfHwgJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlvbmljb25Db250ZW50LnNldCh1cmwsICcnKTtcbiAgICAgIH0pO1xuICAgICAgLy8gY2FjaGUgZm9yIHRoZSBzYW1lIHJlcXVlc3RzXG4gICAgICByZXF1ZXN0cy5zZXQodXJsLCByZXEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHNldCB0byBlbXB0eSBmb3Igc3NyIHNjZW5hcmlvcyBhbmQgcmVzb2x2ZSBwcm9taXNlXG4gICAgICBpb25pY29uQ29udGVudC5zZXQodXJsLCAnJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXE7XG59O1xuXG5jb25zdCBpY29uQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxZW07aGVpZ2h0OjFlbTtjb250YWluOnN0cmljdDtmaWxsOmN1cnJlbnRDb2xvcjstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudDtib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnR9Omhvc3QgLmlvbmljb257c3Ryb2tlOmN1cnJlbnRDb2xvcn0uaW9uaWNvbi1maWxsLW5vbmV7ZmlsbDpub25lfS5pb25pY29uLXN0cm9rZS13aWR0aHtzdHJva2Utd2lkdGg6MzJweDtzdHJva2Utd2lkdGg6dmFyKC0taW9uaWNvbi1zdHJva2Utd2lkdGgsIDMycHgpfS5pY29uLWlubmVyLC5pb25pY29uLHN2Z3tkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO3dpZHRoOjEwMCV9Omhvc3QoLmZsaXAtcnRsKSAuaWNvbi1pbm5lcnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZVgoLTEpfTpob3N0KC5pY29uLXNtYWxsKXtmb250LXNpemU6MThweCAhaW1wb3J0YW50fTpob3N0KC5pY29uLWxhcmdlKXtmb250LXNpemU6MzJweCAhaW1wb3J0YW50fTpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKSAhaW1wb3J0YW50fTpob3N0KC5pb24tY29sb3ItcHJpbWFyeSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZil9Omhvc3QoLmlvbi1jb2xvci1zZWNvbmRhcnkpey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLXNlY29uZGFyeSwgIzBjZDFlOCl9Omhvc3QoLmlvbi1jb2xvci10ZXJ0aWFyeSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItdGVydGlhcnksICNmNGE5NDIpfTpob3N0KC5pb24tY29sb3Itc3VjY2Vzcyl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3Itc3VjY2VzcywgIzEwZGM2MCl9Omhvc3QoLmlvbi1jb2xvci13YXJuaW5nKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci13YXJuaW5nLCAjZmZjZTAwKX06aG9zdCguaW9uLWNvbG9yLWRhbmdlcil7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItZGFuZ2VyLCAjZjE0MTQxKX06aG9zdCguaW9uLWNvbG9yLWxpZ2h0KXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1saWdodCwgI2Y0ZjVmOCl9Omhvc3QoLmlvbi1jb2xvci1tZWRpdW0pey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLW1lZGl1bSwgIzk4OWFhMil9Omhvc3QoLmlvbi1jb2xvci1kYXJrKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1kYXJrLCAjMjIyNDI4KX1cIjtcblxubGV0IEljb24gPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaWNvbk5hbWUgPSBudWxsO1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGUgZGV0ZXJtaW5lcyB3aGljaCBwbGF0Zm9ybSBzdHlsZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IGdldElvbk1vZGUoKTtcbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkLCBpb24taWNvbiB3aWxsIGJlIGxvYWRlZCBsYXppbHkgd2hlbiBpdCdzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIERlZmF1bHQsIGBmYWxzZWAuXG4gICAgICovXG4gICAgdGhpcy5sYXp5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgU1ZHIGNvbnRlbnQgdGhhdCBpcyBIVFRQIGZldGNoZWQgd2lsbCBub3QgYmUgY2hlY2tlZFxuICAgICAqIGlmIHRoZSByZXNwb25zZSBTVkcgY29udGVudCBoYXMgYW55IGA8c2NyaXB0PmAgZWxlbWVudHMsIG9yIGFueSBhdHRyaWJ1dGVzXG4gICAgICogdGhhdCBzdGFydCB3aXRoIGBvbmAsIHN1Y2ggYXMgYG9uY2xpY2tgLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnNhbml0aXplID0gdHJ1ZTtcbiAgICB0aGlzLmhhc0FyaWFIaWRkZW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGVsIH0gPSB0aGlzO1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgPT09ICd0cnVlJztcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IGluaGVyaXRBdHRyaWJ1dGVzKHRoaXMuZWwsIFsnYXJpYS1sYWJlbCddKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAvLyBwdXJwb3NlbHkgZG8gbm90IHJldHVybiB0aGUgcHJvbWlzZSBoZXJlIGJlY2F1c2UgbG9hZGluZ1xuICAgIC8vIHRoZSBzdmcgZmlsZSBzaG91bGQgbm90IGhvbGQgdXAgbG9hZGluZyB0aGUgYXBwXG4gICAgLy8gb25seSBsb2FkIHRoZSBzdmcgaWYgaXQncyB2aXNpYmxlXG4gICAgdGhpcy53YWl0VW50aWxWaXNpYmxlKHRoaXMuZWwsICc1MHB4JywgKCkgPT4ge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5sb2FkSWNvbigpO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmlvKSB7XG4gICAgICB0aGlzLmlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuaW8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHdhaXRVbnRpbFZpc2libGUoZWwsIHJvb3RNYXJnaW4sIGNiKSB7XG4gICAgaWYgKEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLmxhenkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBjb25zdCBpbyA9ICh0aGlzLmlvID0gbmV3IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlcigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YVswXS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLmlvID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHsgcm9vdE1hcmdpbiB9KSk7XG4gICAgICBpby5vYnNlcnZlKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgLy8gc28ganVzdCBmYWxsYmFjayB0byBhbHdheXMgc2hvdyBpdFxuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbiAgbG9hZEljb24oKSB7XG4gICAgaWYgKEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgY29uc3QgdXJsID0gZ2V0VXJsKHRoaXMpO1xuICAgICAgaWYgKHVybCkge1xuICAgICAgICBpZiAoaW9uaWNvbkNvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAvLyBzeW5jIGlmIGl0J3MgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICB0aGlzLnN2Z0NvbnRlbnQgPSBpb25pY29uQ29udGVudC5nZXQodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhc3luYyBpZiBpdCBoYXNuJ3QgYmVlbiBsb2FkZWRcbiAgICAgICAgICBnZXRTdmdDb250ZW50KHVybCwgdGhpcy5zYW5pdGl6ZSkudGhlbigoKSA9PiAodGhpcy5zdmdDb250ZW50ID0gaW9uaWNvbkNvbnRlbnQuZ2V0KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuaWNvbk5hbWUgPSBnZXROYW1lKHRoaXMubmFtZSwgdGhpcy5pY29uLCB0aGlzLm1vZGUsIHRoaXMuaW9zLCB0aGlzLm1kKTtcbiAgICAvKipcbiAgICAgKiBDb21lIHVwIHdpdGggYSBkZWZhdWx0IGxhYmVsXG4gICAgICogaW4gY2FzZSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgdGhlaXIgb3duLlxuICAgICAqL1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hcmlhTGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9cXC0vZywgJyAnKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaWNvbk5hbWUsIGFyaWFMYWJlbCwgaW5oZXJpdGVkQXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlIHx8ICdtZCc7XG4gICAgY29uc3QgZmxpcFJ0bCA9IHRoaXMuZmxpcFJ0bCB8fFxuICAgICAgKGljb25OYW1lICYmXG4gICAgICAgIChpY29uTmFtZS5pbmRleE9mKCdhcnJvdycpID4gLTEgfHwgaWNvbk5hbWUuaW5kZXhPZignY2hldnJvbicpID4gLTEpICYmXG4gICAgICAgIHRoaXMuZmxpcFJ0bCAhPT0gZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIE9ubHkgc2V0IHRoZSBhcmlhLWxhYmVsIGlmIGEpIHdlIGhhdmUgZ2VuZXJhdGVkXG4gICAgICogb25lIGZvciB0aGUgaWNvbiBhbmQgaWYgYXJpYS1oaWRkZW4gaXMgbm90IHNldCB0byBcInRydWVcIi5cbiAgICAgKiBJZiBkZXZlbG9wZXIgd2FudHMgdG8gc2V0IHRoZWlyIG93biBhcmlhLWxhYmVsLCB0aGVuXG4gICAgICogaW5oZXJpdGVkQXR0cmlidXRlcyBkb3duIGJlbG93IHdpbGwgb3ZlcnJpZGUgd2hhdGV2ZXJcbiAgICAgKiBkZWZhdWx0IGxhYmVsIHdlIGhhdmUgc2V0LlxuICAgICAqL1xuICAgIHJldHVybiAoaChIb3N0LCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhc0FyaWFIaWRkZW4oKSA/IGFyaWFMYWJlbCA6IG51bGwsIHJvbGU6IFwiaW1nXCIsIGNsYXNzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBbbW9kZV06IHRydWUgfSwgY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IpKSwgeyBbYGljb24tJHt0aGlzLnNpemV9YF06ICEhdGhpcy5zaXplLCAnZmxpcC1ydGwnOiAhIWZsaXBSdGwgJiYgdGhpcy5lbC5vd25lckRvY3VtZW50LmRpciA9PT0gJ3J0bCcgfSkgfSwgaW5oZXJpdGVkQXR0cmlidXRlcyksIEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLnN2Z0NvbnRlbnQgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBcImljb24taW5uZXJcIiwgaW5uZXJIVE1MOiB0aGlzLnN2Z0NvbnRlbnQgfSkpIDogKGgoXCJkaXZcIiwgeyBjbGFzczogXCJpY29uLWlubmVyXCIgfSkpKSk7XG4gIH1cbiAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1wic3ZnXCJdOyB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcIm5hbWVcIjogW1wibG9hZEljb25cIl0sXG4gICAgXCJzcmNcIjogW1wibG9hZEljb25cIl0sXG4gICAgXCJpY29uXCI6IFtcImxvYWRJY29uXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIGljb25Dc3M7IH1cbn07XG5jb25zdCBnZXRJb25Nb2RlID0gKCkgPT4gKEJ1aWxkLmlzQnJvd3NlciAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGUnKSkgfHwgJ21kJztcbmNvbnN0IGNyZWF0ZUNvbG9yQ2xhc3NlcyA9IChjb2xvcikgPT4ge1xuICByZXR1cm4gY29sb3JcbiAgICA/IHtcbiAgICAgICdpb24tY29sb3InOiB0cnVlLFxuICAgICAgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSxcbiAgICB9XG4gICAgOiBudWxsO1xufTtcbkljb24gPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChJY29uLCBbMSwgXCJpb24taWNvblwiLCB7XG4gICAgXCJtb2RlXCI6IFsxMDI1XSxcbiAgICBcImNvbG9yXCI6IFsxXSxcbiAgICBcImlvc1wiOiBbMV0sXG4gICAgXCJtZFwiOiBbMV0sXG4gICAgXCJmbGlwUnRsXCI6IFs0LCBcImZsaXAtcnRsXCJdLFxuICAgIFwibmFtZVwiOiBbNTEzXSxcbiAgICBcInNyY1wiOiBbMV0sXG4gICAgXCJpY29uXCI6IFs4XSxcbiAgICBcInNpemVcIjogWzFdLFxuICAgIFwibGF6eVwiOiBbNF0sXG4gICAgXCJzYW5pdGl6ZVwiOiBbNF0sXG4gICAgXCJzdmdDb250ZW50XCI6IFszMl0sXG4gICAgXCJpc1Zpc2libGVcIjogWzMyXSxcbiAgICBcImFyaWFMYWJlbFwiOiBbMzJdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1pY29uXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgSWNvbik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uSWNvbiA9IEljb247XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25JY29uLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCJleHBvcnQgKiBmcm9tICcuL2VzbS1lczUvaW5kZXguanMnOyIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCwgY3JlYXRlRWxlbWVudCwgdXNlU3RhdGUsIEZyYWdtZW50LCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzUGxhdGZvcm0gYXMgaXNQbGF0Zm9ybSQxLCBnZXRQbGF0Zm9ybXMgYXMgZ2V0UGxhdGZvcm1zJDEsIGFsZXJ0Q29udHJvbGxlciwgbG9hZGluZ0NvbnRyb2xsZXIsIHRvYXN0Q29udHJvbGxlciBhcyB0b2FzdENvbnRyb2xsZXIkMSwgcGlja2VyQ29udHJvbGxlciwgYWN0aW9uU2hlZXRDb250cm9sbGVyIGFzIGFjdGlvblNoZWV0Q29udHJvbGxlciQxLCBjcmVhdGVBbmltYXRpb24sIG1vZGFsQ29udHJvbGxlciwgcG9wb3ZlckNvbnRyb2xsZXIsIGluaXRpYWxpemUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzJztcbmV4cG9ydCB7IElvbmljU2FmZVN0cmluZywgSW9uaWNTbGlkZXMsIElvbmljU3dpcGVyLCBjcmVhdGVBbmltYXRpb24sIGNyZWF0ZUdlc3R1cmUsIGdldFRpbWVHaXZlblByb2dyZXNzaW9uLCBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uLCBtZFRyYW5zaXRpb25BbmltYXRpb24gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzJztcbmltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hY2NvcmRpb24uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hY2NvcmRpb24tZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDMgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hdmF0YXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1iYWNrZHJvcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkNSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJhZGdlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ2IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYnJlYWRjcnVtYnMuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1idXR0b25zLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ5IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC1oZWFkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jYXJkLXN1YnRpdGxlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRiIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC10aXRsZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkYyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNoZWNrYm94LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRkIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2hpcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkZSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNvbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkZiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1kYXRldGltZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkaCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWZhYi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkaSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWZhYi1saXN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRqIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZm9vdGVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRrIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZ3JpZC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWhlYWRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWltZy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWluZmluaXRlLXNjcm9sbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWluZmluaXRlLXNjcm9sbC1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRwIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taW5wdXQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLWRpdmlkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLWdyb3VwLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRzIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS1vcHRpb25zLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR0IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS1zbGlkaW5nLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR1IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbGFiZWwuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1saXN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR3IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbGlzdC1oZWFkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tZW51LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR5IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbWVudS1idXR0b24uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHogfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tZW51LXRvZ2dsZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkQSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW5hdi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkQiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW5hdi1saW5rLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRDIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbm90ZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkRCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXByb2dyZXNzLWJhci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkRSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJhZGlvLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRGIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmFkaW8tZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yYW5nZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlZnJlc2hlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlZnJlc2hlci1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRKIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmVvcmRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlb3JkZXItZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEwgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yaXBwbGUtZWZmZWN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRNIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcm93LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCROIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VhcmNoYmFyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRPIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VnbWVudC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkUCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNlZ21lbnQtYnV0dG9uLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRRIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VsZWN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRSIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VsZWN0LW9wdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkUyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNrZWxldG9uLXRleHQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zbGlkZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkVSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNsaWRlcy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkViB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNwaW5uZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zcGxpdC1wYW5lLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRYIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRZIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGV4dC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkWiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRleHRhcmVhLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRfIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGh1bWJuYWlsLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQkIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGl0bGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEwIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdG9nZ2xlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRvb2xiYXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEyIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdmlydHVhbC1zY3JvbGwuanMnO1xuaW1wb3J0IHsgSW9uQnJlYWRjcnVtYiBhcyBJb25CcmVhZGNydW1iJDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1icmVhZGNydW1iLmpzJztcbmltcG9ydCB7IElvbkJ1dHRvbiBhcyBJb25CdXR0b24kMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBJb25DYXJkIGFzIElvbkNhcmQkMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNhcmQuanMnO1xuaW1wb3J0IHsgSW9uRmFiQnV0dG9uIGFzIElvbkZhYkJ1dHRvbiQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZmFiLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBJb25JdGVtT3B0aW9uIGFzIElvbkl0ZW1PcHRpb24kMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWl0ZW0tb3B0aW9uLmpzJztcbmltcG9ydCB7IElvbkl0ZW0gYXMgSW9uSXRlbSQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS5qcyc7XG5pbXBvcnQgeyBJb25Sb3V0ZXJMaW5rIGFzIElvblJvdXRlckxpbmskMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJvdXRlci1saW5rLmpzJztcbmltcG9ydCB7IElvbkFsZXJ0IGFzIElvbkFsZXJ0JDEsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFsZXJ0LmpzJztcbmltcG9ydCB7IElvbkxvYWRpbmcgYXMgSW9uTG9hZGluZyQxLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMWYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1sb2FkaW5nLmpzJztcbmltcG9ydCB7IElvblRvYXN0IGFzIElvblRvYXN0JDEsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRvYXN0LmpzJztcbmltcG9ydCB7IElvblBpY2tlciBhcyBJb25QaWNrZXIkMSwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDFlIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcGlja2VyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFjdGlvbi1zaGVldC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tb2RhbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1wb3BvdmVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFwcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1iYWNrLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTkgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yb3V0ZXItb3V0bGV0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRhYi1iYXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDE2IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMWIgfSBmcm9tICdpb25pY29ucy9jb21wb25lbnRzL2lvbi1pY29uLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICdAaW9uaWMvY29yZSc7XG5cbmNvbnN0IElvbkxpZmVDeWNsZUNvbnRleHQgPSAvKkBfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIG9uSW9uVmlld1dpbGxFbnRlcjogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBpb25WaWV3V2lsbEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIG9uSW9uVmlld0RpZEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGlvblZpZXdEaWRFbnRlcjogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBvbklvblZpZXdXaWxsTGVhdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgaW9uVmlld1dpbGxMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBvbklvblZpZXdEaWRMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBpb25WaWV3RGlkTGVhdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG59KTtcbmNvbnN0IERlZmF1bHRJb25MaWZlQ3ljbGVDb250ZXh0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIG9uSW9uVmlld1dpbGxFbnRlcihjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3V2lsbEVudGVyQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3NbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld1dpbGxFbnRlcigpIHtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbEVudGVyQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9XG4gICAgb25Jb25WaWV3RGlkRW50ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld0RpZEVudGVyKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfVxuICAgIG9uSW9uVmlld1dpbGxMZWF2ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3NbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld1dpbGxMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9XG4gICAgb25Jb25WaWV3RGlkTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRMZWF2ZUNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld0RpZExlYXZlKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdEaWRMZWF2ZUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWQoKTtcbiAgICB9XG4gICAgb25Db21wb25lbnRDYW5CZURlc3Ryb3llZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENhbkJlRGVzdHJveWVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgY29tcG9uZW50Q2FuQmVEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudENhbkJlRGVzdHJveWVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3Qgd2l0aElvbkxpZmVDeWNsZSA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzIElvbkxpZmVDeWNsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY29tcG9uZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3V2lsbEVudGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlvblZpZXdXaWxsRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3V2lsbEVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3RGlkRW50ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld0RpZEVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW9uVmlld0RpZEVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3V2lsbExlYXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlvblZpZXdXaWxsTGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3V2lsbExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3RGlkTGVhdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld0RpZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW9uVmlld0RpZExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvbkxpZmVDeWNsZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmNvbXBvbmVudFJlZiB9LCB0aGlzLnByb3BzKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgdXNlSW9uVmlld1dpbGxFbnRlciA9IChjYWxsYmFjaywgZGVwcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uTGlmZUN5Y2xlQ29udGV4dCk7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYoKTtcbiAgICBpZC5jdXJyZW50ID0gaWQuY3VycmVudCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5pZCA9IGlkLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQub25Jb25WaWV3V2lsbEVudGVyKGNhbGxiYWNrKTtcbiAgICB9LCBkZXBzKTtcbn07XG5jb25zdCB1c2VJb25WaWV3RGlkRW50ZXIgPSAoY2FsbGJhY2ssIGRlcHMgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KElvbkxpZmVDeWNsZUNvbnRleHQpO1xuICAgIGNvbnN0IGlkID0gdXNlUmVmKCk7XG4gICAgaWQuY3VycmVudCA9IGlkLmN1cnJlbnQgfHwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2suaWQgPSBpZC5jdXJyZW50O1xuICAgICAgICBjb250ZXh0Lm9uSW9uVmlld0RpZEVudGVyKGNhbGxiYWNrKTtcbiAgICB9LCBkZXBzKTtcbn07XG5jb25zdCB1c2VJb25WaWV3V2lsbExlYXZlID0gKGNhbGxiYWNrLCBkZXBzID0gW10pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJb25MaWZlQ3ljbGVDb250ZXh0KTtcbiAgICBjb25zdCBpZCA9IHVzZVJlZigpO1xuICAgIGlkLmN1cnJlbnQgPSBpZC5jdXJyZW50IHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmlkID0gaWQuY3VycmVudDtcbiAgICAgICAgY29udGV4dC5vbklvblZpZXdXaWxsTGVhdmUoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcbmNvbnN0IHVzZUlvblZpZXdEaWRMZWF2ZSA9IChjYWxsYmFjaywgZGVwcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uTGlmZUN5Y2xlQ29udGV4dCk7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYoKTtcbiAgICBpZC5jdXJyZW50ID0gaWQuY3VycmVudCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5pZCA9IGlkLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQub25Jb25WaWV3RGlkTGVhdmUoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcblxuY29uc3QgTmF2Q29udGV4dCA9IC8qQF9fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgZ2V0SW9uUmVkaXJlY3Q6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnZXRJb25Sb3V0ZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldFBhZ2VNYW5hZ2VyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ2V0U3RhY2tNYW5hZ2VyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ29CYWNrOiAocm91dGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvdXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9IHJvdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBuYXZpZ2F0ZTogKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXNJb25pY1JvdXRlcjogKCkgPT4gZmFsc2UsXG4gICAgcm91dGVJbmZvOiB1bmRlZmluZWQsXG4gICAgc2V0Q3VycmVudFRhYjogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNoYW5nZVRhYjogKF90YWIsIHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldFRhYjogKF90YWIsIHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5jb25zdCBkYXNoVG9QYXNjYWxDYXNlID0gKHN0cikgPT4gc3RyXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAuc3BsaXQoJy0nKVxuICAgIC5tYXAoKHNlZ21lbnQpID0+IHNlZ21lbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWdtZW50LnNsaWNlKDEpKVxuICAgIC5qb2luKCcnKTtcbmNvbnN0IGNhbWVsVG9EYXNoQ2FzZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIChtKSA9PiBgLSR7bVswXS50b0xvd2VyQ2FzZSgpfWApO1xuXG5jb25zdCBhdHRhY2hQcm9wcyA9IChub2RlLCBuZXdQcm9wcywgb2xkUHJvcHMgPSB7fSkgPT4ge1xuICAgIC8vIHNvbWUgdGVzdCBmcmFtZXdvcmtzIGRvbid0IHJlbmRlciBET00gZWxlbWVudHMsIHNvIHdlIHRlc3QgaGVyZSB0byBtYWtlIHN1cmUgd2UgYXJlIGRlYWxpbmcgd2l0aCBET00gZmlyc3RcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYWRkIGFueSBjbGFzc2VzIGluIGNsYXNzTmFtZSB0byB0aGUgY2xhc3MgbGlzdFxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUobm9kZS5jbGFzc0xpc3QsIG5ld1Byb3BzLCBvbGRQcm9wcyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUgIT09ICcnKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhuZXdQcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjaGlsZHJlbicgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ3JlZicgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2NsYXNzTmFtZScgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnZm9yd2FyZGVkUmVmJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbmFtZVsyXSA9PT0gbmFtZVsyXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbmFtZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lTGMgPSBldmVudE5hbWVbMF0udG9Mb3dlckNhc2UoKSArIGV2ZW50TmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZUxjKSkge1xuICAgICAgICAgICAgICAgICAgICBzeW5jRXZlbnQobm9kZSwgZXZlbnROYW1lTGMsIG5ld1Byb3BzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW25hbWVdID0gbmV3UHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFR5cGUgPSB0eXBlb2YgbmV3UHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjYW1lbFRvRGFzaENhc2UobmFtZSksIG5ld1Byb3BzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRDbGFzc05hbWUgPSAoY2xhc3NMaXN0LCBuZXdQcm9wcywgb2xkUHJvcHMpID0+IHtcbiAgICBjb25zdCBuZXdDbGFzc1Byb3AgPSBuZXdQcm9wcy5jbGFzc05hbWUgfHwgbmV3UHJvcHMuY2xhc3M7XG4gICAgY29uc3Qgb2xkQ2xhc3NQcm9wID0gb2xkUHJvcHMuY2xhc3NOYW1lIHx8IG9sZFByb3BzLmNsYXNzO1xuICAgIC8vIG1hcCB0aGUgY2xhc3NlcyB0byBNYXBzIGZvciBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IGN1cnJlbnRDbGFzc2VzID0gYXJyYXlUb01hcChjbGFzc0xpc3QpO1xuICAgIGNvbnN0IGluY29taW5nUHJvcENsYXNzZXMgPSBhcnJheVRvTWFwKG5ld0NsYXNzUHJvcCA/IG5ld0NsYXNzUHJvcC5zcGxpdCgnICcpIDogW10pO1xuICAgIGNvbnN0IG9sZFByb3BDbGFzc2VzID0gYXJyYXlUb01hcChvbGRDbGFzc1Byb3AgPyBvbGRDbGFzc1Byb3Auc3BsaXQoJyAnKSA6IFtdKTtcbiAgICBjb25zdCBmaW5hbENsYXNzTmFtZXMgPSBbXTtcbiAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBvZiB0aGUgY3VycmVudCBjbGFzc2VzIG9uIHRoZSBjb21wb25lbnRcbiAgICAvLyB0byBzZWUgaWYgaXQgc2hvdWxkIGJlIGEgcGFydCBvZiB0aGUgY2xhc3NOYW1lcyBhZGRlZFxuICAgIGN1cnJlbnRDbGFzc2VzLmZvckVhY2goKGN1cnJlbnRDbGFzcykgPT4ge1xuICAgICAgICBpZiAoaW5jb21pbmdQcm9wQ2xhc3Nlcy5oYXMoY3VycmVudENsYXNzKSkge1xuICAgICAgICAgICAgLy8gYWRkIGl0IGFzIGl0cyBhbHJlYWR5IGluY2x1ZGVkIGluIGNsYXNzbmFtZXMgY29taW5nIGluIGZyb20gbmV3UHJvcHNcbiAgICAgICAgICAgIGZpbmFsQ2xhc3NOYW1lcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgICAgICBpbmNvbWluZ1Byb3BDbGFzc2VzLmRlbGV0ZShjdXJyZW50Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvbGRQcm9wQ2xhc3Nlcy5oYXMoY3VycmVudENsYXNzKSkge1xuICAgICAgICAgICAgLy8gYWRkIGl0IGFzIGl0IGhhcyBOT1QgYmVlbiByZW1vdmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGZpbmFsQ2xhc3NOYW1lcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbmNvbWluZ1Byb3BDbGFzc2VzLmZvckVhY2goKHMpID0+IGZpbmFsQ2xhc3NOYW1lcy5wdXNoKHMpKTtcbiAgICByZXR1cm4gZmluYWxDbGFzc05hbWVzLmpvaW4oJyAnKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmNvbnN0IGlzQ292ZXJlZEJ5UmVhY3QgPSAoZXZlbnROYW1lU3VmZml4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICAgICAgICBsZXQgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxufTtcbmNvbnN0IHN5bmNFdmVudCA9IChub2RlLCBldmVudE5hbWUsIG5ld0V2ZW50SGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IGV2ZW50U3RvcmUgPSBub2RlLl9fZXZlbnRzIHx8IChub2RlLl9fZXZlbnRzID0ge30pO1xuICAgIGNvbnN0IG9sZEV2ZW50SGFuZGxlciA9IGV2ZW50U3RvcmVbZXZlbnROYW1lXTtcbiAgICAvLyBSZW1vdmUgb2xkIGxpc3RlbmVyIHNvIHRoZXkgZG9uJ3QgZG91YmxlIHVwLlxuICAgIGlmIChvbGRFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgb2xkRXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gQmluZCBuZXcgbGlzdGVuZXIuXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGV2ZW50U3RvcmVbZXZlbnROYW1lXSA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICBpZiAobmV3RXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdFdmVudEhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbn07XG5jb25zdCBhcnJheVRvTWFwID0gKGFycikgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBhcnIuZm9yRWFjaCgocykgPT4gbWFwLnNldChzLCBzKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmNvbnN0IHNldFJlZiA9IChyZWYsIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2FzdCBhcyBhIE11dGFibGVSZWYgc28gd2UgY2FuIGFzc2lnbiBjdXJyZW50XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxufTtcbmNvbnN0IG1lcmdlUmVmcyA9ICguLi5yZWZzKSA9PiB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgICAgIHNldFJlZihyZWYsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5jb25zdCBjcmVhdGVGb3J3YXJkUmVmJDEgPSAoUmVhY3RDb21wb25lbnQsIGRpc3BsYXlOYW1lKSA9PiB7XG4gICAgY29uc3QgZm9yd2FyZFJlZiA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gICAgfTtcbiAgICBmb3J3YXJkUmVmLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgcmV0dXJuIFJlYWN0LmZvcndhcmRSZWYoZm9yd2FyZFJlZik7XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9ICh0YWdOYW1lLCBjdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGN1c3RvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgY3VzdG9tRWxlbWVudHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIGN1c3RvbUVsZW1lbnQpO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJlYWN0Q29tcG9uZW50ID0gKHRhZ05hbWUsIFJlYWN0Q29tcG9uZW50Q29udGV4dCwgbWFuaXB1bGF0ZVByb3BzRnVuY3Rpb24sIGRlZmluZUN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBpZiAoZGVmaW5lQ3VzdG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXNoVG9QYXNjYWxDYXNlKHRhZ05hbWUpO1xuICAgIGNvbnN0IFJlYWN0Q29tcG9uZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRDb21wb25lbnRFbFJlZiA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRFbCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgYXR0YWNoUHJvcHModGhpcy5jb21wb25lbnRFbCwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2hpbGRyZW4sIGZvcndhcmRlZFJlZiwgc3R5bGUsIGNsYXNzTmFtZSwgcmVmIH0gPSBfYSwgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImZvcndhcmRlZFJlZlwiLCBcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVmXCJdKTtcbiAgICAgICAgICAgIGxldCBwcm9wc1RvUGFzcyA9IE9iamVjdC5rZXlzKGNQcm9wcykucmVkdWNlKChhY2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdvbicpID09PSAwICYmIG5hbWVbMl0gPT09IG5hbWVbMl0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgaWYgKG1hbmlwdWxhdGVQcm9wc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1Bhc3MgPSBtYW5pcHVsYXRlUHJvcHNGdW5jdGlvbih0aGlzLnByb3BzLCBwcm9wc1RvUGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUb1Bhc3MpLCB7IHJlZjogbWVyZ2VSZWZzKGZvcndhcmRlZFJlZiwgdGhpcy5zZXRDb21wb25lbnRFbFJlZiksIHN0eWxlIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSB1c2UgY3JlYXRlRWxlbWVudCBoZXJlIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAqIFJlYWN0LmNyZWF0ZUVsZW1lbnQgdG8gd29yayBhcm91bmQgYVxuICAgICAgICAgICAgICogYnVnIGluIFZpdGUgKGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvNjEwNCkuXG4gICAgICAgICAgICAgKiBSZWFjdC5jcmVhdGVFbGVtZW50IGNhdXNlcyBhbGwgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAqIGFzIDx0YWduYW1lPiBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgV2ViIENvbXBvbmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgbmV3UHJvcHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjb250ZXh0IHdhcyBwYXNzZWQgdG8gY3JlYXRlUmVhY3RDb21wb25lbnQgdGhlbiBjb25kaXRpb25hbGx5IGFkZCBpdCB0byB0aGUgQ29tcG9uZW50IENsYXNzXG4gICAgaWYgKFJlYWN0Q29tcG9uZW50Q29udGV4dCkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5jb250ZXh0VHlwZSA9IFJlYWN0Q29tcG9uZW50Q29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcndhcmRSZWYkMShSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IElvbkFjY29yZGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1hY2NvcmRpb24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxKTtcbmNvbnN0IElvbkFjY29yZGlvbkdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWFjY29yZGlvbi1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDIpO1xuY29uc3QgSW9uQXZhdGFyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWF2YXRhcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDMpO1xuY29uc3QgSW9uQmFja2Ryb3AgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYmFja2Ryb3AnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ0KTtcbmNvbnN0IElvbkJhZGdlID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJhZGdlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkNSk7XG5jb25zdCBJb25CcmVhZGNydW1icyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1icmVhZGNydW1icycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDYpO1xuY29uc3QgSW9uQnV0dG9ucyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1idXR0b25zJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkNyk7XG5jb25zdCBJb25DYXJkQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLWNvbnRlbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4KTtcbmNvbnN0IElvbkNhcmRIZWFkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2FyZC1oZWFkZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ5KTtcbmNvbnN0IElvbkNhcmRTdWJ0aXRsZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLXN1YnRpdGxlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkYSk7XG5jb25zdCBJb25DYXJkVGl0bGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2FyZC10aXRsZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGIpO1xuY29uc3QgSW9uQ2hlY2tib3ggPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2hlY2tib3gnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRjKTtcbmNvbnN0IElvbkNoaXAgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2hpcCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGQpO1xuY29uc3QgSW9uQ29sID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWNvbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGUpO1xuY29uc3QgSW9uQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jb250ZW50JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkZik7XG5jb25zdCBJb25EYXRldGltZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1kYXRldGltZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGcpO1xuY29uc3QgSW9uRmFiID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWZhYicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGgpO1xuY29uc3QgSW9uRmFiTGlzdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1mYWItbGlzdCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGkpO1xuY29uc3QgSW9uRm9vdGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWZvb3RlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGopO1xuY29uc3QgSW9uR3JpZCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1ncmlkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkayk7XG5jb25zdCBJb25IZWFkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taGVhZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkbCk7XG5jb25zdCBJb25JbWcgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taW1nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkbSk7XG5jb25zdCBJb25JbmZpbml0ZVNjcm9sbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbmZpbml0ZS1zY3JvbGwnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRuKTtcbmNvbnN0IElvbkluZmluaXRlU2Nyb2xsQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbmZpbml0ZS1zY3JvbGwtY29udGVudCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JG8pO1xuY29uc3QgSW9uSW5wdXQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taW5wdXQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRwKTtcbmNvbnN0IElvbkl0ZW1EaXZpZGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tZGl2aWRlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHEpO1xuY29uc3QgSW9uSXRlbUdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tZ3JvdXAnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRyKTtcbmNvbnN0IElvbkl0ZW1PcHRpb25zID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tb3B0aW9ucycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHMpO1xuY29uc3QgSW9uSXRlbVNsaWRpbmcgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taXRlbS1zbGlkaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdCk7XG5jb25zdCBJb25MYWJlbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1sYWJlbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHUpO1xuY29uc3QgSW9uTGlzdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1saXN0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdik7XG5jb25zdCBJb25MaXN0SGVhZGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWxpc3QtaGVhZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdyk7XG5jb25zdCBJb25NZW51ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLW1lbnUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR4KTtcbmNvbnN0IElvbk1lbnVCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbWVudS1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR5KTtcbmNvbnN0IElvbk1lbnVUb2dnbGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbWVudS10b2dnbGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR6KTtcbmNvbnN0IElvbk5hdiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1uYXYnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRBKTtcbmNvbnN0IElvbk5hdkxpbmsgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbmF2LWxpbmsnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRCKTtcbmNvbnN0IElvbk5vdGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbm90ZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEMpO1xuY29uc3QgSW9uUHJvZ3Jlc3NCYXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcHJvZ3Jlc3MtYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkRCk7XG5jb25zdCBJb25SYWRpbyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yYWRpbycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEUpO1xuY29uc3QgSW9uUmFkaW9Hcm91cCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yYWRpby1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEYpO1xuY29uc3QgSW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmFuZ2UnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRHKTtcbmNvbnN0IElvblJlZnJlc2hlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yZWZyZXNoZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRIKTtcbmNvbnN0IElvblJlZnJlc2hlckNvbnRlbnQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmVmcmVzaGVyLWNvbnRlbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRJKTtcbmNvbnN0IElvblJlb3JkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmVvcmRlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEopO1xuY29uc3QgSW9uUmVvcmRlckdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJlb3JkZXItZ3JvdXAnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRLKTtcbmNvbnN0IElvblJpcHBsZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yaXBwbGUtZWZmZWN0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTCk7XG5jb25zdCBJb25Sb3cgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcm93JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTSk7XG5jb25zdCBJb25TZWFyY2hiYXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2VhcmNoYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTik7XG5jb25zdCBJb25TZWdtZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNlZ21lbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRPKTtcbmNvbnN0IElvblNlZ21lbnRCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2VnbWVudC1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRQKTtcbmNvbnN0IElvblNlbGVjdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWxlY3QnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRRKTtcbmNvbnN0IElvblNlbGVjdE9wdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWxlY3Qtb3B0aW9uJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkUik7XG5jb25zdCBJb25Ta2VsZXRvblRleHQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2tlbGV0b24tdGV4dCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFMpO1xuY29uc3QgSW9uU2xpZGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2xpZGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRUKTtcbmNvbnN0IElvblNsaWRlcyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zbGlkZXMnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRVKTtcbmNvbnN0IElvblNwaW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc3Bpbm5lcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFYpO1xuY29uc3QgSW9uU3BsaXRQYW5lID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNwbGl0LXBhbmUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRXKTtcbmNvbnN0IElvblRhYiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10YWInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRYKTtcbmNvbnN0IElvblRleHQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGV4dCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFkpO1xuY29uc3QgSW9uVGV4dGFyZWEgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGV4dGFyZWEnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRaKTtcbmNvbnN0IElvblRodW1ibmFpbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10aHVtYm5haWwnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRfKTtcbmNvbnN0IElvblRpdGxlID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRpdGxlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkJCk7XG5jb25zdCBJb25Ub2dnbGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdG9nZ2xlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTApO1xuY29uc3QgSW9uVG9vbGJhciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10b29sYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTEpO1xuY29uc3QgSW9uVmlydHVhbFNjcm9sbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi12aXJ0dWFsLXNjcm9sbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDEyKTtcblxuY29uc3QgY3JlYXRlRm9yd2FyZFJlZiA9IChSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpID0+IHtcbiAgICBjb25zdCBmb3J3YXJkUmVmID0gKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9O1xuICAgIGZvcndhcmRSZWYuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZihmb3J3YXJkUmVmKTtcbn07XG5jb25zdCBpc1BsYXRmb3JtID0gKHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuIGlzUGxhdGZvcm0kMSh3aW5kb3csIHBsYXRmb3JtKTtcbn07XG5jb25zdCBnZXRQbGF0Zm9ybXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFBsYXRmb3JtcyQxKHdpbmRvdyk7XG59O1xuY29uc3QgZ2V0Q29uZmlnID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBJb25pYyA9IHdpbmRvdy5Jb25pYztcbiAgICAgICAgaWYgKElvbmljICYmIElvbmljLmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIElvbmljLmNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGNyZWF0ZVJvdXRpbmdDb21wb25lbnQgPSAodGFnTmFtZSwgY3VzdG9tRWxlbWVudCkgPT4ge1xuICAgIGRlZmluZUN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY3VzdG9tRWxlbWVudCk7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXNoVG9QYXNjYWxDYXNlKHRhZ05hbWUpO1xuICAgIGNvbnN0IFJlYWN0Q29tcG9uZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByb3V0ZXJMaW5rLCByb3V0ZXJEaXJlY3Rpb24sIHJvdXRlck9wdGlvbnMsIHJvdXRlckFuaW1hdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBpZiAocm91dGVyTGluayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lm5hdmlnYXRlKHJvdXRlckxpbmssIHJvdXRlckRpcmVjdGlvbiwgdW5kZWZpbmVkLCByb3V0ZXJBbmltYXRpb24sIHJvdXRlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdG8gYXR0YWNoIHByb3BzIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgLy8gUmVhY3QgcmVmcyBtdXN0IGJlIHN0YWJsZSAobm90IGNyZWF0ZWQgaW5saW5lKS5cbiAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyA9IG1lcmdlUmVmcyh0aGlzLnJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyhub2RlLCB0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmLCBzdHlsZSwgY2xhc3NOYW1lLCByZWYgfSA9IF9hLCBjUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJyZWZcIl0pO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1Bhc3MgPSBPYmplY3Qua2V5cyhjUHJvcHMpLnJlZHVjZSgoYWNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignb24nKSA9PT0gMCAmJiBuYW1lWzJdID09PSBuYW1lWzJdLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ292ZXJlZEJ5UmVhY3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIGNQcm9wc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2NhbWVsVG9EYXNoQ2FzZShuYW1lKV0gPSBjUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUb1Bhc3MpLCB7IHJlZjogdGhpcy5zdGFibGVNZXJnZWRSZWZzLCBzdHlsZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnJvdXRlckxpbmsgJiYgIXRoaXMucHJvcHMuaHJlZikge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLmhyZWYgPSB0aGlzLnByb3BzLnJvdXRlckxpbms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3UHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZENsaWNrID0gbmV3UHJvcHMub25DbGljaztcbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5vbkNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgbmV3UHJvcHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZUZvcndhcmRSZWYoUmVhY3RDb21wb25lbnQsIGRpc3BsYXlOYW1lKTtcbn07XG5cbmNvbnN0IElvblJvdXRlckxpbmsgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1yb3V0ZXItbGluaycsIElvblJvdXRlckxpbmskMSk7XG5jb25zdCBJb25CdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1idXR0b24nLCBJb25CdXR0b24kMSk7XG5jb25zdCBJb25DYXJkID0gLypAX19QVVJFX18qLyBjcmVhdGVSb3V0aW5nQ29tcG9uZW50KCdpb24tY2FyZCcsIElvbkNhcmQkMSk7XG5jb25zdCBJb25GYWJCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1mYWItYnV0dG9uJywgSW9uRmFiQnV0dG9uJDEpO1xuY29uc3QgSW9uSXRlbSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWl0ZW0nLCBJb25JdGVtJDEpO1xuY29uc3QgSW9uSXRlbU9wdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWl0ZW0tb3B0aW9uJywgSW9uSXRlbU9wdGlvbiQxKTtcbmNvbnN0IElvbkJyZWFkY3J1bWIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1icmVhZGNydW1iJywgSW9uQnJlYWRjcnVtYiQxKTtcblxuY29uc3QgY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCA9ICh0YWdOYW1lLCBjb250cm9sbGVyLCBjdXN0b21FbGVtZW50KSA9PiB7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBjdXN0b21FbGVtZW50KTtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgZGlkRGlzbWlzc0V2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9RGlkRGlzbWlzc2A7XG4gICAgY29uc3QgZGlkUHJlc2VudEV2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9RGlkUHJlc2VudGA7XG4gICAgY29uc3Qgd2lsbERpc21pc3NFdmVudE5hbWUgPSBgb24ke2Rpc3BsYXlOYW1lfVdpbGxEaXNtaXNzYDtcbiAgICBjb25zdCB3aWxsUHJlc2VudEV2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9V2lsbFByZXNlbnRgO1xuICAgIGNsYXNzIE92ZXJsYXkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNtaXNzID0gdGhpcy5oYW5kbGVEaXNtaXNzLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNPcGVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJldlByb3BzLmlzT3BlbiAhPT0gdGhpcy5wcm9wcy5pc09wZW4gJiYgdGhpcy5wcm9wcy5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlbnQocHJldlByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkgJiYgcHJldlByb3BzLmlzT3BlbiAhPT0gdGhpcy5wcm9wcy5pc09wZW4gJiYgdGhpcy5wcm9wcy5pc09wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHByZXNlbnQocHJldlByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIGNQcm9wcyA9IF9fcmVzdChfYSwgW1wiaXNPcGVuXCIsIFwib25EaWREaXNtaXNzXCIsIFwib25EaWRQcmVzZW50XCIsIFwib25XaWxsRGlzbWlzc1wiLCBcIm9uV2lsbFByZXNlbnRcIl0pO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5ID0gYXdhaXQgY29udHJvbGxlci5jcmVhdGUoT2JqZWN0LmFzc2lnbih7fSwgY1Byb3BzKSk7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyh0aGlzLm92ZXJsYXksIHtcbiAgICAgICAgICAgICAgICBbZGlkRGlzbWlzc0V2ZW50TmFtZV06IHRoaXMuaGFuZGxlRGlzbWlzcyxcbiAgICAgICAgICAgICAgICBbZGlkUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiB0aGlzLnByb3BzLm9uRGlkUHJlc2VudCAmJiB0aGlzLnByb3BzLm9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgICAgICBbd2lsbERpc21pc3NFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzICYmIHRoaXMucHJvcHMub25XaWxsRGlzbWlzcyhlKSxcbiAgICAgICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50ICYmIHRoaXMucHJvcHMub25XaWxsUHJlc2VudChlKSxcbiAgICAgICAgICAgIH0sIHByZXZQcm9wcyk7XG4gICAgICAgICAgICAvLyBDaGVjayBpc09wZW4gYWdhaW4gc2luY2UgdGhlIHZhbHVlIGNvdWxkIGhhdmUgY2hhbmdlZCBkdXJpbmcgdGhlIGFzeW5jIGNhbGwgdG8gY29udHJvbGxlci5jcmVhdGVcbiAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBwb3NzaWJsZSBmb3IgdGhlIGNvbXBvbmVudCB0byBoYXZlIGJlY29tZSB1bm1vdW50ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5pc09wZW4gPT09IHRydWUgJiYgdGhpcy5pc1VubW91bnRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIHRoaXMub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vdmVybGF5LnByZXNlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBJb25BbGVydCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLWFsZXJ0JywgYWxlcnRDb250cm9sbGVyLCBJb25BbGVydCQxKTtcblxuY29uc3QgSW9uTG9hZGluZyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLWxvYWRpbmcnLCBsb2FkaW5nQ29udHJvbGxlciwgSW9uTG9hZGluZyQxKTtcblxuY29uc3QgdG9hc3RDb250cm9sbGVyID0ge1xuICAgIGNyZWF0ZTogKG9wdGlvbnMpID0+IHRvYXN0Q29udHJvbGxlciQxLmNyZWF0ZShvcHRpb25zKSxcbiAgICBkaXNtaXNzOiAoZGF0YSwgcm9sZSwgaWQpID0+IHRvYXN0Q29udHJvbGxlciQxLmRpc21pc3MoZGF0YSwgcm9sZSwgaWQpLFxuICAgIGdldFRvcDogKCkgPT4gdG9hc3RDb250cm9sbGVyJDEuZ2V0VG9wKCksXG59O1xuY29uc3QgSW9uVG9hc3QgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXJDb21wb25lbnQoJ2lvbi10b2FzdCcsIHRvYXN0Q29udHJvbGxlciwgSW9uVG9hc3QkMSk7XG5cbmNvbnN0IElvblBpY2tlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLXBpY2tlcicsIHBpY2tlckNvbnRyb2xsZXIsIElvblBpY2tlciQxKTtcblxuY29uc3QgY3JlYXRlT3ZlcmxheUNvbXBvbmVudCA9ICh0YWdOYW1lLCBjb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGRlZmluZUN1c3RvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZGFzaFRvUGFzY2FsQ2FzZSh0YWdOYW1lKTtcbiAgICBjb25zdCBkaWREaXNtaXNzRXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWREaXNtaXNzYDtcbiAgICBjb25zdCBkaWRQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWRQcmVzZW50YDtcbiAgICBjb25zdCB3aWxsRGlzbWlzc0V2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9V2lsbERpc21pc3NgO1xuICAgIGNvbnN0IHdpbGxQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1XaWxsUHJlc2VudGA7XG4gICAgY2xhc3MgT3ZlcmxheSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmlzRGlzbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc21pc3MgPSB0aGlzLmhhbmRsZURpc21pc3MuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBvdmVybGF5IGNvbXBvbmVudCBpcyBhYm91dCB0byBkaXNtaXNzXG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5ICYmIG5leHRQcm9wcy5pc09wZW4gIT09IHRoaXMucHJvcHMuaXNPcGVuICYmIG5leHRQcm9wcy5pc09wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc21pc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaFByb3BzKHRoaXMub3ZlcmxheSwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudChwcmV2UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxheSAmJiBwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXNtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTm93IHRoYXQgdGhlIG92ZXJsYXkgaXMgZGlzbWlzc2VkXG4gICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byByZW5kZXIgYWdhaW4gc28gdGhhdCBhbnlcbiAgICAgICAgICAgICAgICAgKiBpbm5lciBjb21wb25lbnRzIHdpbGwgYmUgdW5tb3VudGVkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHByZXNlbnQocHJldlByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIGNQcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJpc09wZW5cIiwgXCJvbkRpZERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxEaXNtaXNzXCIsIFwib25XaWxsUHJlc2VudFwiXSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNQcm9wcyksIHsgcmVmOiB0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgW2RpZERpc21pc3NFdmVudE5hbWVdOiB0aGlzLmhhbmRsZURpc21pc3MsIFtkaWRQcmVzZW50RXZlbnROYW1lXTogKGUpID0+IHRoaXMucHJvcHMub25EaWRQcmVzZW50ICYmIHRoaXMucHJvcHMub25EaWRQcmVzZW50KGUpLCBbd2lsbERpc21pc3NFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzICYmIHRoaXMucHJvcHMub25XaWxsRGlzbWlzcyhlKSwgW3dpbGxQcmVzZW50RXZlbnROYW1lXTogKGUpID0+IHRoaXMucHJvcHMub25XaWxsUHJlc2VudCAmJiB0aGlzLnByb3BzLm9uV2lsbFByZXNlbnQoZSkgfSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRQcm9wcyksIHsgY29tcG9uZW50OiB0aGlzLmVsLCBjb21wb25lbnRQcm9wczoge30gfSkpO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZm9yd2FyZGVkUmVmLCB0aGlzLm92ZXJsYXkpO1xuICAgICAgICAgICAgYXR0YWNoUHJvcHModGhpcy5vdmVybGF5LCBlbGVtZW50UHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkucHJlc2VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udGludWUgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQgZXZlbiB3aGVuXG4gICAgICAgICAgICAgKiBvdmVybGF5IGlzIGRpc21pc3Npbmcgb3RoZXJ3aXNlIGNvbXBvbmVudFxuICAgICAgICAgICAgICogd2lsbCBiZSBoaWRkZW4gYmVmb3JlIGFuaW1hdGlvbiBpcyBkb25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKHRoaXMucHJvcHMuaXNPcGVuIHx8IHRoaXMuaXNEaXNtaXNzaW5nID8gdGhpcy5wcm9wcy5jaGlsZHJlbiA6IG51bGwsIHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXksIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGFjdGlvblNoZWV0Q29udHJvbGxlciA9IHtcbiAgICBjcmVhdGU6IChvcHRpb25zKSA9PiBhY3Rpb25TaGVldENvbnRyb2xsZXIkMS5jcmVhdGUob3B0aW9ucyksXG4gICAgZGlzbWlzczogKGRhdGEsIHJvbGUsIGlkKSA9PiBhY3Rpb25TaGVldENvbnRyb2xsZXIkMS5kaXNtaXNzKGRhdGEsIHJvbGUsIGlkKSxcbiAgICBnZXRUb3A6ICgpID0+IGFjdGlvblNoZWV0Q29udHJvbGxlciQxLmdldFRvcCgpLFxufTtcbmNvbnN0IElvbkFjdGlvblNoZWV0ID0gLypAX19QVVJFX18qLyBjcmVhdGVPdmVybGF5Q29tcG9uZW50KCdpb24tYWN0aW9uLXNoZWV0JywgYWN0aW9uU2hlZXRDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDEzKTtcblxuY29uc3QgY3JlYXRlSW5saW5lT3ZlcmxheUNvbXBvbmVudCA9ICh0YWdOYW1lLCBkZWZpbmVDdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGRlZmluZUN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdG8gYXR0YWNoIHByb3BzIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgLy8gUmVhY3QgcmVmcyBtdXN0IGJlIHN0YWJsZSAobm90IGNyZWF0ZWQgaW5saW5lKS5cbiAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyA9IG1lcmdlUmVmcyh0aGlzLnJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50IGlzIGhpZGRlbiBieSBkZWZhdWx0XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0geyBpc09wZW46IGZhbHNlIH07XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdGhlIGlubmVyIGNoaWxkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLndyYXBwZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTW91bnQgdGhlIGlubmVyIGNvbXBvbmVudFxuICAgICAgICAgICAgICogd2hlbiBvdmVybGF5IGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICAgICAgICAgKiBBbHNvIG1hbnVhbGx5IGNhbGwgdGhlIG9uV2lsbFByZXNlbnRcbiAgICAgICAgICAgICAqIGhhbmRsZXIgaWYgcHJlc2VudCBhcyBzZXRTdGF0ZSB3aWxsXG4gICAgICAgICAgICAgKiBjYXVzZSB0aGUgZXZlbnQgaGFuZGxlcnMgdG8gYmVcbiAgICAgICAgICAgICAqIGRlc3Ryb3llZCBhbmQgcmUtY3JlYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKF9hID0gdGhpcy5yZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ3dpbGxQcmVzZW50JywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50ICYmIHRoaXMucHJvcHMub25XaWxsUHJlc2VudChldnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVubW91bnQgdGhlIGlubmVyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAqIFJlYWN0IHdpbGwgY2FsbCBOb2RlLnJlbW92ZUNoaWxkXG4gICAgICAgICAgICAgKiB3aGljaCBleHBlY3RzIHRoZSBjaGlsZCB0byBiZVxuICAgICAgICAgICAgICogYSBkaXJlY3QgZGVzY2VuZGVudCBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgKiBidXQgZHVlIHRvIHRoZSBwcmVzZW5jZSBvZlxuICAgICAgICAgICAgICogV2ViIENvbXBvbmVudCBzbG90cywgdGhpcyBpcyBub3RcbiAgICAgICAgICAgICAqIGFsd2F5cyB0aGUgY2FzZS4gVG8gd29yayBhcm91bmQgdGhpc1xuICAgICAgICAgICAgICogd2UgbW92ZSB0aGUgaW5uZXIgY29tcG9uZW50IHRvIHRoZSByb290XG4gICAgICAgICAgICAgKiBvZiB0aGUgV2ViIENvbXBvbmVudCBzbyBSZWFjdCBjYW5cbiAgICAgICAgICAgICAqIGNsZWFudXAgcHJvcGVybHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIChfYiA9IHRoaXMucmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdkaWREaXNtaXNzJywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBjb21wb25lbnQgbWlnaHQgYmUgdW5tb3VudGVkIGFscmVhZHksIGlmIHRoZSBjb250YWluaW5nXG4gICAgICAgICAgICAgICAgICogZWxlbWVudCB3YXMgcmVtb3ZlZCB3aGlsZSB0aGUgcG9wb3ZlciB3YXMgc3RpbGwgb3Blbi4gKEZvclxuICAgICAgICAgICAgICAgICAqIGV4YW1wbGUsIGlmIGFuIGl0ZW0gY29udGFpbnMgYW4gaW5saW5lIHBvcG92ZXIgd2l0aCBhIGJ1dHRvblxuICAgICAgICAgICAgICAgICAqIHRoYXQgcmVtb3ZlcyB0aGUgaXRlbS4pXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRpZERpc21pc3MgJiYgdGhpcy5wcm9wcy5vbkRpZERpc21pc3MoZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZi5jdXJyZW50O1xuICAgICAgICAgICAgYXR0YWNoUHJvcHMobm9kZSwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2hpbGRyZW4sIGZvcndhcmRlZFJlZiwgc3R5bGUsIGNsYXNzTmFtZSwgcmVmIH0gPSBfYSwgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImZvcndhcmRlZFJlZlwiLCBcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVmXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9QYXNzID0gT2JqZWN0LmtleXMoY1Byb3BzKS5yZWR1Y2UoKGFjYywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbmFtZVsyXSA9PT0gbmFtZVsyXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbJ3N0cmluZycsICdib29sZWFuJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiBjUHJvcHNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1tjYW1lbFRvRGFzaENhc2UobmFtZSldID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzVG9QYXNzKSwgeyByZWY6IHRoaXMuc3RhYmxlTWVyZ2VkUmVmcywgc3R5bGUgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIG9ubHkgd2FudCB0aGUgaW5uZXIgY29tcG9uZW50XG4gICAgICAgICAgICAgKiB0byBiZSBtb3VudGVkIGlmIHRoZSBvdmVybGF5IGlzIG9wZW4sXG4gICAgICAgICAgICAgKiBzbyBjb25kaXRpb25hbGx5IHJlbmRlciB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAgKiBiYXNlZCBvbiB0aGUgaXNPcGVuIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBuZXdQcm9wcywgKHRoaXMuc3RhdGUuaXNPcGVuKSA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lvbi1yZWFjdC13cmFwcGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0aGlzLndyYXBwZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbikgOlxuICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVGb3J3YXJkUmVmKFJlYWN0Q29tcG9uZW50LCBkaXNwbGF5TmFtZSk7XG59O1xuXG5jb25zdCBJb25Nb2RhbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlSW5saW5lT3ZlcmxheUNvbXBvbmVudCgnaW9uLW1vZGFsJywgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNCk7XG5cbmNvbnN0IElvblBvcG92ZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUlubGluZU92ZXJsYXlDb21wb25lbnQoJ2lvbi1wb3BvdmVyJywgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNSk7XG5cbmNvbnN0IElvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhZGRPdmVybGF5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIHJlbW92ZU92ZXJsYXk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG59KTtcblxuLyoqXG4gKiBNYW5hZ2VzIG92ZXJsYXlzIHRoYXQgYXJlIGFkZGVkIHZpYSB0aGUgdXNlT3ZlcmxheSBob29rLlxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgY29tcG9uZW50IHNvIGNoYW5nZXMgdG8gaXRzIGNoaWxkcmVuIGRvbid0IGNhdXNlIG90aGVyIGRlc2NlbmRhbnRcbiAqIGNvbXBvbmVudHMgdG8gcmUtcmVuZGVyIHdoZW4gb3ZlcmxheXMgYXJlIGFkZGVkLiBIb3dldmVyLCB3ZSBuZWVkIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIElvbkNvbnRleHRcbiAqIHRoYXQgaXMgc2V0IHVwIGluIDxJb25BcHAgLz4sIHNvIHdlIHJlZ2lzdGVyIGNhbGxiYWNrcyBzbyB3aGVuIG92ZXJsYXlzIGFyZSBhZGRlZCB0byBJb25Db250ZXh0LFxuICogdGhleSB1bHRpbWF0ZWx5IGFkZGVkIGhlcmUuXG4gKi9cbmNvbnN0IElvbk92ZXJsYXlNYW5hZ2VyID0gKHsgb25BZGRPdmVybGF5LCBvblJlbW92ZU92ZXJsYXksIH0pID0+IHtcbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSB3YXkgd2UncmUgcGFzc2luZyBhcm91bmQgdGhlIGFkZE92ZXJsYXkgYW5kIHJlbW92ZU92ZXJsYXlcbiAgICAgKiBjYWxsYmFja3MsIGJ5IHRoZSB0aW1lIHRoZXkgZmluYWxseSBnZXQgY2FsbGVkLCB0aGV5IHVzZSBhIHN0YWxlIHJlZmVyZW5jZVxuICAgICAqIHRvIHRoZSBzdGF0ZSB0aGF0IG9ubHkgaGFzIHRoZSBpbml0aWFsIHZhbHVlcy4gU28gaWYgdHdvIG92ZXJsYXlzIGFyZSBvcGVuZWRcbiAgICAgKiBhdCB0aGUgc2FtZSB0aW1lLCBib3RoIHVzaW5nIHVzZUlvbk1vZGFsIG9yIHNpbWlsYXIgKHN1Y2ggYXMgdGhyb3VnaCBuZXN0aW5nKSxcbiAgICAgKiB0aGUgc2Vjb25kIHdpbGwgZXJhc2UgdGhlIGZpcnN0IGZyb20gdGhlIG92ZXJsYXlzIGxpc3QuIFRoaXMgY2F1c2VzIHRoZSBjb250ZW50XG4gICAgICogb2YgdGhlIGZpcnN0IG92ZXJsYXkgdG8gdW5tb3VudC5cbiAgICAgKlxuICAgICAqIFdlIHdyYXAgdGhlIHN0YXRlIGluIHVzZVJlZiB0byBlbnN1cmUgdGhlIHR3byBjYWxsYmFja3MgYWx3YXlzIHVzZSB0aGUgbW9zdFxuICAgICAqIHVwLXRvLWRhdGUgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEZ1cnRoZXIgcmVhZGluZzogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU2NTU0MDU2XG4gICAgICovXG4gICAgY29uc3QgW292ZXJsYXlzLCBzZXRPdmVybGF5c10gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3Qgb3ZlcmxheXNSZWYgPSB1c2VSZWYoe30pO1xuICAgIG92ZXJsYXlzUmVmLmN1cnJlbnQgPSBvdmVybGF5cztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvKiBTZXR1cCB0aGUgY2FsbGJhY2tzIHRoYXQgZ2V0IGNhbGxlZCBmcm9tIDxJb25BcHAgLz4gKi9cbiAgICAgICAgb25BZGRPdmVybGF5KGFkZE92ZXJsYXkpO1xuICAgICAgICBvblJlbW92ZU92ZXJsYXkocmVtb3ZlT3ZlcmxheSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZE92ZXJsYXkgPSAoaWQsIGNvbXBvbmVudCwgY29udGFpbmVyRWxlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdPdmVybGF5cyA9IE9iamVjdC5hc3NpZ24oe30sIG92ZXJsYXlzUmVmLmN1cnJlbnQpO1xuICAgICAgICBuZXdPdmVybGF5c1tpZF0gPSB7IGNvbXBvbmVudCwgY29udGFpbmVyRWxlbWVudCB9O1xuICAgICAgICBzZXRPdmVybGF5cyhuZXdPdmVybGF5cyk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVPdmVybGF5ID0gKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld092ZXJsYXlzID0gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcmxheXNSZWYuY3VycmVudCk7XG4gICAgICAgIGRlbGV0ZSBuZXdPdmVybGF5c1tpZF07XG4gICAgICAgIHNldE92ZXJsYXlzKG5ld092ZXJsYXlzKTtcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJsYXlLZXlzID0gT2JqZWN0LmtleXMob3ZlcmxheXMpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgb3ZlcmxheUtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IG92ZXJsYXlzW2tleV07XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwob3ZlcmxheS5jb21wb25lbnQsIG92ZXJsYXkuY29udGFpbmVyRWxlbWVudCwgYG92ZXJsYXktJHtrZXl9YCk7XG4gICAgfSkpKTtcbn07XG5cbmNvbnN0IElvblRhYkJ1dHRvbklubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRhYi1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNik7XG5jb25zdCBJb25UYWJCYXJJbm5lciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10YWItYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTcpO1xuY29uc3QgSW9uQmFja0J1dHRvbklubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJhY2stYnV0dG9uJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTgpO1xuY29uc3QgSW9uUm91dGVyT3V0bGV0SW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcm91dGVyLW91dGxldCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDE5KTtcbmNvbnN0IElvbkFwcElubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWFwcCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDFhKTtcbi8vIGlvbmljb25zXG5jb25zdCBJb25JY29uSW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taWNvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDFiKTtcblxuY29uc3QgSW9uQXBwID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgLypcbiAgICAgICAgICBXaXJlIHVwIG1ldGhvZHMgdG8gY2FsbCBpbnRvIElvbk92ZXJsYXlNYW5hZ2VyXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW9uQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGFkZE92ZXJsYXk6IChpZCwgb3ZlcmxheSwgY29udGFpbmVyRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkZE92ZXJsYXlDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE92ZXJsYXlDYWxsYmFjayhpZCwgb3ZlcmxheSwgY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZU92ZXJsYXk6IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU92ZXJsYXlDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXlDYWxsYmFjayhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5pb25Db250ZXh0IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvbkFwcElubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgdGhpcy5wcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvbk92ZXJsYXlNYW5hZ2VyLCB7IG9uQWRkT3ZlcmxheTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxheUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgfSwgb25SZW1vdmVPdmVybGF5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9IH0pKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uQXBwJztcbiAgICB9XG59KSgpO1xuXG5jb25zdCBTdGFja0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICByZWdpc3RlcklvblBhZ2U6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBpc0luT3V0bGV0OiAoKSA9PiBmYWxzZSxcbn0pO1xuXG5jbGFzcyBQYWdlTWFuYWdlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAvLyBSZWFjdCByZWZzIG11c3QgYmUgc3RhYmxlIChub3QgY3JlYXRlZCBpbmxpbmUpLlxuICAgICAgICB0aGlzLnN0YWJsZU1lcmdlZFJlZnMgPSBtZXJnZVJlZnModGhpcy5pb25QYWdlRWxlbWVudFJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pc0luT3V0bGV0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZCgnaW9uLXBhZ2UtaW52aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJb25QYWdlKHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5yb3V0ZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsRW50ZXInLCB0aGlzLmlvblZpZXdXaWxsRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRFbnRlcicsIHRoaXMuaW9uVmlld0RpZEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkTGVhdmUnLCB0aGlzLmlvblZpZXdEaWRMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbEVudGVyJywgdGhpcy5pb25WaWV3V2lsbEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkRW50ZXInLCB0aGlzLmlvblZpZXdEaWRFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxMZWF2ZScsIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZExlYXZlJywgdGhpcy5pb25WaWV3RGlkTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlvblZpZXdXaWxsRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxFbnRlcigpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZEVudGVyKCk7XG4gICAgfVxuICAgIGlvblZpZXdXaWxsTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxMZWF2ZSgpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZExlYXZlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNsYXNzTmFtZSwgY2hpbGRyZW4sIHJvdXRlSW5mbywgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwicm91dGVJbmZvXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvbkxpZmVDeWNsZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0gaW9uLXBhZ2VgIDogYGlvbi1wYWdlYCwgcmVmOiB0aGlzLnN0YWJsZU1lcmdlZFJlZnMgfSwgcHJvcHMpLCBjaGlsZHJlbikpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTdGFja0NvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25QYWdlSW50ZXJuYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZU1hbmFnZXIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX1gIDogJycsIHJvdXRlSW5mbzogdGhpcy5jb250ZXh0LnJvdXRlSW5mbywgZm9yd2FyZGVkUmVmOiBmb3J3YXJkZWRSZWYgfSwgcHJvcHMpLCBjaGlsZHJlbikpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYGlvbi1wYWdlICR7Y2xhc3NOYW1lfWAgOiAnaW9uLXBhZ2UnLCByZWY6IGZvcndhcmRlZFJlZiB9LCBwcm9wcyksIGNoaWxkcmVuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uUGFnZSc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cbmNvbnN0IElvblBhZ2UgPSBjcmVhdGVGb3J3YXJkUmVmKElvblBhZ2VJbnRlcm5hbCwgJ0lvblBhZ2UnKTtcblxuY29uc3QgSW9uVGFic0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhY3RpdmVUYWI6IHVuZGVmaW5lZCxcbiAgICBzZWxlY3RUYWI6ICgpID0+IGZhbHNlLFxufSk7XG5cbmNvbnN0IEhUTUxFbGVtZW50U1NSID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IEhUTUxFbGVtZW50XG4gICAgOiBjbGFzcyB7XG4gICAgfSk7XG5cbmNsYXNzIE91dGxldFBhZ2VNYW5hZ2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5pb25Sb3V0ZXJPdXRsZXQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkodGhpcy5pb25Sb3V0ZXJPdXRsZXQsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJb25QYWdlKHRoaXMuaW9uUm91dGVyT3V0bGV0LCB0aGlzLnByb3BzLnJvdXRlSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsRW50ZXInLCB0aGlzLmlvblZpZXdXaWxsRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZEVudGVyJywgdGhpcy5pb25WaWV3RGlkRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxMZWF2ZScsIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkTGVhdmUnLCB0aGlzLmlvblZpZXdEaWRMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlvblJvdXRlck91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxFbnRlcicsIHRoaXMuaW9uVmlld1dpbGxFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkRW50ZXInLCB0aGlzLmlvblZpZXdEaWRFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRMZWF2ZScsIHRoaXMuaW9uVmlld0RpZExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3V2lsbEVudGVySGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdXaWxsRW50ZXIoKTtcbiAgICB9XG4gICAgaW9uVmlld0RpZEVudGVySGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdEaWRFbnRlcigpO1xuICAgIH1cbiAgICBpb25WaWV3V2lsbExlYXZlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdXaWxsTGVhdmUoKTtcbiAgICB9XG4gICAgaW9uVmlld0RpZExlYXZlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdEaWRMZWF2ZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBTdGFja01hbmFnZXIsIGNoaWxkcmVuLCByb3V0ZUluZm8gfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiU3RhY2tNYW5hZ2VyXCIsIFwiY2hpbGRyZW5cIiwgXCJyb3V0ZUluZm9cIl0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uTGlmZUN5Y2xlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhY2tNYW5hZ2VyLCB7IHJvdXRlSW5mbzogcm91dGVJbmZvIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJb25Sb3V0ZXJPdXRsZXRJbm5lciwgT2JqZWN0LmFzc2lnbih7IHNldFJlZjogKHZhbCkgPT4gKHRoaXMuaW9uUm91dGVyT3V0bGV0ID0gdmFsKSB9LCBwcm9wcyksIGNoaWxkcmVuKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTdGFja0NvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25Sb3V0ZXJPdXRsZXRDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBTdGFja01hbmFnZXIgPSB0aGlzLmNvbnRleHQuZ2V0U3RhY2tNYW5hZ2VyKCk7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpID8gKHByb3BzLmlvblBhZ2UgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsZXRQYWdlTWFuYWdlciwgT2JqZWN0LmFzc2lnbih7IFN0YWNrTWFuYWdlcjogU3RhY2tNYW5hZ2VyLCByb3V0ZUluZm86IHRoaXMuY29udGV4dC5yb3V0ZUluZm8gfSwgcHJvcHMpLCBjaGlsZHJlbikpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhY2tNYW5hZ2VyLCB7IHJvdXRlSW5mbzogdGhpcy5jb250ZXh0LnJvdXRlSW5mbyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJb25Sb3V0ZXJPdXRsZXRJbm5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiBmb3J3YXJkZWRSZWYgfSksIGNoaWxkcmVuKSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlck91dGxldElubmVyLCBPYmplY3QuYXNzaWduKHsgcmVmOiBmb3J3YXJkZWRSZWYgfSwgdGhpcy5wcm9wcyksIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuY29uc3QgSW9uUm91dGVyT3V0bGV0ID0gY3JlYXRlRm9yd2FyZFJlZihJb25Sb3V0ZXJPdXRsZXRDb250YWluZXIsICdJb25Sb3V0ZXJPdXRsZXQnKTtcblxuY29uc3QgSW9uVGFiQnV0dG9uID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVJb25UYWJCdXR0b25DbGljayA9IHRoaXMuaGFuZGxlSW9uVGFiQnV0dG9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlSW9uVGFiQnV0dG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DbGljayhuZXcgQ3VzdG9tRXZlbnQoJ2lvblRhYkJ1dHRvbkNsaWNrJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICB0YWI6IHRoaXMucHJvcHMudGFiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLnByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlT3B0aW9uczogdGhpcy5wcm9wcy5yb3V0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm9uQ2xpY2tcIl0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uVGFiQnV0dG9uSW5uZXIsIE9iamVjdC5hc3NpZ24oeyBvbklvblRhYkJ1dHRvbkNsaWNrOiB0aGlzLmhhbmRsZUlvblRhYkJ1dHRvbkNsaWNrIH0sIHJlc3QpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uVGFiQnV0dG9uJztcbiAgICB9XG59KSgpO1xuXG5jbGFzcyBJb25UYWJCYXJVbndyYXBwZWQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gKF90YWIpID0+IHsgfTtcbiAgICAgICAgY29uc3QgdGFicyA9IHt9O1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkLnR5cGUgPT09IElvblRhYkJ1dHRvbiB8fCBjaGlsZC50eXBlLmlzVGFiQnV0dG9uKSkge1xuICAgICAgICAgICAgICAgIHRhYnNbY2hpbGQucHJvcHMudGFiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiBjaGlsZC5wcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogY2hpbGQucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSb3V0ZU9wdGlvbnM6IGNoaWxkLnByb3BzLmhyZWYgPT09ICgoX2EgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9iID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm91dGVPcHRpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5ocmVmID09PSAoKF9jID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGF0aG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChfZCA9IHByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJvdXRlT3B0aW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRhYnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25UYWJCdXR0b25DbGljayA9IHRoaXMub25UYWJCdXR0b25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlclRhYkJ1dHRvbiA9IHRoaXMucmVuZGVyVGFiQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gdGhpcy5zZXRBY3RpdmVUYWJPbkNvbnRleHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWxlY3RUYWIgPSB0aGlzLnNlbGVjdFRhYi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMuc3RhdGUudGFicztcbiAgICAgICAgY29uc3QgdGFiS2V5cyA9IE9iamVjdC5rZXlzKHRhYnMpO1xuICAgICAgICBjb25zdCBhY3RpdmVUYWIgPSB0YWJLZXlzLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHRhYnNba2V5XS5vcmlnaW5hbEhyZWY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5yb3V0ZUluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aChocmVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhYixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYk9uQ29udGV4dCh0aGlzLnN0YXRlLmFjdGl2ZVRhYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0VGFiKHRhYikge1xuICAgICAgICBjb25zdCB0YWJVcmwgPSB0aGlzLnN0YXRlLnRhYnNbdGFiXTtcbiAgICAgICAgaWYgKHRhYlVybCkge1xuICAgICAgICAgICAgdGhpcy5vblRhYkJ1dHRvbkNsaWNrKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiQnV0dG9uQ2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHRhYlVybC5jdXJyZW50SHJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFiLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogdGFiID09PSB0aGlzLnN0YXRlLmFjdGl2ZVRhYixcbiAgICAgICAgICAgICAgICAgICAgcm91dGVPcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS50YWJzKTtcbiAgICAgICAgY29uc3QgdGFiS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlLnRhYnMpO1xuICAgICAgICBjb25zdCBhY3RpdmVUYWIgPSB0YWJLZXlzLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHN0YXRlLnRhYnNba2V5XS5vcmlnaW5hbEhyZWY7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMucm91dGVJbmZvLnBhdGhuYW1lLnN0YXJ0c1dpdGgoaHJlZik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHRhYiBidXR0b24gaHJlZiBoYXMgY2hhbmdlZCwgYW5kIGlmIHNvLCB1cGRhdGUgaXQgaW4gdGhlIHRhYnMgc3RhdGVcbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgICAgICAgIChjaGlsZC50eXBlID09PSBJb25UYWJCdXR0b24gfHwgY2hpbGQudHlwZS5pc1RhYkJ1dHRvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWIgPSB0YWJzW2NoaWxkLnByb3BzLnRhYl07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWIgfHwgdGFiLm9yaWdpbmFsSHJlZiAhPT0gY2hpbGQucHJvcHMuaHJlZikge1xuICAgICAgICAgICAgICAgICAgICB0YWJzW2NoaWxkLnByb3BzLnRhYl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhyZWY6IGNoaWxkLnByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogY2hpbGQucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUm91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBhY3RpdmVUYWI6IHByZXZBY3RpdmVUYWIgfSA9IHN0YXRlO1xuICAgICAgICBpZiAoYWN0aXZlVGFiICYmIHByZXZBY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZIcmVmID0gc3RhdGUudGFic1twcmV2QWN0aXZlVGFiXS5jdXJyZW50SHJlZjtcbiAgICAgICAgICAgIGNvbnN0IHByZXZSb3V0ZU9wdGlvbnMgPSBzdGF0ZS50YWJzW3ByZXZBY3RpdmVUYWJdLmN1cnJlbnRSb3V0ZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFiICE9PSBwcmV2QWN0aXZlVGFiIHx8XG4gICAgICAgICAgICAgICAgcHJldkhyZWYgIT09ICgoX2EgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBwcmV2Um91dGVPcHRpb25zICE9PSAoKF9iID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm91dGVPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRhYnNbYWN0aXZlVGFiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiB0YWJzW2FjdGl2ZVRhYl0ub3JpZ2luYWxIcmVmLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogcHJvcHMucm91dGVJbmZvLnBhdGhuYW1lICsgKHByb3BzLnJvdXRlSW5mby5zZWFyY2ggfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJvdXRlT3B0aW9uczogdGFic1thY3RpdmVUYWJdLm9yaWdpbmFsUm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiAoX2MgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucm91dGVJbmZvLnJvdXRlQWN0aW9uID09PSAncG9wJyAmJiBhY3RpdmVUYWIgIT09IHByZXZBY3RpdmVUYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmF2aWdhdGluZyBiYWNrIGFuZCB0aGUgdGFicyBjaGFuZ2UsIHNldCB0aGUgcHJldiB0YWIgYmFjayB0byBpdHMgb3JpZ2luYWwgaHJlZlxuICAgICAgICAgICAgICAgICAgICB0YWJzW3ByZXZBY3RpdmVUYWJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIcmVmOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUm91dGVPcHRpb25zOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsUm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlT3B0aW9uczogdGFic1twcmV2QWN0aXZlVGFiXS5jdXJyZW50Um91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVUYWIgJiYgcHJvcHMub25TZXRDdXJyZW50VGFiKGFjdGl2ZVRhYiwgcHJvcHMucm91dGVJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhYixcbiAgICAgICAgICAgIHRhYnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uVGFiQnV0dG9uQ2xpY2soZSkge1xuICAgICAgICBjb25zdCB0YXBwZWRUYWIgPSB0aGlzLnN0YXRlLnRhYnNbZS5kZXRhaWwudGFiXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxIcmVmID0gdGFwcGVkVGFiLm9yaWdpbmFsSHJlZjtcbiAgICAgICAgY29uc3QgY3VycmVudEhyZWYgPSBlLmRldGFpbC5ocmVmO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZVRhYjogcHJldkFjdGl2ZVRhYiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgLy8gdGhpcy5wcm9wcy5vblNldEN1cnJlbnRUYWIoZS5kZXRhaWwudGFiLCB0aGlzLnByb3BzLnJvdXRlSW5mbyk7XG4gICAgICAgIC8vIENsaWNraW5nIHRoZSBjdXJyZW50IHRhYiB3aWxsIGJyaW5nIHlvdSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBocmVmXG4gICAgICAgIGlmIChwcmV2QWN0aXZlVGFiID09PSBlLmRldGFpbC50YWIpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEhyZWYgIT09IGN1cnJlbnRIcmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc2V0VGFiKGUuZGV0YWlsLnRhYiwgb3JpZ2luYWxIcmVmLCB0YXBwZWRUYWIub3JpZ2luYWxSb3V0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Jb25UYWJzV2lsbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Jb25UYWJzV2lsbENoYW5nZShuZXcgQ3VzdG9tRXZlbnQoJ2lvblRhYldpbGxDaGFuZ2UnLCB7IGRldGFpbDogeyB0YWI6IGUuZGV0YWlsLnRhYiB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW9uVGFic0RpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Jb25UYWJzRGlkQ2hhbmdlKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiRGlkQ2hhbmdlJywgeyBkZXRhaWw6IHsgdGFiOiBlLmRldGFpbC50YWIgfSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYk9uQ29udGV4dChlLmRldGFpbC50YWIpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNoYW5nZVRhYihlLmRldGFpbC50YWIsIGN1cnJlbnRIcmVmLCBlLmRldGFpbC5yb3V0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRhYkJ1dHRvbihhY3RpdmVUYWIpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoY2hpbGQudHlwZSA9PT0gSW9uVGFiQnV0dG9uIHx8IGNoaWxkLnR5cGUuaXNUYWJCdXR0b24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNoaWxkLnByb3BzLnRhYiA9PT0gYWN0aXZlVGFiXG4gICAgICAgICAgICAgICAgICAgID8gKF9hID0gdGhpcy5wcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSA6IHRoaXMuc3RhdGUudGFic1tjaGlsZC5wcm9wcy50YWJdLmN1cnJlbnRIcmVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlT3B0aW9ucyA9IGNoaWxkLnByb3BzLnRhYiA9PT0gYWN0aXZlVGFiXG4gICAgICAgICAgICAgICAgICAgID8gKF9iID0gdGhpcy5wcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yb3V0ZU9wdGlvbnMgOiB0aGlzLnN0YXRlLnRhYnNbY2hpbGQucHJvcHMudGFiXS5jdXJyZW50Um91dGVPcHRpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm9uVGFiQnV0dG9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGFjdGl2ZVRhYiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvblRhYkJhcklubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHNlbGVjdGVkVGFiOiBhY3RpdmVUYWIgfSksIFJlYWN0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLnJlbmRlclRhYkJ1dHRvbihhY3RpdmVUYWIpKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59XG5jb25zdCBJb25UYWJCYXJDb250YWluZXIgPSBSZWFjdC5tZW1vKChfYSkgPT4ge1xuICAgIHZhciB7IGZvcndhcmRlZFJlZiB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5hdkNvbnRleHQpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25UYWJCYXJVbndyYXBwZWQsIE9iamVjdC5hc3NpZ24oeyByZWY6IGZvcndhcmRlZFJlZiB9LCBwcm9wcywgeyByb3V0ZUluZm86IHByb3BzLnJvdXRlSW5mbyB8fCBjb250ZXh0LnJvdXRlSW5mbyB8fCB7IHBhdGhuYW1lOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfSwgb25TZXRDdXJyZW50VGFiOiBjb250ZXh0LnNldEN1cnJlbnRUYWIgfSksIHByb3BzLmNoaWxkcmVuKSk7XG59KTtcbmNvbnN0IElvblRhYkJhciA9IGNyZWF0ZUZvcndhcmRSZWYoSW9uVGFiQmFyQ29udGFpbmVyLCAnSW9uVGFiQmFyJyk7XG5cbmNsYXNzIElvblRhYnNFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnRTU1Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3VzdG9tRWxlbWVudHMpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldCgnaW9uLXRhYnMnKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnaW9uLXRhYnMnLCBJb25UYWJzRWxlbWVudCk7XG4gICAgfVxufVxuY29uc3QgaG9zdFN0eWxlcyA9IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnMCcsXG4gICAgbGVmdDogJzAnLFxuICAgIHJpZ2h0OiAnMCcsXG4gICAgYm90dG9tOiAnMCcsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBjb250YWluOiAnbGF5b3V0IHNpemUgc3R5bGUnLFxufTtcbmNvbnN0IHRhYnNJbm5lciA9IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBmbGV4OiAxLFxuICAgIGNvbnRhaW46ICdsYXlvdXQgc2l6ZSBzdHlsZScsXG59O1xuY29uc3QgSW9uVGFicyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucm91dGVyT3V0bGV0UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMudGFiQmFyUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlID0ge1xuICAgICAgICAgICAgYWN0aXZlVGFiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3RUYWI6ICgpID0+IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFiQmFyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIEdyYWIgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5pb25UYWJDb250ZXh0U3RhdGUuYWN0aXZlVGFiID0gdGhpcy50YWJCYXJSZWYuY3VycmVudC5zdGF0ZS5hY3RpdmVUYWI7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSBtZXRob2RcbiAgICAgICAgICAgIHRoaXMudGFiQmFyUmVmLmN1cnJlbnQuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gKHRhYikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlLmFjdGl2ZVRhYiA9IHRhYjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlvblRhYkNvbnRleHRTdGF0ZS5zZWxlY3RUYWIgPSB0aGlzLnRhYkJhclJlZi5jdXJyZW50LnNlbGVjdFRhYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBvdXRsZXQ7XG4gICAgICAgIGxldCB0YWJCYXI7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjbGFzc05hbWUsIG9uSW9uVGFic0RpZENoYW5nZSwgb25Jb25UYWJzV2lsbENoYW5nZSB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJvbklvblRhYnNEaWRDaGFuZ2VcIiwgXCJvbklvblRhYnNXaWxsQ2hhbmdlXCJdKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlb2YgdGhpcy5wcm9wcy5jaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlKVxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgIWNoaWxkLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gSW9uUm91dGVyT3V0bGV0IHx8IGNoaWxkLnR5cGUuaXNSb3V0ZXJPdXRsZXQpIHtcbiAgICAgICAgICAgICAgICBvdXRsZXQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW5bMF0udHlwZSA9PT0gSW9uUm91dGVyT3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgb3V0bGV0ID0gY2hpbGQucHJvcHMuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMudGFiQmFyUmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPbmx5IHBhc3MgdGhlc2UgcHJvcHNcbiAgICAgICAgICAgICAqIGRvd24gZnJvbSBJb25UYWJzIHRvIElvblRhYkJhclxuICAgICAgICAgICAgICogaWYgdGhleSBhcmUgZGVmaW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgKiBpZiB5b3UgaGF2ZSBhIGhhbmRsZXIgc2V0IG9uXG4gICAgICAgICAgICAgKiBJb25UYWJCYXIgaXQgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob25Jb25UYWJzRGlkQ2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGlsZFByb3BzKSwgeyBvbklvblRhYnNEaWRDaGFuZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Jb25UYWJzV2lsbENoYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRQcm9wcyksIHsgb25Jb25UYWJzV2lsbENoYW5nZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBJb25UYWJCYXIgfHwgY2hpbGQudHlwZS5pc1RhYkJhcikge1xuICAgICAgICAgICAgICAgIHRhYkJhciA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxuICAgICAgICAgICAgICAgIChjaGlsZC5wcm9wcy5jaGlsZHJlblsxXS50eXBlID09PSBJb25UYWJCYXIgfHwgY2hpbGQucHJvcHMuY2hpbGRyZW5bMV0udHlwZS5pc1RhYkJhcikpIHtcbiAgICAgICAgICAgICAgICB0YWJCYXIgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQucHJvcHMuY2hpbGRyZW5bMV0sIGNoaWxkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvdXRsZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW9uVGFicyBtdXN0IGNvbnRhaW4gYW4gSW9uUm91dGVyT3V0bGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWJCYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW9uVGFicyBuZWVkcyBhIElvblRhYkJhcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25UYWJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5pb25UYWJDb250ZXh0U3RhdGUgfSwgdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlTWFuYWdlciwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfWAgOiAnJywgcm91dGVJbmZvOiB0aGlzLmNvbnRleHQucm91dGVJbmZvIH0sIHByb3BzKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpb24tdGFic1wiLCB7IGNsYXNzTmFtZTogXCJpb24tdGFic1wiLCBzdHlsZTogaG9zdFN0eWxlcyB9LFxuICAgICAgICAgICAgICAgIHRhYkJhci5wcm9wcy5zbG90ID09PSAndG9wJyA/IHRhYkJhciA6IG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB0YWJzSW5uZXIsIGNsYXNzTmFtZTogXCJ0YWJzLWlubmVyXCIgfSwgb3V0bGV0KSxcbiAgICAgICAgICAgICAgICB0YWJCYXIucHJvcHMuc2xvdCA9PT0gJ2JvdHRvbScgPyB0YWJCYXIgOiBudWxsKSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfWAgOiAnaW9uLXRhYnMnIH0sIHByb3BzLCB7IHN0eWxlOiBob3N0U3R5bGVzIH0pLFxuICAgICAgICAgICAgdGFiQmFyLnByb3BzLnNsb3QgPT09ICd0b3AnID8gdGFiQmFyIDogbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogdGFic0lubmVyLCBjbGFzc05hbWU6IFwidGFicy1pbm5lclwiIH0sIG91dGxldCksXG4gICAgICAgICAgICB0YWJCYXIucHJvcHMuc2xvdCA9PT0gJ2JvdHRvbScgPyB0YWJCYXIgOiBudWxsKSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufSkoKTtcblxuY29uc3QgSW9uQmFja0J1dHRvbiA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jbGlja0J1dHRvbiA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmF1bHRIcmVmLCByb3V0ZXJBbmltYXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nb0JhY2soZGVmYXVsdEhyZWYsIHJvdXRlckFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZhdWx0SHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZWZhdWx0SHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJb25CYWNrQnV0dG9uSW5uZXIsIE9iamVjdC5hc3NpZ24oeyBvbkNsaWNrOiB0aGlzLmNsaWNrQnV0dG9uIH0sIHRoaXMucHJvcHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdJb25CYWNrQnV0dG9uJztcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufSkoKTtcblxuY2xhc3MgSW9uSWNvbkNvbnRhaW5lciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbiBJb25pYyBSZWFjdCwgeW91IGltcG9ydCBpY29ucyBmcm9tIFwiaW9uaWNvbnMvaWNvbnNcIiBhbmQgc2V0IHRoZSBpY29uIHlvdSBpbXBvcnRlZCB0byB0aGUgXCJpY29uXCIgcHJvcGVydHkuIFNldHRpbmcgdGhlIFwibmFtZVwiIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBfYyA9IHRoaXMucHJvcHMsIHsgaWNvbiwgaW9zLCBtZCB9ID0gX2MsIHJlc3QgPSBfX3Jlc3QoX2MsIFtcImljb25cIiwgXCJpb3NcIiwgXCJtZFwiXSk7XG4gICAgICAgIGxldCBpY29uVG9Vc2U7XG4gICAgICAgIGlmIChpb3MgfHwgbWQpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYXRmb3JtKCdpb3MnKSkge1xuICAgICAgICAgICAgICAgIGljb25Ub1VzZSA9IChfYSA9IGlvcyAhPT0gbnVsbCAmJiBpb3MgIT09IHZvaWQgMCA/IGlvcyA6IG1kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWNvblRvVXNlID0gKF9iID0gbWQgIT09IG51bGwgJiYgbWQgIT09IHZvaWQgMCA/IG1kIDogaW9zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWNvblRvVXNlID0gaWNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uSWNvbklubmVyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgaWNvbjogaWNvblRvVXNlIH0sIHJlc3QpLCB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cbmNvbnN0IElvbkljb24gPSBjcmVhdGVGb3J3YXJkUmVmKElvbkljb25Db250YWluZXIsICdJb25JY29uJyk7XG5cbmNsYXNzIElvblJvdXRlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBJb25Sb3V0ZUlubmVyID0gdGhpcy5jb250ZXh0LmdldElvblJvdXRlKCk7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgfHwgIUlvblJvdXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgZWl0aGVyIGRvIG5vdCBoYXZlIGFuIElvbmljIFJvdXRlciBwYWNrYWdlLCBvciB5b3VyIHJvdXRlciBkb2VzIG5vdCBzdXBwb3J0IHVzaW5nIDxJb25Sb3V0ZT4nKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlSW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25SZWRpcmVjdCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgSW9uUmVkaXJlY3RJbm5lciA9IHRoaXMuY29udGV4dC5nZXRJb25SZWRpcmVjdCgpO1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpIHx8ICFJb25SZWRpcmVjdCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGVpdGhlciBkbyBub3QgaGF2ZSBhbiBJb25pYyBSb3V0ZXIgcGFja2FnZSwgb3IgeW91ciByb3V0ZXIgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyA8SW9uUmVkaXJlY3Q+Jyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJb25SZWRpcmVjdElubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cblxuY29uc3QgSW9uUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIHJvdXRlSW5mbzogdW5kZWZpbmVkLFxuICAgIHB1c2g6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJb25pYyBSb3V0ZXIgaXMgcmVxdWlyZWQgZm9yIElvblJvdXRlckNvbnRleHQnKTtcbiAgICB9LFxuICAgIGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJb25pYyBSb3V0ZXIgaXMgcmVxdWlyZWQgZm9yIElvblJvdXRlckNvbnRleHQnKTtcbiAgICB9LFxuICAgIGNhbkdvQmFjazogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG4gICAgbmF0aXZlQmFjazogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG59KTtcbi8qKlxuICogQSBob29rIGZvciBtb3JlIGRpcmVjdCBjb250cm9sIG92ZXIgcm91dGluZyBpbiBhbiBJb25pYyBSZWFjdCBhcHBsaWNhdGlvbi4gQWxsb3dzIHlvdSB0byBwYXNzIGFkZGl0aW9uYWwgbWV0YS1kYXRhIHRvIHRoZSByb3V0ZXIgYmVmb3JlIHRoZSBjYWxsIHRvIHRoZSBuYXRpdmUgcm91dGVyLlxuICovXG5mdW5jdGlvbiB1c2VJb25Sb3V0ZXIoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uUm91dGVyQ29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogY29udGV4dC5iYWNrLFxuICAgICAgICBwdXNoOiBjb250ZXh0LnB1c2gsXG4gICAgICAgIGdvQmFjazogY29udGV4dC5iYWNrLFxuICAgICAgICBjYW5Hb0JhY2s6IGNvbnRleHQuY2FuR29CYWNrLFxuICAgICAgICByb3V0ZUluZm86IGNvbnRleHQucm91dGVJbmZvLFxuICAgIH07XG59XG5cbmNsYXNzIENyZWF0ZUFuaW1hdGlvbiBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24ocHJvcHMuaWQpO1xuICAgIH1cbiAgICBzZXR1cEFuaW1hdGlvbihwcm9wcykge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5hZGRFbGVtZW50KEFycmF5LmZyb20odGhpcy5ub2Rlcy52YWx1ZXMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29uZmlnKGFuaW1hdGlvbiwgcHJvcHMpO1xuICAgICAgICBjaGVja1BsYXliYWNrKGFuaW1hdGlvbiwgcHJvcHMpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnNldHVwQW5pbWF0aW9uKHByb3BzKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBjaGVja0NvbmZpZyhhbmltYXRpb24sIHByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICBjaGVja1Byb2dyZXNzKGFuaW1hdGlvbiwgcHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgIGNoZWNrUGxheWJhY2soYW5pbWF0aW9uLCBwcm9wcywgcHJldlByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpZCkgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7IHJlZjogKGVsKSA9PiB0aGlzLm5vZGVzLnNldChpZCwgZWwpIH0pKSkpO1xuICAgIH1cbn1cbmNvbnN0IGNoZWNrQ29uZmlnID0gKGFuaW1hdGlvbiwgY3VycmVudFByb3BzID0ge30sIHByZXZQcm9wcyA9IHt9KSA9PiB7XG4gICAgY29uc3QgcmVzZXJ2ZWRQcm9wcyA9IFtcbiAgICAgICAgJ2NoaWxkcmVuJyxcbiAgICAgICAgJ3Byb2dyZXNzU3RhcnQnLFxuICAgICAgICAncHJvZ3Jlc3NTdGVwJyxcbiAgICAgICAgJ3Byb2dyZXNzRW5kJyxcbiAgICAgICAgJ3BhdXNlJyxcbiAgICAgICAgJ3N0b3AnLFxuICAgICAgICAnZGVzdHJveScsXG4gICAgICAgICdwbGF5JyxcbiAgICAgICAgJ2Zyb20nLFxuICAgICAgICAndG8nLFxuICAgICAgICAnZnJvbVRvJyxcbiAgICAgICAgJ29uRmluaXNoJyxcbiAgICBdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnRQcm9wcykge1xuICAgICAgICBpZiAoY3VycmVudFByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAgICFyZXNlcnZlZFByb3BzLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uW2tleV0oY3VycmVudFByb3BzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBjdXJyZW50UHJvcHMuZnJvbTtcbiAgICBpZiAoZnJvbVZhbHVlcyAmJiBmcm9tVmFsdWVzICE9PSBwcmV2UHJvcHMuZnJvbSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGZyb21WYWx1ZXMpID8gZnJvbVZhbHVlcyA6IFtmcm9tVmFsdWVzXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbCkgPT4gYW5pbWF0aW9uLmZyb20odmFsLnByb3BlcnR5LCB2YWwudmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3QgdG9WYWx1ZXMgPSBjdXJyZW50UHJvcHMudG87XG4gICAgaWYgKHRvVmFsdWVzICYmIHRvVmFsdWVzICE9PSBwcmV2UHJvcHMudG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh0b1ZhbHVlcykgPyB0b1ZhbHVlcyA6IFt0b1ZhbHVlc107XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IGFuaW1hdGlvbi50byh2YWwucHJvcGVydHksIHZhbC52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9WYWx1ZXMgPSBjdXJyZW50UHJvcHMuZnJvbVRvO1xuICAgIGlmIChmcm9tVG9WYWx1ZXMgJiYgZnJvbVRvVmFsdWVzICE9PSBwcmV2UHJvcHMuZnJvbVRvKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoZnJvbVRvVmFsdWVzKSA/IGZyb21Ub1ZhbHVlcyA6IFtmcm9tVG9WYWx1ZXNdO1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiBhbmltYXRpb24uZnJvbVRvKHZhbC5wcm9wZXJ0eSwgdmFsLmZyb21WYWx1ZSwgdmFsLnRvVmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3Qgb25GaW5pc2hWYWx1ZXMgPSBjdXJyZW50UHJvcHMub25GaW5pc2g7XG4gICAgaWYgKG9uRmluaXNoVmFsdWVzICYmIG9uRmluaXNoVmFsdWVzICE9PSBwcmV2UHJvcHMub25GaW5pc2gpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShvbkZpbmlzaFZhbHVlcykgPyBvbkZpbmlzaFZhbHVlcyA6IFtvbkZpbmlzaFZhbHVlc107XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IGFuaW1hdGlvbi5vbkZpbmlzaCh2YWwuY2FsbGJhY2ssIHZhbC5vcHRzKSk7XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrUHJvZ3Jlc3MgPSAoYW5pbWF0aW9uLCBjdXJyZW50UHJvcHMgPSB7fSwgcHJldlByb3BzID0ge30pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgcHJvZ3Jlc3NTdGFydCwgcHJvZ3Jlc3NTdGVwLCBwcm9ncmVzc0VuZCB9ID0gY3VycmVudFByb3BzO1xuICAgIGlmIChwcm9ncmVzc1N0YXJ0ICYmXG4gICAgICAgICgoKF9hID0gcHJldlByb3BzLnByb2dyZXNzU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUxpbmVhckVhc2luZykgIT09IChwcm9ncmVzc1N0YXJ0ID09PSBudWxsIHx8IHByb2dyZXNzU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzU3RhcnQuZm9yY2VMaW5lYXJFYXNpbmcpIHx8XG4gICAgICAgICAgICAoKF9iID0gcHJldlByb3BzLnByb2dyZXNzU3RhcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGVwKSAhPT0gKHByb2dyZXNzU3RhcnQgPT09IG51bGwgfHwgcHJvZ3Jlc3NTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdGFydC5zdGVwKSkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RhcnQocHJvZ3Jlc3NTdGFydC5mb3JjZUxpbmVhckVhc2luZywgcHJvZ3Jlc3NTdGFydC5zdGVwKTtcbiAgICB9XG4gICAgaWYgKHByb2dyZXNzU3RlcCAmJiAoKF9jID0gcHJldlByb3BzLnByb2dyZXNzU3RlcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0ZXApICE9PSAocHJvZ3Jlc3NTdGVwID09PSBudWxsIHx8IHByb2dyZXNzU3RlcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdGVwLnN0ZXApKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc1N0ZXAocHJvZ3Jlc3NTdGVwLnN0ZXApO1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NFbmQgJiZcbiAgICAgICAgKCgoX2QgPSBwcmV2UHJvcHMucHJvZ3Jlc3NFbmQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wbGF5VG8pICE9PSAocHJvZ3Jlc3NFbmQgPT09IG51bGwgfHwgcHJvZ3Jlc3NFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzRW5kLnBsYXlUbykgfHxcbiAgICAgICAgICAgICgoX2UgPSBwcmV2UHJvcHMucHJvZ3Jlc3NFbmQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zdGVwKSAhPT0gKHByb2dyZXNzRW5kID09PSBudWxsIHx8IHByb2dyZXNzRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9ncmVzc0VuZC5zdGVwKSB8fFxuICAgICAgICAgICAgKHByZXZQcm9wcyA9PT0gbnVsbCB8fCBwcmV2UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZQcm9wcy5kdXIpICE9PSAocHJvZ3Jlc3NFbmQgPT09IG51bGwgfHwgcHJvZ3Jlc3NFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzRW5kLmR1cikpKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc0VuZChwcm9ncmVzc0VuZC5wbGF5VG8sIHByb2dyZXNzRW5kLnN0ZXAsIHByb2dyZXNzRW5kLmR1cik7XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrUGxheWJhY2sgPSAoYW5pbWF0aW9uLCBjdXJyZW50UHJvcHMgPSB7fSwgcHJldlByb3BzID0ge30pID0+IHtcbiAgICBpZiAoIXByZXZQcm9wcy5wbGF5ICYmIGN1cnJlbnRQcm9wcy5wbGF5KSB7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzLnBhdXNlICYmIGN1cnJlbnRQcm9wcy5wYXVzZSkge1xuICAgICAgICBhbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMuc3RvcCAmJiBjdXJyZW50UHJvcHMuc3RvcCkge1xuICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcy5kZXN0cm95ICYmIGN1cnJlbnRQcm9wcy5kZXN0cm95KSB7XG4gICAgICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihkaXNwbGF5TmFtZSwgY29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBkaWREaXNtaXNzRXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfURpZERpc21pc3NgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCBkaWRQcmVzZW50RXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfURpZFByZXNlbnRgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCB3aWxsRGlzbWlzc0V2ZW50TmFtZSA9IHVzZU1lbW8oKCkgPT4gYG9uJHtkaXNwbGF5TmFtZX1XaWxsRGlzbWlzc2AsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IHdpbGxQcmVzZW50RXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfVdpbGxQcmVzZW50YCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjayhhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAob3ZlcmxheVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvbkRpZERpc21pc3MsIG9uV2lsbERpc21pc3MsIG9uRGlkUHJlc2VudCwgb25XaWxsUHJlc2VudCB9ID0gb3B0aW9ucywgcmVzdCA9IF9fcmVzdChvcHRpb25zLCBbXCJvbkRpZERpc21pc3NcIiwgXCJvbldpbGxEaXNtaXNzXCIsIFwib25EaWRQcmVzZW50XCIsIFwib25XaWxsUHJlc2VudFwiXSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURpc21pc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChvbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICBvbkRpZERpc21pc3MoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKHt9LCByZXN0KSk7XG4gICAgICAgIGF0dGFjaFByb3BzKG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgW2RpZERpc21pc3NFdmVudE5hbWVdOiBoYW5kbGVEaXNtaXNzLFxuICAgICAgICAgICAgW2RpZFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25EaWRQcmVzZW50ICYmIG9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiBvbldpbGxEaXNtaXNzICYmIG9uV2lsbERpc21pc3MoZSksXG4gICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25XaWxsUHJlc2VudCAmJiBvbldpbGxQcmVzZW50KGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnByZXNlbnQoKTtcbiAgICB9LCBbY29udHJvbGxlcl0pO1xuICAgIGNvbnN0IGRpc21pc3MgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCAmJiAoYXdhaXQgb3ZlcmxheVJlZi5jdXJyZW50LmRpc21pc3MoKSk7XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlc2VudCxcbiAgICAgICAgZGlzbWlzcyxcbiAgICB9O1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkFjdGlvblNoZWV0IGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbkFjdGlvblNoZWV0KCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25BY3Rpb25TaGVldCcsIGFjdGlvblNoZWV0Q29udHJvbGxlciQxLCBkZWZpbmVDdXN0b21FbGVtZW50JDEzKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKGJ1dHRvbnNPck9wdGlvbnMsIGhlYWRlcikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidXR0b25zT3JPcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9uc09yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoYnV0dG9uc09yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkFsZXJ0IGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbkFsZXJ0KCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25BbGVydCcsIGFsZXJ0Q29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYyk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChtZXNzYWdlT3JPcHRpb25zLCBidXR0b25zKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZU9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VPck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9ucyAhPT0gbnVsbCAmJiBidXR0b25zICE9PSB2b2lkIDAgPyBidXR0b25zIDogW3sgdGV4dDogJ09rJyB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudChtZXNzYWdlT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyLnByZXNlbnRdKTtcbiAgICByZXR1cm4gW3ByZXNlbnQsIGNvbnRyb2xsZXIuZGlzbWlzc107XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uVG9hc3QgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uVG9hc3QoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHVzZUNvbnRyb2xsZXIoJ0lvblRvYXN0JywgdG9hc3RDb250cm9sbGVyJDEsIGRlZmluZUN1c3RvbUVsZW1lbnQkMWQpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygobWVzc2FnZU9yT3B0aW9ucywgZHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHByZXNlbnQsXG4gICAgICAgIGNvbnRyb2xsZXIuZGlzbWlzc1xuICAgIF07XG59XG5cbmNvbnN0IGlkcyA9IHsgbWFpbjogMCB9O1xuY29uc3QgZ2VuZXJhdGVJZCA9ICh0eXBlID0gJ21haW4nKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGlkID0gKChfYSA9IGlkc1t0eXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyAxO1xuICAgIGlkc1t0eXBlXSA9IGlkO1xuICAgIHJldHVybiBpZC50b1N0cmluZygpO1xufTtcblxuZnVuY3Rpb24gdXNlT3ZlcmxheShkaXNwbGF5TmFtZSwgY29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgY29tcG9uZW50LCBjb21wb25lbnRQcm9wcykge1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBjb250YWluZXJFbFJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IGRpZERpc21pc3NFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkRGlzbWlzc2AsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IGRpZFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkUHJlc2VudGAsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IHdpbGxEaXNtaXNzRXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfVdpbGxEaXNtaXNzYCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgY29uc3Qgd2lsbFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9V2lsbFByZXNlbnRgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGlvbkNvbnRleHQgPSB1c2VDb250ZXh0KElvbkNvbnRleHQpO1xuICAgIGNvbnN0IFtvdmVybGF5SWRdID0gdXNlU3RhdGUoZ2VuZXJhdGVJZCgnb3ZlcmxheScpKTtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiAmJiBjb21wb25lbnQgJiYgY29udGFpbmVyRWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBpb25Db250ZXh0LmFkZE92ZXJsYXkob3ZlcmxheUlkLCBjb21wb25lbnQsIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBjb21wb25lbnRQcm9wcyk7XG4gICAgICAgICAgICAgICAgaW9uQ29udGV4dC5hZGRPdmVybGF5KG92ZXJsYXlJZCwgZWxlbWVudCwgY29udGFpbmVyRWxSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY29tcG9uZW50LCBjb250YWluZXJFbFJlZi5jdXJyZW50LCBpc09wZW4sIGNvbXBvbmVudFByb3BzXSk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChvdmVybGF5UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uRGlkRGlzbWlzcywgb25XaWxsRGlzbWlzcywgb25EaWRQcmVzZW50LCBvbldpbGxQcmVzZW50IH0gPSBvcHRpb25zLCByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcIm9uRGlkRGlzbWlzc1wiLCBcIm9uV2lsbERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxQcmVzZW50XCJdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IGNvbXBvbmVudDogY29udGFpbmVyRWxSZWYuY3VycmVudCB9KSk7XG4gICAgICAgIGF0dGFjaFByb3BzKG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgW2RpZERpc21pc3NFdmVudE5hbWVdOiBoYW5kbGVEaXNtaXNzLFxuICAgICAgICAgICAgW2RpZFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25EaWRQcmVzZW50ICYmIG9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiBvbldpbGxEaXNtaXNzICYmIG9uV2lsbERpc21pc3MoZSksXG4gICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25XaWxsUHJlc2VudCAmJiBvbldpbGxQcmVzZW50KGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnByZXNlbnQoKTtcbiAgICAgICAgc2V0SXNPcGVuKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAob25EaWREaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgb25EaWREaXNtaXNzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgaW9uQ29udGV4dC5yZW1vdmVPdmVybGF5KG92ZXJsYXlJZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ICYmIChhd2FpdCBvdmVybGF5UmVmLmN1cnJlbnQuZGlzbWlzcygpKTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250YWluZXJFbFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVzZW50LFxuICAgICAgICBkaXNtaXNzLFxuICAgIH07XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uTW9kYWwgY29tcG9uZW50XG4gKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdGhhdCB0aGUgbW9kYWwgd2lsbCBzaG93LiBDYW4gYmUgYSBSZWFjdCBDb21wb25lbnQsIGEgZnVuY3Rpb25hbCBjb21wb25lbnQsIG9yIGEgSlNYIEVsZW1lbnRcbiAqIEBwYXJhbSBjb21wb25lbnRQcm9wcyBUaGUgcHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LCBpZiByZXF1aXJlZFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbk1vZGFsKGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlT3ZlcmxheSgnSW9uTW9kYWwnLCBtb2RhbENvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTQsIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucHJlc2VudChvcHRpb25zKTtcbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvblBpY2tlciBjb21wb25lbnRcbiAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0aGF0IHRoZSBwb3BvdmVyIHdpbGwgc2hvdy4gQ2FuIGJlIGEgUmVhY3QgQ29tcG9uZW50LCBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LCBvciBhIEpTWCBFbGVtZW50XG4gKiBAcGFyYW0gY29tcG9uZW50UHJvcHMgVGhlIHByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCwgaWYgcmVxdWlyZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHByZXNlbnQgYW5kIGRpc21pc3MgbWV0aG9kcyBpbiBhbiBhcnJheVxuICovXG5mdW5jdGlvbiB1c2VJb25Qb3BvdmVyKGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlT3ZlcmxheSgnSW9uUG9wb3ZlcicsIHBvcG92ZXJDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDE1LCBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnByZXNlbnQob3B0aW9ucyk7XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHByZXNlbnQsXG4gICAgICAgIGNvbnRyb2xsZXIuZGlzbWlzc1xuICAgIF07XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uUGlja2VyIGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvblBpY2tlcigpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlQ29udHJvbGxlcignSW9uUGlja2VyJywgcGlja2VyQ29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZSk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChjb2x1bW5zT3JPcHRpb25zLCBidXR0b25zKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbnNPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zT3JPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IGJ1dHRvbnMgIT09IG51bGwgJiYgYnV0dG9ucyAhPT0gdm9pZCAwID8gYnV0dG9ucyA6IFt7IHRleHQ6ICdPaycgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoY29sdW1uc09yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkxvYWRpbmcgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uTG9hZGluZygpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlQ29udHJvbGxlcignSW9uTG9hZGluZycsIGxvYWRpbmdDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDFmKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2VPck9wdGlvbnMgPSAnJywgZHVyYXRpb24sIHNwaW5uZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGlubmVyOiBzcGlubmVyICE9PSBudWxsICYmIHNwaW5uZXIgIT09IHZvaWQgMCA/IHNwaW5uZXIgOiAnbGluZXMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbcHJlc2VudCwgY29udHJvbGxlci5kaXNtaXNzXTtcbn1cblxuY29uc3Qgc2V0dXBJb25pY1JlYWN0ID0gKGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBJb25pYyBGcmFtZXdvcmsgaGlkZXMgZWxlbWVudHMgdGhhdFxuICAgICAqIGFyZSBub3QgaHlkcmF0ZWQsIGJ1dCBpbiB0aGUgQ0UgYnVpbGQgdGhlcmUgaXMgbm9cbiAgICAgKiBoeWRyYXRpb24uXG4gICAgICogVE9ETzogUmVtb3ZlIHdoZW4gYWxsIGludGVncmF0aW9ucyBoYXZlIGJlZW5cbiAgICAgKiBtaWdyYXRlZCB0byBDRSBidWlsZC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW9uLWNlJyk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSk7XG59O1xuXG5jb25zdCBSb3V0ZU1hbmFnZXJDb250ZXh0ID0gLypAX19QVVJFX18qLyBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhZGRWaWV3SXRlbTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNhbkdvQmFjazogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNsZWFyT3V0bGV0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY3JlYXRlVmlld0l0ZW06ICgpID0+IHVuZGVmaW5lZCxcbiAgICBmaW5kVmlld0l0ZW1CeVBhdGhuYW1lOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZmluZExlYXZpbmdWaWV3SXRlbUJ5Um91dGVJbmZvOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZmluZFZpZXdJdGVtQnlSb3V0ZUluZm86ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnZXRDaGlsZHJlblRvUmVuZGVyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ29CYWNrOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgdW5Nb3VudFZpZXdJdGVtOiAoKSA9PiB1bmRlZmluZWQsXG59KTtcblxuY2xhc3MgVmlld0xpZmVDeWNsZU1hbmFnZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0ID0gbmV3IERlZmF1bHRJb25MaWZlQ3ljbGVDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQub25Db21wb25lbnRDYW5CZURlc3Ryb3llZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMubW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sICgpID0+IHRoaXMucHJvcHMucmVtb3ZlVmlldygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHNob3cgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25MaWZlQ3ljbGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQgfSwgc2hvdyAmJiB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuXG4vLyBjb25zdCBSRVNUUklDVF9TSVpFID0gMTAwO1xuY2xhc3MgTG9jYXRpb25IaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy50YWJIaXN0b3J5ID0ge307XG4gICAgfVxuICAgIGFkZChyb3V0ZUluZm8pIHtcbiAgICAgICAgaWYgKHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PT0gJ3B1c2gnIHx8IHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8ucm91dGVBY3Rpb24gPT09ICdwb3AnKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3Aocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8ucm91dGVBY3Rpb24gPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZShyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZUluZm8ucm91dGVEaXJlY3Rpb24gPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZChyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyVGFiU3RhY2sodGFiKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkodGFiKTtcbiAgICAgICAgaWYgKHJvdXRlSW5mb3MpIHtcbiAgICAgICAgICAgIHJvdXRlSW5mb3MuZm9yRWFjaCgocmkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeSA9IHRoaXMubG9jYXRpb25IaXN0b3J5LmZpbHRlcigoeCkgPT4geC5pZCAhPT0gcmkuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhYkhpc3RvcnlbdGFiXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShyb3V0ZUluZm8pIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb25JbmRleCA9IHRoaXMubG9jYXRpb25IaXN0b3J5LmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gcm91dGVJbmZvLmlkKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3Rvcnkuc3BsaWNlKGxvY2F0aW9uSW5kZXgsIDEsIHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFiQXJyYXkgPSB0aGlzLnRhYkhpc3Rvcnlbcm91dGVJbmZvLnRhYiB8fCAnJ107XG4gICAgICAgIGlmICh0YWJBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0YWJBcnJheS5maW5kSW5kZXgoKHgpID0+IHguaWQgPT09IHJvdXRlSW5mby5pZCk7XG4gICAgICAgICAgICBpZiAodGFiSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRhYkFycmF5LnNwbGljZSh0YWJJbmRleCwgMSwgcm91dGVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYkFycmF5LnB1c2gocm91dGVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8udGFiKSB7XG4gICAgICAgICAgICB0aGlzLnRhYkhpc3Rvcnlbcm91dGVJbmZvLnRhYl0gPSBbcm91dGVJbmZvXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxhdGVzdCByb3V0ZUluZm8gaXMgdGhlIHNhbWUgKGdvaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGFicyksIHJlcGxhY2UgaXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9hcmVSb3V0ZXNFcXVhbChyb3V0ZUluZm9zW3JvdXRlSW5mb3MubGVuZ3RoIC0gMV0sIHJvdXRlSW5mbykpIHtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm9zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91dGVJbmZvcy5wdXNoKHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkucHVzaChyb3V0ZUluZm8pO1xuICAgIH1cbiAgICBfYXJlUm91dGVzRXF1YWwocm91dGUxLCByb3V0ZTIpIHtcbiAgICAgICAgaWYgKCFyb3V0ZTEgfHwgIXJvdXRlMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZTEucGF0aG5hbWUgPT09IHJvdXRlMi5wYXRobmFtZSAmJiByb3V0ZTEuc2VhcmNoID09PSByb3V0ZTIuc2VhcmNoO1xuICAgIH1cbiAgICBfcG9wKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyByb3V0ZVxuICAgICAgICAgICAgcm91dGVJbmZvcy5wb3AoKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgcm91dGUgd2l0aCBhbiB1cGRhdGVkIHZlcnNpb25cbiAgICAgICAgICAgIHJvdXRlSW5mb3MucG9wKCk7XG4gICAgICAgICAgICByb3V0ZUluZm9zLnB1c2gocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHJvdXRlXG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjdXJyZW50IHJvdXRlIHdpdGggYW4gdXBkYXRlZCB2ZXJzaW9uXG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeS5wdXNoKHJvdXRlSW5mbyk7XG4gICAgfVxuICAgIF9yZXBsYWNlKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICByb3V0ZUluZm9zICYmIHJvdXRlSW5mb3MucG9wKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICB0aGlzLl9hZGQocm91dGVJbmZvKTtcbiAgICB9XG4gICAgX2NsZWFyKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy50YWJIaXN0b3J5KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiAodGhpcy50YWJIaXN0b3J5W2tdID0gW10pKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkgPSBbXTtcbiAgICB9XG4gICAgX2dldFJvdXRlSW5mb3NCeUtleShrZXkpIHtcbiAgICAgICAgbGV0IHJvdXRlSW5mb3M7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHJvdXRlSW5mb3MgPSB0aGlzLnRhYkhpc3Rvcnlba2V5XTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvcykge1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mb3MgPSB0aGlzLnRhYkhpc3Rvcnlba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZUluZm9zO1xuICAgIH1cbiAgICBnZXRGaXJzdFJvdXRlSW5mb0ZvclRhYih0YWIpIHtcbiAgICAgICAgY29uc3Qgcm91dGVJbmZvcyA9IHRoaXMuX2dldFJvdXRlSW5mb3NCeUtleSh0YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mb3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFJvdXRlSW5mb0ZvclRhYih0YWIpIHtcbiAgICAgICAgY29uc3Qgcm91dGVJbmZvcyA9IHRoaXMuX2dldFJvdXRlSW5mb3NCeUtleSh0YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mb3Nbcm91dGVJbmZvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kTGFzdExvY2F0aW9uKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvdXRlSW5mb3MubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByaSA9IHJvdXRlSW5mb3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaS5wYXRobmFtZSA9PT0gcm91dGVJbmZvLnB1c2hlZEJ5Um91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJpID0gdGhpcy5sb2NhdGlvbkhpc3RvcnlbaV07XG4gICAgICAgICAgICBpZiAocmkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmkucGF0aG5hbWUgPT09IHJvdXRlSW5mby5wdXNoZWRCeVJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcHJldmlvdXMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2NhdGlvbkhpc3RvcnlbdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMl0gfHxcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5W3RoaXMubG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25IaXN0b3J5W3RoaXMubG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjYW5Hb0JhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uSGlzdG9yeS5sZW5ndGggPiAxO1xuICAgIH1cbn1cblxuY2xhc3MgTmF2TWFuYWdlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW9uUm91dGVyQ29udGV4dFZhbHVlID0ge1xuICAgICAgICAgICAgcHVzaDogKHBhdGhuYW1lLCByb3V0ZXJEaXJlY3Rpb24sIHJvdXRlQWN0aW9uLCByb3V0ZXJPcHRpb25zLCBhbmltYXRpb25CdWlsZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShwYXRobmFtZSwgcm91dGVyRGlyZWN0aW9uLCByb3V0ZUFjdGlvbiwgYW5pbWF0aW9uQnVpbGRlciwgcm91dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFjazogKGFuaW1hdGlvbkJ1aWxkZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvQmFjayh1bmRlZmluZWQsIGFuaW1hdGlvbkJ1aWxkZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbkdvQmFjazogKCkgPT4gdGhpcy5wcm9wcy5sb2NhdGlvbkhpc3RvcnkuY2FuR29CYWNrKCksXG4gICAgICAgICAgICBuYXRpdmVCYWNrOiAoKSA9PiB0aGlzLnByb3BzLm9uTmF0aXZlQmFjaygpLFxuICAgICAgICAgICAgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGdvQmFjazogdGhpcy5nb0JhY2suYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGhhc0lvbmljUm91dGVyOiAoKSA9PiB0cnVlLFxuICAgICAgICAgICAgbmF2aWdhdGU6IHRoaXMubmF2aWdhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldElvblJlZGlyZWN0OiB0aGlzLmdldElvblJlZGlyZWN0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRJb25Sb3V0ZTogdGhpcy5nZXRJb25Sb3V0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0U3RhY2tNYW5hZ2VyOiB0aGlzLmdldFN0YWNrTWFuYWdlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0UGFnZU1hbmFnZXI6IHRoaXMuZ2V0UGFnZU1hbmFnZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJvdXRlSW5mbzogdGhpcy5wcm9wcy5yb3V0ZUluZm8sXG4gICAgICAgICAgICBzZXRDdXJyZW50VGFiOiB0aGlzLnByb3BzLm9uU2V0Q3VycmVudFRhYixcbiAgICAgICAgICAgIGNoYW5nZVRhYjogdGhpcy5wcm9wcy5vbkNoYW5nZVRhYixcbiAgICAgICAgICAgIHJlc2V0VGFiOiB0aGlzLnByb3BzLm9uUmVzZXRUYWIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbiA9IHRoaXMuaGFuZGxlSGFyZHdhcmVCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdpb25CYWNrQnV0dG9uJywgdGhpcy5oYW5kbGVIYXJkd2FyZUJhY2tCdXR0b24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbkJhY2tCdXR0b24nLCB0aGlzLmhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbik7XG4gICAgICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVIYXJkd2FyZUJhY2tCdXR0b24oZSkge1xuICAgICAgICBlLmRldGFpbC5yZWdpc3RlcigwLCAocHJvY2Vzc05leHRIYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVHb0JhY2soKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dEhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdvQmFjayhyb3V0ZSwgYW5pbWF0aW9uQnVpbGRlcikge1xuICAgICAgICB0aGlzLnByb3BzLm9uTmF2aWdhdGVCYWNrKHJvdXRlLCBhbmltYXRpb25CdWlsZGVyKTtcbiAgICB9XG4gICAgbmF0aXZlR29CYWNrKCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTmF0aXZlQmFjaygpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZShwYXRoLCBkaXJlY3Rpb24gPSAnZm9yd2FyZCcsIGFjdGlvbiA9ICdwdXNoJywgYW5pbWF0aW9uQnVpbGRlciwgb3B0aW9ucywgdGFiKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25OYXZpZ2F0ZShwYXRoLCBhY3Rpb24sIGRpcmVjdGlvbiwgYW5pbWF0aW9uQnVpbGRlciwgb3B0aW9ucywgdGFiKTtcbiAgICB9XG4gICAgZ2V0UGFnZU1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiBQYWdlTWFuYWdlcjtcbiAgICB9XG4gICAgZ2V0SW9uUmVkaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmlvblJlZGlyZWN0O1xuICAgIH1cbiAgICBnZXRJb25Sb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW9uUm91dGU7XG4gICAgfVxuICAgIGdldFN0YWNrTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3RhY2tNYW5hZ2VyO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOYXZDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB7IHJvdXRlSW5mbzogdGhpcy5wcm9wcy5yb3V0ZUluZm8gfSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmlvblJvdXRlckNvbnRleHRWYWx1ZSksIHsgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyB9KSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld1N0YWNrcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlld1N0YWNrcyA9IHt9O1xuICAgICAgICB0aGlzLmFkZCA9IHRoaXMuYWRkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLmNsZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Vmlld0l0ZW1zRm9yT3V0bGV0ID0gdGhpcy5nZXRWaWV3SXRlbXNGb3JPdXRsZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBhZGQodmlld0l0ZW0pIHtcbiAgICAgICAgY29uc3QgeyBvdXRsZXRJZCB9ID0gdmlld0l0ZW07XG4gICAgICAgIGlmICghdGhpcy52aWV3U3RhY2tzW291dGxldElkXSkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhY2tzW291dGxldElkXSA9IFt2aWV3SXRlbV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdLnB1c2godmlld0l0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKG91dGxldElkKSB7XG4gICAgICAgIC8vIEdpdmUgc29tZSB0aW1lIGZvciB0aGUgbGVhdmluZyB2aWV3cyB0byB0cmFuc2l0aW9uIGJlZm9yZSByZW1vdmluZ1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZW1vdmluZyB2aWV3c3RhY2sgZm9yIG91dGxldElEICcgKyBvdXRsZXRJZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy52aWV3U3RhY2tzW291dGxldElkXTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgZ2V0Vmlld0l0ZW1zRm9yT3V0bGV0KG91dGxldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdIHx8IFtdO1xuICAgIH1cbiAgICByZW1vdmUodmlld0l0ZW0pIHtcbiAgICAgICAgY29uc3QgeyBvdXRsZXRJZCB9ID0gdmlld0l0ZW07XG4gICAgICAgIGNvbnN0IHZpZXdTdGFjayA9IHRoaXMudmlld1N0YWNrc1tvdXRsZXRJZF07XG4gICAgICAgIGlmICh2aWV3U3RhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdJdGVtVG9SZW1vdmUgPSB2aWV3U3RhY2suZmluZCgoeCkgPT4geC5pZCA9PT0gdmlld0l0ZW0uaWQpO1xuICAgICAgICAgICAgaWYgKHZpZXdJdGVtVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB2aWV3SXRlbVRvUmVtb3ZlLm1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhY2tzW291dGxldElkXSA9IHZpZXdTdGFjay5maWx0ZXIoKHgpID0+IHguaWQgIT09IHZpZXdJdGVtVG9SZW1vdmUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN0YWNrSWRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy52aWV3U3RhY2tzKTtcbiAgICB9XG4gICAgZ2V0QWxsVmlld0l0ZW1zKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5nZXRTdGFja0lkcygpO1xuICAgICAgICBjb25zdCB2aWV3SXRlbXMgPSBbXTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB2aWV3SXRlbXMucHVzaCguLi50aGlzLnZpZXdTdGFja3Nba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpZXdJdGVtcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IENyZWF0ZUFuaW1hdGlvbiwgRGVmYXVsdElvbkxpZmVDeWNsZUNvbnRleHQsIElvbkFjY29yZGlvbiwgSW9uQWNjb3JkaW9uR3JvdXAsIElvbkFjdGlvblNoZWV0LCBJb25BbGVydCwgSW9uQXBwLCBJb25BdmF0YXIsIElvbkJhY2tCdXR0b24sIElvbkJhY2tkcm9wLCBJb25CYWRnZSwgSW9uQnJlYWRjcnVtYiwgSW9uQnJlYWRjcnVtYnMsIElvbkJ1dHRvbiwgSW9uQnV0dG9ucywgSW9uQ2FyZCwgSW9uQ2FyZENvbnRlbnQsIElvbkNhcmRIZWFkZXIsIElvbkNhcmRTdWJ0aXRsZSwgSW9uQ2FyZFRpdGxlLCBJb25DaGVja2JveCwgSW9uQ2hpcCwgSW9uQ29sLCBJb25Db250ZW50LCBJb25EYXRldGltZSwgSW9uRmFiLCBJb25GYWJCdXR0b24sIElvbkZhYkxpc3QsIElvbkZvb3RlciwgSW9uR3JpZCwgSW9uSGVhZGVyLCBJb25JY29uLCBJb25JbWcsIElvbkluZmluaXRlU2Nyb2xsLCBJb25JbmZpbml0ZVNjcm9sbENvbnRlbnQsIElvbklucHV0LCBJb25JdGVtLCBJb25JdGVtRGl2aWRlciwgSW9uSXRlbUdyb3VwLCBJb25JdGVtT3B0aW9uLCBJb25JdGVtT3B0aW9ucywgSW9uSXRlbVNsaWRpbmcsIElvbkxhYmVsLCBJb25MaWZlQ3ljbGVDb250ZXh0LCBJb25MaXN0LCBJb25MaXN0SGVhZGVyLCBJb25Mb2FkaW5nLCBJb25NZW51LCBJb25NZW51QnV0dG9uLCBJb25NZW51VG9nZ2xlLCBJb25Nb2RhbCwgSW9uTmF2LCBJb25OYXZMaW5rLCBJb25Ob3RlLCBJb25QYWdlLCBJb25QaWNrZXIsIElvblBvcG92ZXIsIElvblByb2dyZXNzQmFyLCBJb25SYWRpbywgSW9uUmFkaW9Hcm91cCwgSW9uUmFuZ2UsIElvblJlZGlyZWN0LCBJb25SZWZyZXNoZXIsIElvblJlZnJlc2hlckNvbnRlbnQsIElvblJlb3JkZXIsIElvblJlb3JkZXJHcm91cCwgSW9uUmlwcGxlRWZmZWN0LCBJb25Sb3V0ZSwgSW9uUm91dGVyQ29udGV4dCwgSW9uUm91dGVyTGluaywgSW9uUm91dGVyT3V0bGV0LCBJb25Sb3csIElvblNlYXJjaGJhciwgSW9uU2VnbWVudCwgSW9uU2VnbWVudEJ1dHRvbiwgSW9uU2VsZWN0LCBJb25TZWxlY3RPcHRpb24sIElvblNrZWxldG9uVGV4dCwgSW9uU2xpZGUsIElvblNsaWRlcywgSW9uU3Bpbm5lciwgSW9uU3BsaXRQYW5lLCBJb25UYWIsIElvblRhYkJhciwgSW9uVGFiQnV0dG9uLCBJb25UYWJzLCBJb25UYWJzQ29udGV4dCwgSW9uVGV4dCwgSW9uVGV4dGFyZWEsIElvblRodW1ibmFpbCwgSW9uVGl0bGUsIElvblRvYXN0LCBJb25Ub2dnbGUsIElvblRvb2xiYXIsIElvblZpcnR1YWxTY3JvbGwsIExvY2F0aW9uSGlzdG9yeSwgTmF2Q29udGV4dCwgTmF2TWFuYWdlciwgUm91dGVNYW5hZ2VyQ29udGV4dCwgU3RhY2tDb250ZXh0LCBWaWV3TGlmZUN5Y2xlTWFuYWdlciwgVmlld1N0YWNrcywgZ2VuZXJhdGVJZCwgZ2V0Q29uZmlnLCBnZXRQbGF0Zm9ybXMsIGlzUGxhdGZvcm0sIHNldHVwSW9uaWNSZWFjdCwgdXNlSW9uQWN0aW9uU2hlZXQsIHVzZUlvbkFsZXJ0LCB1c2VJb25Mb2FkaW5nLCB1c2VJb25Nb2RhbCwgdXNlSW9uUGlja2VyLCB1c2VJb25Qb3BvdmVyLCB1c2VJb25Sb3V0ZXIsIHVzZUlvblRvYXN0LCB1c2VJb25WaWV3RGlkRW50ZXIsIHVzZUlvblZpZXdEaWRMZWF2ZSwgdXNlSW9uVmlld1dpbGxFbnRlciwgdXNlSW9uVmlld1dpbGxMZWF2ZSwgd2l0aElvbkxpZmVDeWNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6491\n")},7210:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z5\": () => (/* binding */ Build),\n  \"mv\": () => (/* binding */ H),\n  \"AA\": () => (/* binding */ Host),\n  \"yM\": () => (/* binding */ createEvent),\n  \"xE\": () => (/* binding */ forceUpdate),\n  \"iJ\": () => (/* binding */ getMode),\n  \"h\": () => (/* binding */ h),\n  \"GH\": () => (/* binding */ proxyCustomElement),\n  \"wj\": () => (/* binding */ readTask),\n  \"Iu\": () => (/* binding */ writeTask)\n});\n\n// UNUSED EXPORTS: BUILD, CSS, Context, Env, Fragment, H, NAMESPACE, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getRenderingRef, getValue, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructibleStylesheets, supportsListenerOptions, supportsShadow, win\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.14.1 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (app_data_BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (app_data_BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (ref) => {\n    if (app_data_BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n    const didValueChange = newVal !== oldVal && !areBothNaN;\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 576).then(__webpack_require__.bind(__webpack_require__, 576)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(1993)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNLGNBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7OztBQ3ZGakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21FO0FBQ25FO0FBQ0EsWUFBWSx5QkFBZ0I7QUFDNUIsOEJBQThCO0FBQzlCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBbUIsSUFBSSx3QkFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDQUF5QywrQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5Q0FBZ0M7QUFDeEM7QUFDQSxRQUFRLHVDQUE4QjtBQUN0QztBQUNBLFFBQVEscUNBQTRCO0FBQ3BDO0FBQ0EsUUFBUSx1Q0FBOEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQixVQUFVLG1CQUFtQjtBQUN0RTtBQUNBO0FBQ0EsUUFBUSxzQkFBYTtBQUNyQiwwQkFBMEIsT0FBTyxHQUFHLFFBQVEsR0FBRyxJQUFJO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPLE1BQU0sUUFBUTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUF1QjtBQUMzQztBQUNBLHFFQUFxRSxrQkFBa0IsSUFBSSxRQUFRO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUF1QixJQUFJLG1DQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUFlO0FBQzVDLFNBQVMsd0JBQWUsSUFBSSxxQkFBWSxLQUFLLDZCQUFvQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQVU7QUFDckQsMEVBQTBFLElBQUksUUFBUTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFhO0FBQ3pCO0FBQ0E7QUFDQSxZQUFZLDZCQUFvQjtBQUNoQztBQUNBO0FBQ0EsWUFBWSx3QkFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkJBQW9CO0FBQzVCO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsNkJBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxRQUFRLHNCQUFhO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRLDZCQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQWU7QUFDaEM7QUFDQSxnQkFBZ0Isd0JBQWU7QUFDL0I7QUFDQTtBQUNBLDZCQUE2QixnQ0FBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQWE7QUFDOUI7QUFDQSxpQkFBaUIsc0JBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBa0I7QUFDbkMsYUFBYSx1QkFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZCQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBVztBQUNuQixtQ0FBbUMsK0JBQStCLGdCQUFnQixjQUFjLGVBQWUsWUFBWTtBQUMzSDtBQUNBLFFBQVEsdUJBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBb0I7QUFDakM7QUFDQTtBQUNBLFlBQVksc0JBQWEsSUFBSSxnQ0FBdUI7QUFDcEQ7QUFDQTtBQUNBLFlBQVksa0JBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFTO0FBQ3pDLGdFQUFnRSw2QkFBb0I7QUFDcEY7QUFDQTtBQUNBLGdDQUFnQyw2QkFBb0I7QUFDcEQ7QUFDQTtBQUNBLFlBQVksa0JBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBbUI7QUFDL0I7QUFDQTtBQUNBLGFBQWEsd0JBQWUsSUFBSSxxQkFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2QkFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQW9CO0FBQzdDO0FBQ0EsUUFBUSx3QkFBZTtBQUN2QjtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkJBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBYTtBQUM3QixzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxZQUFZLHNCQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUJBQWM7QUFDdkIsWUFBWSxrQkFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBbUIsSUFBSSxzQkFBYTtBQUNoRCxnQkFBZ0IsbUJBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0JBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBZSxJQUFJLHVCQUFjO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQWMsSUFBSSw2QkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFXO0FBQ25CO0FBQ0EsdUNBQXVDLDBCQUEwQjs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQWU7QUFDdkQsUUFBUSxxQkFBWSxJQUFJLHdCQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRLDZCQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkJBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFhLElBQUksZ0NBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwyREFBMkQsVUFBVSwwQkFBMEI7QUFDdks7QUFDQTtBQUNBLGNBQWMseUJBQXlCLFVBQVUsdUJBQXVCO0FBQ3hFLGNBQWMsMkJBQTJCO0FBQ3pDLDZCQUE2Qix1QkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBVztBQUMzQix1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBZSxJQUFJLHdCQUFlO0FBQzFDO0FBQ0E7QUFDQSxRQUFRLDJCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBYztBQUNuQztBQUNBO0FBQ0EsWUFBWSx1QkFBYyxJQUFJLDJCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQVc7QUFDbkI7QUFDQTtBQUNBLFFBQVEsZ0NBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUFnQjtBQUN4QjtBQUNBO0FBQ0EsUUFBUSxvQkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdDQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUFpQjtBQUN6QyxxQkFBcUIsdUJBQWM7QUFDbkMsc0JBQXNCLHdCQUFlO0FBQ3JDLHNCQUFzQix3QkFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUFpQixJQUFJLHNCQUFhO0FBQzlDLGdCQUFnQix5QkFBZ0IsSUFBSSxzQkFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUFjO0FBQ25DO0FBQ0EsUUFBUSwyQkFBa0I7QUFDMUIsWUFBWSxvQkFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQWtCLElBQUksNkJBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQWdCO0FBQzVCLGdCQUFnQixvQkFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUNBQTBCO0FBQ2xDO0FBQ0E7QUFDQSxRQUFRLHFCQUFZLElBQUksdUJBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2QkFBb0I7QUFDNUI7QUFDQTtBQUNBLFFBQVEseUJBQWdCO0FBQ3hCO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxXQUFXLFNBQVMsSUFBSTtBQUNqRixRQUFRLHNCQUFhO0FBQ3JCLHlDQUF5QyxTQUFTLEVBQUUsbUJBQW1CLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLDRCQUFtQjtBQUNwRDtBQUNBLE1BQU0sZ0NBQXVCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLHdCQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEdBQUcsT0FBTyxHQUFHLE1BQU0sR0FBRyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsTUFBTSxHQUFHLE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYSxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxTQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxHQUFHLE9BQU87QUFDbkQsd0JBQXdCLHdCQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBYztBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLHVCQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFXO0FBQ3ZCO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQSxhQUFhLHVCQUFjO0FBQzNCO0FBQ0EsZ0JBQWdCLDRCQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQWU7QUFDL0I7QUFDQSxvQkFBb0IsOEJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFZO0FBQ3BCLFlBQVksNEJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBVSxJQUFJLG9CQUFXO0FBQzFDO0FBQ0EsdUJBQXVCLHVCQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixvQkFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLFFBQVEsa0JBQWtCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQkFBcUIsdUJBQWM7QUFDbkMsZ0JBQWdCLHFCQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxZQUFZLCtCQUFzQixNQUFNLHVCQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1QkFBYyxJQUFJLGdDQUF1QixJQUFJLG9CQUFXO0FBQ2pFO0FBQ0EsWUFBWSx1QkFBYyxJQUFJLGdDQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQixHQUFHLG1CQUFtQixpQ0FBaUMsa0JBQWtCO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBVyxJQUFJLHNCQUFhO0FBQzdDLG9EQUFvRCxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDNUY7QUFDQSxnQkFBZ0IscUJBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFZO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQVU7QUFDMUI7QUFDQSxvQkFBb0IsZ0NBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBdUI7QUFDNUMsb0JBQW9CLHdCQUFlO0FBQ25DLG9CQUFvQiw0QkFBbUI7QUFDdkM7QUFDQSxrQ0FBa0Msa0dBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBYyxJQUFJLGdDQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQWU7QUFDdkMsd0NBQXdDLG1CQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBdUI7QUFDM0Msc0JBQXNCLG1CQUFVLElBQUksd0JBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQVUsS0FBSyxnQ0FBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0JBQWdCLGlDQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxzQkFBYSx3QkFBd0IsY0FBYztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQWM7QUFDdkMsWUFBWSwyQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksdUJBQWMsSUFBSSxtQ0FBMEI7QUFDeEQ7QUFDQTtBQUNBLFlBQVksMkJBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQVk7QUFDcEI7QUFDQTtBQUNBLFFBQVEsMkJBQWtCO0FBQzFCO0FBQ0E7QUFDQSxRQUFRLDRCQUFtQjtBQUMzQjtBQUNBO0FBQ0EsUUFBUSxzQkFBYTtBQUNyQjtBQUNBO0FBQ0EsUUFBUSx3QkFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUF1QjtBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQTBCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixtQ0FBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLGVBQWUsd0JBQWU7QUFDOUI7QUFDd0U7QUFDNHZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2JhOTUiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcz8zMTA1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJVSUxEID0ge1xuICAgIGFsbFJlbmRlckZuOiBmYWxzZSxcbiAgICBjbXBEaWRMb2FkOiB0cnVlLFxuICAgIGNtcERpZFVubG9hZDogZmFsc2UsXG4gICAgY21wRGlkVXBkYXRlOiB0cnVlLFxuICAgIGNtcERpZFJlbmRlcjogdHJ1ZSxcbiAgICBjbXBXaWxsTG9hZDogdHJ1ZSxcbiAgICBjbXBXaWxsVXBkYXRlOiB0cnVlLFxuICAgIGNtcFdpbGxSZW5kZXI6IHRydWUsXG4gICAgY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZWxlbWVudDogdHJ1ZSxcbiAgICBldmVudDogdHJ1ZSxcbiAgICBoYXNSZW5kZXJGbjogdHJ1ZSxcbiAgICBsaWZlY3ljbGU6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudDogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRCb2R5OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0OiB0cnVlLFxuICAgIG1lbWJlcjogdHJ1ZSxcbiAgICBtZXRob2Q6IHRydWUsXG4gICAgbW9kZTogdHJ1ZSxcbiAgICBvYnNlcnZlQXR0cmlidXRlOiB0cnVlLFxuICAgIHByb3A6IHRydWUsXG4gICAgcHJvcE11dGFibGU6IHRydWUsXG4gICAgcmVmbGVjdDogdHJ1ZSxcbiAgICBzY29wZWQ6IHRydWUsXG4gICAgc2hhZG93RG9tOiB0cnVlLFxuICAgIHNsb3Q6IHRydWUsXG4gICAgY3NzQW5ub3RhdGlvbnM6IHRydWUsXG4gICAgc3RhdGU6IHRydWUsXG4gICAgc3R5bGU6IHRydWUsXG4gICAgc3ZnOiB0cnVlLFxuICAgIHVwZGF0YWJsZTogdHJ1ZSxcbiAgICB2ZG9tQXR0cmlidXRlOiB0cnVlLFxuICAgIHZkb21YbGluazogdHJ1ZSxcbiAgICB2ZG9tQ2xhc3M6IHRydWUsXG4gICAgdmRvbUZ1bmN0aW9uYWw6IHRydWUsXG4gICAgdmRvbUtleTogdHJ1ZSxcbiAgICB2ZG9tTGlzdGVuZXI6IHRydWUsXG4gICAgdmRvbVJlZjogdHJ1ZSxcbiAgICB2ZG9tUHJvcE9yQXR0cjogdHJ1ZSxcbiAgICB2ZG9tUmVuZGVyOiB0cnVlLFxuICAgIHZkb21TdHlsZTogdHJ1ZSxcbiAgICB2ZG9tVGV4dDogdHJ1ZSxcbiAgICB3YXRjaENhbGxiYWNrOiB0cnVlLFxuICAgIHRhc2tRdWV1ZTogdHJ1ZSxcbiAgICBob3RNb2R1bGVSZXBsYWNlbWVudDogZmFsc2UsXG4gICAgaXNEZWJ1ZzogZmFsc2UsXG4gICAgaXNEZXY6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogZmFsc2UsXG4gICAgaHlkcmF0ZVNlcnZlclNpZGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVDbGllbnRTaWRlOiBmYWxzZSxcbiAgICBsaWZlY3ljbGVET01FdmVudHM6IGZhbHNlLFxuICAgIGxhenlMb2FkOiBmYWxzZSxcbiAgICBwcm9maWxlOiBmYWxzZSxcbiAgICBzbG90UmVsb2NhdGlvbjogdHJ1ZSxcbiAgICBhcHBlbmRDaGlsZFNsb3RGaXg6IGZhbHNlLFxuICAgIGNsb25lTm9kZUZpeDogZmFsc2UsXG4gICAgaHlkcmF0ZWRBdHRyaWJ1dGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQ2xhc3M6IHRydWUsXG4gICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgIHNjcmlwdERhdGFPcHRzOiBmYWxzZSxcbiAgICBzY29wZWRTbG90VGV4dENvbnRlbnRGaXg6IGZhbHNlLFxuICAgIHNoYWRvd0RvbVNoaW06IGZhbHNlLFxuICAgIHNsb3RDaGlsZE5vZGVzRml4OiBmYWxzZSxcbiAgICBpbnZpc2libGVQcmVoeWRyYXRpb246IHRydWUsXG4gICAgcHJvcEJvb2xlYW46IHRydWUsXG4gICAgcHJvcE51bWJlcjogdHJ1ZSxcbiAgICBwcm9wU3RyaW5nOiB0cnVlLFxuICAgIGNzc1ZhclNoaW06IGZhbHNlLFxuICAgIGNvbnN0cnVjdGFibGVDU1M6IHRydWUsXG4gICAgY21wU2hvdWxkVXBkYXRlOiB0cnVlLFxuICAgIGRldlRvb2xzOiBmYWxzZSxcbiAgICBkeW5hbWljSW1wb3J0U2hpbTogZmFsc2UsXG4gICAgc2hhZG93RGVsZWdhdGVzRm9jdXM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSxcbiAgICBhc3luY0xvYWRpbmc6IGZhbHNlLFxuICAgIGFzeW5jUXVldWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIGF0dGFjaFN0eWxlczogdHJ1ZSxcbn07XG5jb25zdCBFbnYgPSB7fTtcbmNvbnN0IE5BTUVTUEFDRSA9IC8qIGRlZmF1bHQgKi8gJ2FwcCc7XG5cbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9O1xuIiwibGV0IHNjb3BlSWQ7XG5sZXQgY29udGVudFJlZjtcbmxldCBob3N0VGFnTmFtZTtcbmxldCBjdXN0b21FcnJvcjtcbmxldCBpID0gMDtcbmxldCB1c2VOYXRpdmVTaGFkb3dEb20gPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RSZWxvY2F0ZSA9IGZhbHNlO1xubGV0IGlzU3ZnTW9kZSA9IGZhbHNlO1xubGV0IHJlbmRlcmluZ1JlZiA9IG51bGw7XG5sZXQgcXVldWVDb25nZXN0aW9uID0gMDtcbmxldCBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuMTQuMSB8IE1JVCBMaWNlbnNlZCB8IGh0dHBzOi8vc3RlbmNpbGpzLmNvbVxuICovXG5pbXBvcnQgeyBCVUlMRCwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuY29uc3QgQ1NTID0gQlVJTEQuY3NzVmFyU2hpbSA/IHdpbi5DU1MgOiBudWxsO1xuY29uc3QgZG9jID0gd2luLmRvY3VtZW50IHx8IHsgaGVhZDoge30gfTtcbmNvbnN0IEggPSAod2luLkhUTUxFbGVtZW50IHx8IGNsYXNzIHtcbn0pO1xuY29uc3QgcGx0ID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHJlc291cmNlc1VybCQ6ICcnLFxuICAgIGptcDogKGgpID0+IGgoKSxcbiAgICByYWY6IChoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCksXG4gICAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgcmVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgY2U6IChldmVudE5hbWUsIG9wdHMpID0+IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9wdHMpLFxufTtcbmNvbnN0IHNldFBsYXRmb3JtSGVscGVycyA9IChoZWxwZXJzKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIGhlbHBlcnMpO1xufTtcbmNvbnN0IHN1cHBvcnRzU2hhZG93ID0gQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBCVUlMRC5zaGFkb3dEb21cbiAgICA/IC8qQF9fUFVSRV9fKi8gKCgpID0+IChkb2MuaGVhZC5hdHRhY2hTaGFkb3cgKyAnJykuaW5kZXhPZignW25hdGl2ZScpID4gLTEpKClcbiAgICA6IHRydWU7XG5jb25zdCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICBsZXQgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zO1xufSkoKTtcbmNvbnN0IHByb21pc2VSZXNvbHZlID0gKHYpID0+IFByb21pc2UucmVzb2x2ZSh2KTtcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzID0gQlVJTEQuY29uc3RydWN0YWJsZUNTU1xuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmV3IENTU1N0eWxlU2hlZXQoKS5yZXBsYWNlID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKClcbiAgICA6IGZhbHNlO1xuY29uc3QgQ29udGV4dCA9IHt9O1xuY29uc3QgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoaW4gdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBpbml0aWFsaXplIG91ciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIG5vdyBzbyB0aGF0IHdlIGNhbiBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgbWF5XG4gICAgICAgIC8vIGhhdmUgZmlyZWQgZXZlbiBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIHJlYWR5XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IG1heSBoYXZlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICBpZiAoYXR0YWNoUGFyZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW1wb3J0YW50IHNvIHRoYXQgd2Uga25vdyB0aGUgaG9zdCBlbGVtZW50IGFjdHVhbGx5IGhhcyBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRvIG9ubHkgaGF2ZSB0aGUgb25lcyB0aGF0IEFSRSBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgQlVUIHRoZSBwYXJlbnQgZWxlbWVudCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGF0dGFjaGVkIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0aGF0IGFyZSBOT1QgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+ICEoZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldCA/IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA6IGVsbTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBob3N0TGlzdGVuZXJQcm94eShob3N0UmVmLCBtZXRob2QpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGhvc3RMaXN0ZW5lck9wdHMoZmxhZ3MpO1xuICAgICAgICAgICAgcGx0LmFlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpO1xuICAgICAgICAgICAgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCB8fCBbXSkucHVzaCgoKSA9PiBwbHQucmVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaG9zdExpc3RlbmVyUHJveHkgPSAoaG9zdFJlZiwgbWV0aG9kTmFtZSkgPT4gKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZSBpcyByZWFkeSwgbGV0J3MgY2FsbCBpdCdzIG1lbWJlciBtZXRob2QgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRsYXp5SW5zdGFuY2UkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCB8fCBbXSkucHVzaChbbWV0aG9kTmFtZSwgZXZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGhvc3RFbGVtZW50JFttZXRob2ROYW1lXShldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbn07XG5jb25zdCBnZXRIb3N0TGlzdGVuZXJUYXJnZXQgPSAoZWxtLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudCAmJiBmbGFncyAmIDQgLyogVGFyZ2V0RG9jdW1lbnQgKi8pXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdyAmJiBmbGFncyAmIDggLyogVGFyZ2V0V2luZG93ICovKVxuICAgICAgICByZXR1cm4gd2luO1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRCb2R5ICYmIGZsYWdzICYgMTYgLyogVGFyZ2V0Qm9keSAqLylcbiAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQgJiYgZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pXG4gICAgICAgIHJldHVybiBlbG0ucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWxtO1xufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaG9zdExpc3RlbmVyT3B0cyA9IChmbGFncykgPT4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnNcbiAgICA/ICh7XG4gICAgICAgIHBhc3NpdmU6IChmbGFncyAmIDEgLyogUGFzc2l2ZSAqLykgIT09IDAsXG4gICAgICAgIGNhcHR1cmU6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDAsXG4gICAgfSlcbiAgICA6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDA7XG5jb25zdCBDT05URU5UX1JFRl9JRCA9ICdyJztcbmNvbnN0IE9SR19MT0NBVElPTl9JRCA9ICdvJztcbmNvbnN0IFNMT1RfTk9ERV9JRCA9ICdzJztcbmNvbnN0IFRFWFRfTk9ERV9JRCA9ICd0JztcbmNvbnN0IEhZRFJBVEVfSUQgPSAncy1pZCc7XG5jb25zdCBIWURSQVRFRF9TVFlMRV9JRCA9ICdzdHktaWQnO1xuY29uc3QgSFlEUkFURV9DSElMRF9JRCA9ICdjLWlkJztcbmNvbnN0IEhZRFJBVEVEX0NTUyA9ICd7dmlzaWJpbGl0eTpoaWRkZW59Lmh5ZHJhdGVke3Zpc2liaWxpdHk6aW5oZXJpdH0nO1xuY29uc3QgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBjcmVhdGVUaW1lID0gKGZuTmFtZSwgdGFnTmFtZSA9ICcnKSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBjb25zdCBrZXkgPSBgc3Q6JHtmbk5hbWV9OiR7dGFnTmFtZX06JHtpKyt9YDtcbiAgICAgICAgLy8gU3RhcnRcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICAvLyBFbmRcbiAgICAgICAgcmV0dXJuICgpID0+IHBlcmZvcm1hbmNlLm1lYXN1cmUoYFtTdGVuY2lsXSAke2ZuTmFtZX0oKSA8JHt0YWdOYW1lfT5gLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdW5pcXVlVGltZSA9IChrZXksIG1lYXN1cmVUZXh0KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShrZXkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShtZWFzdXJlVGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlVGV4dCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBpZiAoIWhvc3RSZWYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmxhZ3MgPSBob3N0UmVmLiRmbGFncyQ7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyQ291bnQ6IGhvc3RSZWYuJHJlbmRlckNvdW50JCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkOiAhIShmbGFncyAmIDIgLyogaGFzUmVuZGVyZWQgKi8pLFxuICAgICAgICAgICAgaGFzQ29ubmVjdGVkOiAhIShmbGFncyAmIDEgLyogaGFzQ29ubmVjdGVkICovKSxcbiAgICAgICAgICAgIGlzV2FpdGluZ0ZvckNoaWxkcmVuOiAhIShmbGFncyAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pLFxuICAgICAgICAgICAgaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZTogISEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pLFxuICAgICAgICAgICAgaXNRdWV1ZWRGb3JVcGRhdGU6ICEhKGZsYWdzICYgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pLFxuICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaGFzTG9hZGVkQ29tcG9uZW50OiAhIShmbGFncyAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBpc1dhdGNoUmVhZHk6ICEhKGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLyksXG4gICAgICAgICAgICBpc0xpc3RlblJlYWR5OiAhIShmbGFncyAmIDI1NiAvKiBpc0xpc3RlblJlYWR5ICovKSxcbiAgICAgICAgICAgIG5lZWRzUmVyZW5kZXI6ICEhKGZsYWdzICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pLFxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVZhbHVlczogaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLFxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudDogaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkLFxuICAgICAgICBob3N0RWxlbWVudCxcbiAgICAgICAgbGF6eUluc3RhbmNlOiBob3N0UmVmLiRsYXp5SW5zdGFuY2UkLFxuICAgICAgICB2bm9kZTogaG9zdFJlZi4kdm5vZGUkLFxuICAgICAgICBtb2RlTmFtZTogaG9zdFJlZi4kbW9kZU5hbWUkLFxuICAgICAgICBvblJlYWR5UHJvbWlzZTogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLFxuICAgICAgICBvblJlYWR5UmVzb2x2ZTogaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkLFxuICAgICAgICBvbkluc3RhbmNlUHJvbWlzZTogaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkLFxuICAgICAgICBvbkluc3RhbmNlUmVzb2x2ZTogaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkLFxuICAgICAgICBvblJlbmRlclJlc29sdmU6IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQsXG4gICAgICAgIHF1ZXVlZExpc3RlbmVyczogaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCxcbiAgICAgICAgcm1MaXN0ZW5lcnM6IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCxcbiAgICAgICAgWydzLWlkJ106IGhvc3RFbGVtZW50WydzLWlkJ10sXG4gICAgICAgIFsncy1jciddOiBob3N0RWxlbWVudFsncy1jciddLFxuICAgICAgICBbJ3MtbHInXTogaG9zdEVsZW1lbnRbJ3MtbHInXSxcbiAgICAgICAgWydzLXAnXTogaG9zdEVsZW1lbnRbJ3MtcCddLFxuICAgICAgICBbJ3MtcmMnXTogaG9zdEVsZW1lbnRbJ3MtcmMnXSxcbiAgICAgICAgWydzLXNjJ106IGhvc3RFbGVtZW50WydzLXNjJ10sXG4gICAgfTtcbn07XG5jb25zdCBpbnN0YWxsRGV2VG9vbHMgPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmRldlRvb2xzKSB7XG4gICAgICAgIGNvbnN0IHN0ZW5jaWwgPSAod2luLnN0ZW5jaWwgPSB3aW4uc3RlbmNpbCB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5zcGVjdCA9IHN0ZW5jaWwuaW5zcGVjdDtcbiAgICAgICAgc3RlbmNpbC5pbnNwZWN0ID0gKHJlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIHR5cGVvZiBvcmlnaW5hbEluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW5hbEluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHJvb3RBcHBsaWVkU3R5bGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyU3R5bGUgPSAoc2NvcGVJZCwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICAgICAgc3R5bGUgPSAoc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKSk7XG4gICAgICAgIHN0eWxlLnJlcGxhY2UoY3NzVGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgfVxuICAgIHN0eWxlcy5zZXQoc2NvcGVJZCwgc3R5bGUpO1xufTtcbmNvbnN0IGFkZFN0eWxlID0gKHN0eWxlQ29udGFpbmVyTm9kZSwgY21wTWV0YSwgbW9kZSwgaG9zdEVsbSkgPT4ge1xuICAgIGxldCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmICghQlVJTEQuYXR0YWNoU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUlkO1xuICAgIH1cbiAgICAvLyBpZiBhbiBlbGVtZW50IGlzIE5PVCBjb25uZWN0ZWQgdGhlbiBnZXRSb290Tm9kZSgpIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyByb290IG5vZGVcbiAgICAvLyBzbyB0aGUgZmFsbGJhY2sgaXMgdG8gYWx3YXlzIHVzZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSByb290IG5vZGUgaW4gdGhvc2UgY2FzZXNcbiAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gPyBzdHlsZUNvbnRhaW5lck5vZGUgOiBkb2M7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUuaGVhZCB8fCBzdHlsZUNvbnRhaW5lck5vZGU7XG4gICAgICAgICAgICBsZXQgYXBwbGllZFN0eWxlcyA9IHJvb3RBcHBsaWVkU3R5bGVzLmdldChzdHlsZUNvbnRhaW5lck5vZGUpO1xuICAgICAgICAgICAgbGV0IHN0eWxlRWxtO1xuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcm9vdEFwcGxpZWRTdHlsZXMuc2V0KHN0eWxlQ29udGFpbmVyTm9kZSwgKGFwcGxpZWRTdHlsZXMgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmhvc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlRWxtID0gc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoYFske0hZRFJBVEVEX1NUWUxFX0lEfT1cIiR7c2NvcGVJZH1cIl1gKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGhhcHBlbmluZyBvbiBuYXRpdmUgc2hhZG93LWRvbSwgZG8gbm90IG5lZWRzIENTUyB2YXIgc2hpbVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtID0gcGx0LiRjc3NTaGltJC5jcmVhdGVIb3N0U3R5bGUoaG9zdEVsbSwgc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGVJZCA9IHN0eWxlRWxtWydzLXNjJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlSWQgPSBuZXdTY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgc3R5bGVJRCB0byB0aGUgYXBwbGllZFN0eWxlcyBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY3NzVmFyU2hpbSBtaWdodCBuZWVkIHRvIGFwcGx5IHNldmVyYWwgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzaGVldHMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lELCBzY29wZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlRWxtLCBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcignbGluaycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcy5hZGQoc2NvcGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELmNvbnN0cnVjdGFibGVDU1MgJiYgIXN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzID0gWy4uLnN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMsIHN0eWxlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVJZDtcbn07XG5jb25zdCBhdHRhY2hTdHlsZXMgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgY29uc3QgZW5kQXR0YWNoU3R5bGVzID0gY3JlYXRlVGltZSgnYXR0YWNoU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSBhZGRTdHlsZShCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgZWxtLnNoYWRvd1Jvb3QgPyBlbG0uc2hhZG93Um9vdCA6IGVsbS5nZXRSb290Tm9kZSgpLCBjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQsIGVsbSk7XG4gICAgaWYgKChCVUlMRC5zaGFkb3dEb20gfHwgQlVJTEQuc2NvcGVkKSAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucyAmJiBmbGFncyAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgICAgIGlmIChCVUlMRC5zY29wZWQgJiYgZmxhZ3MgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRBdHRhY2hTdHlsZXMoKTtcbn07XG5jb25zdCBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gJ3NjLScgKyAoQlVJTEQubW9kZSAmJiBtb2RlICYmIGNtcC4kZmxhZ3MkICYgMzIgLyogaGFzTW9kZSAqLyA/IGNtcC4kdGFnTmFtZSQgKyAnLScgKyBtb2RlIDogY21wLiR0YWdOYW1lJCk7XG5jb25zdCBjb252ZXJ0U2NvcGVkVG9TaGFkb3cgPSAoY3NzKSA9PiBjc3MucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csICckMXsnKTtcbi8vIFByaXZhdGVcbmNvbnN0IGNvbXB1dGVNb2RlID0gKGVsbSkgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGgpID0+IGgoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gaCgpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG4vLyBjb25zdCBzdGFjazogYW55W10gPSBbXTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgdk5vZGVDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmICgoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmICFpc0NvbXBsZXhUeXBlKGNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgY2hpbGQuJGZsYWdzJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHZub2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGNsYXNzIC8gY2xhc3NuYW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgdm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NEYXRhID0gdm5vZGVEYXRhLmNsYXNzTmFtZSB8fCB2bm9kZURhdGEuY2xhc3M7XG4gICAgICAgICAgICBpZiAoY2xhc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEYXRhLmNsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNsYXNzRGF0YSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xhc3NEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChrKSA9PiBjbGFzc0RhdGFba10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdk5vZGVDaGlsZHJlbi5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC4gTWFrZSBzdXJlOlxuLSBZb3UgYXJlIE5PVCB1c2luZyBob3N0RGF0YSgpIGFuZCA8SG9zdD4gaW4gdGhlIHNhbWUgY29tcG9uZW50LlxuLSA8SG9zdD4gaXMgdXNlZCBvbmNlLCBhbmQgaXQncyB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50IG9mIHRoZSByZW5kZXIoKSBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21GdW5jdGlvbmFsICYmIHR5cGVvZiBub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub2RlTmFtZSBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIHJldHVybiBub2RlTmFtZSh2bm9kZURhdGEgPT09IG51bGwgPyB7fSA6IHZub2RlRGF0YSwgdk5vZGVDaGlsZHJlbiwgdmRvbUZuVXRpbHMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGVOYW1lLCBudWxsKTtcbiAgICB2bm9kZS4kYXR0cnMkID0gdm5vZGVEYXRhO1xuICAgIGlmICh2Tm9kZUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdm5vZGUuJGNoaWxkcmVuJCA9IHZOb2RlQ2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0ga2V5O1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgdm5vZGUuJG5hbWUkID0gc2xvdE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBuZXdWTm9kZSA9ICh0YWcsIHRleHQpID0+IHtcbiAgICBjb25zdCB2bm9kZSA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJHRhZyQ6IHRhZyxcbiAgICAgICAgJHRleHQkOiB0ZXh0LFxuICAgICAgICAkZWxtJDogbnVsbCxcbiAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICB9O1xuICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgIHZub2RlLiRhdHRycyQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICB2bm9kZS4ka2V5JCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgSG9zdCA9IHt9O1xuY29uc3QgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbmNvbnN0IHZkb21GblV0aWxzID0ge1xuICAgIGZvckVhY2g6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLmZvckVhY2goY2IpLFxuICAgIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSksXG59O1xuY29uc3QgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gICAgdmF0dHJzOiBub2RlLiRhdHRycyQsXG4gICAgdmNoaWxkcmVuOiBub2RlLiRjaGlsZHJlbiQsXG4gICAgdmtleTogbm9kZS4ka2V5JCxcbiAgICB2bmFtZTogbm9kZS4kbmFtZSQsXG4gICAgdnRhZzogbm9kZS4kdGFnJCxcbiAgICB2dGV4dDogbm9kZS4kdGV4dCQsXG59KTtcbmNvbnN0IGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52dGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZub2RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmF0dHJzKTtcbiAgICAgICAgaWYgKG5vZGUudmtleSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLmtleSA9IG5vZGUudmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52bmFtZSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLm5hbWUgPSBub2RlLnZuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi4obm9kZS52Y2hpbGRyZW4gfHwgW10pKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICAgIHZub2RlLiRhdHRycyQgPSBub2RlLnZhdHRycztcbiAgICB2bm9kZS4kY2hpbGRyZW4kID0gbm9kZS52Y2hpbGRyZW47XG4gICAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gICAgdm5vZGUuJG5hbWUkID0gbm9kZS52bmFtZTtcbiAgICByZXR1cm4gdm5vZGU7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG9yZGVyaW5nIG9mIGF0dHJpYnV0ZXMgb24gYW4gaW5wdXQgZWxlbWVudFxuICogQHBhcmFtIGlucHV0RWxtIHRoZSBlbGVtZW50IHRvIHZhbGlkYXRlXG4gKi9cbmNvbnN0IHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzID0gKGlucHV0RWxtKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhpbnB1dEVsbSk7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wcy5pbmRleE9mKCd2YWx1ZScpO1xuICAgIGlmICh2YWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5kZXggPSBwcm9wcy5pbmRleE9mKCd0eXBlJyk7XG4gICAgY29uc3QgbWluSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHByb3BzLmluZGV4T2YoJ21heCcpO1xuICAgIGNvbnN0IHN0ZXBJbmRleCA9IHByb3BzLmluZGV4T2YoJ3N0ZXAnKTtcbiAgICBpZiAodmFsdWUgPCB0eXBlSW5kZXggfHwgdmFsdWUgPCBtaW5JbmRleCB8fCB2YWx1ZSA8IG1heEluZGV4IHx8IHZhbHVlIDwgc3RlcEluZGV4KSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCJ2YWx1ZVwiIHByb3Agb2YgPGlucHV0PiBzaG91bGQgYmUgc2V0IGFmdGVyIFwibWluXCIsIFwibWF4XCIsIFwidHlwZVwiIGFuZCBcInN0ZXBcImApO1xuICAgIH1cbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gc2V0QWNjZXNzb3IoKSBmdW5jdGlvbiBiYXNlZCBvbiBQcmVhY3QgYnlcbiAqIEphc29uIE1pbGxlciAoQGRldmVsb3BpdClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgY29tcGlsZXIgYW5kIHZkb21cbiAqL1xuY29uc3Qgc2V0QWNjZXNzb3IgPSAoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGlzU3ZnLCBmbGFncykgPT4ge1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IGlzUHJvcCA9IGlzTWVtYmVySW5FbGVtZW50KGVsbSwgbWVtYmVyTmFtZSk7XG4gICAgICAgIGxldCBsbiA9IG1lbWJlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcyAmJiBtZW1iZXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbG0uY2xhc3NMaXN0O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFuZXdDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFvbGRDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSBuZXdWYWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09ICdrZXknKVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUmVmICYmIG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUxpc3RlbmVyICYmXG4gICAgICAgICAgICAoQlVJTEQubGF6eUxvYWQgPyAhaXNQcm9wIDogIWVsbS5fX2xvb2t1cFNldHRlcl9fKG1lbWJlck5hbWUpKSAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVswXSA9PT0gJ28nICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IGlmIGl0IGV4aXN0cyBhbmQgaXQncyBub3QgYSBTVkdcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKChpc1Byb3AgfHwgKGlzQ29tcGxleCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkpICYmICFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgPyBuZXdWbm9kZS4kZWxtJC5ob3N0XG4gICAgICAgIDogbmV3Vm5vZGUuJGVsbSQ7XG4gICAgY29uc3Qgb2xkVm5vZGVBdHRycyA9IChvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkKSB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgbm8gbG9uZ2VyIHByZXNlbnQgb24gdGhlIHZub2RlIGJ5IHNldHRpbmcgdGhlbSB0byB1bmRlZmluZWRcbiAgICAgICAgZm9yIChtZW1iZXJOYW1lIGluIG9sZFZub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykpIHtcbiAgICAgICAgICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHVuZGVmaW5lZCwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgIGZvciAobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgbmV3Vm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICB9XG59O1xuY29uc3QgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID1cbiAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJClcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA/ICdzbG90LWZiJ1xuICAgICAgICAgICAgICAgIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUsIG5ld0NoKSA9PiB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBpZHhJbk9sZCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGVsbVRvTW92ZTtcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtaWdodCBoYXZlIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVLZXlUb09sZElkeFxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkU3RhcnRJZHg7IGkgPD0gb2xkRW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoW2ldICYmIG9sZENoW2ldLiRrZXkkICE9PSBudWxsICYmIG9sZENoW2ldLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsbVRvTW92ZS4kdGFnJCAhPT0gbmV3U3RhcnRWbm9kZS4kdGFnJCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIGlkeEluT2xkLCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgbmV3U3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxufTtcbmNvbnN0IGlzU2FtZVZub2RlID0gKHZub2RlMSwgdm5vZGUyKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAodm5vZGUxLiR0YWckID09PSB2bm9kZTIuJHRhZyQpIHtcbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlMS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRuYW1lJCA9PT0gdm5vZGUyLiRuYW1lJDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4ka2V5JCA9PT0gdm5vZGUyLiRrZXkkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgLy8gdGhpcyBub2RlIHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGRvbVxuICAgIC8vIGJlY2F1c2Ugb2Ygc29tZSBvdGhlciBjb21wb25lbnQncyBzbG90XG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYW4gaHRtbCBjb21tZW50IGluIHBsYWNlIG9mIHdoZXJlXG4gICAgLy8gaXQncyBvcmlnaW5hbCBsb2NhdGlvbiB3YXMgYWNjb3JkaW5nIHRvIGl0J3Mgb3JpZ2luYWwgdmRvbVxuICAgIHJldHVybiAobm9kZSAmJiBub2RlWydzLW9sJ10pIHx8IG5vZGU7XG59O1xuY29uc3QgcGFyZW50UmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiAobm9kZVsncy1vbCddID8gbm9kZVsncy1vbCddIDogbm9kZSkucGFyZW50Tm9kZTtcbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgbGV0IGRlZmF1bHRIb2xkZXI7XG4gICAgaWYgKCFCVUlMRC52ZG9tVGV4dCB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVuZGVyaW5nIGFuIHN2ZyBlbGVtZW50LCBvciBzdGlsbCByZW5kZXJpbmcgbm9kZXMgaW5zaWRlIG9mIG9uZVxuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhpcyB0byB0aGUgd2hlbiB0aGUgY29tcGlsZXIgc2VlcyB3ZSdyZSB1c2luZyBhbiBzdmcgc29tZXdoZXJlXG4gICAgICAgICAgICBpc1N2Z01vZGUgPSB0YWcgPT09ICdzdmcnID8gdHJ1ZSA6IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudCBub2RlXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90ICYmIHRhZyA9PT0gJ3Nsb3QnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgb2YgYW4gZWxlbWVudCBPUiBpdCdzIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBhbHJlYWR5IGtub3cgaXQncyBwb3NzaWJsZSBpdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIGVsZW1lbnQncyBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlJ3MgY2hpbGQgdm5vZGVzIGZvciBib3RoIHRoZSBvbGQgYW5kIG5ldyB2bm9kZXNcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2hpbGRyZW4sIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG9sZCBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgbmV3IGNoaWxkIHZub2RlcyB0byBhZGRcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSB3YXMgdGV4dCwgc28gYmUgc3VyZSB0byBjbGVhciBpdCBvdXRcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHZub2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiB0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAoZGVmYXVsdEhvbGRlciA9IGVsbVsncy1jciddKSkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIHNsb3R0ZWQgY29udGVudFxuICAgICAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSB0ZXh0IG9ubHkgdm5vZGVcbiAgICAgICAgLy8gYW5kIGFsc28gb25seSBpZiB0aGUgdGV4dCBpcyBkaWZmZXJlbnQgdGhhbiBiZWZvcmVcbiAgICAgICAgZWxtLmRhdGEgPSB0ZXh0O1xuICAgIH1cbn07XG5jb25zdCB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBpO1xuICAgIGxldCBpbGVuO1xuICAgIGxldCBqO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCBmYWxsYmFjayBub2RlXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzbG90IG5hbWUgZm9yIHRoaXMgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIHNob3cgYSBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgaWYgdGhlcmUgYXJlIG90aGVyIHNsb3RzIGluIHRoZSBsaWdodCBkb21cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNoaWxkTm9kZXNbal0ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddIHx8IHNsb3ROYW1lQXR0ciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2libGluZyBub2RlIGlzIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IE9SIGlzIGEgbmFtZWQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8gJiYgY2hpbGROb2Rlc1tqXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVsb2NhdGVOb2RlcyA9IFtdO1xuY29uc3QgcmVsb2NhdGVTbG90Q29udGVudCA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgcmVsb2NhdGVOb2RlRGF0YTtcbiAgICBsZXQgajtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgc29tZSBjaGFuZ2VzIHRvIHNsb3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgd2UgYWxzbyBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrcyBhcmUgY29ycmVjdGx5IGhpZGRlbiBvciBzaG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IG5vZGVbJ3Mtc24nXSB8fCBzbG90TmFtZUF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgd2UgbmV2ZXIgZm91bmQgYSBzbG90IGhvbWUgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0dXJucyBvdXQgd2UgZGlkLCBzbyBsZXQncyByZW1lbWJlciBpdCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3VyIGxpc3Qgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2xvdFJlZk5vZGUkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5tYXAoKHJlbG9jYXRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZSgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZmFyIHRoaXMgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgc2xvdCBob21lLCBub3Qgc2V0dGluZyBzbG90UmVmTm9kZSBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZXZlciBmaW5kIGEgaG9tZSBmb3IgdGhpcyBlbGVtZW50IHRoZW4gd2UnbGwgbmVlZCB0byBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNOb2RlTG9jYXRlZEluU2xvdCA9IChub2RlVG9SZWxvY2F0ZSwgc2xvdE5hbWVBdHRyKSA9PiB7XG4gICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gbnVsbCAmJiBzbG90TmFtZUF0dHIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKCdzbG90JykgPT09IHNsb3ROYW1lQXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5hbWVBdHRyID09PSAnJztcbn07XG5jb25zdCBjYWxsTm9kZVJlZnMgPSAodk5vZGUpID0+IHtcbiAgICBpZiAoQlVJTEQudmRvbVJlZikge1xuICAgICAgICB2Tm9kZS4kYXR0cnMkICYmIHZOb2RlLiRhdHRycyQucmVmICYmIHZOb2RlLiRhdHRycyQucmVmKG51bGwpO1xuICAgICAgICB2Tm9kZS4kY2hpbGRyZW4kICYmIHZOb2RlLiRjaGlsZHJlbiQubWFwKGNhbGxOb2RlUmVmcyk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlclZkb20gPSAoaG9zdFJlZiwgcmVuZGVyRm5SZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgaG9zdEVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3Qgb2xkVk5vZGUgPSBob3N0UmVmLiR2bm9kZSQgfHwgbmV3Vk5vZGUobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgcm9vdFZub2RlID0gaXNIb3N0KHJlbmRlckZuUmVzdWx0cykgPyByZW5kZXJGblJlc3VsdHMgOiBoKG51bGwsIG51bGwsIHJlbmRlckZuUmVzdWx0cyk7XG4gICAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gICAgLy8gPEhvc3Q+IHJ1bnRpbWUgY2hlY2tcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgQXJyYXkuaXNBcnJheShyZW5kZXJGblJlc3VsdHMpICYmIHJlbmRlckZuUmVzdWx0cy5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5tYXAoKFtwcm9wTmFtZSwgYXR0cmlidXRlXSkgPT4gKHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICByb290Vm5vZGUuJHRhZyQgPSBudWxsO1xuICAgIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogaXNIb3N0ICovO1xuICAgIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgICByb290Vm5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCA9IChCVUlMRC5zaGFkb3dEb20gPyBob3N0RWxtLnNoYWRvd1Jvb3QgfHwgaG9zdEVsbSA6IGhvc3RFbG0pO1xuICAgIGlmIChCVUlMRC5zY29wZWQgfHwgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIHNjb3BlSWQgPSBob3N0RWxtWydzLXNjJ107XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBjb250ZW50UmVmID0gaG9zdEVsbVsncy1jciddO1xuICAgICAgICB1c2VOYXRpdmVTaGFkb3dEb20gPSBzdXBwb3J0c1NoYWRvdyAmJiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSAhPT0gMDtcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBzeW5jaHJvbm91cyBwYXRjaFxuICAgIHBhdGNoKG9sZFZOb2RlLCByb290Vm5vZGUpO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAvLyB3aGlsZSB3ZSdyZSBtb3Zpbmcgbm9kZXMgYXJvdW5kIGV4aXN0aW5nIG5vZGVzLCB0ZW1wb3JhcmlseSBkaXNhYmxlXG4gICAgICAgIC8vIHRoZSBkaXNjb25uZWN0Q2FsbGJhY2sgZnJvbSB3b3JraW5nXG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIGlmIChjaGVja1Nsb3RSZWxvY2F0ZSkge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgbGV0IHJlbG9jYXRlRGF0YTtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZWxvY2F0ZTtcbiAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZVJlZjtcbiAgICAgICAgICAgIGxldCBpbnNlcnRCZWZvcmVOb2RlO1xuICAgICAgICAgICAgbGV0IHJlZk5vZGU7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlbG9jYXRlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWxvY2F0ZURhdGEgPSByZWxvY2F0ZU5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlID0gcmVsb2NhdGVEYXRhLiRub2RlVG9SZWxvY2F0ZSQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIHJlZmVyZW5jZSBub2RlIG1hcmtpbmcgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgZm9yIGxhdGVyIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsTG9jYXRpb25EZWJ1Z05vZGUobm9kZVRvUmVsb2NhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgobm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZSksIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGluc2VydCBpdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9yZ0xvY2F0aW9uTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSAmJiByZWZOb2RlWydzLXNuJ10gPT09IG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlWydzLW5yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbnNlcnRCZWZvcmVOb2RlICYmIHBhcmVudE5vZGVSZWYgIT09IG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5uZXh0U2libGluZyAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgY2hlY2tlZCB0aGF0IGl0J3Mgd29ydGggd2hpbGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoYXQgdGhlIG5vZGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBuZXh0IHNpYmxpbmcgb3IgcGFyZW50IHJlbG9jYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1obiddICYmIG5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYSBjb21wb25lbnQgaW4gdGhlIGluZGV4Lmh0bWwgdGhhdCBkb2Vzbid0IGhhdmUgaXQncyBob3N0bmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ10ucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0IGJhY2sgdG8gdGhlIGRvbSBidXQgaW4gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZVJlZi5pbnNlcnRCZWZvcmUobm9kZVRvUmVsb2NhdGUsIGluc2VydEJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lc24ndCBoYXZlIGEgc2xvdCBob21lIHRvIGdvIHRvLCBzbyBsZXQncyBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZSBtb3Zpbmcgbm9kZXMgYXJvdW5kXG4gICAgICAgIC8vIGFsbG93IHRoZSBkaXNjb25uZWN0IGNhbGxiYWNrIHRvIHdvcmsgYWdhaW5cbiAgICAgICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICByZWxvY2F0ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgfVxufTtcbi8vIHNsb3QgY29tbWVudCBkZWJ1ZyBub2RlcyBvbmx5IGNyZWF0ZWQgd2l0aCB0aGUgYC0tZGVidWdgIGZsYWdcbi8vIG90aGVyd2lzZSB0aGVzZSBub2RlcyBhcmUgdGV4dCBub2RlcyB3L291dCBjb250ZW50XG5jb25zdCBzbG90UmVmZXJlbmNlRGVidWdOb2RlID0gKHNsb3RWTm9kZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYDxzbG90JHtzbG90Vk5vZGUuJG5hbWUkID8gJyBuYW1lPVwiJyArIHNsb3RWTm9kZS4kbmFtZSQgKyAnXCInIDogJyd9PiAoaG9zdD0ke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9KWApO1xuY29uc3Qgb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZSA9IChub2RlVG9SZWxvY2F0ZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYG9yZy1sb2NhdGlvbiBmb3IgYCArXG4gICAgKG5vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZVxuICAgICAgICA/IGA8JHtub2RlVG9SZWxvY2F0ZS5sb2NhbE5hbWV9PiAoaG9zdD0ke25vZGVUb1JlbG9jYXRlWydzLWhuJ119KWBcbiAgICAgICAgOiBgWyR7bm9kZVRvUmVsb2NhdGUudGV4dENvbnRlbnR9XWApKTtcbmNvbnN0IGdldEVsZW1lbnQgPSAocmVmKSA9PiAoQlVJTEQubGF6eUxvYWQgPyBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA6IHJlZik7XG5jb25zdCBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gICAgY29uc3QgZWxtID0gZ2V0RWxlbWVudChyZWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtaXQ6IChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcIiR7bmFtZX1cIiBldmVudCB3YXMgZW1pdHRlZCwgYnV0IHRoZSBkaXNwYXRjaGVyIG5vZGUgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byB0aGUgZG9tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRFdmVudChlbG0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogISEoZmxhZ3MgJiAxIC8qIENhbmNlbGxhYmxlICovKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSAmIGRpc3BhdGNoIGEgY3VzdG9tIEV2ZW50IG9uIGEgcHJvdmlkZWQgdGFyZ2V0XG4gKiBAcGFyYW0gZWxtIHRoZSB0YXJnZXQgb2YgdGhlIEV2ZW50XG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBnaXZlIHRoZSBjdXN0b20gRXZlbnRcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGEgY3VzdG9tIEV2ZW50XG4gKiBAcmV0dXJucyB0aGUgY3VzdG9tIEV2ZW50XG4gKi9cbmNvbnN0IGVtaXRFdmVudCA9IChlbG0sIG5hbWUsIG9wdHMpID0+IHtcbiAgICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gICAgcmV0dXJuIGV2O1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10ucHVzaChuZXcgUHJvbWlzZSgocikgPT4gKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSkpO1xuICAgIH1cbn07XG5jb25zdCBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgaWYgKEJVSUxELnRhc2tRdWV1ZSAmJiBCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGhvc3RSZWYuJGZsYWdzJCAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiBCVUlMRC50YXNrUXVldWUgPyB3cml0ZVRhc2soZGlzcGF0Y2gpIDogZGlzcGF0Y2goKTtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kU2NoZWR1bGUgPSBjcmVhdGVUaW1lKCdzY2hlZHVsZVVwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsTG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFJlbmRlcicpO1xuICAgIGlmIChCVUlMRC5jbXBXaWxsUmVuZGVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjb25uZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgc2VydmVyU2lkZUNvbm5lY3RlZChlbG0pO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBvbmx5IGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICdjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICAgICAgLy8gb2ssIHNvIHR1cm5zIG91dCB0aGVyZSBhcmUgc29tZSBjaGlsZCBob3N0IGVsZW1lbnRzXG4gICAgICAgIC8vIHdhaXRpbmcgb24gdGhpcyBwYXJlbnQgZWxlbWVudCB0byBsb2FkXG4gICAgICAgIC8vIGxldCdzIGZpcmUgb2ZmIGFsbCB1cGRhdGUgY2FsbGJhY2tzIHdhaXRpbmdcbiAgICAgICAgcmMubWFwKChjYikgPT4gY2IoKSk7XG4gICAgICAgIGVsbVsncy1yYyddID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRSZW5kZXIoKTtcbiAgICBlbmRVcGRhdGUoKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUHJvbWlzZXMgPSBlbG1bJ3MtcCddO1xuICAgICAgICBjb25zdCBwb3N0VXBkYXRlID0gKCkgPT4gcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwb3N0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChjaGlsZHJlblByb21pc2VzKS50aGVuKHBvc3RVcGRhdGUpO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICAgICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIC8vIGluIG9yZGVyIGZvciBidW5kbGVycyB0byBjb3JyZWN0bHkgdHJlZXNoYWtlIHRoZSBCVUlMRCBvYmplY3RcbiAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSBCVUlMRCBpcyBub3QgZGVvcHRpbWl6ZWQgd2l0aGluIGEgdHJ5L2NhdGNoXG4gICAgLy8gaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI3RyZWVzaGFrZSB0cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgY29uc3QgYWxsUmVuZGVyRm4gPSBCVUlMRC5hbGxSZW5kZXJGbiA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBsYXp5TG9hZCA9IEJVSUxELmxhenlMb2FkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHRhc2tRdWV1ZSA9IEJVSUxELnRhc2tRdWV1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB1cGRhdGFibGUgPSBCVUlMRC51cGRhdGFibGUgPyB0cnVlIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyaW5nUmVmID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKHVwZGF0YWJsZSAmJiB0YXNrUXVldWUpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0YWJsZSB8fCBsYXp5TG9hZCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogaGFzUmVuZGVyZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmhhc1JlbmRlckZuIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tUmVuZGVyIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBjaGlsZCBub2RlcyB0byByZW5kZXIgaW50byB0aGlzIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjc3MgY2xhc3MvYXR0cnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSkudGhlbigodmFsdWUpID0+IHJlbmRlclZkb20oaG9zdFJlZiwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICAgIH1cbiAgICByZW5kZXJpbmdSZWYgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgaWYgKEJVSUxELmNtcERpZFJlbmRlcikge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQoZWxtKTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gZmlyZSBvZmYgdGhlIHVzZXIncyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIChpZiBvbmUgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgLy8gY29tcG9uZW50RGlkVXBkYXRlIHJ1bnMgQUZURVIgcmVuZGVyKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxtWydzLWhtci1sb2FkJ10gJiYgZWxtWydzLWhtci1sb2FkJ10oKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELm1ldGhvZCAmJiBCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+KDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIFwidHJ1ZVwiIHdoZW4gdGhlIGZvcmNlZCB1cGRhdGUgd2FzIHN1Y2Nlc3NmdWxseSBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwRGlkTG9hZCA9ICh3aG8pID0+IHtcbiAgICAvLyBvbiBhcHBsb2FkXG4gICAgLy8gd2UgaGF2ZSBmaW5pc2ggdGhlIGZpcnN0IGJpZyBpbml0aWFsIHJlbmRlclxuICAgIGlmIChCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICBhZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBuZXh0VGljaygoKSA9PiBlbWl0RXZlbnQod2luLCAnYXBwbG9hZCcsIHsgZGV0YWlsOiB7IG5hbWVzcGFjZTogTkFNRVNQQUNFIH0gfSkpO1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1lYXN1cmUpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7TkFNRVNQQUNFfSBpbml0aWFsIGxvYWQgKGJ5ICR7d2hvfSlgLCAnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxufTtcbmNvbnN0IHNhZmVDYWxsID0gKGluc3RhbmNlLCBtZXRob2QsIGFyZykgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2RdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCB0aGVuID0gKHByb21pc2UsIHRoZW5GbikgPT4ge1xuICAgIHJldHVybiBwcm9taXNlICYmIHByb21pc2UudGhlbiA/IHByb21pc2UudGhlbih0aGVuRm4pIDogdGhlbkZuKCk7XG59O1xuY29uc3QgZW1pdExpZmVjeWNsZUV2ZW50ID0gKGVsbSwgbGlmZWN5Y2xlTmFtZSkgPT4ge1xuICAgIGlmIChCVUlMRC5saWZlY3ljbGVET01FdmVudHMpIHtcbiAgICAgICAgZW1pdEV2ZW50KGVsbSwgJ3N0ZW5jaWxfJyArIGxpZmVjeWNsZU5hbWUsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogTkFNRVNQQUNFLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGFkZEh5ZHJhdGVkRmxhZyA9IChlbG0pID0+IEJVSUxELmh5ZHJhdGVkQ2xhc3NcbiAgICA/IGVsbS5jbGFzc0xpc3QuYWRkKCdoeWRyYXRlZCcpXG4gICAgOiBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZVxuICAgICAgICA/IGVsbS5zZXRBdHRyaWJ1dGUoJ2h5ZHJhdGVkJywgJycpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuY29uc3Qgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZEVsbS5jb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBlbmRIeWRyYXRlID0gY3JlYXRlVGltZSgnaHlkcmF0ZUNsaWVudCcsIHRhZ05hbWUpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBob3N0RWxtLnNoYWRvd1Jvb3Q7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3ROb2RlcyA9IEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290ID8gW10gOiBudWxsO1xuICAgIGNvbnN0IHZub2RlID0gKGhvc3RSZWYuJHZub2RlJCA9IG5ld1ZOb2RlKHRhZ05hbWUsIG51bGwpKTtcbiAgICBpZiAoIXBsdC4kb3JnTG9jTm9kZXMkKSB7XG4gICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZG9jLmJvZHksIChwbHQuJG9yZ0xvY05vZGVzJCA9IG5ldyBNYXAoKSkpO1xuICAgIH1cbiAgICBob3N0RWxtW0hZRFJBVEVfSURdID0gaG9zdElkO1xuICAgIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgIGNsaWVudEh5ZHJhdGUodm5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBob3N0RWxtLCBob3N0SWQpO1xuICAgIGNoaWxkUmVuZGVyTm9kZXMubWFwKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uSWQgPSBjLiRob3N0SWQkICsgJy4nICsgYy4kbm9kZUlkJDtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlID0gcGx0LiRvcmdMb2NOb2RlcyQuZ2V0KG9yZ0xvY2F0aW9uSWQpO1xuICAgICAgICBjb25zdCBub2RlID0gYy4kZWxtJDtcbiAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvcmdMb2NhdGlvbk5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbm9kZVsncy1obiddID0gdGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddWydzLW5yJ10gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShvcmdMb2NhdGlvbklkKTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2hhZG93Um9vdE5vZGVzLm1hcCgoc2hhZG93Um9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2hhZG93Um9vdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kSHlkcmF0ZSgpO1xufTtcbmNvbnN0IGNsaWVudEh5ZHJhdGUgPSAocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLCBob3N0SWQpID0+IHtcbiAgICBsZXQgY2hpbGROb2RlVHlwZTtcbiAgICBsZXQgY2hpbGRJZFNwbHQ7XG4gICAgbGV0IGNoaWxkVk5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGROb2RlVHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO1xuICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSkge1xuICAgICAgICAgICAgLy8gZ290IHRoZSBub2RlIGRhdGEgZnJvbSB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgICAgICBjaGlsZElkU3BsdCA9IGNoaWxkTm9kZVR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzBdID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICRub2RlSWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICAgICAkdGFnJDogbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAkYXR0cnMkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJG5hbWUkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldyBjaGlsZCB2bm9kZVxuICAgICAgICAgICAgICAgIC8vIHNvIGVuc3VyZSBpdHMgcGFyZW50IHZub2RlIGhhcyB0aGUgdmNoaWxkcmVuIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIG91ciBjaGlsZCB2bm9kZSB0byBhIHNwZWNpZmljIGluZGV4IG9mIHRoZSB2bm9kZSdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdyB0aGUgbmV3IHBhcmVudCB2bm9kZSBmb3IgYWxsIHRoZSBuZXh0IGNoaWxkIGNoZWNrc1xuICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZHJpbGwgZG93biwgZW5kIHRvIHN0YXJ0IHNvIHdlIGNhbiByZW1vdmUgbm9kZXNcbiAgICAgICAgZm9yIChpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5jaGlsZE5vZGVzW2ldLCBob3N0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgZHJpbGxpbmcgZG93biB0aHJvdWdoIHRoZSBzaGFkb3cgcm9vdCBub2Rlc1xuICAgICAgICAgICAgZm9yIChpID0gbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICAvLyBgJHtDT01NRU5UX1RZUEV9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzFdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMV0gPT09ICcwJykge1xuICAgICAgICAgICAgLy8gY29tbWVudCBub2RlIGZvciBlaXRoZXIgdGhlIGhvc3QgaWQgb3IgYSAwIGhvc3QgaWRcbiAgICAgICAgICAgIGNoaWxkTm9kZVR5cGUgPSBjaGlsZElkU3BsdFswXTtcbiAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzRdLFxuICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRhZyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBURVhUX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRleHQkID0gY2hpbGRWTm9kZS4kZWxtJC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZW5kZXJOb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRleHQgY29tbWVudCBzaW5jZSBpdCdzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlcyAmJiBjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRWTm9kZS4kaG9zdElkJCA9PT0gaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21tZW50IG5vZGUgaXMgc3BlY2lmY2FsbHkgZm9yIHRoaXMgaG9zdCBpZFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBTTE9UX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7U0xPVF9OT0RFX0lEfS4ke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGFnJCA9ICdzbG90JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSBjaGlsZFZOb2RlLiRuYW1lJCA9IGNoaWxkSWRTcGx0WzVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgc3VwcG9ydCBzaGFkb3dSb290IGFuZCB0aGlzIGlzIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhY3R1YWwgc2xvdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZUVsZW1lbnQoY2hpbGRWTm9kZS4kdGFnJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kbmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsb3QgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kLnNldEF0dHJpYnV0ZSgnbmFtZScsIGNoaWxkVk5vZGUuJG5hbWUkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbmV3IHNsb3QgZWxlbWVudCBiZWZvcmUgdGhlIHNsb3QgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZFZOb2RlLiRlbG0kLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2xvdCBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZE5vZGVUeXBlID09PSBDT05URU5UX1JFRl9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtDT05URU5UX1JFRl9JRH0uJHtob3N0SWR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudCByZWYgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsbVsncy1jciddID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3MtY24nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Vk5vZGUgJiYgcGFyZW50Vk5vZGUuJHRhZyQgPT09ICdzdHlsZScpIHtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShudWxsLCBub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgdm5vZGUuJGVsbSQgPSBub2RlO1xuICAgICAgICB2bm9kZS4kaW5kZXgkID0gJzAnO1xuICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW3Zub2RlXTtcbiAgICB9XG59O1xuY29uc3QgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZSA9IChub2RlLCBvcmdMb2NOb2RlcykgPT4ge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgb3JnTG9jTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IE9SR19MT0NBVElPTl9JRCkge1xuICAgICAgICAgICAgb3JnTG9jTm9kZXMuc2V0KGNoaWxkSWRTcGx0WzFdICsgJy4nICsgY2hpbGRJZFNwbHRbMl0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBrbm93IGlmIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBpc1xuICAgICAgICAgICAgLy8gdGhlIHJvb3QgbGlnaHQtZG9tIG9mIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgIG5vZGVbJ3MtZW4nXSA9IGNoaWxkSWRTcGx0WzNdO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUGFyc2UgYSBuZXcgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gcHJvcGVydHkgdHlwZS5cbiAqXG4gKiBXaGlsZSB0aGUgcHJvcCB2YWx1ZSBjYW4gcmVhc29uYWJseSBiZSBleHBlY3RlZCB0byBiZSBvZiBgYW55YCB0eXBlIGFzIGZhciBhcyBUeXBlU2NyaXB0J3MgdHlwZSBjaGVja2VyIGlzIGNvbmNlcm5lZCxcbiAqIGl0IGlzIG5vdCBzYWZlIHRvIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgZXZhbHVhdGluZyBgdHlwZW9mIHByb3BWYWx1ZWAgbWF0Y2hlczpcbiAqICAgMS4gYGFueWAsIHRoZSB0eXBlIGdpdmVuIHRvIGBwcm9wVmFsdWVgIGluIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAqICAgMi4gdGhlIHR5cGUgc3RvcmVkIGZyb20gYHByb3BUeXBlYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIHRoZSBjYXBhYmlsaXR5IHRvIHBhcnNlL2NvZXJjZSBhIHByb3BlcnR5J3MgdmFsdWUgdG8gcG90ZW50aWFsbHkgYW55IG90aGVyIEphdmFTY3JpcHQgdHlwZS5cbiAqXG4gKiBQcm9wZXJ0eSB2YWx1ZXMgcmVwcmVzZW50ZWQgaW4gVFNYIHByZXNlcnZlIHRoZWlyIHR5cGUgaW5mb3JtYXRpb24uIEluIHRoZSBleGFtcGxlIGJlbG93LCB0aGUgbnVtYmVyIDAgaXMgcGFzc2VkIHRvXG4gKiBhIGNvbXBvbmVudC4gVGhpcyBgcHJvcFZhbHVlYCB3aWxsIHByZXNlcnZlIGl0cyB0eXBlIGluZm9ybWF0aW9uIChgdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ251bWJlcidgKS4gTm90ZSB0aGF0IGlzXG4gKiBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGluLCBub3QgdGhlIHR5cGUgZGVjbGFyZWQgb2YgdGhlIGNsYXNzIG1lbWJlciBkZWNvcmF0ZWQgd2l0aCBgQFByb3BgLlxuICogYGBgdHN4XG4gKiA8bXktY21wIHByb3AtdmFsPXswfT48L215LWNtcD5cbiAqIGBgYFxuICpcbiAqIEhUTUwgcHJvcCB2YWx1ZXMgb24gdGhlIG90aGVyIGhhbmQsIHdpbGwgYWx3YXlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHByb3BWYWx1ZSB0aGUgbmV3IHZhbHVlIHRvIGNvZXJjZSB0byBzb21lIHR5cGVcbiAqIEBwYXJhbSBwcm9wVHlwZSB0aGUgdHlwZSBvZiB0aGUgcHJvcCwgZXhwcmVzc2VkIGFzIGEgYmluYXJ5IG51bWJlclxuICogQHJldHVybnMgdGhlIHBhcnNlZC9jb2VyY2VkIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlUHJvcGVydHlWYWx1ZSA9IChwcm9wVmFsdWUsIHByb3BUeXBlKSA9PiB7XG4gICAgLy8gZW5zdXJlIHRoaXMgdmFsdWUgaXMgb2YgdGhlIGNvcnJlY3QgcHJvcCB0eXBlXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgaWYgKEJVSUxELnByb3BCb29sZWFuICYmIHByb3BUeXBlICYgNCAvKiBCb29sZWFuICovKSB7XG4gICAgICAgICAgICAvLyBwZXIgdGhlIEhUTUwgc3BlYywgYW55IHN0cmluZyB2YWx1ZSBtZWFucyBpdCBpcyBhIGJvb2xlYW4gdHJ1ZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnV0IHdlJ2xsIGNoZWF0IGhlcmUgYW5kIHNheSB0aGF0IHRoZSBzdHJpbmcgXCJmYWxzZVwiIGlzIHRoZSBib29sZWFuIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiBwcm9wVmFsdWUgPT09ICcnIHx8ICEhcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wTnVtYmVyICYmIHByb3BUeXBlICYgMiAvKiBOdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBTdHJpbmcgKi8pIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBwYXNzZWQgYXMgYSBudW1iZXIgb3IgYm9vbGVhblxuICAgICAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgaXQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1bmRhbnQgcmV0dXJuIGhlcmUgZm9yIGJldHRlciBtaW5pZmljYXRpb25cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgLy8gbm90IHN1cmUgZXhhY3RseSB3aGF0IHR5cGUgd2Ugd2FudFxuICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hhbmdlIHRvIGEgZGlmZmVyZW50IHR5cGVcbiAgICByZXR1cm4gcHJvcFZhbHVlO1xufTtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGhvc3RFbGVtZW50JCA6IHJlZjtcbiAgICBjb25zdCBvbGRWYWwgPSBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICAgIC8vIGV4cGxpY2l0bHkgY2hlY2sgZm9yIE5hTiBvbiBib3RoIHNpZGVzLCBhcyBgTmFOID09PSBOYU5gIGlzIGFsd2F5cyBmYWxzZVxuICAgIGNvbnN0IGFyZUJvdGhOYU4gPSBOdW1iZXIuaXNOYU4ob2xkVmFsKSAmJiBOdW1iZXIuaXNOYU4obmV3VmFsKTtcbiAgICBjb25zdCBkaWRWYWx1ZUNoYW5nZSA9IG5ld1ZhbCAhPT0gb2xkVmFsICYmICFhcmVCb3RoTmFOO1xuICAgIGlmICgoIUJVSUxELmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pIHx8IG9sZFZhbCA9PT0gdW5kZWZpbmVkKSAmJiBkaWRWYWx1ZUNoYW5nZSkge1xuICAgICAgICAvLyBnYWR6b29rcyEgdGhlIHByb3BlcnR5J3MgdmFsdWUgaGFzIGNoYW5nZWQhIVxuICAgICAgICAvLyBzZXQgb3VyIG5ldyB2YWx1ZSFcbiAgICAgICAgaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLnNldChwcm9wTmFtZSwgbmV3VmFsKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMTAyNCAvKiBkZXZPblJlbmRlciAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgcmVuZGVyaW5nLiBUaGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIGluZmluaXRlLWxvb3BzIGFuZCBvdGhlciBidWdzLmAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDIwNDggLyogZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyBcImNvbXBvbmVudERpZExvYWQoKVwiLCB0aGlzIHRyaWdnZXJzIGV4dHJhIHJlLXJlbmRlcnMsIHRyeSB0byBzZXR1cCBvbiBcImNvbXBvbmVudFdpbGxMb2FkKClcImAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJVSUxELmxhenlMb2FkIHx8IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbWV0aG9kIG5hbWVzIG9mIHdhdGNoIGZ1bmN0aW9ucyB0byBjYWxsXG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hNZXRob2RzID0gY21wTWV0YS4kd2F0Y2hlcnMkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaW5zdGFuY2UgaXMgd2F0Y2hpbmcgZm9yIHdoZW4gdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTWV0aG9kcy5tYXAoKHdhdGNoTWV0aG9kTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIG9mZiBlYWNoIG9mIHRoZSB3YXRjaCBtZXRob2RzIHRoYXQgYXJlIHdhdGNoaW5nIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIG9sZFZhbCwgcHJvcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhpcyB2YWx1ZSBhY3R1YWxseSBjaGFuZ2VkLCBzbyB3ZSd2ZSBnb3Qgd29yayB0byBkbyFcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkLCBvdGhlcndpc2UganVzdCBjaGlsbCBvdXRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGF0IHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlLCBidXQgZG9uJ3Qgd29ycnkgYWJvdXQgcXVldWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwIG1pbGxpb25zIGN1eiB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgaXQgb25seSBydW5zIG9uY2VcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoQlVJTEQucHJvcCB8fCBCVUlMRC5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovIHx8XG4gICAgICAgICAgICAgICAgICAgICgoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIHByb3BcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBnZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGR1cmluZyBkZXYgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmLiRmbGFncyQgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgYSBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8pICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgbm90IG11dGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMTAyNCAvKiBNdXRhYmxlICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgQFByb3AoKSBcIiR7bWVtYmVyTmFtZX1cIiBvbiA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IGlzIGltbXV0YWJsZSBidXQgd2FzIG1vZGlmaWVkIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQuXFxuTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvcHJvcGVydGllcyNwcm9wLW11dGFiaWxpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmxhenlMb2FkICYmXG4gICAgICAgICAgICAgICAgQlVJTEQubWV0aG9kICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyRmxhZ3MgJiA2NCAvKiBNZXRob2QgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIG1ldGhvZFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYuJG9uSW5zdGFuY2VQcm9taXNlJC50aGVuKCgpID0+IHJlZi4kbGF6eUluc3RhbmNlJFttZW1iZXJOYW1lXSguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQlVJTEQub2JzZXJ2ZUF0dHJpYnV0ZSAmJiAoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluIGEgd2ViIGNvbXBvbmVudCBsaWZlY3ljbGUgdGhlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBydW5zIHByaW9yIHRvIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgY2FzZSB3aGVyZSBhbiBhdHRyaWJ1dGUgd2FzIHNldCBpbmxpbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBzZXRzIHRoZSBhdHRyaWJ1dGUgaW5saW5lIG9uIGEgY3VzdG9tIGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyBpdCBiZWZvcmUgaXQgaGFzIGJlZW4gdXBncmFkZWQgYXMgc2hvd24gYmVsb3c6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwhLS0gdGhpcyBjb21wb25lbnQgaGFzIF9ub3RfIGJlZW4gdXBncmFkZWQgeWV0IC0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8bXktY29tcG9uZW50IGlkPVwidGVzdFwiIHNvbWUtYXR0cmlidXRlPVwic29tZS12YWx1ZVwiPjwvbXktY29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIGdyYWIgbm9uLXVwZ3JhZGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAvLyB1cGdyYWRlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlIGlmIHdlIGRvIG5vdCB1bnNoYWRvdyBoZXJlIGFuZCB1c2UgdGhlIHZhbHVlIG9mIHRoZSBzaGFkb3dpbmcgcHJvcGVydHksIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyAgd2lsbCBiZSBjYWxsZWQgd2l0aCBgbmV3VmFsdWUgPSBcInNvbWUtdmFsdWVcImAgYW5kIHdpbGwgc2V0IHRoZSBzaGFkb3dlZCBwcm9wZXJ0eSAodGhpcy5zb21lQXR0cmlidXRlID0gXCJhbm90aGVyLXZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vICB0byB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IGlubGluZSBpLmUuIFwic29tZS12YWx1ZVwiIGZyb20gYWJvdmUgZXhhbXBsZS4gV2hlblxuICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGNvbm5lY3RlZENhbGxiYWNrIGF0dGVtcHRzIHRvIHVuc2hhZG93IGl0IHdpbGwgdXNlIFwic29tZS12YWx1ZVwiIGFzIHRoZSBpbml0aWFsIHZhbHVlIHJhdGhlciB0aGFuIFwiYW5vdGhlci12YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIHdhcyBOT1Qgc2V0IGlubGluZSBidXQgd2FzIG5vdCBzZXQgcHJvZ3JhbW1hdGljYWxseSBzaGFsbCBiZSBoYW5kbGVkL3Vuc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJ5IGNvbm5lY3RlZENhbGxiYWNrIGFzIHRoaXMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVE9ETyhTVEVOQ0lMLTE2KSB3ZSBzaG91bGQgdGhpbmsgYWJvdXQgd2hldGhlciBvciBub3Qgd2UgYWN0dWFsbHkgd2FudCB0byBiZSByZWZsZWN0aW5nIHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9wZXJ0aWVzIGhlcmUgZ2l2ZW4gdGhhdCB0aGlzIGdvZXMgYWdhaW5zdCBiZXN0IHByYWN0aWNlcyBvdXRsaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2F2b2lkLXJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcE5hbWUgZXhpc3RzIG9uIHRoZSBwcm90b3R5cGUgb2YgYENzdHJgLCB0aGlzIHVwZGF0ZSBtYXkgYmUgYSByZXN1bHQgb2YgU3RlbmNpbCB1c2luZyBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFQSXMgdG8gcmVmbGVjdCBwcm9wcyBhcyBhdHRyaWJ1dGVzLiBDYWxscyB0byBgc2V0QXR0cmlidXRlKHNvbWVFbGVtZW50LCBwcm9wTmFtZSlgIHdpbGwgcmVzdWx0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvcE5hbWVgIHRvIGJlIGNvbnZlcnRlZCB0byBhIGBET01TdHJpbmdgLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgd2Ugd2FudCBmb3Igb3RoZXIgcHJpbWl0aXZlIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBSZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5zdHlsZSkgJiZcbiAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChDc3RyLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBBd2FpdCBjcmVhdGVzIGEgbWljcm8tdGFzayBhdm9pZCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExvYWQgPSB1bmlxdWVUaW1lKGBzdDpsb2FkOiR7Y21wTWV0YS4kdGFnTmFtZSR9OiR7aG9zdFJlZi4kbW9kZU5hbWUkfWAsIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gKTtcbiAgICAgICAgICAgICAgICBDc3RyID0gYXdhaXQgQ3N0cjtcbiAgICAgICAgICAgICAgICBlbmRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKEJVSUxELmlzRGV2IHx8IEJVSUxELmlzRGVidWcpICYmICFDc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyICYmICFDc3RyLmlzUHJveGllZCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIG5ldmVyIHByb3hpZWQgdGhpcyBDb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBhZGQgdGhlIGdldHRlcnMvc2V0dGVycyB0byBpdHMgcHJvdG90eXBlIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHdlIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAyIC8qIHByb3h5U3RhdGUgKi8pO1xuICAgICAgICAgICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZSgnY3JlYXRlSW5zdGFuY2UnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAvLyBvaywgdGltZSB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCB0cmFjayBvZiB3aGVuIHdlIHN0YXJ0IGFuZCBzdG9wXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBnZXR0ZXJzL3NldHRlcnMgZG9uJ3QgaW5jb3JyZWN0bHkgc3RlcCBvbiBkYXRhXG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgbGF6eS1sb2FkZWQgY29tcG9uZW50IGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBwYXNzaW5nIHRoZSBob3N0UmVmIGlzIHZlcnkgaW1wb3J0YW50IGR1cmluZ1xuICAgICAgICAgICAgLy8gY29uc3RydWN0aW9uIGluIG9yZGVyIHRvIGRpcmVjdGx5IHdpcmUgdG9nZXRoZXIgdGhlXG4gICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgYW5kIHRoZSBsYXp5LWxvYWRlZCBpbnN0YW5jZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgQ3N0cihob3N0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzeW5jIGNvbnN0cnVjdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgQ3N0ciA9IGVsbS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBDdXN0b21FbGVtZW50UmVnaXN0cnkgdG8gbWFyayB0aGUgY29tcG9uZW50IGFzIHJlYWR5IGJlZm9yZSBzZXR0aW5nIGBpc1dhdGNoUmVhZHlgLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB3YXRjaGVycyBtYXkgZmlyZSBwcmVtYXR1cmVseSBpZiBgY3VzdG9tRWxlbWVudHMuZ2V0KClgL2BjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCgpYCByZXNvbHZlcyBfYmVmb3JlX1xuICAgICAgICAgICAgLy8gU3RlbmNpbCBoYXMgY29tcGxldGVkIGluc3RhbnRpYXRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKGNtcE1ldGEuJHRhZ05hbWUkKS50aGVuKCgpID0+IChob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbSAmJlxuICAgICAgICAgICAgICAgICAgICBCVUlMRC5zaGFkb3dEb21TaGltICYmXG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KCcuL3NoYWRvdy1jc3MuanMnKS50aGVuKChtKSA9PiBtLnNjb3BlQ3NzKHN0eWxlLCBzY29wZUlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICBlbmRSZWdpc3RlclN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgbGF6eSBpbnN0YW5jZVxuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBhbmNlc3RvckNvbXBvbmVudCAmJiBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgbG9hZCBhbmQgdGhpcyBjb21wb25lbnQgaXQgaGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBidXQgdGhlIGFuY2VzdG9yIGNvbXBvbmVudCBoYXMgTk9UIGZpcmVkIGl0cyB3aWxsIHVwZGF0ZSBsaWZlY3ljbGUgeWV0XG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3QgY29vbCBvdXIgamV0cyBhbmQgd2FpdCBmb3IgdGhlIGFuY2VzdG9yIHRvIGNvbnRpbnVlIGZpcnN0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBnZXQgZmlyZWQgb2ZmIHdoZW4gdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBmaW5hbGx5IGdldHMgYXJvdW5kIHRvIHJlbmRlcmluZyBpdHMgbGF6eSBzZWxmXG4gICAgICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddLnB1c2goc2NoZWR1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuY29uc3QgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcnVuIGlmIHdlIGhhdmUgbGlzdGVuZXJzIGJlaW5nIGF0dGFjaGVkIHRvIGEgcGFyZW50XG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IEJVSUxELm1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhLCBlbG0uZ2V0QXR0cmlidXRlKCdzLW1vZGUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlSWQgKyAnLWgnLCBzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZWxtLCBjbXBNZXRhLiR0YWdOYW1lJCwgaG9zdElkLCBob3N0UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIWhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xvdCBwb2x5ZmlsbCBpcyByZXF1aXJlZCB3ZSdsbCBuZWVkIHRvIHB1dCBzb21lIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gaGVyZSB0byBhY3QgYXMgb3JpZ2luYWwgY29udGVudCBhbmNob3JzIGFzIHdlIG1vdmUgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICgoQlVJTEQuc2xvdCB8fCBCVUlMRC5zaGFkb3dEb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRmbGFncyQgJiAoNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLyB8IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBhbmNlc3RvciBjb21wb25lbnQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgYXMgb25lIG9mIHRoZSBhY3RpdmVseSBsb2FkaW5nIGNoaWxkIGNvbXBvbmVudHMgZm9yIGl0cyBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGltYiB1cCB0aGUgYW5jZXN0b3JzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgZmluaXNoZWQgaXRzIGxpZmVjeWNsZSB1cGRhdGUgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICgoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoJ3MtaWQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCB0aGlzIGNvbXBvbmVudHMgZmlyc3QgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgY29tcG9uZW50J3MgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIChob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQgPSBhbmNlc3RvckNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMYXp5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQucHJvcCAmJiAhQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCkubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLyAmJiBlbG0uaGFzT3duUHJvcGVydHkobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaW5pdGlhbGl6ZU5leHRUaWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGVkQ2FsbGJhY2ssIHRhc2tRdWV1ZSwgaW5pdGlhbExvYWRcbiAgICAgICAgICAgICAgICAvLyBhbmd1bGFyIHNldHMgYXR0cmlidXRlIEFGVEVSIGNvbm5lY3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE4OTA5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk5NDBcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IHRoZSBmaXJzdCB0aW1lIHRoaXMgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gcmVhdHRhY2ggYW55IGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaG9zdFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSB3b3VsZCBoYXZlIGJlZW4gcmVtb3ZlZCB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmlyZSBvZmYgY29ubmVjdGVkQ2FsbGJhY2soKSBvbiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRDb25uZWN0ZWQoKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29udGVudFJlZmVyZW5jZSA9IChlbG0pID0+IHtcbiAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAvLyBhbmQgdGhpcyBob3N0IGVsZW1lbnQgd2FzIE5PVCBjcmVhdGVkIHdpdGggU1NSXG4gICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNvbnRlbnQgd2FzIGZpcnN0IHBsYWNlZCwgd2hpY2ggaXMgdXNlZnVsIGxhdGVyIG9uXG4gICAgY29uc3QgY29udGVudFJlZkVsbSA9IChlbG1bJ3MtY3InXSA9IGRvYy5jcmVhdGVDb21tZW50KEJVSUxELmlzRGVidWcgPyBgY29udGVudC1yZWYgKGhvc3Q9JHtlbG0ubG9jYWxOYW1lfSlgIDogJycpKTtcbiAgICBjb250ZW50UmVmRWxtWydzLWNuJ10gPSB0cnVlO1xuICAgIGVsbS5pbnNlcnRCZWZvcmUoY29udGVudFJlZkVsbSwgZWxtLmZpcnN0Q2hpbGQpO1xufTtcbmNvbnN0IGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHJtTGlzdGVuZXJzJC5tYXAoKHJtTGlzdGVuZXIpID0+IHJtTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIENTUyB2YXItc2hpbSB0cmFja2luZ1xuICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICBwbHQuJGNzc1NoaW0kLnJlbW92ZUhvc3QoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVW5sb2FkKSB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVubG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSAoQ3N0ciwgY29tcGFjdE1ldGEpID0+IHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY29tcGFjdE1ldGFbMV0sIHByb3h5Q3VzdG9tRWxlbWVudChDc3RyLCBjb21wYWN0TWV0YSkpO1xufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci4kd2F0Y2hlcnMkO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgICAgIF9fcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHRoaXMsIGNtcE1ldGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmNvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRhY2hTaGFkb3coKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIENzdHIuaXMgPSBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xuY29uc3QgZm9yY2VNb2RlVXBkYXRlID0gKGVsbSkgPT4ge1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBCVUlMRC5tb2RlICYmICFCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBjb25zdCBtb2RlID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCAhPT0gbW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NvcGVJZCA9IGVsbVsncy1zYyddO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsbS5jb25zdHJ1Y3Rvci5zdHlsZVttb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGZsYWdzICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBobXJTdGFydCA9IChlbG0sIGNtcE1ldGEsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAvLyByZXNldCBzdGF0ZSBmbGFncyB0byBvbmx5IGhhdmUgYmVlbiBjb25uZWN0ZWRcbiAgICBob3N0UmVmLiRmbGFncyQgPSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAvLyBUT0RPXG4gICAgLy8gZGV0YXRjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IHBhc3NpbmcgYW4gZXhhY3QgZXZlbnQgbmFtZSBpdCdsbFxuICAgIC8vIHJlbW92ZSBhbGwgb2YgdGhpcyBlbGVtZW50J3MgZXZlbnQsIHdoaWNoIGlzIGdvb2RcbiAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGlzIGNvbXBvbmVudCBmaW5pc2hlcyBobXJcbiAgICBlbG1bJ3MtaG1yLWxvYWQnXSA9ICgpID0+IHtcbiAgICAgICAgLy8gZmluaXNoZWQgaG1yIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgZGVsZXRlIGVsbVsncy1obXItbG9hZCddO1xuICAgIH07XG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuY29uc3QgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBjb25zdCBvcmdDbG9uZU5vZGUgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGU7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzU2hhZG93RG9tID0gQlVJTEQuc2hhZG93RG9tID8gc3JjTm9kZS5zaGFkb3dSb290ICYmIHN1cHBvcnRzU2hhZG93IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgICAgIGlmIChCVUlMRC5zbG90ICYmICFpc1NoYWRvd0RvbSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgc2xvdHRlZCwgbm9uU3RlbmNpbE5vZGU7XG4gICAgICAgICAgICBsZXQgc3RlbmNpbFByaXZhdGVzID0gW1xuICAgICAgICAgICAgICAgICdzLWlkJyxcbiAgICAgICAgICAgICAgICAncy1jcicsXG4gICAgICAgICAgICAgICAgJ3MtbHInLFxuICAgICAgICAgICAgICAgICdzLXJjJyxcbiAgICAgICAgICAgICAgICAncy1zYycsXG4gICAgICAgICAgICAgICAgJ3MtcCcsXG4gICAgICAgICAgICAgICAgJ3MtY24nLFxuICAgICAgICAgICAgICAgICdzLXNyJyxcbiAgICAgICAgICAgICAgICAncy1zbicsXG4gICAgICAgICAgICAgICAgJ3MtaG4nLFxuICAgICAgICAgICAgICAgICdzLW9sJyxcbiAgICAgICAgICAgICAgICAncy1ucicsXG4gICAgICAgICAgICAgICAgJ3Mtc2knLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgIG5vblN0ZW5jaWxOb2RlID0gc3RlbmNpbFByaXZhdGVzLmV2ZXJ5KChwcml2YXRlRmllbGQpID0+ICFzcmNOb2RlLmNoaWxkTm9kZXNbaV1bcHJpdmF0ZUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCAmJiBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uU3RlbmNpbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaFNsb3RBcHBlbmRDaGlsZCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IChuZXdDaGlsZFsncy1zbiddID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpKTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEFmdGVyID0gc2xvdENoaWxkTm9kZXNbc2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIGFwcGVuZEFmdGVyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9O1xufTtcbi8qKlxuICogUGF0Y2hlcyB0aGUgdGV4dCBjb250ZW50IG9mIGFuIHVubmFtZWQgc2xvdHRlZCBub2RlIGluc2lkZSBhIHNjb3BlZCBjb21wb25lbnRcbiAqIEBwYXJhbSBob3N0RWxlbWVudFByb3RvdHlwZSB0aGUgYEVsZW1lbnRgIHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBjbXBNZXRhIGNvbXBvbmVudCBydW50aW1lIG1ldGFkYXRhIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHBhdGNoZWQgb3Igbm90XG4gKi9cbmNvbnN0IHBhdGNoVGV4dENvbnRlbnQgPSAoaG9zdEVsZW1lbnRQcm90b3R5cGUsIGNtcE1ldGEpID0+IHtcbiAgICBpZiAoQlVJTEQuc2NvcGVkICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50Jyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0RWxlbWVudFByb3RvdHlwZSwgJ19fdGV4dENvbnRlbnQnLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgJ2RlZmF1bHQgc2xvdCcsIHdoaWNoIHdvdWxkIGJlIHRoZSBmaXJzdCBzbG90IGluIGEgc2hhZG93IHRyZWUgKGlmIHdlIHdlcmUgdXNpbmcgb25lKSwgd2hvc2UgbmFtZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsICcnKTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc2xvdCBub2RlIGlzIGZvdW5kLCB0aGUgdGV4dENvbnRlbnQgX21heV8gYmUgZm91bmQgaW4gdGhlIG5leHQgc2libGluZyAodGV4dCkgbm9kZSwgZGVwZW5kaW5nIG9uIGhvd1xuICAgICAgICAgICAgICAgIC8vIG5vZGVzIHdlcmUgcmVvcmRlcmVkIGR1cmluZyB0aGUgdmRvbSByZW5kZXIuIGZpcnN0IHRyeSB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tIHRoZSBzaWJsaW5nLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT09IG51bGwgfHwgc2xvdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIFRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBuZWVkIHRvIGJlIHBsYWNlZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLFxuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiBob3cgbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIHNldCB0aGUgdGV4dCBjb250ZW50IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZG4ndCBmaW5kIGEgc2xvdCwgYnV0IHRoYXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlcmUgaXNuJ3Qgb25lLiBpZiB0aGlzIGNoZWNrIHJhbiBiZWZvcmUgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkZWQsIHdlIGNvdWxkIGhhdmUgbWlzc2VkIGl0LiBjaGVjayBmb3IgYSBjb250ZW50IHJlZmVyZW5jZSBlbGVtZW50IG9uIHRoZSBzY29wZWQgY29tcG9uZW50IGFuZCBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSB0aGlzWydzLWNyJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmRWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXygnY2hpbGROb2RlcycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZEVsZW1lbnRDb3VudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGROb2RlcycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0ZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEhvc3RSZWYodGhpcykuJGZsYWdzJCAmIDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGEgc2VyaWVzIG9mIGNoaWxkIG5vZGVzIGZvciBhIHNsb3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqIEBwYXJhbSBjaGlsZE5vZGVzIHRoZSBub2RlcyB0byBzZWFyY2ggZm9yIGEgc2xvdCB3aXRoIGEgc3BlY2lmaWMgbmFtZS5cbiAqIEBwYXJhbSBzbG90TmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdCB0byBtYXRjaCBvbi5cbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBuYW1lLCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGdldEhvc3RTbG90Tm9kZSA9IChjaGlsZE5vZGVzLCBzbG90TmFtZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGZvciAoOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgY2hpbGROb2RlWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZSA9IGdldEhvc3RTbG90Tm9kZShjaGlsZE5vZGUuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbbl07XG4gICAgd2hpbGUgKChuID0gbi5uZXh0U2libGluZykgJiYgblsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xufTtcbmNvbnN0IGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxuICAgIGluc3RhbGxEZXZUb29scygpO1xuICAgIGNvbnN0IGVuZEJvb3RzdHJhcCA9IGNyZWF0ZVRpbWUoJ2Jvb3RzdHJhcExhenknKTtcbiAgICBjb25zdCBjbXBUYWdzID0gW107XG4gICAgY29uc3QgZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSB8fCBbXTtcbiAgICBjb25zdCBjdXN0b21FbGVtZW50cyA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgICBjb25zdCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgY29uc3QgbWV0YUNoYXJzZXQgPSAvKkBfX1BVUkVfXyovIGhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtjaGFyc2V0XScpO1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdHlsZSA9IC8qQF9fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICBjb25zdCBzdHlsZXMgPSAvKkBfX1BVUkVfXyovIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBbJHtIWURSQVRFRF9TVFlMRV9JRH1dYCk7XG4gICAgbGV0IGFwcExvYWRGYWxsYmFjaztcbiAgICBsZXQgaXNCb290c3RyYXBwaW5nID0gdHJ1ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIG9wdGlvbnMpO1xuICAgIHBsdC4kcmVzb3VyY2VzVXJsJCA9IG5ldyBVUkwob3B0aW9ucy5yZXNvdXJjZXNVcmwgfHwgJy4vJywgZG9jLmJhc2VVUkkpLmhyZWY7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luY1F1ZXVlKSB7XG4gICAgICAgICAgICBwbHQuJGZsYWdzJCB8PSA0IC8qIHF1ZXVlU3luYyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGFwcCBpcyBhbHJlYWR5IGh5ZHJhdGVkIHRoZXJlIGlzIG5vdCBwb2ludCB0byBkaXNhYmxlIHRoZVxuICAgICAgICAvLyBhc3luYyBxdWV1ZS4gVGhpcyB3aWxsIGltcHJvdmUgdGhlIGZpcnN0IGlucHV0IGRlbGF5XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiYgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIGZvciAoOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWdpc3RlclN0eWxlKHN0eWxlc1tpXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLCBjb252ZXJ0U2NvcGVkVG9TaGFkb3coc3R5bGVzW2ldLmlubmVySFRNTCksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgICAgICBsYXp5QnVuZGxlWzFdLm1hcCgoY29tcGFjdE1ldGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICAgICAgICAgJHRhZ05hbWUkOiBjb21wYWN0TWV0YVsxXSxcbiAgICAgICAgICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAgICAgICAgICRsaXN0ZW5lcnMkOiBjb21wYWN0TWV0YVszXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgIXN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKVxuICAgICAgICAgICAgICAgIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgICAgICBjb25zdCBIb3N0RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGlzIHVzaW5nIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSByZWFkLW9ubHkgcHJvcGVydHkgXCJzaGFkb3dSb290XCIgdG8gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIHRoZSBzaGFkb3cgcm9vdCBidWlsZCBjb25kaXRpb25hbHMgdG8gbWluaW1pemUgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBzaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoJ3NoYWRvd1Jvb3QnIGluIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaGFkb3dSb290ID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdENoaWxkTm9kZXNGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChhcHBMb2FkRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayB3aWxsIGJlIHByb2Nlc3NlZCBvbmNlIGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnRPblJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQuY2xvbmVOb2RlRml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hDbG9uZU5vZGUoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFNsb3RBcHBlbmRDaGlsZChIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlWydzLWhtciddID0gZnVuY3Rpb24gKGhtclZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUZXh0Q29udGVudChIb3N0RWxlbWVudC5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21wTWV0YS4kbGF6eUJ1bmRsZUlkJCA9IGxhenlCdW5kbGVbMF07XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgcHJveHlDb21wb25lbnQoSG9zdEVsZW1lbnQsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELmludmlzaWJsZVByZWh5ZHJhdGlvbiAmJiAoQlVJTEQuaHlkcmF0ZWRDbGFzcyB8fCBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLmlubmVySFRNTCA9IGNtcFRhZ3MgKyBIWURSQVRFRF9DU1M7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJywgJycpO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZSh2aXNpYmlsaXR5U3R5bGUsIG1ldGFDaGFyc2V0ID8gbWV0YUNoYXJzZXQubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGRlZmVycmVkIGNvbm5lY3RlZENhbGxiYWNrcyBub3cgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICBpc0Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLm1hcCgoaG9zdCkgPT4gaG9zdC5jb25uZWN0ZWRDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9maWxlKSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwLCAndGltZW91dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGFwcExvYWQgZXZlbnRcbiAgICBlbmRCb290c3RyYXAoKTtcbn07XG5jb25zdCBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFzc2V0VXJsID0gbmV3IFVSTChwYXRoLCBwbHQuJHJlc291cmNlc1VybCQpO1xuICAgIHJldHVybiBhc3NldFVybC5vcmlnaW4gIT09IHdpbi5sb2NhdGlvbi5vcmlnaW4gPyBhc3NldFVybC5ocmVmIDogYXNzZXRVcmwucGF0aG5hbWU7XG59O1xuY29uc3Qgc2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IChwbHQuJHJlc291cmNlc1VybCQgPSBwYXRoKTtcbmNvbnN0IGdldENvbm5lY3QgPSAoX3JlZiwgdGFnTmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBlbG0gPSBkb2MucXVlcnlTZWxlY3Rvcih0YWdOYW1lKTtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICAgIGVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsbS5jb21wb25lbnRPblJlYWR5ID09PSAnZnVuY3Rpb24nID8gZWxtLmNvbXBvbmVudE9uUmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChlbCkgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2goKG9yZ0xvY2F0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZVJlZi5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlbGVzcyB3aGl0ZXNwYWNlIG5vZGUgYXQgdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBub2RlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlSWQgPSBgJHtPUkdfTE9DQVRJT05fSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5cIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTSEFET1cgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICdjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5jXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0NPUEVEIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5ub2RlVmFsdWUgPSBvcmdMb2NhdGlvbk5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGVbJ3MtbnInXSAhPSBudWxsKSB7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChob3N0UmVmICE9IG51bGwgJiYgIWRvY0RhdGEuc3RhdGljQ29tcG9uZW50cy5oYXMoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkczogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluc2VydFZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gICAgaWYgKHZub2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgICAgIGhvc3RFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfSUQsIGhvc3RJZCk7XG4gICAgICAgIGlmIChob3N0RWxtWydzLWNyJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEVsbVsncy1jciddLm5vZGVWYWx1ZSA9IGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoJ2MtaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaG9zdEVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbJ3Mtc3InXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgYCR7Y29tbWVudFsncy1ob3N0LWlkJ119LiR7Y29tbWVudFsncy1ub2RlLWlkJ119LjAuJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zID0gKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZEVsbSA9IHZub2RlQ2hpbGQuJGVsbSQ7XG4gICAgaWYgKGNoaWxkRWxtID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgICBjb25zdCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gO1xuICAgIGNoaWxkRWxtWydzLWhvc3QtaWQnXSA9IGhvc3RJZDtcbiAgICBjaGlsZEVsbVsncy1ub2RlLWlkJ10gPSBub2RlSWQ7XG4gICAgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChjaGlsZEVsbVsncy1zciddKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkRWxtWydzLXNuJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlQ2hpbGQuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIHZub2RlQ2hpbGQuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlLCBjbXBEYXRhLCBob3N0SWQsIGNoaWxkRGVwdGgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHNldFBsYXRmb3JtT3B0aW9ucyA9IChvcHRzKSA9PiBPYmplY3QuYXNzaWduKHBsdCwgb3B0cyk7XG5jb25zdCBGcmFnbWVudCA9IChfLCBjaGlsZHJlbikgPT4gY2hpbGRyZW47XG5jb25zdCBob3N0UmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlKSwgaG9zdFJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkID0gcikpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkID0gcikpO1xuICAgICAgICBlbG1bJ3MtcCddID0gW107XG4gICAgICAgIGVsbVsncy1yYyddID0gW107XG4gICAgfVxuICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICByZXR1cm4gaG9zdFJlZnMuc2V0KGVsbSwgaG9zdFJlZik7XG59O1xuY29uc3QgaXNNZW1iZXJJbkVsZW1lbnQgPSAoZWxtLCBtZW1iZXJOYW1lKSA9PiBtZW1iZXJOYW1lIGluIGVsbTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKGN1c3RvbUVycm9yIHx8IGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcbmNvbnN0IFNURU5DSUxfREVWX01PREUgPSBCVUlMRC5pc1Rlc3RpbmdcbiAgICA/IFsnU1RFTkNJTDonXSAvLyBFMkUgdGVzdGluZ1xuICAgIDogW1xuICAgICAgICAnJWNzdGVuY2lsJyxcbiAgICAgICAgJ2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweCcsXG4gICAgXTtcbmNvbnN0IGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldldhcm4gPSAoLi4ubSkgPT4gY29uc29sZS53YXJuKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldkluZm8gPSAoLi4ubSkgPT4gY29uc29sZS5pbmZvKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3Qgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IChjdXN0b21FcnJvciA9IGhhbmRsZXIpO1xuY29uc3QgY21wTW9kdWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3QgbG9hZE1vZHVsZSA9IChjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyBsb2FkTW9kdWxlSW1wb3J0XG4gICAgY29uc3QgZXhwb3J0TmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBidW5kbGVJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUcnlpbmcgdG8gbGF6aWx5IGxvYWQgY29tcG9uZW50IDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gd2l0aCBzdHlsZSBtb2RlIFwiJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDogZmFsc2U7XG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICAgICAgaWYgKCFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0ZWRNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfSwgY29uc29sZUVycm9yKTtcbn07XG5jb25zdCBzdHlsZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBtb2RlUmVzb2x1dGlvbkNoYWluID0gW107XG5jb25zdCBxdWV1ZURvbVJlYWRzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXNMb3cgPSBbXTtcbmNvbnN0IHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICAgIHF1ZXVlLnB1c2goY2IpO1xuICAgIGlmICghcXVldWVQZW5kaW5nKSB7XG4gICAgICAgIHF1ZXVlUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaV0ocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbn07XG5jb25zdCBjb25zdW1lVGltZW91dCA9IChxdWV1ZSwgdGltZW91dCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdHMgPSAwO1xuICAgIHdoaWxlIChpIDwgcXVldWUubGVuZ3RoICYmICh0cyA9IHBlcmZvcm1hbmNlLm5vdygpKSA8IHRpbWVvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2krK10odHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcXVldWVDb25nZXN0aW9uKys7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBmb3JjZSBhIGJ1bmNoIG9mIG1lZGl1bSBjYWxsYmFja3MgdG8gcnVuLCBidXQgc3RpbGwgaGF2ZVxuICAgIC8vIGEgdGhyb3R0bGUgb24gaG93IG1hbnkgY2FuIHJ1biBpbiBhIGNlcnRhaW4gdGltZVxuICAgIC8vIERPTSBSRUFEUyEhIVxuICAgIGNvbnN1bWUocXVldWVEb21SZWFkcyk7XG4gICAgLy8gRE9NIFdSSVRFUyEhIVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAocGx0LiRmbGFncyQgJiA2IC8qIHF1ZXVlTWFzayAqLykgPT09IDIgLyogYXBwTG9hZGVkICovXG4gICAgICAgICAgICA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTQgKiBNYXRoLmNlaWwocXVldWVDb25nZXN0aW9uICogKDEuMCAvIDEwLjApKVxuICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXMsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlc0xvdywgdGltZW91dCk7XG4gICAgICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlQ29uZ2VzdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN1bWUocXVldWVEb21Xcml0ZXMpO1xuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5leHRUaWNrID0gLypAX19QVVJFX18qLyAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG5jb25zdCByZWFkVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbmNvbnN0IHdyaXRlVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuZXhwb3J0IHsgQnVpbGQsIENTUywgQ29udGV4dCwgRnJhZ21lbnQsIEgsIEggYXMgSFRNTEVsZW1lbnQsIEhvc3QsIFNURU5DSUxfREVWX01PREUsIGFkZEhvc3RFdmVudExpc3RlbmVycywgYm9vdHN0cmFwTGF6eSwgY21wTW9kdWxlcywgY29ubmVjdGVkQ2FsbGJhY2ssIGNvbnNvbGVEZXZFcnJvciwgY29uc29sZURldkluZm8sIGNvbnNvbGVEZXZXYXJuLCBjb25zb2xlRXJyb3IsIGNyZWF0ZUV2ZW50LCBkZWZpbmVDdXN0b21FbGVtZW50LCBkaXNjb25uZWN0ZWRDYWxsYmFjaywgZG9jLCBmb3JjZU1vZGVVcGRhdGUsIGZvcmNlVXBkYXRlLCBnZXRBc3NldFBhdGgsIGdldENvbm5lY3QsIGdldENvbnRleHQsIGdldEVsZW1lbnQsIGdldEhvc3RSZWYsIGdldE1vZGUsIGdldFJlbmRlcmluZ1JlZiwgZ2V0VmFsdWUsIGgsIGluc2VydFZkb21Bbm5vdGF0aW9ucywgaXNNZW1iZXJJbkVsZW1lbnQsIGxvYWRNb2R1bGUsIG1vZGVSZXNvbHV0aW9uQ2hhaW4sIG5leHRUaWNrLCBwYXJzZVByb3BlcnR5VmFsdWUsIHBsdCwgcG9zdFVwZGF0ZUNvbXBvbmVudCwgcHJvbWlzZVJlc29sdmUsIHByb3h5Q29tcG9uZW50LCBwcm94eUN1c3RvbUVsZW1lbnQsIHJlYWRUYXNrLCByZWdpc3Rlckhvc3QsIHJlZ2lzdGVySW5zdGFuY2UsIHJlbmRlclZkb20sIHNldEFzc2V0UGF0aCwgc2V0RXJyb3JIYW5kbGVyLCBzZXRNb2RlLCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldFBsYXRmb3JtT3B0aW9ucywgc2V0VmFsdWUsIHN0eWxlcywgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMsIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zLCBzdXBwb3J0c1NoYWRvdywgd2luLCB3cml0ZVRhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7210\n")},655:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ZT": () => (/* binding */ __extends),\n/* harmony export */   "_T": () => (/* binding */ __rest),\n/* harmony export */   "mG": () => (/* binding */ __awaiter),\n/* harmony export */   "Jh": () => (/* binding */ __generator),\n/* harmony export */   "ev": () => (/* binding */ __spreadArray)\n/* harmony export */ });\n/* unused harmony exports __assign, __decorate, __param, __metadata, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///655\n')}}]);