"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[4255],{29895:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"xz\": () => (/* binding */ CapacitorException),\n/* harmony export */   \"Uw\": () => (/* binding */ WebPlugin),\n/* harmony export */   \"fo\": () => (/* binding */ registerPlugin)\n/* harmony export */ });\n/* unused harmony exports Capacitor, CapacitorPlatforms, ExceptionCode, Plugins, WebView, addPlatform, registerWebPlugin, setPlatform */\n/*! Capacitor: https://capacitorjs.com/ - MIT License */\nconst createCapacitorPlatforms = (win) => {\n    const defaultPlatformMap = new Map();\n    defaultPlatformMap.set('web', { name: 'web' });\n    const capPlatforms = win.CapacitorPlatforms || {\n        currentPlatform: { name: 'web' },\n        platforms: defaultPlatformMap,\n    };\n    const addPlatform = (name, platform) => {\n        capPlatforms.platforms.set(name, platform);\n    };\n    const setPlatform = (name) => {\n        if (capPlatforms.platforms.has(name)) {\n            capPlatforms.currentPlatform = capPlatforms.platforms.get(name);\n        }\n    };\n    capPlatforms.addPlatform = addPlatform;\n    capPlatforms.setPlatform = setPlatform;\n    return capPlatforms;\n};\nconst initPlatforms = (win) => (win.CapacitorPlatforms = createCapacitorPlatforms(win));\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst CapacitorPlatforms = /*#__PURE__*/ initPlatforms((typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof __webpack_require__.g !== 'undefined'\n                ? __webpack_require__.g\n                : {}));\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst addPlatform = CapacitorPlatforms.addPlatform;\n/**\n * @deprecated Set `CapacitorCustomPlatform` on the window object prior to runtime executing in the web app instead\n */\nconst setPlatform = CapacitorPlatforms.setPlatform;\n\nconst legacyRegisterWebPlugin = (cap, webPlugin) => {\n    var _a;\n    const config = webPlugin.config;\n    const Plugins = cap.Plugins;\n    if (!config || !config.name) {\n        // TODO: add link to upgrade guide\n        throw new Error(`Capacitor WebPlugin is using the deprecated \"registerWebPlugin()\" function, but without the config. Please use \"registerPlugin()\" instead to register this web plugin.\"`);\n    }\n    // TODO: add link to upgrade guide\n    console.warn(`Capacitor plugin \"${config.name}\" is using the deprecated \"registerWebPlugin()\" function`);\n    if (!Plugins[config.name] || ((_a = config === null || config === void 0 ? void 0 : config.platforms) === null || _a === void 0 ? void 0 : _a.includes(cap.getPlatform()))) {\n        // Add the web plugin into the plugins registry if there already isn't\n        // an existing one. If it doesn't already exist, that means\n        // there's no existing native implementation for it.\n        // - OR -\n        // If we already have a plugin registered (meaning it was defined in the native layer),\n        // then we should only overwrite it if the corresponding web plugin activates on\n        // a certain platform. For example: Geolocation uses the WebPlugin on Android but not iOS\n        Plugins[config.name] = webPlugin;\n    }\n};\n\nvar ExceptionCode;\n(function (ExceptionCode) {\n    /**\n     * API is not implemented.\n     *\n     * This usually means the API can't be used because it is not implemented for\n     * the current platform.\n     */\n    ExceptionCode[\"Unimplemented\"] = \"UNIMPLEMENTED\";\n    /**\n     * API is not available.\n     *\n     * This means the API can't be used right now because:\n     *   - it is currently missing a prerequisite, such as network connectivity\n     *   - it requires a particular platform or browser version\n     */\n    ExceptionCode[\"Unavailable\"] = \"UNAVAILABLE\";\n})(ExceptionCode || (ExceptionCode = {}));\nclass CapacitorException extends Error {\n    constructor(message, code) {\n        super(message);\n        this.message = message;\n        this.code = code;\n    }\n}\nconst getPlatformId = (win) => {\n    var _a, _b;\n    if (win === null || win === void 0 ? void 0 : win.androidBridge) {\n        return 'android';\n    }\n    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {\n        return 'ios';\n    }\n    else {\n        return 'web';\n    }\n};\n\nconst createCapacitor = (win) => {\n    var _a, _b, _c, _d, _e;\n    const capCustomPlatform = win.CapacitorCustomPlatform || null;\n    const cap = win.Capacitor || {};\n    const Plugins = (cap.Plugins = cap.Plugins || {});\n    /**\n     * @deprecated Use `capCustomPlatform` instead, default functions like registerPlugin will function with the new object.\n     */\n    const capPlatforms = win.CapacitorPlatforms;\n    const defaultGetPlatform = () => {\n        return capCustomPlatform !== null\n            ? capCustomPlatform.name\n            : getPlatformId(win);\n    };\n    const getPlatform = ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;\n    const defaultIsNativePlatform = () => getPlatform() !== 'web';\n    const isNativePlatform = ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) || defaultIsNativePlatform;\n    const defaultIsPluginAvailable = (pluginName) => {\n        const plugin = registeredPlugins.get(pluginName);\n        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {\n            // JS implementation available for the current platform.\n            return true;\n        }\n        if (getPluginHeader(pluginName)) {\n            // Native implementation available.\n            return true;\n        }\n        return false;\n    };\n    const isPluginAvailable = ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) ||\n        defaultIsPluginAvailable;\n    const defaultGetPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find(h => h.name === pluginName); };\n    const getPluginHeader = ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) || defaultGetPluginHeader;\n    const handleError = (err) => win.console.error(err);\n    const pluginMethodNoop = (_target, prop, pluginName) => {\n        return Promise.reject(`${pluginName} does not have an implementation of \"${prop}\".`);\n    };\n    const registeredPlugins = new Map();\n    const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {\n        const registeredPlugin = registeredPlugins.get(pluginName);\n        if (registeredPlugin) {\n            console.warn(`Capacitor plugin \"${pluginName}\" already registered. Cannot register plugins twice.`);\n            return registeredPlugin.proxy;\n        }\n        const platform = getPlatform();\n        const pluginHeader = getPluginHeader(pluginName);\n        let jsImplementation;\n        const loadPluginImplementation = async () => {\n            if (!jsImplementation && platform in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations[platform] === 'function'\n                        ? (jsImplementation = await jsImplementations[platform]())\n                        : (jsImplementation = jsImplementations[platform]);\n            }\n            else if (capCustomPlatform !== null &&\n                !jsImplementation &&\n                'web' in jsImplementations) {\n                jsImplementation =\n                    typeof jsImplementations['web'] === 'function'\n                        ? (jsImplementation = await jsImplementations['web']())\n                        : (jsImplementation = jsImplementations['web']);\n            }\n            return jsImplementation;\n        };\n        const createPluginMethod = (impl, prop) => {\n            var _a, _b;\n            if (pluginHeader) {\n                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find(m => prop === m.name);\n                if (methodHeader) {\n                    if (methodHeader.rtype === 'promise') {\n                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);\n                    }\n                    else {\n                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);\n                    }\n                }\n                else if (impl) {\n                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);\n                }\n            }\n            else if (impl) {\n                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);\n            }\n            else {\n                throw new CapacitorException(`\"${pluginName}\" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n            }\n        };\n        const createPluginMethodWrapper = (prop) => {\n            let remove;\n            const wrapper = (...args) => {\n                const p = loadPluginImplementation().then(impl => {\n                    const fn = createPluginMethod(impl, prop);\n                    if (fn) {\n                        const p = fn(...args);\n                        remove = p === null || p === void 0 ? void 0 : p.remove;\n                        return p;\n                    }\n                    else {\n                        throw new CapacitorException(`\"${pluginName}.${prop}()\" is not implemented on ${platform}`, ExceptionCode.Unimplemented);\n                    }\n                });\n                if (prop === 'addListener') {\n                    p.remove = async () => remove();\n                }\n                return p;\n            };\n            // Some flair ✨\n            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;\n            Object.defineProperty(wrapper, 'name', {\n                value: prop,\n                writable: false,\n                configurable: false,\n            });\n            return wrapper;\n        };\n        const addListener = createPluginMethodWrapper('addListener');\n        const removeListener = createPluginMethodWrapper('removeListener');\n        const addListenerNative = (eventName, callback) => {\n            const call = addListener({ eventName }, callback);\n            const remove = async () => {\n                const callbackId = await call;\n                removeListener({\n                    eventName,\n                    callbackId,\n                }, callback);\n            };\n            const p = new Promise(resolve => call.then(() => resolve({ remove })));\n            p.remove = async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            };\n            return p;\n        };\n        const proxy = new Proxy({}, {\n            get(_, prop) {\n                switch (prop) {\n                    // https://github.com/facebook/react/issues/20030\n                    case '$$typeof':\n                        return undefined;\n                    case 'toJSON':\n                        return () => ({});\n                    case 'addListener':\n                        return pluginHeader ? addListenerNative : addListener;\n                    case 'removeListener':\n                        return removeListener;\n                    default:\n                        return createPluginMethodWrapper(prop);\n                }\n            },\n        });\n        Plugins[pluginName] = proxy;\n        registeredPlugins.set(pluginName, {\n            name: pluginName,\n            proxy,\n            platforms: new Set([\n                ...Object.keys(jsImplementations),\n                ...(pluginHeader ? [platform] : []),\n            ]),\n        });\n        return proxy;\n    };\n    const registerPlugin = ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) || defaultRegisterPlugin;\n    // Add in convertFileSrc for web, it will already be available in native context\n    if (!cap.convertFileSrc) {\n        cap.convertFileSrc = filePath => filePath;\n    }\n    cap.getPlatform = getPlatform;\n    cap.handleError = handleError;\n    cap.isNativePlatform = isNativePlatform;\n    cap.isPluginAvailable = isPluginAvailable;\n    cap.pluginMethodNoop = pluginMethodNoop;\n    cap.registerPlugin = registerPlugin;\n    cap.Exception = CapacitorException;\n    cap.DEBUG = !!cap.DEBUG;\n    cap.isLoggingEnabled = !!cap.isLoggingEnabled;\n    // Deprecated props\n    cap.platform = cap.getPlatform();\n    cap.isNative = cap.isNativePlatform();\n    return cap;\n};\nconst initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));\n\nconst Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n            ? window\n            : typeof __webpack_require__.g !== 'undefined'\n                ? __webpack_require__.g\n                : {});\nconst registerPlugin = Capacitor.registerPlugin;\n/**\n * @deprecated Provided for backwards compatibility for Capacitor v2 plugins.\n * Capacitor v3 plugins should import the plugin directly. This \"Plugins\"\n * export is deprecated in v3, and will be removed in v4.\n */\nconst Plugins = Capacitor.Plugins;\n/**\n * Provided for backwards compatibility. Use the registerPlugin() API\n * instead, and provide the web plugin as the \"web\" implmenetation.\n * For example\n *\n * export const Example = registerPlugin('Example', {\n *   web: () => import('./web').then(m => new m.Example())\n * })\n *\n * @deprecated Deprecated in v3, will be removed from v4.\n */\nconst registerWebPlugin = (plugin) => legacyRegisterWebPlugin(Capacitor, plugin);\n\n/**\n * Base class web plugins should extend.\n */\nclass WebPlugin {\n    constructor(config) {\n        this.listeners = {};\n        this.windowListeners = {};\n        if (config) {\n            // TODO: add link to upgrade guide\n            console.warn(`Capacitor WebPlugin \"${config.name}\" config object was deprecated in v3 and will be removed in v4.`);\n            this.config = config;\n        }\n    }\n    addListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            this.listeners[eventName] = [];\n        }\n        this.listeners[eventName].push(listenerFunc);\n        // If we haven't added a window listener for this event and it requires one,\n        // go ahead and add it\n        const windowListener = this.windowListeners[eventName];\n        if (windowListener && !windowListener.registered) {\n            this.addWindowListener(windowListener);\n        }\n        const remove = async () => this.removeListener(eventName, listenerFunc);\n        const p = Promise.resolve({ remove });\n        Object.defineProperty(p, 'remove', {\n            value: async () => {\n                console.warn(`Using addListener() without 'await' is deprecated.`);\n                await remove();\n            },\n        });\n        return p;\n    }\n    async removeAllListeners() {\n        this.listeners = {};\n        for (const listener in this.windowListeners) {\n            this.removeWindowListener(this.windowListeners[listener]);\n        }\n        this.windowListeners = {};\n    }\n    notifyListeners(eventName, data) {\n        const listeners = this.listeners[eventName];\n        if (listeners) {\n            listeners.forEach(listener => listener(data));\n        }\n    }\n    hasListeners(eventName) {\n        return !!this.listeners[eventName].length;\n    }\n    registerWindowListener(windowEventName, pluginEventName) {\n        this.windowListeners[pluginEventName] = {\n            registered: false,\n            windowEventName,\n            pluginEventName,\n            handler: event => {\n                this.notifyListeners(pluginEventName, event);\n            },\n        };\n    }\n    unimplemented(msg = 'not implemented') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);\n    }\n    unavailable(msg = 'not available') {\n        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);\n    }\n    async removeListener(eventName, listenerFunc) {\n        const listeners = this.listeners[eventName];\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(listenerFunc);\n        this.listeners[eventName].splice(index, 1);\n        // If there are no more listeners for this type of event,\n        // remove the window listener\n        if (!this.listeners[eventName].length) {\n            this.removeWindowListener(this.windowListeners[eventName]);\n        }\n    }\n    addWindowListener(handle) {\n        window.addEventListener(handle.windowEventName, handle.handler);\n        handle.registered = true;\n    }\n    removeWindowListener(handle) {\n        if (!handle) {\n            return;\n        }\n        window.removeEventListener(handle.windowEventName, handle.handler);\n        handle.registered = false;\n    }\n}\n\nconst WebView = /*#__PURE__*/ (/* unused pure expression or super */ null && (registerPlugin('WebView')));\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4OTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQU07QUFDM0Isa0JBQWtCLHFCQUFNO0FBQ3hCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWSxzQ0FBc0MsS0FBSztBQUN4RjtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVyxpQ0FBaUMsU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXLEdBQUcsS0FBSyw0QkFBNEIsU0FBUztBQUNqSDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCLEtBQUssa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQU07QUFDM0Isa0JBQWtCLHFCQUFNO0FBQ3hCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIseUVBQXlCOztBQUUrRztBQUN0SyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci9jb3JlL2Rpc3QvaW5kZXguanM/MTU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQ2FwYWNpdG9yOiBodHRwczovL2NhcGFjaXRvcmpzLmNvbS8gLSBNSVQgTGljZW5zZSAqL1xuY29uc3QgY3JlYXRlQ2FwYWNpdG9yUGxhdGZvcm1zID0gKHdpbikgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRQbGF0Zm9ybU1hcCA9IG5ldyBNYXAoKTtcbiAgICBkZWZhdWx0UGxhdGZvcm1NYXAuc2V0KCd3ZWInLCB7IG5hbWU6ICd3ZWInIH0pO1xuICAgIGNvbnN0IGNhcFBsYXRmb3JtcyA9IHdpbi5DYXBhY2l0b3JQbGF0Zm9ybXMgfHwge1xuICAgICAgICBjdXJyZW50UGxhdGZvcm06IHsgbmFtZTogJ3dlYicgfSxcbiAgICAgICAgcGxhdGZvcm1zOiBkZWZhdWx0UGxhdGZvcm1NYXAsXG4gICAgfTtcbiAgICBjb25zdCBhZGRQbGF0Zm9ybSA9IChuYW1lLCBwbGF0Zm9ybSkgPT4ge1xuICAgICAgICBjYXBQbGF0Zm9ybXMucGxhdGZvcm1zLnNldChuYW1lLCBwbGF0Zm9ybSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRQbGF0Zm9ybSA9IChuYW1lKSA9PiB7XG4gICAgICAgIGlmIChjYXBQbGF0Zm9ybXMucGxhdGZvcm1zLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgY2FwUGxhdGZvcm1zLmN1cnJlbnRQbGF0Zm9ybSA9IGNhcFBsYXRmb3Jtcy5wbGF0Zm9ybXMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYXBQbGF0Zm9ybXMuYWRkUGxhdGZvcm0gPSBhZGRQbGF0Zm9ybTtcbiAgICBjYXBQbGF0Zm9ybXMuc2V0UGxhdGZvcm0gPSBzZXRQbGF0Zm9ybTtcbiAgICByZXR1cm4gY2FwUGxhdGZvcm1zO1xufTtcbmNvbnN0IGluaXRQbGF0Zm9ybXMgPSAod2luKSA9PiAod2luLkNhcGFjaXRvclBsYXRmb3JtcyA9IGNyZWF0ZUNhcGFjaXRvclBsYXRmb3Jtcyh3aW4pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2V0IGBDYXBhY2l0b3JDdXN0b21QbGF0Zm9ybWAgb24gdGhlIHdpbmRvdyBvYmplY3QgcHJpb3IgdG8gcnVudGltZSBleGVjdXRpbmcgaW4gdGhlIHdlYiBhcHAgaW5zdGVhZFxuICovXG5jb25zdCBDYXBhY2l0b3JQbGF0Zm9ybXMgPSAvKiNfX1BVUkVfXyovIGluaXRQbGF0Zm9ybXMoKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZ2xvYmFsVGhpc1xuICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gc2VsZlxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgOiB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBTZXQgYENhcGFjaXRvckN1c3RvbVBsYXRmb3JtYCBvbiB0aGUgd2luZG93IG9iamVjdCBwcmlvciB0byBydW50aW1lIGV4ZWN1dGluZyBpbiB0aGUgd2ViIGFwcCBpbnN0ZWFkXG4gKi9cbmNvbnN0IGFkZFBsYXRmb3JtID0gQ2FwYWNpdG9yUGxhdGZvcm1zLmFkZFBsYXRmb3JtO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBTZXQgYENhcGFjaXRvckN1c3RvbVBsYXRmb3JtYCBvbiB0aGUgd2luZG93IG9iamVjdCBwcmlvciB0byBydW50aW1lIGV4ZWN1dGluZyBpbiB0aGUgd2ViIGFwcCBpbnN0ZWFkXG4gKi9cbmNvbnN0IHNldFBsYXRmb3JtID0gQ2FwYWNpdG9yUGxhdGZvcm1zLnNldFBsYXRmb3JtO1xuXG5jb25zdCBsZWdhY3lSZWdpc3RlcldlYlBsdWdpbiA9IChjYXAsIHdlYlBsdWdpbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb25maWcgPSB3ZWJQbHVnaW4uY29uZmlnO1xuICAgIGNvbnN0IFBsdWdpbnMgPSBjYXAuUGx1Z2lucztcbiAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLm5hbWUpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIGxpbmsgdG8gdXBncmFkZSBndWlkZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhcGFjaXRvciBXZWJQbHVnaW4gaXMgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgXCJyZWdpc3RlcldlYlBsdWdpbigpXCIgZnVuY3Rpb24sIGJ1dCB3aXRob3V0IHRoZSBjb25maWcuIFBsZWFzZSB1c2UgXCJyZWdpc3RlclBsdWdpbigpXCIgaW5zdGVhZCB0byByZWdpc3RlciB0aGlzIHdlYiBwbHVnaW4uXCJgKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYWRkIGxpbmsgdG8gdXBncmFkZSBndWlkZVxuICAgIGNvbnNvbGUud2FybihgQ2FwYWNpdG9yIHBsdWdpbiBcIiR7Y29uZmlnLm5hbWV9XCIgaXMgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgXCJyZWdpc3RlcldlYlBsdWdpbigpXCIgZnVuY3Rpb25gKTtcbiAgICBpZiAoIVBsdWdpbnNbY29uZmlnLm5hbWVdIHx8ICgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucGxhdGZvcm1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoY2FwLmdldFBsYXRmb3JtKCkpKSkge1xuICAgICAgICAvLyBBZGQgdGhlIHdlYiBwbHVnaW4gaW50byB0aGUgcGx1Z2lucyByZWdpc3RyeSBpZiB0aGVyZSBhbHJlYWR5IGlzbid0XG4gICAgICAgIC8vIGFuIGV4aXN0aW5nIG9uZS4gSWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LCB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgbmF0aXZlIGltcGxlbWVudGF0aW9uIGZvciBpdC5cbiAgICAgICAgLy8gLSBPUiAtXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIHBsdWdpbiByZWdpc3RlcmVkIChtZWFuaW5nIGl0IHdhcyBkZWZpbmVkIGluIHRoZSBuYXRpdmUgbGF5ZXIpLFxuICAgICAgICAvLyB0aGVuIHdlIHNob3VsZCBvbmx5IG92ZXJ3cml0ZSBpdCBpZiB0aGUgY29ycmVzcG9uZGluZyB3ZWIgcGx1Z2luIGFjdGl2YXRlcyBvblxuICAgICAgICAvLyBhIGNlcnRhaW4gcGxhdGZvcm0uIEZvciBleGFtcGxlOiBHZW9sb2NhdGlvbiB1c2VzIHRoZSBXZWJQbHVnaW4gb24gQW5kcm9pZCBidXQgbm90IGlPU1xuICAgICAgICBQbHVnaW5zW2NvbmZpZy5uYW1lXSA9IHdlYlBsdWdpbjtcbiAgICB9XG59O1xuXG52YXIgRXhjZXB0aW9uQ29kZTtcbihmdW5jdGlvbiAoRXhjZXB0aW9uQ29kZSkge1xuICAgIC8qKlxuICAgICAqIEFQSSBpcyBub3QgaW1wbGVtZW50ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIEFQSSBjYW4ndCBiZSB1c2VkIGJlY2F1c2UgaXQgaXMgbm90IGltcGxlbWVudGVkIGZvclxuICAgICAqIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqL1xuICAgIEV4Y2VwdGlvbkNvZGVbXCJVbmltcGxlbWVudGVkXCJdID0gXCJVTklNUExFTUVOVEVEXCI7XG4gICAgLyoqXG4gICAgICogQVBJIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1lYW5zIHRoZSBBUEkgY2FuJ3QgYmUgdXNlZCByaWdodCBub3cgYmVjYXVzZTpcbiAgICAgKiAgIC0gaXQgaXMgY3VycmVudGx5IG1pc3NpbmcgYSBwcmVyZXF1aXNpdGUsIHN1Y2ggYXMgbmV0d29yayBjb25uZWN0aXZpdHlcbiAgICAgKiAgIC0gaXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIHBsYXRmb3JtIG9yIGJyb3dzZXIgdmVyc2lvblxuICAgICAqL1xuICAgIEV4Y2VwdGlvbkNvZGVbXCJVbmF2YWlsYWJsZVwiXSA9IFwiVU5BVkFJTEFCTEVcIjtcbn0pKEV4Y2VwdGlvbkNvZGUgfHwgKEV4Y2VwdGlvbkNvZGUgPSB7fSkpO1xuY2xhc3MgQ2FwYWNpdG9yRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuY29uc3QgZ2V0UGxhdGZvcm1JZCA9ICh3aW4pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uYW5kcm9pZEJyaWRnZSkge1xuICAgICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2IgPSAoX2EgPSB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4ud2Via2l0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZUhhbmRsZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnd2ViJztcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVDYXBhY2l0b3IgPSAod2luKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBjYXBDdXN0b21QbGF0Zm9ybSA9IHdpbi5DYXBhY2l0b3JDdXN0b21QbGF0Zm9ybSB8fCBudWxsO1xuICAgIGNvbnN0IGNhcCA9IHdpbi5DYXBhY2l0b3IgfHwge307XG4gICAgY29uc3QgUGx1Z2lucyA9IChjYXAuUGx1Z2lucyA9IGNhcC5QbHVnaW5zIHx8IHt9KTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGNhcEN1c3RvbVBsYXRmb3JtYCBpbnN0ZWFkLCBkZWZhdWx0IGZ1bmN0aW9ucyBsaWtlIHJlZ2lzdGVyUGx1Z2luIHdpbGwgZnVuY3Rpb24gd2l0aCB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdCBjYXBQbGF0Zm9ybXMgPSB3aW4uQ2FwYWNpdG9yUGxhdGZvcm1zO1xuICAgIGNvbnN0IGRlZmF1bHRHZXRQbGF0Zm9ybSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhcEN1c3RvbVBsYXRmb3JtICE9PSBudWxsXG4gICAgICAgICAgICA/IGNhcEN1c3RvbVBsYXRmb3JtLm5hbWVcbiAgICAgICAgICAgIDogZ2V0UGxhdGZvcm1JZCh3aW4pO1xuICAgIH07XG4gICAgY29uc3QgZ2V0UGxhdGZvcm0gPSAoKF9hID0gY2FwUGxhdGZvcm1zID09PSBudWxsIHx8IGNhcFBsYXRmb3JtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwUGxhdGZvcm1zLmN1cnJlbnRQbGF0Zm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBsYXRmb3JtKSB8fCBkZWZhdWx0R2V0UGxhdGZvcm07XG4gICAgY29uc3QgZGVmYXVsdElzTmF0aXZlUGxhdGZvcm0gPSAoKSA9PiBnZXRQbGF0Zm9ybSgpICE9PSAnd2ViJztcbiAgICBjb25zdCBpc05hdGl2ZVBsYXRmb3JtID0gKChfYiA9IGNhcFBsYXRmb3JtcyA9PT0gbnVsbCB8fCBjYXBQbGF0Zm9ybXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcFBsYXRmb3Jtcy5jdXJyZW50UGxhdGZvcm0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc05hdGl2ZVBsYXRmb3JtKSB8fCBkZWZhdWx0SXNOYXRpdmVQbGF0Zm9ybTtcbiAgICBjb25zdCBkZWZhdWx0SXNQbHVnaW5BdmFpbGFibGUgPSAocGx1Z2luTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSByZWdpc3RlcmVkUGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICAgIGlmIChwbHVnaW4gPT09IG51bGwgfHwgcGx1Z2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW4ucGxhdGZvcm1zLmhhcyhnZXRQbGF0Zm9ybSgpKSkge1xuICAgICAgICAgICAgLy8gSlMgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBpc1BsdWdpbkF2YWlsYWJsZSA9ICgoX2MgPSBjYXBQbGF0Zm9ybXMgPT09IG51bGwgfHwgY2FwUGxhdGZvcm1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBQbGF0Zm9ybXMuY3VycmVudFBsYXRmb3JtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaXNQbHVnaW5BdmFpbGFibGUpIHx8XG4gICAgICAgIGRlZmF1bHRJc1BsdWdpbkF2YWlsYWJsZTtcbiAgICBjb25zdCBkZWZhdWx0R2V0UGx1Z2luSGVhZGVyID0gKHBsdWdpbk5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gY2FwLlBsdWdpbkhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKGggPT4gaC5uYW1lID09PSBwbHVnaW5OYW1lKTsgfTtcbiAgICBjb25zdCBnZXRQbHVnaW5IZWFkZXIgPSAoKF9kID0gY2FwUGxhdGZvcm1zID09PSBudWxsIHx8IGNhcFBsYXRmb3JtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FwUGxhdGZvcm1zLmN1cnJlbnRQbGF0Zm9ybSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdldFBsdWdpbkhlYWRlcikgfHwgZGVmYXVsdEdldFBsdWdpbkhlYWRlcjtcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnIpID0+IHdpbi5jb25zb2xlLmVycm9yKGVycik7XG4gICAgY29uc3QgcGx1Z2luTWV0aG9kTm9vcCA9IChfdGFyZ2V0LCBwcm9wLCBwbHVnaW5OYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgJHtwbHVnaW5OYW1lfSBkb2VzIG5vdCBoYXZlIGFuIGltcGxlbWVudGF0aW9uIG9mIFwiJHtwcm9wfVwiLmApO1xuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXJlZFBsdWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVmYXVsdFJlZ2lzdGVyUGx1Z2luID0gKHBsdWdpbk5hbWUsIGpzSW1wbGVtZW50YXRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFBsdWdpbiA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwYWNpdG9yIHBsdWdpbiBcIiR7cGx1Z2luTmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQuIENhbm5vdCByZWdpc3RlciBwbHVnaW5zIHR3aWNlLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRQbHVnaW4ucHJveHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBjb25zdCBwbHVnaW5IZWFkZXIgPSBnZXRQbHVnaW5IZWFkZXIocGx1Z2luTmFtZSk7XG4gICAgICAgIGxldCBqc0ltcGxlbWVudGF0aW9uO1xuICAgICAgICBjb25zdCBsb2FkUGx1Z2luSW1wbGVtZW50YXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWpzSW1wbGVtZW50YXRpb24gJiYgcGxhdGZvcm0gaW4ganNJbXBsZW1lbnRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBqc0ltcGxlbWVudGF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoanNJbXBsZW1lbnRhdGlvbiA9IGF3YWl0IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoanNJbXBsZW1lbnRhdGlvbiA9IGpzSW1wbGVtZW50YXRpb25zW3BsYXRmb3JtXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYXBDdXN0b21QbGF0Zm9ybSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICFqc0ltcGxlbWVudGF0aW9uICYmXG4gICAgICAgICAgICAgICAgJ3dlYicgaW4ganNJbXBsZW1lbnRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBqc0ltcGxlbWVudGF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGpzSW1wbGVtZW50YXRpb25zWyd3ZWInXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoanNJbXBsZW1lbnRhdGlvbiA9IGF3YWl0IGpzSW1wbGVtZW50YXRpb25zWyd3ZWInXSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoanNJbXBsZW1lbnRhdGlvbiA9IGpzSW1wbGVtZW50YXRpb25zWyd3ZWInXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3JlYXRlUGx1Z2luTWV0aG9kID0gKGltcGwsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAocGx1Z2luSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kSGVhZGVyID0gcGx1Z2luSGVhZGVyID09PSBudWxsIHx8IHBsdWdpbkhlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGx1Z2luSGVhZGVyLm1ldGhvZHMuZmluZChtID0+IHByb3AgPT09IG0ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kSGVhZGVyLnJ0eXBlID09PSAncHJvbWlzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucykgPT4gY2FwLm5hdGl2ZVByb21pc2UocGx1Z2luTmFtZSwgcHJvcC50b1N0cmluZygpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAob3B0aW9ucywgY2FsbGJhY2spID0+IGNhcC5uYXRpdmVDYWxsYmFjayhwbHVnaW5OYW1lLCBwcm9wLnRvU3RyaW5nKCksIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBpbXBsW3Byb3BdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChpbXBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IGltcGxbcHJvcF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKGltcGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhcGFjaXRvckV4Y2VwdGlvbihgXCIke3BsdWdpbk5hbWV9XCIgcGx1Z2luIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiAke3BsYXRmb3JtfWAsIEV4Y2VwdGlvbkNvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBsdWdpbk1ldGhvZFdyYXBwZXIgPSAocHJvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbW92ZTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBsb2FkUGx1Z2luSW1wbGVtZW50YXRpb24oKS50aGVuKGltcGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IGNyZWF0ZVBsdWdpbk1ldGhvZChpbXBsLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBwID09PSBudWxsIHx8IHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHAucmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2FwYWNpdG9yRXhjZXB0aW9uKGBcIiR7cGx1Z2luTmFtZX0uJHtwcm9wfSgpXCIgaXMgbm90IGltcGxlbWVudGVkIG9uICR7cGxhdGZvcm19YCwgRXhjZXB0aW9uQ29kZS5VbmltcGxlbWVudGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnYWRkTGlzdGVuZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucmVtb3ZlID0gYXN5bmMgKCkgPT4gcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFNvbWUgZmxhaXIg4pyoXG4gICAgICAgICAgICB3cmFwcGVyLnRvU3RyaW5nID0gKCkgPT4gYCR7cHJvcC50b1N0cmluZygpfSgpIHsgW2NhcGFjaXRvciBjb2RlXSB9YDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyLCAnbmFtZScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcCxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZExpc3RlbmVyID0gY3JlYXRlUGx1Z2luTWV0aG9kV3JhcHBlcignYWRkTGlzdGVuZXInKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBjcmVhdGVQbHVnaW5NZXRob2RXcmFwcGVyKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICBjb25zdCBhZGRMaXN0ZW5lck5hdGl2ZSA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gYWRkTGlzdGVuZXIoeyBldmVudE5hbWUgfSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBhd2FpdCBjYWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjYWxsLnRoZW4oKCkgPT4gcmVzb2x2ZSh7IHJlbW92ZSB9KSkpO1xuICAgICAgICAgICAgcC5yZW1vdmUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVc2luZyBhZGRMaXN0ZW5lcigpIHdpdGhvdXQgJ2F3YWl0JyBpcyBkZXByZWNhdGVkLmApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDAzMFxuICAgICAgICAgICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b0pTT04nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+ICh7fSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZExpc3RlbmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5IZWFkZXIgPyBhZGRMaXN0ZW5lck5hdGl2ZSA6IGFkZExpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZW1vdmVMaXN0ZW5lcic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGx1Z2luTWV0aG9kV3JhcHBlcihwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgUGx1Z2luc1twbHVnaW5OYW1lXSA9IHByb3h5O1xuICAgICAgICByZWdpc3RlcmVkUGx1Z2lucy5zZXQocGx1Z2luTmFtZSwge1xuICAgICAgICAgICAgbmFtZTogcGx1Z2luTmFtZSxcbiAgICAgICAgICAgIHByb3h5LFxuICAgICAgICAgICAgcGxhdGZvcm1zOiBuZXcgU2V0KFtcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhqc0ltcGxlbWVudGF0aW9ucyksXG4gICAgICAgICAgICAgICAgLi4uKHBsdWdpbkhlYWRlciA/IFtwbGF0Zm9ybV0gOiBbXSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyUGx1Z2luID0gKChfZSA9IGNhcFBsYXRmb3JtcyA9PT0gbnVsbCB8fCBjYXBQbGF0Zm9ybXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcFBsYXRmb3Jtcy5jdXJyZW50UGxhdGZvcm0pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWdpc3RlclBsdWdpbikgfHwgZGVmYXVsdFJlZ2lzdGVyUGx1Z2luO1xuICAgIC8vIEFkZCBpbiBjb252ZXJ0RmlsZVNyYyBmb3Igd2ViLCBpdCB3aWxsIGFscmVhZHkgYmUgYXZhaWxhYmxlIGluIG5hdGl2ZSBjb250ZXh0XG4gICAgaWYgKCFjYXAuY29udmVydEZpbGVTcmMpIHtcbiAgICAgICAgY2FwLmNvbnZlcnRGaWxlU3JjID0gZmlsZVBhdGggPT4gZmlsZVBhdGg7XG4gICAgfVxuICAgIGNhcC5nZXRQbGF0Zm9ybSA9IGdldFBsYXRmb3JtO1xuICAgIGNhcC5oYW5kbGVFcnJvciA9IGhhbmRsZUVycm9yO1xuICAgIGNhcC5pc05hdGl2ZVBsYXRmb3JtID0gaXNOYXRpdmVQbGF0Zm9ybTtcbiAgICBjYXAuaXNQbHVnaW5BdmFpbGFibGUgPSBpc1BsdWdpbkF2YWlsYWJsZTtcbiAgICBjYXAucGx1Z2luTWV0aG9kTm9vcCA9IHBsdWdpbk1ldGhvZE5vb3A7XG4gICAgY2FwLnJlZ2lzdGVyUGx1Z2luID0gcmVnaXN0ZXJQbHVnaW47XG4gICAgY2FwLkV4Y2VwdGlvbiA9IENhcGFjaXRvckV4Y2VwdGlvbjtcbiAgICBjYXAuREVCVUcgPSAhIWNhcC5ERUJVRztcbiAgICBjYXAuaXNMb2dnaW5nRW5hYmxlZCA9ICEhY2FwLmlzTG9nZ2luZ0VuYWJsZWQ7XG4gICAgLy8gRGVwcmVjYXRlZCBwcm9wc1xuICAgIGNhcC5wbGF0Zm9ybSA9IGNhcC5nZXRQbGF0Zm9ybSgpO1xuICAgIGNhcC5pc05hdGl2ZSA9IGNhcC5pc05hdGl2ZVBsYXRmb3JtKCk7XG4gICAgcmV0dXJuIGNhcDtcbn07XG5jb25zdCBpbml0Q2FwYWNpdG9yR2xvYmFsID0gKHdpbikgPT4gKHdpbi5DYXBhY2l0b3IgPSBjcmVhdGVDYXBhY2l0b3Iod2luKSk7XG5cbmNvbnN0IENhcGFjaXRvciA9IC8qI19fUFVSRV9fKi8gaW5pdENhcGFjaXRvckdsb2JhbCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFRoaXNcbiAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgICAgIDoge30pO1xuY29uc3QgcmVnaXN0ZXJQbHVnaW4gPSBDYXBhY2l0b3IucmVnaXN0ZXJQbHVnaW47XG4vKipcbiAqIEBkZXByZWNhdGVkIFByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgQ2FwYWNpdG9yIHYyIHBsdWdpbnMuXG4gKiBDYXBhY2l0b3IgdjMgcGx1Z2lucyBzaG91bGQgaW1wb3J0IHRoZSBwbHVnaW4gZGlyZWN0bHkuIFRoaXMgXCJQbHVnaW5zXCJcbiAqIGV4cG9ydCBpcyBkZXByZWNhdGVkIGluIHYzLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0LlxuICovXG5jb25zdCBQbHVnaW5zID0gQ2FwYWNpdG9yLlBsdWdpbnM7XG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVXNlIHRoZSByZWdpc3RlclBsdWdpbigpIEFQSVxuICogaW5zdGVhZCwgYW5kIHByb3ZpZGUgdGhlIHdlYiBwbHVnaW4gYXMgdGhlIFwid2ViXCIgaW1wbG1lbmV0YXRpb24uXG4gKiBGb3IgZXhhbXBsZVxuICpcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlID0gcmVnaXN0ZXJQbHVnaW4oJ0V4YW1wbGUnLCB7XG4gKiAgIHdlYjogKCkgPT4gaW1wb3J0KCcuL3dlYicpLnRoZW4obSA9PiBuZXcgbS5FeGFtcGxlKCkpXG4gKiB9KVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gdjMsIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHY0LlxuICovXG5jb25zdCByZWdpc3RlcldlYlBsdWdpbiA9IChwbHVnaW4pID0+IGxlZ2FjeVJlZ2lzdGVyV2ViUGx1Z2luKENhcGFjaXRvciwgcGx1Z2luKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHdlYiBwbHVnaW5zIHNob3VsZCBleHRlbmQuXG4gKi9cbmNsYXNzIFdlYlBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0ge307XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBsaW5rIHRvIHVwZ3JhZGUgZ3VpZGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwYWNpdG9yIFdlYlBsdWdpbiBcIiR7Y29uZmlnLm5hbWV9XCIgY29uZmlnIG9iamVjdCB3YXMgZGVwcmVjYXRlZCBpbiB2MyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0LmApO1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lckZ1bmMpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXJGdW5jKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBhZGRlZCBhIHdpbmRvdyBsaXN0ZW5lciBmb3IgdGhpcyBldmVudCBhbmQgaXQgcmVxdWlyZXMgb25lLFxuICAgICAgICAvLyBnbyBhaGVhZCBhbmQgYWRkIGl0XG4gICAgICAgIGNvbnN0IHdpbmRvd0xpc3RlbmVyID0gdGhpcy53aW5kb3dMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKHdpbmRvd0xpc3RlbmVyICYmICF3aW5kb3dMaXN0ZW5lci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVyKHdpbmRvd0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmUgPSBhc3luYyAoKSA9PiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGdW5jKTtcbiAgICAgICAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSh7IHJlbW92ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsICdyZW1vdmUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNpbmcgYWRkTGlzdGVuZXIoKSB3aXRob3V0ICdhd2FpdCcgaXMgZGVwcmVjYXRlZC5gKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIGluIHRoaXMud2luZG93TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVyKHRoaXMud2luZG93TGlzdGVuZXJzW2xpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgbm90aWZ5TGlzdGVuZXJzKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihkYXRhKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLmxlbmd0aDtcbiAgICB9XG4gICAgcmVnaXN0ZXJXaW5kb3dMaXN0ZW5lcih3aW5kb3dFdmVudE5hbWUsIHBsdWdpbkV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLndpbmRvd0xpc3RlbmVyc1twbHVnaW5FdmVudE5hbWVdID0ge1xuICAgICAgICAgICAgcmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAgICAgICB3aW5kb3dFdmVudE5hbWUsXG4gICAgICAgICAgICBwbHVnaW5FdmVudE5hbWUsXG4gICAgICAgICAgICBoYW5kbGVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMocGx1Z2luRXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB1bmltcGxlbWVudGVkKG1zZyA9ICdub3QgaW1wbGVtZW50ZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2FwYWNpdG9yLkV4Y2VwdGlvbihtc2csIEV4Y2VwdGlvbkNvZGUuVW5pbXBsZW1lbnRlZCk7XG4gICAgfVxuICAgIHVuYXZhaWxhYmxlKG1zZyA9ICdub3QgYXZhaWxhYmxlJykge1xuICAgICAgICByZXR1cm4gbmV3IENhcGFjaXRvci5FeGNlcHRpb24obXNnLCBFeGNlcHRpb25Db2RlLlVuYXZhaWxhYmxlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lckZ1bmMpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyRnVuYyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGZvciB0aGlzIHR5cGUgb2YgZXZlbnQsXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2luZG93IGxpc3RlbmVyXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXIodGhpcy53aW5kb3dMaXN0ZW5lcnNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXIoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGhhbmRsZS53aW5kb3dFdmVudE5hbWUsIGhhbmRsZS5oYW5kbGVyKTtcbiAgICAgICAgaGFuZGxlLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcihoYW5kbGUpIHtcbiAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGUud2luZG93RXZlbnROYW1lLCBoYW5kbGUuaGFuZGxlcik7XG4gICAgICAgIGhhbmRsZS5yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgfVxufVxuXG5jb25zdCBXZWJWaWV3ID0gLyojX19QVVJFX18qLyByZWdpc3RlclBsdWdpbignV2ViVmlldycpO1xuXG5leHBvcnQgeyBDYXBhY2l0b3IsIENhcGFjaXRvckV4Y2VwdGlvbiwgQ2FwYWNpdG9yUGxhdGZvcm1zLCBFeGNlcHRpb25Db2RlLCBQbHVnaW5zLCBXZWJQbHVnaW4sIFdlYlZpZXcsIGFkZFBsYXRmb3JtLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0ZXJXZWJQbHVnaW4sIHNldFBsYXRmb3JtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29895\n")},60773:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"V\": () => (/* binding */ PushNotifications)\n/* harmony export */ });\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29895);\n\nconst PushNotifications = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__/* .registerPlugin */ .fo)('PushNotifications', {});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA3NzMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFpRDtBQUNqRCwwQkFBMEIseUVBQWMsd0JBQXdCO0FBQ2xDO0FBQ0Q7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BjYXBhY2l0b3IvcHVzaC1ub3RpZmljYXRpb25zL2Rpc3QvZXNtL2luZGV4LmpzPzZhYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnaXN0ZXJQbHVnaW4gfSBmcm9tICdAY2FwYWNpdG9yL2NvcmUnO1xuY29uc3QgUHVzaE5vdGlmaWNhdGlvbnMgPSByZWdpc3RlclBsdWdpbignUHVzaE5vdGlmaWNhdGlvbnMnLCB7fSk7XG5leHBvcnQgKiBmcm9tICcuL2RlZmluaXRpb25zJztcbmV4cG9ydCB7IFB1c2hOb3RpZmljYXRpb25zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60773\n")},12634:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* unused harmony export Toast */\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29895);\n\nconst Toast = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__/* .registerPlugin */ .fo)('Toast', {\n    web: () => __webpack_require__.e(/* import() */ 5056).then(__webpack_require__.bind(__webpack_require__, 15056)).then(m => new m.ToastWeb()),\n});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2MzQuanMiLCJtYXBwaW5ncyI6Ijs7QUFBaUQ7QUFDakQsY0FBYyx5RUFBYztBQUM1QixlQUFlLHFHQUFlO0FBQzlCLENBQUM7QUFDNkI7QUFDYjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGNhcGFjaXRvci90b2FzdC9kaXN0L2VzbS9pbmRleC5qcz9hZjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ2lzdGVyUGx1Z2luIH0gZnJvbSAnQGNhcGFjaXRvci9jb3JlJztcbmNvbnN0IFRvYXN0ID0gcmVnaXN0ZXJQbHVnaW4oJ1RvYXN0Jywge1xuICAgIHdlYjogKCkgPT4gaW1wb3J0KCcuL3dlYicpLnRoZW4obSA9PiBuZXcgbS5Ub2FzdFdlYigpKSxcbn0pO1xuZXhwb3J0ICogZnJvbSAnLi9kZWZpbml0aW9ucyc7XG5leHBvcnQgeyBUb2FzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12634\n")},96587:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": () => (/* binding */ componentOnReady),\n/* harmony export */   \"j\": () => (/* binding */ clamp),\n/* harmony export */   \"r\": () => (/* binding */ raf),\n/* harmony export */   \"s\": () => (/* binding */ shallowEqualStringMap)\n/* harmony export */ });\n/* unused harmony exports a, b, d, e, f, g, h, i, k, l, m, n, o, p, q, t */\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst transitionEndAsync = (el, expectedDuration = 0) => {\n  return new Promise(resolve => {\n    transitionEnd(el, expectedDuration, resolve);\n  });\n};\n/**\n * Allows developer to wait for a transition\n * to finish and fallback to a timer if the\n * transition is cancelled or otherwise\n * never finishes. Also see transitionEndAsync\n * which is an await-able version of this.\n */\nconst transitionEnd = (el, expectedDuration = 0, callback) => {\n  let unRegTrans;\n  let animationTimeout;\n  const opts = { passive: true };\n  const ANIMATION_FALLBACK_TIMEOUT = 500;\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (ev === undefined || el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n    animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);\n    unRegTrans = () => {\n      if (animationTimeout) {\n        clearTimeout(animationTimeout);\n        animationTimeout = undefined;\n      }\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\n/**\n * Waits for a component to be ready for\n * both custom element and non-custom element builds.\n * If non-custom element build, el.componentOnReady\n * will be used.\n * For custom element builds, we wait a frame\n * so that the inner contents of the component\n * have a chance to render.\n *\n * Use this utility rather than calling\n * el.componentOnReady yourself.\n */\nconst componentOnReady = (el, callback) => {\n  if (el.componentOnReady) {\n    el.componentOnReady().then((resolvedEl) => callback(resolvedEl));\n  }\n  else {\n    raf(() => callback(el));\n  }\n};\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      }\n      else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.addEventListener(eventName, callback, opts);\n};\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      }\n      else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nconst hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\nconst findItemLabel = (componentEl) => {\n  const itemEl = componentEl.closest('ion-item');\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n  return null;\n};\nconst focusElement = (el) => {\n  el.focus();\n  /**\n   * When programmatically focusing an element,\n   * the focus-visible utility will not run because\n   * it is expecting a keyboard event to have triggered this;\n   * however, there are times when we need to manually control\n   * this behavior so we call the `setFocus` method on ion-app\n   * which will let us explicitly set the elements to focus.\n   */\n  if (el.classList.contains('ion-focusable')) {\n    const app = el.closest('ion-app');\n    if (app) {\n      app.setFocus([el]);\n    }\n  }\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText;\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.getElementById(labelledBy)\n    : findItemLabel(componentEl);\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n    // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  }\n  else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      }\n      else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n      labelText = label.textContent;\n    }\n  }\n  return { label, labelId, labelText };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n    throw new Error(message);\n  }\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\nconst pointerCoord = (ev) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return { x: touch.clientX, y: touch.clientY };\n    }\n    if (ev.pageX !== undefined) {\n      return { x: ev.pageX, y: ev.pageY };\n    }\n  }\n  return { x: 0, y: 0 };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\nconst isEndSide = (side) => {\n  const isRTL = document.dir === 'rtl';\n  switch (side) {\n    case 'start': return isRTL;\n    case 'end': return !isRTL;\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n/**\n * Check whether the two string maps are shallow equal.\n *\n * undefined is treated as an empty map.\n *\n * @returns whether the keys are the same and the values are shallow equal.\n */\nconst shallowEqualStringMap = (map1, map2) => {\n  map1 !== null && map1 !== void 0 ? map1 : (map1 = {});\n  map2 !== null && map2 !== void 0 ? map2 : (map2 = {});\n  if (map1 === map2) {\n    return true;\n  }\n  const keys1 = Object.keys(map1);\n  if (keys1.length !== Object.keys(map2).length) {\n    return false;\n  }\n  for (const k1 of keys1) {\n    if (!(k1 in map2)) {\n      return false;\n    }\n    if (map1[k1] !== map2[k1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY1ODcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNFkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaGVscGVycy5qcz9lYzAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5jb25zdCB0cmFuc2l0aW9uRW5kQXN5bmMgPSAoZWwsIGV4cGVjdGVkRHVyYXRpb24gPSAwKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB0cmFuc2l0aW9uRW5kKGVsLCBleHBlY3RlZER1cmF0aW9uLCByZXNvbHZlKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBBbGxvd3MgZGV2ZWxvcGVyIHRvIHdhaXQgZm9yIGEgdHJhbnNpdGlvblxuICogdG8gZmluaXNoIGFuZCBmYWxsYmFjayB0byBhIHRpbWVyIGlmIHRoZVxuICogdHJhbnNpdGlvbiBpcyBjYW5jZWxsZWQgb3Igb3RoZXJ3aXNlXG4gKiBuZXZlciBmaW5pc2hlcy4gQWxzbyBzZWUgdHJhbnNpdGlvbkVuZEFzeW5jXG4gKiB3aGljaCBpcyBhbiBhd2FpdC1hYmxlIHZlcnNpb24gb2YgdGhpcy5cbiAqL1xuY29uc3QgdHJhbnNpdGlvbkVuZCA9IChlbCwgZXhwZWN0ZWREdXJhdGlvbiA9IDAsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCB1blJlZ1RyYW5zO1xuICBsZXQgYW5pbWF0aW9uVGltZW91dDtcbiAgY29uc3Qgb3B0cyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICBjb25zdCBBTklNQVRJT05fRkFMTEJBQ0tfVElNRU9VVCA9IDUwMDtcbiAgY29uc3QgdW5yZWdpc3RlciA9ICgpID0+IHtcbiAgICBpZiAodW5SZWdUcmFucykge1xuICAgICAgdW5SZWdUcmFucygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKGV2KSA9PiB7XG4gICAgaWYgKGV2ID09PSB1bmRlZmluZWQgfHwgZWwgPT09IGV2LnRhcmdldCkge1xuICAgICAgdW5yZWdpc3RlcigpO1xuICAgICAgY2FsbGJhY2soZXYpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgYW5pbWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQob25UcmFuc2l0aW9uRW5kLCBleHBlY3RlZER1cmF0aW9uICsgQU5JTUFUSU9OX0ZBTExCQUNLX1RJTUVPVVQpO1xuICAgIHVuUmVnVHJhbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICAgIGFuaW1hdGlvblRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBvblRyYW5zaXRpb25FbmQsIG9wdHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVucmVnaXN0ZXI7XG59O1xuLyoqXG4gKiBXYWl0cyBmb3IgYSBjb21wb25lbnQgdG8gYmUgcmVhZHkgZm9yXG4gKiBib3RoIGN1c3RvbSBlbGVtZW50IGFuZCBub24tY3VzdG9tIGVsZW1lbnQgYnVpbGRzLlxuICogSWYgbm9uLWN1c3RvbSBlbGVtZW50IGJ1aWxkLCBlbC5jb21wb25lbnRPblJlYWR5XG4gKiB3aWxsIGJlIHVzZWQuXG4gKiBGb3IgY3VzdG9tIGVsZW1lbnQgYnVpbGRzLCB3ZSB3YWl0IGEgZnJhbWVcbiAqIHNvIHRoYXQgdGhlIGlubmVyIGNvbnRlbnRzIG9mIHRoZSBjb21wb25lbnRcbiAqIGhhdmUgYSBjaGFuY2UgdG8gcmVuZGVyLlxuICpcbiAqIFVzZSB0aGlzIHV0aWxpdHkgcmF0aGVyIHRoYW4gY2FsbGluZ1xuICogZWwuY29tcG9uZW50T25SZWFkeSB5b3Vyc2VsZi5cbiAqL1xuY29uc3QgY29tcG9uZW50T25SZWFkeSA9IChlbCwgY2FsbGJhY2spID0+IHtcbiAgaWYgKGVsLmNvbXBvbmVudE9uUmVhZHkpIHtcbiAgICBlbC5jb21wb25lbnRPblJlYWR5KCkudGhlbigocmVzb2x2ZWRFbCkgPT4gY2FsbGJhY2socmVzb2x2ZWRFbCkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJhZigoKSA9PiBjYWxsYmFjayhlbCkpO1xuICB9XG59O1xuLyoqXG4gKiBFbGVtZW50cyBpbnNpZGUgb2Ygd2ViIGNvbXBvbmVudHMgc29tZXRpbWVzIG5lZWQgdG8gaW5oZXJpdCBnbG9iYWwgYXR0cmlidXRlc1xuICogc2V0IG9uIHRoZSBob3N0LiBGb3IgZXhhbXBsZSwgdGhlIGlubmVyIGlucHV0IGluIGBpb24taW5wdXRgIHNob3VsZCBpbmhlcml0XG4gKiB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgdGhhdCBkZXZlbG9wZXJzIHNldCBkaXJlY3RseSBvbiBgaW9uLWlucHV0YC4gVGhpc1xuICogaGVscGVyIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaW4gY29tcG9uZW50V2lsbExvYWQgYW5kIGFzc2lnbmVkIHRvIGEgdmFyaWFibGVcbiAqIHRoYXQgaXMgbGF0ZXIgdXNlZCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSByZWFjdGl2ZSBhcyBjaGFuZ2luZyBhdHRyaWJ1dGVzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAqIGRvZXMgbm90IHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gKi9cbmNvbnN0IGluaGVyaXRBdHRyaWJ1dGVzID0gKGVsLCBhdHRyaWJ1dGVzID0gW10pID0+IHtcbiAgY29uc3QgYXR0cmlidXRlT2JqZWN0ID0ge307XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVPYmplY3RbYXR0cl0gPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZU9iamVjdDtcbn07XG5jb25zdCBhZGRFdmVudExpc3RlbmVyID0gKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgICBjb25zdCBjb25maWcgPSB3aW4gJiYgd2luLklvbmljICYmIHdpbi5Jb25pYy5jb25maWc7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgY29uc3QgYWVsID0gY29uZmlnLmdldCgnX2FlbCcpO1xuICAgICAgaWYgKGFlbCkge1xuICAgICAgICByZXR1cm4gYWVsKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbmZpZy5fYWVsKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuX2FlbChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xufTtcbmNvbnN0IHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgIGNvbnN0IGNvbmZpZyA9IHdpbiAmJiB3aW4uSW9uaWMgJiYgd2luLklvbmljLmNvbmZpZztcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBjb25zdCByZWwgPSBjb25maWcuZ2V0KCdfcmVsJyk7XG4gICAgICBpZiAocmVsKSB7XG4gICAgICAgIHJldHVybiByZWwoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29uZmlnLl9yZWwpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5fcmVsKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSByb290IGNvbnRleHQgb2YgYSBzaGFkb3cgZG9tIGVsZW1lbnRcbiAqIE9uIG5ld2VyIGJyb3dzZXJzIHRoaXMgd2lsbCBiZSB0aGUgc2hhZG93Um9vdCxcbiAqIGJ1dCBmb3Igb2xkZXIgYnJvd3NlciB0aGlzIG1heSBqdXN0IGJlIHRoZVxuICogZWxlbWVudCBpdHNlbGYuXG4gKlxuICogVXNlZnVsIGZvciB3aGVuZXZlciB5b3UgbmVlZCB0byBleHBsaWNpdGx5XG4gKiBkbyBcIm15RWxlbWVudC5zaGFkb3dSb290IS5xdWVyeVNlbGVjdG9yKC4uLilcIi5cbiAqL1xuY29uc3QgZ2V0RWxlbWVudFJvb3QgPSAoZWwsIGZhbGxiYWNrID0gZWwpID0+IHtcbiAgcmV0dXJuIGVsLnNoYWRvd1Jvb3QgfHwgZmFsbGJhY2s7XG59O1xuLyoqXG4gKiBQYXRjaGVkIHZlcnNpb24gb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRoYXQgYXZvaWRzIG5nem9uZVxuICogVXNlIG9ubHkgd2hlbiB5b3Uga25vdyBuZ3pvbmUgc2hvdWxkIG5vdCBydW5cbiAqL1xuY29uc3QgcmFmID0gKGgpID0+IHtcbiAgaWYgKHR5cGVvZiBfX3pvbmVfc3ltYm9sX19yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgpO1xuICB9XG4gIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShoKTtcbiAgfVxuICByZXR1cm4gc2V0VGltZW91dChoKTtcbn07XG5jb25zdCBoYXNTaGFkb3dEb20gPSAoZWwpID0+IHtcbiAgcmV0dXJuICEhZWwuc2hhZG93Um9vdCAmJiAhIWVsLmF0dGFjaFNoYWRvdztcbn07XG5jb25zdCBmaW5kSXRlbUxhYmVsID0gKGNvbXBvbmVudEVsKSA9PiB7XG4gIGNvbnN0IGl0ZW1FbCA9IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1pdGVtJyk7XG4gIGlmIChpdGVtRWwpIHtcbiAgICByZXR1cm4gaXRlbUVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1sYWJlbCcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGZvY3VzRWxlbWVudCA9IChlbCkgPT4ge1xuICBlbC5mb2N1cygpO1xuICAvKipcbiAgICogV2hlbiBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzaW5nIGFuIGVsZW1lbnQsXG4gICAqIHRoZSBmb2N1cy12aXNpYmxlIHV0aWxpdHkgd2lsbCBub3QgcnVuIGJlY2F1c2VcbiAgICogaXQgaXMgZXhwZWN0aW5nIGEga2V5Ym9hcmQgZXZlbnQgdG8gaGF2ZSB0cmlnZ2VyZWQgdGhpcztcbiAgICogaG93ZXZlciwgdGhlcmUgYXJlIHRpbWVzIHdoZW4gd2UgbmVlZCB0byBtYW51YWxseSBjb250cm9sXG4gICAqIHRoaXMgYmVoYXZpb3Igc28gd2UgY2FsbCB0aGUgYHNldEZvY3VzYCBtZXRob2Qgb24gaW9uLWFwcFxuICAgKiB3aGljaCB3aWxsIGxldCB1cyBleHBsaWNpdGx5IHNldCB0aGUgZWxlbWVudHMgdG8gZm9jdXMuXG4gICAqL1xuICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdpb24tZm9jdXNhYmxlJykpIHtcbiAgICBjb25zdCBhcHAgPSBlbC5jbG9zZXN0KCdpb24tYXBwJyk7XG4gICAgaWYgKGFwcCkge1xuICAgICAgYXBwLnNldEZvY3VzKFtlbF0pO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgSW9uaWMncyBpbnB1dCBjb21wb25lbnRzIHRoYXQgdXNlIFNoYWRvdyBET00uIEluXG4gKiBvcmRlciB0byBwcm9wZXJseSBsYWJlbCB0aGUgaW5wdXRzIHRvIHdvcmsgd2l0aCBzY3JlZW4gcmVhZGVycywgd2UgbmVlZFxuICogdG8gZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGxhYmVsIG91dHNpZGUgb2YgdGhlIHNoYWRvdyByb290IGFuZCBwYXNzXG4gKiBpdCB0byB0aGUgaW5wdXQgaW5zaWRlIG9mIHRoZSBzaGFkb3cgcm9vdC5cbiAqXG4gKiBSZWZlcmVuY2luZyBsYWJlbCBlbGVtZW50cyBieSBpZCBmcm9tIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudCBpc1xuICogaW1wb3NzaWJsZSBkdWUgdG8gdGhlIHNoYWRvdyBib3VuZGFyeSwgcmVhZCBtb3JlIGhlcmU6XG4gKiBodHRwczovL2RldmVsb3Blci5zYWxlc2ZvcmNlLmNvbS9ibG9ncy8yMDIwLzAxL2FjY2Vzc2liaWxpdHktZm9yLXdlYi1jb21wb25lbnRzLmh0bWxcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50RWwgVGhlIHNoYWRvdyBlbGVtZW50IHRoYXQgbmVlZHMgdGhlIGFyaWEgbGFiZWxcbiAqIEBwYXJhbSBpbnB1dElkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGlucHV0XG4gKi9cbmNvbnN0IGdldEFyaWFMYWJlbCA9IChjb21wb25lbnRFbCwgaW5wdXRJZCkgPT4ge1xuICBsZXQgbGFiZWxUZXh0O1xuICAvLyBJZiB0aGUgdXNlciBwcm92aWRlcyB0aGVpciBvd24gbGFiZWwgdmlhIHRoZSBhcmlhLWxhYmVsbGVkYnkgYXR0clxuICAvLyB3ZSBzaG91bGQgdXNlIHRoYXQgaW5zdGVhZCBvZiBsb29raW5nIGZvciBhbiBpb24tbGFiZWxcbiAgY29uc3QgbGFiZWxsZWRCeSA9IGNvbXBvbmVudEVsLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gIC8vIEdyYWIgdGhlIGlkIG9mZiBvZiB0aGUgY29tcG9uZW50IGluIGNhc2UgdGhleSBhcmUgdXNpbmdcbiAgLy8gYSBjdXN0b20gbGFiZWwgdXNpbmcgdGhlIGxhYmVsIGVsZW1lbnRcbiAgY29uc3QgY29tcG9uZW50SWQgPSBjb21wb25lbnRFbC5pZDtcbiAgbGV0IGxhYmVsSWQgPSBsYWJlbGxlZEJ5ICE9PSBudWxsICYmIGxhYmVsbGVkQnkudHJpbSgpICE9PSAnJ1xuICAgID8gbGFiZWxsZWRCeVxuICAgIDogaW5wdXRJZCArICctbGJsJztcbiAgbGV0IGxhYmVsID0gbGFiZWxsZWRCeSAhPT0gbnVsbCAmJiBsYWJlbGxlZEJ5LnRyaW0oKSAhPT0gJydcbiAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsbGVkQnkpXG4gICAgOiBmaW5kSXRlbUxhYmVsKGNvbXBvbmVudEVsKTtcbiAgaWYgKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsbGVkQnkgPT09IG51bGwpIHtcbiAgICAgIGxhYmVsLmlkID0gbGFiZWxJZDtcbiAgICB9XG4gICAgbGFiZWxUZXh0ID0gbGFiZWwudGV4dENvbnRlbnQ7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gbGFiZWwsIGNoZWNrIHRvIHNlZSBpZiB0aGUgdXNlciBoYXMgcHJvdmlkZWRcbiAgICAvLyBvbmUgYnkgc2V0dGluZyBhbiBpZCBvbiB0aGUgY29tcG9uZW50IGFuZCB1c2luZyB0aGUgbGFiZWwgZWxlbWVudFxuICB9XG4gIGVsc2UgaWYgKGNvbXBvbmVudElkLnRyaW0oKSAhPT0gJycpIHtcbiAgICBsYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxhYmVsW2Zvcj1cIiR7Y29tcG9uZW50SWR9XCJdYCk7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBpZiAobGFiZWwuaWQgIT09ICcnKSB7XG4gICAgICAgIGxhYmVsSWQgPSBsYWJlbC5pZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsYWJlbC5pZCA9IGxhYmVsSWQgPSBgJHtjb21wb25lbnRJZH0tbGJsYDtcbiAgICAgIH1cbiAgICAgIGxhYmVsVGV4dCA9IGxhYmVsLnRleHRDb250ZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBsYWJlbCwgbGFiZWxJZCwgbGFiZWxUZXh0IH07XG59O1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFkZCBhIGhpZGRlbiBpbnB1dCB0byBhIGhvc3QgZWxlbWVudCB0aGF0IGNvbnRhaW5zXG4gKiBhIFNoYWRvdyBET00uIEl0IGRvZXMgbm90IGFkZCB0aGUgaW5wdXQgaW5zaWRlIG9mIHRoZSBTaGFkb3cgcm9vdCB3aGljaFxuICogYWxsb3dzIGl0IHRvIGJlIHBpY2tlZCB1cCBpbnNpZGUgb2YgZm9ybXMuIEl0IHNob3VsZCBjb250YWluIHRoZSBzYW1lXG4gKiB2YWx1ZXMgYXMgdGhlIGhvc3QgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gYWx3YXlzIEFkZCBhIGhpZGRlbiBpbnB1dCBldmVuIGlmIHRoZSBjb250YWluZXIgZG9lcyBub3QgdXNlIFNoYWRvd1xuICogQHBhcmFtIGNvbnRhaW5lciBUaGUgZWxlbWVudCB3aGVyZSB0aGUgaW5wdXQgd2lsbCBiZSBhZGRlZFxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIGRpc2FibGVkIElmIHRydWUsIHRoZSBpbnB1dCBpcyBkaXNhYmxlZFxuICovXG5jb25zdCByZW5kZXJIaWRkZW5JbnB1dCA9IChhbHdheXMsIGNvbnRhaW5lciwgbmFtZSwgdmFsdWUsIGRpc2FibGVkKSA9PiB7XG4gIGlmIChhbHdheXMgfHwgaGFzU2hhZG93RG9tKGNvbnRhaW5lcikpIHtcbiAgICBsZXQgaW5wdXQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXQuYXV4LWlucHV0Jyk7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgaW5wdXQgPSBjb250YWluZXIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgaW5wdXQudHlwZSA9ICdoaWRkZW4nO1xuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnYXV4LWlucHV0Jyk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIH1cbiAgICBpbnB1dC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIGlucHV0Lm5hbWUgPSBuYW1lO1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgfHwgJyc7XG4gIH1cbn07XG5jb25zdCBjbGFtcCA9IChtaW4sIG4sIG1heCkgPT4ge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihuLCBtYXgpKTtcbn07XG5jb25zdCBhc3NlcnQgPSAoYWN0dWFsLCByZWFzb24pID0+IHtcbiAgaWYgKCFhY3R1YWwpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gJ0FTU0VSVDogJyArIHJlYXNvbjtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIGRlYnVnZ2VyOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuY29uc3Qgbm93ID0gKGV2KSA9PiB7XG4gIHJldHVybiBldi50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn07XG5jb25zdCBwb2ludGVyQ29vcmQgPSAoZXYpID0+IHtcbiAgLy8gZ2V0IFggY29vcmRpbmF0ZXMgZm9yIGVpdGhlciBhIG1vdXNlIGNsaWNrXG4gIC8vIG9yIGEgdG91Y2ggZGVwZW5kaW5nIG9uIHRoZSBnaXZlbiBldmVudFxuICBpZiAoZXYpIHtcbiAgICBjb25zdCBjaGFuZ2VkVG91Y2hlcyA9IGV2LmNoYW5nZWRUb3VjaGVzO1xuICAgIGlmIChjaGFuZ2VkVG91Y2hlcyAmJiBjaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIHsgeDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WSB9O1xuICAgIH1cbiAgICBpZiAoZXYucGFnZVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgeDogZXYucGFnZVgsIHk6IGV2LnBhZ2VZIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqIEdpdmVuIGEgc2lkZSwgcmV0dXJuIGlmIGl0IHNob3VsZCBiZSBvbiB0aGUgZW5kXG4gKiBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgZGlyXG4gKiBAcGFyYW0gc2lkZSB0aGUgc2lkZVxuICogQHBhcmFtIGlzUlRMIHdoZXRoZXIgdGhlIGFwcGxpY2F0aW9uIGRpciBpcyBydGxcbiAqL1xuY29uc3QgaXNFbmRTaWRlID0gKHNpZGUpID0+IHtcbiAgY29uc3QgaXNSVEwgPSBkb2N1bWVudC5kaXIgPT09ICdydGwnO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICdzdGFydCc6IHJldHVybiBpc1JUTDtcbiAgICBjYXNlICdlbmQnOiByZXR1cm4gIWlzUlRMO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtzaWRlfVwiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBbc2lkZV0uIFVzZSBcInN0YXJ0XCIgb3IgXCJlbmRcIiBpbnN0ZWFkLmApO1xuICB9XG59O1xuY29uc3QgZGVib3VuY2VFdmVudCA9IChldmVudCwgd2FpdCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGV2ZW50Ll9vcmlnaW5hbCB8fCBldmVudDtcbiAgcmV0dXJuIHtcbiAgICBfb3JpZ2luYWw6IGV2ZW50LFxuICAgIGVtaXQ6IGRlYm91bmNlKG9yaWdpbmFsLmVtaXQuYmluZChvcmlnaW5hbCksIHdhaXQpXG4gIH07XG59O1xuY29uc3QgZGVib3VuY2UgPSAoZnVuYywgd2FpdCA9IDApID0+IHtcbiAgbGV0IHRpbWVyO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jLCB3YWl0LCAuLi5hcmdzKTtcbiAgfTtcbn07XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHR3byBzdHJpbmcgbWFwcyBhcmUgc2hhbGxvdyBlcXVhbC5cbiAqXG4gKiB1bmRlZmluZWQgaXMgdHJlYXRlZCBhcyBhbiBlbXB0eSBtYXAuXG4gKlxuICogQHJldHVybnMgd2hldGhlciB0aGUga2V5cyBhcmUgdGhlIHNhbWUgYW5kIHRoZSB2YWx1ZXMgYXJlIHNoYWxsb3cgZXF1YWwuXG4gKi9cbmNvbnN0IHNoYWxsb3dFcXVhbFN0cmluZ01hcCA9IChtYXAxLCBtYXAyKSA9PiB7XG4gIG1hcDEgIT09IG51bGwgJiYgbWFwMSAhPT0gdm9pZCAwID8gbWFwMSA6IChtYXAxID0ge30pO1xuICBtYXAyICE9PSBudWxsICYmIG1hcDIgIT09IHZvaWQgMCA/IG1hcDIgOiAobWFwMiA9IHt9KTtcbiAgaWYgKG1hcDEgPT09IG1hcDIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG1hcDEpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhtYXAyKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrMSBvZiBrZXlzMSkge1xuICAgIGlmICghKGsxIGluIG1hcDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXAxW2sxXSAhPT0gbWFwMltrMV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgeyBhZGRFdmVudExpc3RlbmVyIGFzIGEsIHJlbW92ZUV2ZW50TGlzdGVuZXIgYXMgYiwgY29tcG9uZW50T25SZWFkeSBhcyBjLCBnZXRBcmlhTGFiZWwgYXMgZCwgcmVuZGVySGlkZGVuSW5wdXQgYXMgZSwgZm9jdXNFbGVtZW50IGFzIGYsIGdldEVsZW1lbnRSb290IGFzIGcsIGhhc1NoYWRvd0RvbSBhcyBoLCBpbmhlcml0QXR0cmlidXRlcyBhcyBpLCBjbGFtcCBhcyBqLCBkZWJvdW5jZUV2ZW50IGFzIGssIGZpbmRJdGVtTGFiZWwgYXMgbCwgaXNFbmRTaWRlIGFzIG0sIGFzc2VydCBhcyBuLCBkZWJvdW5jZSBhcyBvLCBwb2ludGVyQ29vcmQgYXMgcCwgbm93IGFzIHEsIHJhZiBhcyByLCBzaGFsbG93RXF1YWxTdHJpbmdNYXAgYXMgcywgdHJhbnNpdGlvbkVuZEFzeW5jIGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96587\n")},55026:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"g\": () => (/* binding */ getIonPageElement),\n/* harmony export */   \"t\": () => (/* binding */ transition)\n/* harmony export */ });\n/* unused harmony exports L, a, b, c, d, e, l, s */\n/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77210);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';\nconst LIFECYCLE_DID_ENTER = 'ionViewDidEnter';\nconst LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';\nconst LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';\nconst LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';\n\nconst iosTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(6338)]).then(__webpack_require__.bind(__webpack_require__, 56338));\nconst mdTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(4753)]).then(__webpack_require__.bind(__webpack_require__, 74753));\nconst transition = (opts) => {\n  return new Promise((resolve, reject) => {\n    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .writeTask */ .Iu)(() => {\n      beforeTransition(opts);\n      runTransition(opts).then(result => {\n        if (result.animation) {\n          result.animation.destroy();\n        }\n        afterTransition(opts);\n        resolve(result);\n      }, error => {\n        afterTransition(opts);\n        reject(error);\n      });\n    });\n  });\n};\nconst beforeTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  setZIndex(enteringEl, leavingEl, opts.direction);\n  if (opts.showGoBack) {\n    enteringEl.classList.add('can-go-back');\n  }\n  else {\n    enteringEl.classList.remove('can-go-back');\n  }\n  setPageHidden(enteringEl, false);\n  /**\n   * When transitioning, the page should not\n   * respond to click events. This resolves small\n   * issues like users double tapping the ion-back-button.\n   * These pointer events are removed in `afterTransition`.\n   */\n  enteringEl.style.setProperty('pointer-events', 'none');\n  if (leavingEl) {\n    setPageHidden(leavingEl, false);\n    leavingEl.style.setProperty('pointer-events', 'none');\n  }\n};\nconst runTransition = async (opts) => {\n  const animationBuilder = await getAnimationBuilder(opts);\n  const ani = (animationBuilder && _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .Build.isBrowser */ .Z5.isBrowser)\n    ? animation(animationBuilder, opts)\n    : noAnimation(opts); // fast path for no animation\n  return ani;\n};\nconst afterTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  enteringEl.classList.remove('ion-page-invisible');\n  enteringEl.style.removeProperty('pointer-events');\n  if (leavingEl !== undefined) {\n    leavingEl.classList.remove('ion-page-invisible');\n    leavingEl.style.removeProperty('pointer-events');\n  }\n};\nconst getAnimationBuilder = async (opts) => {\n  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {\n    return undefined;\n  }\n  if (opts.animationBuilder) {\n    return opts.animationBuilder;\n  }\n  const getAnimation = (opts.mode === 'ios')\n    ? (await iosTransitionAnimation()).iosTransitionAnimation\n    : (await mdTransitionAnimation()).mdTransitionAnimation;\n  return getAnimation;\n};\nconst animation = async (animationBuilder, opts) => {\n  await waitForReady(opts, true);\n  const trans = animationBuilder(opts.baseEl, opts);\n  fireWillEvents(opts.enteringEl, opts.leavingEl);\n  const didComplete = await playTransition(trans, opts);\n  if (opts.progressCallback) {\n    opts.progressCallback(undefined);\n  }\n  if (didComplete) {\n    fireDidEvents(opts.enteringEl, opts.leavingEl);\n  }\n  return {\n    hasCompleted: didComplete,\n    animation: trans\n  };\n};\nconst noAnimation = async (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  await waitForReady(opts, false);\n  fireWillEvents(enteringEl, leavingEl);\n  fireDidEvents(enteringEl, leavingEl);\n  return {\n    hasCompleted: true\n  };\n};\nconst waitForReady = async (opts, defaultDeep) => {\n  const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;\n  const promises = deep ? [\n    deepReady(opts.enteringEl),\n    deepReady(opts.leavingEl),\n  ] : [\n    shallowReady(opts.enteringEl),\n    shallowReady(opts.leavingEl),\n  ];\n  await Promise.all(promises);\n  await notifyViewReady(opts.viewIsReady, opts.enteringEl);\n};\nconst notifyViewReady = async (viewIsReady, enteringEl) => {\n  if (viewIsReady) {\n    await viewIsReady(enteringEl);\n  }\n};\nconst playTransition = (trans, opts) => {\n  const progressCallback = opts.progressCallback;\n  const promise = new Promise(resolve => {\n    trans.onFinish((currentStep) => resolve(currentStep === 1));\n  });\n  // cool, let's do this, start the transition\n  if (progressCallback) {\n    // this is a swipe to go back, just get the transition progress ready\n    // kick off the swipe animation start\n    trans.progressStart(true);\n    progressCallback(trans);\n  }\n  else {\n    // only the top level transition should actually start \"play\"\n    // kick it off and let it play through\n    // ******** DOM WRITE ****************\n    trans.play();\n  }\n  // create a callback for when the animation is done\n  return promise;\n};\nconst fireWillEvents = (enteringEl, leavingEl) => {\n  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);\n  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);\n};\nconst fireDidEvents = (enteringEl, leavingEl) => {\n  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);\n  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);\n};\nconst lifecycle = (el, eventName) => {\n  if (el) {\n    const ev = new CustomEvent(eventName, {\n      bubbles: false,\n      cancelable: false,\n    });\n    el.dispatchEvent(ev);\n  }\n};\nconst shallowReady = (el) => {\n  if (el) {\n    return new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, resolve));\n  }\n  return Promise.resolve();\n};\nconst deepReady = async (el) => {\n  const element = el;\n  if (element) {\n    if (element.componentOnReady != null) {\n      const stencilEl = await element.componentOnReady();\n      if (stencilEl != null) {\n        return;\n      }\n      /**\n       * Custom elements in Stencil will have __registerHost.\n       */\n    }\n    else if (element.__registerHost != null) {\n      /**\n       * Non-lazy loaded custom elements need to wait\n       * one frame for component to be loaded.\n       */\n      const waitForCustomElement = new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.r)(resolve));\n      await waitForCustomElement;\n      return;\n    }\n    await Promise.all(Array.from(element.children).map(deepReady));\n  }\n};\nconst setPageHidden = (el, hidden) => {\n  if (hidden) {\n    el.setAttribute('aria-hidden', 'true');\n    el.classList.add('ion-page-hidden');\n  }\n  else {\n    el.hidden = false;\n    el.removeAttribute('aria-hidden');\n    el.classList.remove('ion-page-hidden');\n  }\n};\nconst setZIndex = (enteringEl, leavingEl, direction) => {\n  if (enteringEl !== undefined) {\n    enteringEl.style.zIndex = (direction === 'back')\n      ? '99'\n      : '101';\n  }\n  if (leavingEl !== undefined) {\n    leavingEl.style.zIndex = '100';\n  }\n};\nconst getIonPageElement = (element) => {\n  if (element.classList.contains('ion-page')) {\n    return element;\n  }\n  const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');\n  if (ionPage) {\n    return ionPage;\n  }\n  // idk, return the original element so at least something animates and we don't have a null pointer\n  return element;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUwMjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNpRTtBQUNGOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxnSkFBNkI7QUFDbEUsb0NBQW9DLGdKQUE0QjtBQUNoRTtBQUNBO0FBQ0EsSUFBSSxrRkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhGQUFlO0FBQ2xEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDhDQUFHO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2luZGV4NC5qcz82NzlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyB3cml0ZVRhc2ssIEJ1aWxkIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYyBhcyBjb21wb25lbnRPblJlYWR5LCByIGFzIHJhZiB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmNvbnN0IExJRkVDWUNMRV9XSUxMX0VOVEVSID0gJ2lvblZpZXdXaWxsRW50ZXInO1xuY29uc3QgTElGRUNZQ0xFX0RJRF9FTlRFUiA9ICdpb25WaWV3RGlkRW50ZXInO1xuY29uc3QgTElGRUNZQ0xFX1dJTExfTEVBVkUgPSAnaW9uVmlld1dpbGxMZWF2ZSc7XG5jb25zdCBMSUZFQ1lDTEVfRElEX0xFQVZFID0gJ2lvblZpZXdEaWRMZWF2ZSc7XG5jb25zdCBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQgPSAnaW9uVmlld1dpbGxVbmxvYWQnO1xuXG5jb25zdCBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uID0gKCkgPT4gaW1wb3J0KCcuL2lvcy50cmFuc2l0aW9uLmpzJyk7XG5jb25zdCBtZFRyYW5zaXRpb25BbmltYXRpb24gPSAoKSA9PiBpbXBvcnQoJy4vbWQudHJhbnNpdGlvbi5qcycpO1xuY29uc3QgdHJhbnNpdGlvbiA9IChvcHRzKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgIGJlZm9yZVRyYW5zaXRpb24ob3B0cyk7XG4gICAgICBydW5UcmFuc2l0aW9uKG9wdHMpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5hbmltYXRpb24pIHtcbiAgICAgICAgICByZXN1bHQuYW5pbWF0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBhZnRlclRyYW5zaXRpb24ob3B0cyk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgYWZ0ZXJUcmFuc2l0aW9uKG9wdHMpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmNvbnN0IGJlZm9yZVRyYW5zaXRpb24gPSAob3B0cykgPT4ge1xuICBjb25zdCBlbnRlcmluZ0VsID0gb3B0cy5lbnRlcmluZ0VsO1xuICBjb25zdCBsZWF2aW5nRWwgPSBvcHRzLmxlYXZpbmdFbDtcbiAgc2V0WkluZGV4KGVudGVyaW5nRWwsIGxlYXZpbmdFbCwgb3B0cy5kaXJlY3Rpb24pO1xuICBpZiAob3B0cy5zaG93R29CYWNrKSB7XG4gICAgZW50ZXJpbmdFbC5jbGFzc0xpc3QuYWRkKCdjYW4tZ28tYmFjaycpO1xuICB9XG4gIGVsc2Uge1xuICAgIGVudGVyaW5nRWwuY2xhc3NMaXN0LnJlbW92ZSgnY2FuLWdvLWJhY2snKTtcbiAgfVxuICBzZXRQYWdlSGlkZGVuKGVudGVyaW5nRWwsIGZhbHNlKTtcbiAgLyoqXG4gICAqIFdoZW4gdHJhbnNpdGlvbmluZywgdGhlIHBhZ2Ugc2hvdWxkIG5vdFxuICAgKiByZXNwb25kIHRvIGNsaWNrIGV2ZW50cy4gVGhpcyByZXNvbHZlcyBzbWFsbFxuICAgKiBpc3N1ZXMgbGlrZSB1c2VycyBkb3VibGUgdGFwcGluZyB0aGUgaW9uLWJhY2stYnV0dG9uLlxuICAgKiBUaGVzZSBwb2ludGVyIGV2ZW50cyBhcmUgcmVtb3ZlZCBpbiBgYWZ0ZXJUcmFuc2l0aW9uYC5cbiAgICovXG4gIGVudGVyaW5nRWwuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgaWYgKGxlYXZpbmdFbCkge1xuICAgIHNldFBhZ2VIaWRkZW4obGVhdmluZ0VsLCBmYWxzZSk7XG4gICAgbGVhdmluZ0VsLnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG4gIH1cbn07XG5jb25zdCBydW5UcmFuc2l0aW9uID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IGF3YWl0IGdldEFuaW1hdGlvbkJ1aWxkZXIob3B0cyk7XG4gIGNvbnN0IGFuaSA9IChhbmltYXRpb25CdWlsZGVyICYmIEJ1aWxkLmlzQnJvd3NlcilcbiAgICA/IGFuaW1hdGlvbihhbmltYXRpb25CdWlsZGVyLCBvcHRzKVxuICAgIDogbm9BbmltYXRpb24ob3B0cyk7IC8vIGZhc3QgcGF0aCBmb3Igbm8gYW5pbWF0aW9uXG4gIHJldHVybiBhbmk7XG59O1xuY29uc3QgYWZ0ZXJUcmFuc2l0aW9uID0gKG9wdHMpID0+IHtcbiAgY29uc3QgZW50ZXJpbmdFbCA9IG9wdHMuZW50ZXJpbmdFbDtcbiAgY29uc3QgbGVhdmluZ0VsID0gb3B0cy5sZWF2aW5nRWw7XG4gIGVudGVyaW5nRWwuY2xhc3NMaXN0LnJlbW92ZSgnaW9uLXBhZ2UtaW52aXNpYmxlJyk7XG4gIGVudGVyaW5nRWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJyk7XG4gIGlmIChsZWF2aW5nRWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGxlYXZpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdpb24tcGFnZS1pbnZpc2libGUnKTtcbiAgICBsZWF2aW5nRWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJyk7XG4gIH1cbn07XG5jb25zdCBnZXRBbmltYXRpb25CdWlsZGVyID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgaWYgKCFvcHRzLmxlYXZpbmdFbCB8fCAhb3B0cy5hbmltYXRlZCB8fCBvcHRzLmR1cmF0aW9uID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAob3B0cy5hbmltYXRpb25CdWlsZGVyKSB7XG4gICAgcmV0dXJuIG9wdHMuYW5pbWF0aW9uQnVpbGRlcjtcbiAgfVxuICBjb25zdCBnZXRBbmltYXRpb24gPSAob3B0cy5tb2RlID09PSAnaW9zJylcbiAgICA/IChhd2FpdCBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uKCkpLmlvc1RyYW5zaXRpb25BbmltYXRpb25cbiAgICA6IChhd2FpdCBtZFRyYW5zaXRpb25BbmltYXRpb24oKSkubWRUcmFuc2l0aW9uQW5pbWF0aW9uO1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uO1xufTtcbmNvbnN0IGFuaW1hdGlvbiA9IGFzeW5jIChhbmltYXRpb25CdWlsZGVyLCBvcHRzKSA9PiB7XG4gIGF3YWl0IHdhaXRGb3JSZWFkeShvcHRzLCB0cnVlKTtcbiAgY29uc3QgdHJhbnMgPSBhbmltYXRpb25CdWlsZGVyKG9wdHMuYmFzZUVsLCBvcHRzKTtcbiAgZmlyZVdpbGxFdmVudHMob3B0cy5lbnRlcmluZ0VsLCBvcHRzLmxlYXZpbmdFbCk7XG4gIGNvbnN0IGRpZENvbXBsZXRlID0gYXdhaXQgcGxheVRyYW5zaXRpb24odHJhbnMsIG9wdHMpO1xuICBpZiAob3B0cy5wcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgb3B0cy5wcm9ncmVzc0NhbGxiYWNrKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKGRpZENvbXBsZXRlKSB7XG4gICAgZmlyZURpZEV2ZW50cyhvcHRzLmVudGVyaW5nRWwsIG9wdHMubGVhdmluZ0VsKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhc0NvbXBsZXRlZDogZGlkQ29tcGxldGUsXG4gICAgYW5pbWF0aW9uOiB0cmFuc1xuICB9O1xufTtcbmNvbnN0IG5vQW5pbWF0aW9uID0gYXN5bmMgKG9wdHMpID0+IHtcbiAgY29uc3QgZW50ZXJpbmdFbCA9IG9wdHMuZW50ZXJpbmdFbDtcbiAgY29uc3QgbGVhdmluZ0VsID0gb3B0cy5sZWF2aW5nRWw7XG4gIGF3YWl0IHdhaXRGb3JSZWFkeShvcHRzLCBmYWxzZSk7XG4gIGZpcmVXaWxsRXZlbnRzKGVudGVyaW5nRWwsIGxlYXZpbmdFbCk7XG4gIGZpcmVEaWRFdmVudHMoZW50ZXJpbmdFbCwgbGVhdmluZ0VsKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNDb21wbGV0ZWQ6IHRydWVcbiAgfTtcbn07XG5jb25zdCB3YWl0Rm9yUmVhZHkgPSBhc3luYyAob3B0cywgZGVmYXVsdERlZXApID0+IHtcbiAgY29uc3QgZGVlcCA9IG9wdHMuZGVlcFdhaXQgIT09IHVuZGVmaW5lZCA/IG9wdHMuZGVlcFdhaXQgOiBkZWZhdWx0RGVlcDtcbiAgY29uc3QgcHJvbWlzZXMgPSBkZWVwID8gW1xuICAgIGRlZXBSZWFkeShvcHRzLmVudGVyaW5nRWwpLFxuICAgIGRlZXBSZWFkeShvcHRzLmxlYXZpbmdFbCksXG4gIF0gOiBbXG4gICAgc2hhbGxvd1JlYWR5KG9wdHMuZW50ZXJpbmdFbCksXG4gICAgc2hhbGxvd1JlYWR5KG9wdHMubGVhdmluZ0VsKSxcbiAgXTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICBhd2FpdCBub3RpZnlWaWV3UmVhZHkob3B0cy52aWV3SXNSZWFkeSwgb3B0cy5lbnRlcmluZ0VsKTtcbn07XG5jb25zdCBub3RpZnlWaWV3UmVhZHkgPSBhc3luYyAodmlld0lzUmVhZHksIGVudGVyaW5nRWwpID0+IHtcbiAgaWYgKHZpZXdJc1JlYWR5KSB7XG4gICAgYXdhaXQgdmlld0lzUmVhZHkoZW50ZXJpbmdFbCk7XG4gIH1cbn07XG5jb25zdCBwbGF5VHJhbnNpdGlvbiA9ICh0cmFucywgb3B0cykgPT4ge1xuICBjb25zdCBwcm9ncmVzc0NhbGxiYWNrID0gb3B0cy5wcm9ncmVzc0NhbGxiYWNrO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgdHJhbnMub25GaW5pc2goKGN1cnJlbnRTdGVwKSA9PiByZXNvbHZlKGN1cnJlbnRTdGVwID09PSAxKSk7XG4gIH0pO1xuICAvLyBjb29sLCBsZXQncyBkbyB0aGlzLCBzdGFydCB0aGUgdHJhbnNpdGlvblxuICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIC8vIHRoaXMgaXMgYSBzd2lwZSB0byBnbyBiYWNrLCBqdXN0IGdldCB0aGUgdHJhbnNpdGlvbiBwcm9ncmVzcyByZWFkeVxuICAgIC8vIGtpY2sgb2ZmIHRoZSBzd2lwZSBhbmltYXRpb24gc3RhcnRcbiAgICB0cmFucy5wcm9ncmVzc1N0YXJ0KHRydWUpO1xuICAgIHByb2dyZXNzQ2FsbGJhY2sodHJhbnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG9ubHkgdGhlIHRvcCBsZXZlbCB0cmFuc2l0aW9uIHNob3VsZCBhY3R1YWxseSBzdGFydCBcInBsYXlcIlxuICAgIC8vIGtpY2sgaXQgb2ZmIGFuZCBsZXQgaXQgcGxheSB0aHJvdWdoXG4gICAgLy8gKioqKioqKiogRE9NIFdSSVRFICoqKioqKioqKioqKioqKipcbiAgICB0cmFucy5wbGF5KCk7XG4gIH1cbiAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBkb25lXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IGZpcmVXaWxsRXZlbnRzID0gKGVudGVyaW5nRWwsIGxlYXZpbmdFbCkgPT4ge1xuICBsaWZlY3ljbGUobGVhdmluZ0VsLCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSk7XG4gIGxpZmVjeWNsZShlbnRlcmluZ0VsLCBMSUZFQ1lDTEVfV0lMTF9FTlRFUik7XG59O1xuY29uc3QgZmlyZURpZEV2ZW50cyA9IChlbnRlcmluZ0VsLCBsZWF2aW5nRWwpID0+IHtcbiAgbGlmZWN5Y2xlKGVudGVyaW5nRWwsIExJRkVDWUNMRV9ESURfRU5URVIpO1xuICBsaWZlY3ljbGUobGVhdmluZ0VsLCBMSUZFQ1lDTEVfRElEX0xFQVZFKTtcbn07XG5jb25zdCBsaWZlY3ljbGUgPSAoZWwsIGV2ZW50TmFtZSkgPT4ge1xuICBpZiAoZWwpIHtcbiAgICBjb25zdCBldiA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChldik7XG4gIH1cbn07XG5jb25zdCBzaGFsbG93UmVhZHkgPSAoZWwpID0+IHtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShlbCwgcmVzb2x2ZSkpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5jb25zdCBkZWVwUmVhZHkgPSBhc3luYyAoZWwpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGVsO1xuICBpZiAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmNvbXBvbmVudE9uUmVhZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RlbmNpbEVsID0gYXdhaXQgZWxlbWVudC5jb21wb25lbnRPblJlYWR5KCk7XG4gICAgICBpZiAoc3RlbmNpbEVsICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDdXN0b20gZWxlbWVudHMgaW4gU3RlbmNpbCB3aWxsIGhhdmUgX19yZWdpc3Rlckhvc3QuXG4gICAgICAgKi9cbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudC5fX3JlZ2lzdGVySG9zdCAhPSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIE5vbi1sYXp5IGxvYWRlZCBjdXN0b20gZWxlbWVudHMgbmVlZCB0byB3YWl0XG4gICAgICAgKiBvbmUgZnJhbWUgZm9yIGNvbXBvbmVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHdhaXRGb3JDdXN0b21FbGVtZW50ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByYWYocmVzb2x2ZSkpO1xuICAgICAgYXdhaXQgd2FpdEZvckN1c3RvbUVsZW1lbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikubWFwKGRlZXBSZWFkeSkpO1xuICB9XG59O1xuY29uc3Qgc2V0UGFnZUhpZGRlbiA9IChlbCwgaGlkZGVuKSA9PiB7XG4gIGlmIChoaWRkZW4pIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdpb24tcGFnZS1oaWRkZW4nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnaW9uLXBhZ2UtaGlkZGVuJyk7XG4gIH1cbn07XG5jb25zdCBzZXRaSW5kZXggPSAoZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBkaXJlY3Rpb24pID0+IHtcbiAgaWYgKGVudGVyaW5nRWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGVudGVyaW5nRWwuc3R5bGUuekluZGV4ID0gKGRpcmVjdGlvbiA9PT0gJ2JhY2snKVxuICAgICAgPyAnOTknXG4gICAgICA6ICcxMDEnO1xuICB9XG4gIGlmIChsZWF2aW5nRWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGxlYXZpbmdFbC5zdHlsZS56SW5kZXggPSAnMTAwJztcbiAgfVxufTtcbmNvbnN0IGdldElvblBhZ2VFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdpb24tcGFnZScpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgY29uc3QgaW9uUGFnZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gLmlvbi1wYWdlLCA6c2NvcGUgPiBpb24tbmF2LCA6c2NvcGUgPiBpb24tdGFicycpO1xuICBpZiAoaW9uUGFnZSkge1xuICAgIHJldHVybiBpb25QYWdlO1xuICB9XG4gIC8vIGlkaywgcmV0dXJuIHRoZSBvcmlnaW5hbCBlbGVtZW50IHNvIGF0IGxlYXN0IHNvbWV0aGluZyBhbmltYXRlcyBhbmQgd2UgZG9uJ3QgaGF2ZSBhIG51bGwgcG9pbnRlclxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmV4cG9ydCB7IExJRkVDWUNMRV9XSUxMX0VOVEVSIGFzIEwsIExJRkVDWUNMRV9ESURfRU5URVIgYXMgYSwgTElGRUNZQ0xFX1dJTExfTEVBVkUgYXMgYiwgTElGRUNZQ0xFX0RJRF9MRUFWRSBhcyBjLCBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQgYXMgZCwgZGVlcFJlYWR5IGFzIGUsIGdldElvblBhZ2VFbGVtZW50IGFzIGcsIGxpZmVjeWNsZSBhcyBsLCBzZXRQYWdlSGlkZGVuIGFzIHMsIHRyYW5zaXRpb24gYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55026\n")},27434:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ createAnimation)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70655);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var animationPrefix;var processKeyframes=function(e){e.forEach((function(e){for(var n in e){if(e.hasOwnProperty(n)){var r=e[n];if(n==="easing"){var t="animation-timing-function";e[t]=r;delete e[n]}else{var t=convertCamelCaseToHypen(n);if(t!==n){e[t]=r;delete e[n]}}}}}));return e};var convertCamelCaseToHypen=function(e){return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()};var getAnimationPrefix=function(e){if(animationPrefix===undefined){var n=e.style.animationName!==undefined;var r=e.style.webkitAnimationName!==undefined;animationPrefix=!n&&r?"-webkit-":""}return animationPrefix};var setStyleProperty=function(e,n,r){var t=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.setProperty(t+n,r)};var removeStyleProperty=function(e,n){var r=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.removeProperty(r+n)};var animationEnd=function(e,n){var r;var t={passive:true};var a=function(){if(r){r()}};var i=function(r){if(e===r.target){a();n(r)}};if(e){e.addEventListener("webkitAnimationEnd",i,t);e.addEventListener("animationend",i,t);r=function(){e.removeEventListener("webkitAnimationEnd",i,t);e.removeEventListener("animationend",i,t)}}return a};var generateKeyframeRules=function(e){if(e===void 0){e=[]}return e.map((function(e){var n=e.offset;var r=[];for(var t in e){if(e.hasOwnProperty(t)&&t!=="offset"){r.push("".concat(t,": ").concat(e[t],";"))}}return"".concat(n*100,"% { ").concat(r.join(" ")," }")})).join(" ")};var keyframeIds=[];var generateKeyframeName=function(e){var n=keyframeIds.indexOf(e);if(n<0){n=keyframeIds.push(e)-1}return"ion-animation-".concat(n)};var getStyleContainer=function(e){var n=e.getRootNode();return n.head||n};var createKeyframeStylesheet=function(e,n,r){var t=getStyleContainer(r);var a=getAnimationPrefix(r);var i=t.querySelector("#"+e);if(i){return i}var o=(r.ownerDocument||document).createElement("style");o.id=e;o.textContent="@".concat(a,"keyframes ").concat(e," { ").concat(n," } @").concat(a,"keyframes ").concat(e,"-alt { ").concat(n," }");t.appendChild(o);return o};var addClassToArray=function(e,n){if(e===void 0){e=[]}if(n!==undefined){var r=Array.isArray(n)?n:[n];return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e,true),r,true)}return e};var createAnimation=function(e){var n;var r;var t;var a;var i;var o;var f=[];var u=[];var c=[];var s=false;var v;var l={};var d=[];var y=[];var m={};var p=0;var h=false;var g=false;var E;var P;var S;var A;var C=true;var T=false;var b=true;var k;var w;var x=e;var K=[];var _=[];var I=[];var D=[];var L=[];var N=[];var R=[];var F=[];var O=[];var W=[];var j=typeof AnimationEffect==="function"||typeof window.AnimationEffect==="function";var H=typeof Element==="function"&&typeof Element.prototype.animate==="function"&&j;var M=100;var $=function(){return W};var q=function(e){D.forEach((function(n){n.destroy(e)}));z(e);I.length=0;D.length=0;f.length=0;G();s=false;b=true;return w};var z=function(e){J();if(e){Q()}};var Z=function(){h=false;g=false;b=true;P=undefined;S=undefined;A=undefined;p=0;T=false;C=true};var B=function(e,n){var r=n&&n.oneTimeCallback?_:K;r.push({c:e,o:n});return w};var G=function(){K.length=0;_.length=0;return w};var J=function(){if(H){W.forEach((function(e){e.cancel()}));W.length=0}else{var e=I.slice();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){e.forEach((function(e){removeStyleProperty(e,"animation-name");removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-timing-function");removeStyleProperty(e,"animation-iteration-count");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state");removeStyleProperty(e,"animation-fill-mode");removeStyleProperty(e,"animation-direction")}))}))}};var Q=function(){L.forEach((function(e){if(e&&e.parentNode){e.parentNode.removeChild(e)}}));L.length=0};var U=function(e){N.push(e);return w};var V=function(e){R.push(e);return w};var X=function(e){F.push(e);return w};var Y=function(e){O.push(e);return w};var ee=function(e){u=addClassToArray(u,e);return w};var ne=function(e){c=addClassToArray(c,e);return w};var re=function(e){if(e===void 0){e={}}l=e;return w};var te=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];l[t]=""}return w};var ae=function(e){d=addClassToArray(d,e);return w};var ie=function(e){y=addClassToArray(y,e);return w};var oe=function(e){if(e===void 0){e={}}m=e;return w};var fe=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];m[t]=""}return w};var ue=function(){if(i!==undefined){return i}if(v){return v.getFill()}return"both"};var ce=function(){if(P!==undefined){return P}if(o!==undefined){return o}if(v){return v.getDirection()}return"normal"};var se=function(){if(h){return"linear"}if(t!==undefined){return t}if(v){return v.getEasing()}return"linear"};var ve=function(){if(g){return 0}if(S!==undefined){return S}if(r!==undefined){return r}if(v){return v.getDuration()}return 0};var le=function(){if(a!==undefined){return a}if(v){return v.getIterations()}return 1};var de=function(){if(A!==undefined){return A}if(n!==undefined){return n}if(v){return v.getDelay()}return 0};var ye=function(){return f};var me=function(e){o=e;Re(true);return w};var pe=function(e){i=e;Re(true);return w};var he=function(e){n=e;Re(true);return w};var ge=function(e){t=e;Re(true);return w};var Ee=function(e){if(!H&&e===0){e=1}r=e;Re(true);return w};var Pe=function(e){a=e;Re(true);return w};var Se=function(e){v=e;return w};var Ae=function(e){if(e!=null){if(e.nodeType===1){I.push(e)}else if(e.length>=0){for(var n=0;n<e.length;n++){I.push(e[n])}}else{console.error("Invalid addElement value")}}return w};var Ce=function(e){if(e!=null){if(Array.isArray(e)){for(var n=0,r=e;n<r.length;n++){var t=r[n];t.parent(w);D.push(t)}}else{e.parent(w);D.push(e)}}return w};var Te=function(e){var n=f!==e;f=e;if(n){be(f)}return w};var be=function(e){if(H){$().forEach((function(n){if(n.effect.setKeyframes){n.effect.setKeyframes(e)}else{var r=new KeyframeEffect(n.effect.target,e,n.effect.getTiming());n.effect=r}}))}else{Ke()}};var ke=function(){N.forEach((function(e){return e()}));R.forEach((function(e){return e()}));var e=u;var n=c;var r=l;I.forEach((function(t){var a=t.classList;e.forEach((function(e){return a.add(e)}));n.forEach((function(e){return a.remove(e)}));for(var i in r){if(r.hasOwnProperty(i)){setStyleProperty(t,i,r[i])}}}))};var we=function(){$e();F.forEach((function(e){return e()}));O.forEach((function(e){return e()}));var e=C?1:0;var n=d;var r=y;var t=m;I.forEach((function(e){var a=e.classList;n.forEach((function(e){return a.add(e)}));r.forEach((function(e){return a.remove(e)}));for(var i in t){if(t.hasOwnProperty(i)){setStyleProperty(e,i,t[i])}}}));K.forEach((function(n){return n.c(e,w)}));_.forEach((function(n){return n.c(e,w)}));_.length=0;b=true;if(C){T=true}C=true};var xe=function(){if(p===0){return}p--;if(p===0){we();if(v){v.animationFinish()}}};var Ke=function(n){if(n===void 0){n=true}Q();var r=processKeyframes(f);I.forEach((function(t){if(r.length>0){var a=generateKeyframeRules(r);k=e!==undefined?e:generateKeyframeName(a);var i=createKeyframeStylesheet(k,a,t);L.push(i);setStyleProperty(t,"animation-duration","".concat(ve(),"ms"));setStyleProperty(t,"animation-timing-function",se());setStyleProperty(t,"animation-delay","".concat(de(),"ms"));setStyleProperty(t,"animation-fill-mode",ue());setStyleProperty(t,"animation-direction",ce());var o=le()===Infinity?"infinite":le().toString();setStyleProperty(t,"animation-iteration-count",o);setStyleProperty(t,"animation-play-state","paused");if(n){setStyleProperty(t,"animation-name","".concat(i.id,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(t,"animation-name",i.id||null)}))}}))};var _e=function(){I.forEach((function(e){var n=e.animate(f,{id:x,delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()});n.pause();W.push(n)}));if(W.length>0){W[0].onfinish=function(){xe()}}};var Ie=function(e){if(e===void 0){e=true}ke();if(f.length>0){if(H){_e()}else{Ke(e)}}s=true};var De=function(e){e=Math.min(Math.max(e,0),.9999);if(H){W.forEach((function(n){n.currentTime=n.effect.getComputedTiming().delay+ve()*e;n.pause()}))}else{var n="-".concat(ve()*e,"ms");I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-delay",n);setStyleProperty(e,"animation-play-state","paused")}}))}};var Le=function(e){W.forEach((function(e){e.effect.updateTiming({delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()})}));if(e!==undefined){De(e)}};var Ne=function(e,n){if(e===void 0){e=true}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(r){setStyleProperty(r,"animation-name",k||null);setStyleProperty(r,"animation-duration","".concat(ve(),"ms"));setStyleProperty(r,"animation-timing-function",se());setStyleProperty(r,"animation-delay",n!==undefined?"-".concat(n*ve(),"ms"):"".concat(de(),"ms"));setStyleProperty(r,"animation-fill-mode",ue()||null);setStyleProperty(r,"animation-direction",ce()||null);var t=le()===Infinity?"infinite":le().toString();setStyleProperty(r,"animation-iteration-count",t);if(e){setStyleProperty(r,"animation-name","".concat(k,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(r,"animation-name",k||null)}))}))}))};var Re=function(e,n,r){if(e===void 0){e=false}if(n===void 0){n=true}if(e){D.forEach((function(t){t.update(e,n,r)}))}if(H){Le(r)}else{Ne(n,r)}return w};var Fe=function(e,n){if(e===void 0){e=false}D.forEach((function(r){r.progressStart(e,n)}));je();h=e;if(!s){Ie()}Re(false,true,n);return w};var Oe=function(e){D.forEach((function(n){n.progressStep(e)}));De(e);return w};var We=function(e,n,r){h=false;D.forEach((function(t){t.progressEnd(e,n,r)}));if(r!==undefined){S=r}T=false;C=true;if(e===0){P=ce()==="reverse"?"normal":"reverse";if(P==="reverse"){C=false}if(H){Re();De(1-n)}else{A=(1-n)*ve()*-1;Re(false,false)}}else if(e===1){if(H){Re();De(n)}else{A=n*ve()*-1;Re(false,false)}}if(e!==undefined){B((function(){S=undefined;P=undefined;A=undefined}),{oneTimeCallback:true});if(!v){Ge()}}return w};var je=function(){if(s){if(H){W.forEach((function(e){e.pause()}))}else{I.forEach((function(e){setStyleProperty(e,"animation-play-state","paused")}))}}};var He=function(){D.forEach((function(e){e.pause()}));je();return w};var Me=function(){E=undefined;xe()};var $e=function(){if(E){clearTimeout(E)}};var qe=function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-play-state","running")}}))}));if(f.length===0||I.length===0){xe()}else{var e=de()||0;var n=ve()||0;var r=le()||1;if(isFinite(r)){E=setTimeout(Me,e+n*r+M)}animationEnd(I[0],(function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){ze();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)(xe)}))}))}};var ze=function(){I.forEach((function(e){removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state")}))};var Ze=function(){W.forEach((function(e){e.play()}));if(f.length===0||I.length===0){xe()}};var Be=function(){if(H){De(0);Le()}else{Ne()}};var Ge=function(e){return new Promise((function(n){if(e&&e.sync){g=true;B((function(){return g=false}),{oneTimeCallback:true})}if(!s){Ie()}if(T){Be();T=false}if(b){p=D.length+1;b=false}B((function(){return n()}),{oneTimeCallback:true});D.forEach((function(e){e.play()}));if(H){Ze()}else{qe()}}))};var Je=function(){D.forEach((function(e){e.stop()}));if(s){J();s=false}Z()};var Qe=function(e,n){var r;var t=f[0];if(t!==undefined&&(t.offset===undefined||t.offset===0)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([(r={offset:0},r[e]=n,r)],f,true)}return w};var Ue=function(e,n){var r;var t=f[f.length-1];if(t!==undefined&&(t.offset===undefined||t.offset===1)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],f,true),[(r={offset:1},r[e]=n,r)],false)}return w};var Ve=function(e,n,r){return Qe(e,n).to(e,r)};return w={parentAnimation:v,elements:I,childAnimations:D,id:x,animationFinish:xe,from:Qe,to:Ue,fromTo:Ve,parent:Se,play:Ge,pause:He,stop:Je,destroy:q,keyframes:Te,addAnimation:Ce,addElement:Ae,update:Re,fill:pe,direction:me,iterations:Pe,duration:Ee,easing:ge,delay:he,getWebAnimations:$,getKeyframes:ye,getFill:ue,getDirection:ce,getDelay:de,getIterations:le,getEasing:se,getDuration:ve,afterAddRead:X,afterAddWrite:Y,afterClearStyles:fe,afterStyles:oe,afterRemoveClass:ie,afterAddClass:ae,beforeAddRead:U,beforeAddWrite:V,beforeClearStyles:te,beforeStyles:re,beforeRemoveClass:ne,beforeAddClass:ee,onFinish:B,progressStart:Fe,progressStep:Oe,progressEnd:We}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXVCLFVBQVUsR0FBRyxLQUFLLHVCQUF1QixvREFBb0QsTUFBTSxrQkFBa0IsdUJBQXVCLFVBQVUsR0FBRyxLQUFLLFVBQVUsa0JBQWtCLFlBQVksTUFBTSxrQkFBa0IsTUFBTSxrQkFBa0Isa0JBQWtCLEtBQUssdURBQUcsYUFBYSx1QkFBdUIsZUFBZSxzREFBc0QsR0FBRyxHQUFHLCtCQUErQixLQUFLLEtBQUssY0FBYyxjQUFjLGNBQWMsZ0JBQWdCLHlCQUF5Qiw4QkFBOEIsS0FBSyx1REFBRyxhQUFhLEtBQUssdURBQUcsS0FBSyxHQUFHLEtBQUssa0JBQWtCLHVCQUF1Qiw0Q0FBNEMseUNBQXlDLDhDQUE4QyxJQUFJLGtCQUFrQix1QkFBdUIsU0FBUyxHQUFHLCtCQUErQixPQUFPLGtCQUFrQixNQUFNLE1BQU0sS0FBSyxLQUFLLE9BQU8sbUJBQW1CLGdDQUFnQyxjQUFjLE9BQU8sY0FBYyxlQUFlLEdBQUcscUJBQXFCLEVBQUUsT0FBTyxLQUFLLE1BQU0sS0FBSyxRQUFRLE1BQU0sYUFBYSxRQUFRLGNBQWMsV0FBVyxHQUFHLHFCQUFxQixFQUFFLHVCQUF1QixTQUFTLEdBQUcsTUFBTSxLQUFLLEtBQUssTUFBTSxJQUFJLGtCQUFrQix1QkFBdUIsU0FBUyxHQUFHLE1BQU0sSUFBSSxRQUFRLEtBQUsscUJBQXFCLE1BQU0sV0FBVyx3REFBd0QsT0FBTyxLQUFLLEVBQUUsOERBQWEsTUFBTSxTQUFTLG9CQUFvQixVQUFVLHFCQUFxQixNQUFNLG9CQUFvQix3REFBd0QsT0FBTyxLQUFLLEVBQUUsOERBQWEsQ0FBQyw4REFBYSxpQkFBaUIsU0FBUyxtQkFBbUIsVUFBVSx1QkFBdUIsd0JBQXdCLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9hbmltYXRpb24tMTlkYmY5YmYuanM/N2UwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19zcHJlYWRBcnJheX1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9pbXBvcnR7ciBhcyByYWZ9ZnJvbVwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7dmFyIGFuaW1hdGlvblByZWZpeDt2YXIgcHJvY2Vzc0tleWZyYW1lcz1mdW5jdGlvbihlKXtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgbiBpbiBlKXtpZihlLmhhc093blByb3BlcnR5KG4pKXt2YXIgcj1lW25dO2lmKG49PT1cImVhc2luZ1wiKXt2YXIgdD1cImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIjtlW3RdPXI7ZGVsZXRlIGVbbl19ZWxzZXt2YXIgdD1jb252ZXJ0Q2FtZWxDYXNlVG9IeXBlbihuKTtpZih0IT09bil7ZVt0XT1yO2RlbGV0ZSBlW25dfX19fX0pKTtyZXR1cm4gZX07dmFyIGNvbnZlcnRDYW1lbENhc2VUb0h5cGVuPWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpfTt2YXIgZ2V0QW5pbWF0aW9uUHJlZml4PWZ1bmN0aW9uKGUpe2lmKGFuaW1hdGlvblByZWZpeD09PXVuZGVmaW5lZCl7dmFyIG49ZS5zdHlsZS5hbmltYXRpb25OYW1lIT09dW5kZWZpbmVkO3ZhciByPWUuc3R5bGUud2Via2l0QW5pbWF0aW9uTmFtZSE9PXVuZGVmaW5lZDthbmltYXRpb25QcmVmaXg9IW4mJnI/XCItd2Via2l0LVwiOlwiXCJ9cmV0dXJuIGFuaW1hdGlvblByZWZpeH07dmFyIHNldFN0eWxlUHJvcGVydHk9ZnVuY3Rpb24oZSxuLHIpe3ZhciB0PW4uc3RhcnRzV2l0aChcImFuaW1hdGlvblwiKT9nZXRBbmltYXRpb25QcmVmaXgoZSk6XCJcIjtlLnN0eWxlLnNldFByb3BlcnR5KHQrbixyKX07dmFyIHJlbW92ZVN0eWxlUHJvcGVydHk9ZnVuY3Rpb24oZSxuKXt2YXIgcj1uLnN0YXJ0c1dpdGgoXCJhbmltYXRpb25cIik/Z2V0QW5pbWF0aW9uUHJlZml4KGUpOlwiXCI7ZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShyK24pfTt2YXIgYW5pbWF0aW9uRW5kPWZ1bmN0aW9uKGUsbil7dmFyIHI7dmFyIHQ9e3Bhc3NpdmU6dHJ1ZX07dmFyIGE9ZnVuY3Rpb24oKXtpZihyKXtyKCl9fTt2YXIgaT1mdW5jdGlvbihyKXtpZihlPT09ci50YXJnZXQpe2EoKTtuKHIpfX07aWYoZSl7ZS5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0QW5pbWF0aW9uRW5kXCIsaSx0KTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIixpLHQpO3I9ZnVuY3Rpb24oKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRBbmltYXRpb25FbmRcIixpLHQpO2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLGksdCl9fXJldHVybiBhfTt2YXIgZ2VuZXJhdGVLZXlmcmFtZVJ1bGVzPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9W119cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXt2YXIgbj1lLm9mZnNldDt2YXIgcj1bXTtmb3IodmFyIHQgaW4gZSl7aWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSYmdCE9PVwib2Zmc2V0XCIpe3IucHVzaChcIlwiLmNvbmNhdCh0LFwiOiBcIikuY29uY2F0KGVbdF0sXCI7XCIpKX19cmV0dXJuXCJcIi5jb25jYXQobioxMDAsXCIlIHsgXCIpLmNvbmNhdChyLmpvaW4oXCIgXCIpLFwiIH1cIil9KSkuam9pbihcIiBcIil9O3ZhciBrZXlmcmFtZUlkcz1bXTt2YXIgZ2VuZXJhdGVLZXlmcmFtZU5hbWU9ZnVuY3Rpb24oZSl7dmFyIG49a2V5ZnJhbWVJZHMuaW5kZXhPZihlKTtpZihuPDApe249a2V5ZnJhbWVJZHMucHVzaChlKS0xfXJldHVyblwiaW9uLWFuaW1hdGlvbi1cIi5jb25jYXQobil9O3ZhciBnZXRTdHlsZUNvbnRhaW5lcj1mdW5jdGlvbihlKXt2YXIgbj1lLmdldFJvb3ROb2RlKCk7cmV0dXJuIG4uaGVhZHx8bn07dmFyIGNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldD1mdW5jdGlvbihlLG4scil7dmFyIHQ9Z2V0U3R5bGVDb250YWluZXIocik7dmFyIGE9Z2V0QW5pbWF0aW9uUHJlZml4KHIpO3ZhciBpPXQucXVlcnlTZWxlY3RvcihcIiNcIitlKTtpZihpKXtyZXR1cm4gaX12YXIgbz0oci5vd25lckRvY3VtZW50fHxkb2N1bWVudCkuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO28uaWQ9ZTtvLnRleHRDb250ZW50PVwiQFwiLmNvbmNhdChhLFwia2V5ZnJhbWVzIFwiKS5jb25jYXQoZSxcIiB7IFwiKS5jb25jYXQobixcIiB9IEBcIikuY29uY2F0KGEsXCJrZXlmcmFtZXMgXCIpLmNvbmNhdChlLFwiLWFsdCB7IFwiKS5jb25jYXQobixcIiB9XCIpO3QuYXBwZW5kQ2hpbGQobyk7cmV0dXJuIG99O3ZhciBhZGRDbGFzc1RvQXJyYXk9ZnVuY3Rpb24oZSxuKXtpZihlPT09dm9pZCAwKXtlPVtdfWlmKG4hPT11bmRlZmluZWQpe3ZhciByPUFycmF5LmlzQXJyYXkobik/bjpbbl07cmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxlLHRydWUpLHIsdHJ1ZSl9cmV0dXJuIGV9O3ZhciBjcmVhdGVBbmltYXRpb249ZnVuY3Rpb24oZSl7dmFyIG47dmFyIHI7dmFyIHQ7dmFyIGE7dmFyIGk7dmFyIG87dmFyIGY9W107dmFyIHU9W107dmFyIGM9W107dmFyIHM9ZmFsc2U7dmFyIHY7dmFyIGw9e307dmFyIGQ9W107dmFyIHk9W107dmFyIG09e307dmFyIHA9MDt2YXIgaD1mYWxzZTt2YXIgZz1mYWxzZTt2YXIgRTt2YXIgUDt2YXIgUzt2YXIgQTt2YXIgQz10cnVlO3ZhciBUPWZhbHNlO3ZhciBiPXRydWU7dmFyIGs7dmFyIHc7dmFyIHg9ZTt2YXIgSz1bXTt2YXIgXz1bXTt2YXIgST1bXTt2YXIgRD1bXTt2YXIgTD1bXTt2YXIgTj1bXTt2YXIgUj1bXTt2YXIgRj1bXTt2YXIgTz1bXTt2YXIgVz1bXTt2YXIgaj10eXBlb2YgQW5pbWF0aW9uRWZmZWN0PT09XCJmdW5jdGlvblwifHx0eXBlb2Ygd2luZG93LkFuaW1hdGlvbkVmZmVjdD09PVwiZnVuY3Rpb25cIjt2YXIgSD10eXBlb2YgRWxlbWVudD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9PT1cImZ1bmN0aW9uXCImJmo7dmFyIE09MTAwO3ZhciAkPWZ1bmN0aW9uKCl7cmV0dXJuIFd9O3ZhciBxPWZ1bmN0aW9uKGUpe0QuZm9yRWFjaCgoZnVuY3Rpb24obil7bi5kZXN0cm95KGUpfSkpO3ooZSk7SS5sZW5ndGg9MDtELmxlbmd0aD0wO2YubGVuZ3RoPTA7RygpO3M9ZmFsc2U7Yj10cnVlO3JldHVybiB3fTt2YXIgej1mdW5jdGlvbihlKXtKKCk7aWYoZSl7USgpfX07dmFyIFo9ZnVuY3Rpb24oKXtoPWZhbHNlO2c9ZmFsc2U7Yj10cnVlO1A9dW5kZWZpbmVkO1M9dW5kZWZpbmVkO0E9dW5kZWZpbmVkO3A9MDtUPWZhbHNlO0M9dHJ1ZX07dmFyIEI9ZnVuY3Rpb24oZSxuKXt2YXIgcj1uJiZuLm9uZVRpbWVDYWxsYmFjaz9fOks7ci5wdXNoKHtjOmUsbzpufSk7cmV0dXJuIHd9O3ZhciBHPWZ1bmN0aW9uKCl7Sy5sZW5ndGg9MDtfLmxlbmd0aD0wO3JldHVybiB3fTt2YXIgSj1mdW5jdGlvbigpe2lmKEgpe1cuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5jYW5jZWwoKX0pKTtXLmxlbmd0aD0wfWVsc2V7dmFyIGU9SS5zbGljZSgpO3JhZigoZnVuY3Rpb24oKXtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1uYW1lXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1kdXJhdGlvblwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWRlbGF5XCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1maWxsLW1vZGVcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWRpcmVjdGlvblwiKX0pKX0pKX19O3ZhciBRPWZ1bmN0aW9uKCl7TC5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihlJiZlLnBhcmVudE5vZGUpe2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX19KSk7TC5sZW5ndGg9MH07dmFyIFU9ZnVuY3Rpb24oZSl7Ti5wdXNoKGUpO3JldHVybiB3fTt2YXIgVj1mdW5jdGlvbihlKXtSLnB1c2goZSk7cmV0dXJuIHd9O3ZhciBYPWZ1bmN0aW9uKGUpe0YucHVzaChlKTtyZXR1cm4gd307dmFyIFk9ZnVuY3Rpb24oZSl7Ty5wdXNoKGUpO3JldHVybiB3fTt2YXIgZWU9ZnVuY3Rpb24oZSl7dT1hZGRDbGFzc1RvQXJyYXkodSxlKTtyZXR1cm4gd307dmFyIG5lPWZ1bmN0aW9uKGUpe2M9YWRkQ2xhc3NUb0FycmF5KGMsZSk7cmV0dXJuIHd9O3ZhciByZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXt9fWw9ZTtyZXR1cm4gd307dmFyIHRlPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9W119Zm9yKHZhciBuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgdD1yW25dO2xbdF09XCJcIn1yZXR1cm4gd307dmFyIGFlPWZ1bmN0aW9uKGUpe2Q9YWRkQ2xhc3NUb0FycmF5KGQsZSk7cmV0dXJuIHd9O3ZhciBpZT1mdW5jdGlvbihlKXt5PWFkZENsYXNzVG9BcnJheSh5LGUpO3JldHVybiB3fTt2YXIgb2U9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT17fX1tPWU7cmV0dXJuIHd9O3ZhciBmZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPVtdfWZvcih2YXIgbj0wLHI9ZTtuPHIubGVuZ3RoO24rKyl7dmFyIHQ9cltuXTttW3RdPVwiXCJ9cmV0dXJuIHd9O3ZhciB1ZT1mdW5jdGlvbigpe2lmKGkhPT11bmRlZmluZWQpe3JldHVybiBpfWlmKHYpe3JldHVybiB2LmdldEZpbGwoKX1yZXR1cm5cImJvdGhcIn07dmFyIGNlPWZ1bmN0aW9uKCl7aWYoUCE9PXVuZGVmaW5lZCl7cmV0dXJuIFB9aWYobyE9PXVuZGVmaW5lZCl7cmV0dXJuIG99aWYodil7cmV0dXJuIHYuZ2V0RGlyZWN0aW9uKCl9cmV0dXJuXCJub3JtYWxcIn07dmFyIHNlPWZ1bmN0aW9uKCl7aWYoaCl7cmV0dXJuXCJsaW5lYXJcIn1pZih0IT09dW5kZWZpbmVkKXtyZXR1cm4gdH1pZih2KXtyZXR1cm4gdi5nZXRFYXNpbmcoKX1yZXR1cm5cImxpbmVhclwifTt2YXIgdmU9ZnVuY3Rpb24oKXtpZihnKXtyZXR1cm4gMH1pZihTIT09dW5kZWZpbmVkKXtyZXR1cm4gU31pZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gcn1pZih2KXtyZXR1cm4gdi5nZXREdXJhdGlvbigpfXJldHVybiAwfTt2YXIgbGU9ZnVuY3Rpb24oKXtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYX1pZih2KXtyZXR1cm4gdi5nZXRJdGVyYXRpb25zKCl9cmV0dXJuIDF9O3ZhciBkZT1mdW5jdGlvbigpe2lmKEEhPT11bmRlZmluZWQpe3JldHVybiBBfWlmKG4hPT11bmRlZmluZWQpe3JldHVybiBufWlmKHYpe3JldHVybiB2LmdldERlbGF5KCl9cmV0dXJuIDB9O3ZhciB5ZT1mdW5jdGlvbigpe3JldHVybiBmfTt2YXIgbWU9ZnVuY3Rpb24oZSl7bz1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgcGU9ZnVuY3Rpb24oZSl7aT1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgaGU9ZnVuY3Rpb24oZSl7bj1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgZ2U9ZnVuY3Rpb24oZSl7dD1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgRWU9ZnVuY3Rpb24oZSl7aWYoIUgmJmU9PT0wKXtlPTF9cj1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgUGU9ZnVuY3Rpb24oZSl7YT1lO1JlKHRydWUpO3JldHVybiB3fTt2YXIgU2U9ZnVuY3Rpb24oZSl7dj1lO3JldHVybiB3fTt2YXIgQWU9ZnVuY3Rpb24oZSl7aWYoZSE9bnVsbCl7aWYoZS5ub2RlVHlwZT09PTEpe0kucHVzaChlKX1lbHNlIGlmKGUubGVuZ3RoPj0wKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7SS5wdXNoKGVbbl0pfX1lbHNle2NvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGFkZEVsZW1lbnQgdmFsdWVcIil9fXJldHVybiB3fTt2YXIgQ2U9ZnVuY3Rpb24oZSl7aWYoZSE9bnVsbCl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciBuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgdD1yW25dO3QucGFyZW50KHcpO0QucHVzaCh0KX19ZWxzZXtlLnBhcmVudCh3KTtELnB1c2goZSl9fXJldHVybiB3fTt2YXIgVGU9ZnVuY3Rpb24oZSl7dmFyIG49ZiE9PWU7Zj1lO2lmKG4pe2JlKGYpfXJldHVybiB3fTt2YXIgYmU9ZnVuY3Rpb24oZSl7aWYoSCl7JCgpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2lmKG4uZWZmZWN0LnNldEtleWZyYW1lcyl7bi5lZmZlY3Quc2V0S2V5ZnJhbWVzKGUpfWVsc2V7dmFyIHI9bmV3IEtleWZyYW1lRWZmZWN0KG4uZWZmZWN0LnRhcmdldCxlLG4uZWZmZWN0LmdldFRpbWluZygpKTtuLmVmZmVjdD1yfX0pKX1lbHNle0tlKCl9fTt2YXIga2U9ZnVuY3Rpb24oKXtOLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7Ui5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpO3ZhciBlPXU7dmFyIG49Yzt2YXIgcj1sO0kuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9dC5jbGFzc0xpc3Q7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5hZGQoZSl9KSk7bi5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5yZW1vdmUoZSl9KSk7Zm9yKHZhciBpIGluIHIpe2lmKHIuaGFzT3duUHJvcGVydHkoaSkpe3NldFN0eWxlUHJvcGVydHkodCxpLHJbaV0pfX19KSl9O3ZhciB3ZT1mdW5jdGlvbigpeyRlKCk7Ri5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpO08uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKTt2YXIgZT1DPzE6MDt2YXIgbj1kO3ZhciByPXk7dmFyIHQ9bTtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBhPWUuY2xhc3NMaXN0O24uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGEuYWRkKGUpfSkpO3IuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGEucmVtb3ZlKGUpfSkpO2Zvcih2YXIgaSBpbiB0KXtpZih0Lmhhc093blByb3BlcnR5KGkpKXtzZXRTdHlsZVByb3BlcnR5KGUsaSx0W2ldKX19fSkpO0suZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIG4uYyhlLHcpfSkpO18uZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIG4uYyhlLHcpfSkpO18ubGVuZ3RoPTA7Yj10cnVlO2lmKEMpe1Q9dHJ1ZX1DPXRydWV9O3ZhciB4ZT1mdW5jdGlvbigpe2lmKHA9PT0wKXtyZXR1cm59cC0tO2lmKHA9PT0wKXt3ZSgpO2lmKHYpe3YuYW5pbWF0aW9uRmluaXNoKCl9fX07dmFyIEtlPWZ1bmN0aW9uKG4pe2lmKG49PT12b2lkIDApe249dHJ1ZX1RKCk7dmFyIHI9cHJvY2Vzc0tleWZyYW1lcyhmKTtJLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHIubGVuZ3RoPjApe3ZhciBhPWdlbmVyYXRlS2V5ZnJhbWVSdWxlcyhyKTtrPWUhPT11bmRlZmluZWQ/ZTpnZW5lcmF0ZUtleWZyYW1lTmFtZShhKTt2YXIgaT1jcmVhdGVLZXlmcmFtZVN0eWxlc2hlZXQoayxhLHQpO0wucHVzaChpKTtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24tZHVyYXRpb25cIixcIlwiLmNvbmNhdCh2ZSgpLFwibXNcIikpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIixzZSgpKTtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24tZGVsYXlcIixcIlwiLmNvbmNhdChkZSgpLFwibXNcIikpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1maWxsLW1vZGVcIix1ZSgpKTtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24tZGlyZWN0aW9uXCIsY2UoKSk7dmFyIG89bGUoKT09PUluZmluaXR5P1wiaW5maW5pdGVcIjpsZSgpLnRvU3RyaW5nKCk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLG8pO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJwYXVzZWRcIik7aWYobil7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLW5hbWVcIixcIlwiLmNvbmNhdChpLmlkLFwiLWFsdFwiKSl9cmFmKChmdW5jdGlvbigpe3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1uYW1lXCIsaS5pZHx8bnVsbCl9KSl9fSkpfTt2YXIgX2U9ZnVuY3Rpb24oKXtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWUuYW5pbWF0ZShmLHtpZDp4LGRlbGF5OmRlKCksZHVyYXRpb246dmUoKSxlYXNpbmc6c2UoKSxpdGVyYXRpb25zOmxlKCksZmlsbDp1ZSgpLGRpcmVjdGlvbjpjZSgpfSk7bi5wYXVzZSgpO1cucHVzaChuKX0pKTtpZihXLmxlbmd0aD4wKXtXWzBdLm9uZmluaXNoPWZ1bmN0aW9uKCl7eGUoKX19fTt2YXIgSWU9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT10cnVlfWtlKCk7aWYoZi5sZW5ndGg+MCl7aWYoSCl7X2UoKX1lbHNle0tlKGUpfX1zPXRydWV9O3ZhciBEZT1mdW5jdGlvbihlKXtlPU1hdGgubWluKE1hdGgubWF4KGUsMCksLjk5OTkpO2lmKEgpe1cuZm9yRWFjaCgoZnVuY3Rpb24obil7bi5jdXJyZW50VGltZT1uLmVmZmVjdC5nZXRDb21wdXRlZFRpbWluZygpLmRlbGF5K3ZlKCkqZTtuLnBhdXNlKCl9KSl9ZWxzZXt2YXIgbj1cIi1cIi5jb25jYXQodmUoKSplLFwibXNcIik7SS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihmLmxlbmd0aD4wKXtzZXRTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZGVsYXlcIixuKTtzZXRTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiLFwicGF1c2VkXCIpfX0pKX19O3ZhciBMZT1mdW5jdGlvbihlKXtXLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuZWZmZWN0LnVwZGF0ZVRpbWluZyh7ZGVsYXk6ZGUoKSxkdXJhdGlvbjp2ZSgpLGVhc2luZzpzZSgpLGl0ZXJhdGlvbnM6bGUoKSxmaWxsOnVlKCksZGlyZWN0aW9uOmNlKCl9KX0pKTtpZihlIT09dW5kZWZpbmVkKXtEZShlKX19O3ZhciBOZT1mdW5jdGlvbihlLG4pe2lmKGU9PT12b2lkIDApe2U9dHJ1ZX1yYWYoKGZ1bmN0aW9uKCl7SS5mb3JFYWNoKChmdW5jdGlvbihyKXtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tbmFtZVwiLGt8fG51bGwpO3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1kdXJhdGlvblwiLFwiXCIuY29uY2F0KHZlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLHNlKCkpO3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1kZWxheVwiLG4hPT11bmRlZmluZWQ/XCItXCIuY29uY2F0KG4qdmUoKSxcIm1zXCIpOlwiXCIuY29uY2F0KGRlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiLHVlKCl8fG51bGwpO3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1kaXJlY3Rpb25cIixjZSgpfHxudWxsKTt2YXIgdD1sZSgpPT09SW5maW5pdHk/XCJpbmZpbml0ZVwiOmxlKCkudG9TdHJpbmcoKTtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIsdCk7aWYoZSl7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLW5hbWVcIixcIlwiLmNvbmNhdChrLFwiLWFsdFwiKSl9cmFmKChmdW5jdGlvbigpe3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1uYW1lXCIsa3x8bnVsbCl9KSl9KSl9KSl9O3ZhciBSZT1mdW5jdGlvbihlLG4scil7aWYoZT09PXZvaWQgMCl7ZT1mYWxzZX1pZihuPT09dm9pZCAwKXtuPXRydWV9aWYoZSl7RC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnVwZGF0ZShlLG4scil9KSl9aWYoSCl7TGUocil9ZWxzZXtOZShuLHIpfXJldHVybiB3fTt2YXIgRmU9ZnVuY3Rpb24oZSxuKXtpZihlPT09dm9pZCAwKXtlPWZhbHNlfUQuZm9yRWFjaCgoZnVuY3Rpb24ocil7ci5wcm9ncmVzc1N0YXJ0KGUsbil9KSk7amUoKTtoPWU7aWYoIXMpe0llKCl9UmUoZmFsc2UsdHJ1ZSxuKTtyZXR1cm4gd307dmFyIE9lPWZ1bmN0aW9uKGUpe0QuZm9yRWFjaCgoZnVuY3Rpb24obil7bi5wcm9ncmVzc1N0ZXAoZSl9KSk7RGUoZSk7cmV0dXJuIHd9O3ZhciBXZT1mdW5jdGlvbihlLG4scil7aD1mYWxzZTtELmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucHJvZ3Jlc3NFbmQoZSxuLHIpfSkpO2lmKHIhPT11bmRlZmluZWQpe1M9cn1UPWZhbHNlO0M9dHJ1ZTtpZihlPT09MCl7UD1jZSgpPT09XCJyZXZlcnNlXCI/XCJub3JtYWxcIjpcInJldmVyc2VcIjtpZihQPT09XCJyZXZlcnNlXCIpe0M9ZmFsc2V9aWYoSCl7UmUoKTtEZSgxLW4pfWVsc2V7QT0oMS1uKSp2ZSgpKi0xO1JlKGZhbHNlLGZhbHNlKX19ZWxzZSBpZihlPT09MSl7aWYoSCl7UmUoKTtEZShuKX1lbHNle0E9bip2ZSgpKi0xO1JlKGZhbHNlLGZhbHNlKX19aWYoZSE9PXVuZGVmaW5lZCl7QigoZnVuY3Rpb24oKXtTPXVuZGVmaW5lZDtQPXVuZGVmaW5lZDtBPXVuZGVmaW5lZH0pLHtvbmVUaW1lQ2FsbGJhY2s6dHJ1ZX0pO2lmKCF2KXtHZSgpfX1yZXR1cm4gd307dmFyIGplPWZ1bmN0aW9uKCl7aWYocyl7aWYoSCl7Vy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnBhdXNlKCl9KSl9ZWxzZXtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJwYXVzZWRcIil9KSl9fX07dmFyIEhlPWZ1bmN0aW9uKCl7RC5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnBhdXNlKCl9KSk7amUoKTtyZXR1cm4gd307dmFyIE1lPWZ1bmN0aW9uKCl7RT11bmRlZmluZWQ7eGUoKX07dmFyICRlPWZ1bmN0aW9uKCl7aWYoRSl7Y2xlYXJUaW1lb3V0KEUpfX07dmFyIHFlPWZ1bmN0aW9uKCl7JGUoKTtyYWYoKGZ1bmN0aW9uKCl7SS5mb3JFYWNoKChmdW5jdGlvbihlKXtpZihmLmxlbmd0aD4wKXtzZXRTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiLFwicnVubmluZ1wiKX19KSl9KSk7aWYoZi5sZW5ndGg9PT0wfHxJLmxlbmd0aD09PTApe3hlKCl9ZWxzZXt2YXIgZT1kZSgpfHwwO3ZhciBuPXZlKCl8fDA7dmFyIHI9bGUoKXx8MTtpZihpc0Zpbml0ZShyKSl7RT1zZXRUaW1lb3V0KE1lLGUrbipyK00pfWFuaW1hdGlvbkVuZChJWzBdLChmdW5jdGlvbigpeyRlKCk7cmFmKChmdW5jdGlvbigpe3plKCk7cmFmKHhlKX0pKX0pKX19O3ZhciB6ZT1mdW5jdGlvbigpe0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1kZWxheVwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiKX0pKX07dmFyIFplPWZ1bmN0aW9uKCl7Vy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnBsYXkoKX0pKTtpZihmLmxlbmd0aD09PTB8fEkubGVuZ3RoPT09MCl7eGUoKX19O3ZhciBCZT1mdW5jdGlvbigpe2lmKEgpe0RlKDApO0xlKCl9ZWxzZXtOZSgpfX07dmFyIEdlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obil7aWYoZSYmZS5zeW5jKXtnPXRydWU7QigoZnVuY3Rpb24oKXtyZXR1cm4gZz1mYWxzZX0pLHtvbmVUaW1lQ2FsbGJhY2s6dHJ1ZX0pfWlmKCFzKXtJZSgpfWlmKFQpe0JlKCk7VD1mYWxzZX1pZihiKXtwPUQubGVuZ3RoKzE7Yj1mYWxzZX1CKChmdW5jdGlvbigpe3JldHVybiBuKCl9KSx7b25lVGltZUNhbGxiYWNrOnRydWV9KTtELmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGxheSgpfSkpO2lmKEgpe1plKCl9ZWxzZXtxZSgpfX0pKX07dmFyIEplPWZ1bmN0aW9uKCl7RC5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnN0b3AoKX0pKTtpZihzKXtKKCk7cz1mYWxzZX1aKCl9O3ZhciBRZT1mdW5jdGlvbihlLG4pe3ZhciByO3ZhciB0PWZbMF07aWYodCE9PXVuZGVmaW5lZCYmKHQub2Zmc2V0PT09dW5kZWZpbmVkfHx0Lm9mZnNldD09PTApKXt0W2VdPW59ZWxzZXtmPV9fc3ByZWFkQXJyYXkoWyhyPXtvZmZzZXQ6MH0scltlXT1uLHIpXSxmLHRydWUpfXJldHVybiB3fTt2YXIgVWU9ZnVuY3Rpb24oZSxuKXt2YXIgcjt2YXIgdD1mW2YubGVuZ3RoLTFdO2lmKHQhPT11bmRlZmluZWQmJih0Lm9mZnNldD09PXVuZGVmaW5lZHx8dC5vZmZzZXQ9PT0xKSl7dFtlXT1ufWVsc2V7Zj1fX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sZix0cnVlKSxbKHI9e29mZnNldDoxfSxyW2VdPW4scildLGZhbHNlKX1yZXR1cm4gd307dmFyIFZlPWZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gUWUoZSxuKS50byhlLHIpfTtyZXR1cm4gdz17cGFyZW50QW5pbWF0aW9uOnYsZWxlbWVudHM6SSxjaGlsZEFuaW1hdGlvbnM6RCxpZDp4LGFuaW1hdGlvbkZpbmlzaDp4ZSxmcm9tOlFlLHRvOlVlLGZyb21UbzpWZSxwYXJlbnQ6U2UscGxheTpHZSxwYXVzZTpIZSxzdG9wOkplLGRlc3Ryb3k6cSxrZXlmcmFtZXM6VGUsYWRkQW5pbWF0aW9uOkNlLGFkZEVsZW1lbnQ6QWUsdXBkYXRlOlJlLGZpbGw6cGUsZGlyZWN0aW9uOm1lLGl0ZXJhdGlvbnM6UGUsZHVyYXRpb246RWUsZWFzaW5nOmdlLGRlbGF5OmhlLGdldFdlYkFuaW1hdGlvbnM6JCxnZXRLZXlmcmFtZXM6eWUsZ2V0RmlsbDp1ZSxnZXREaXJlY3Rpb246Y2UsZ2V0RGVsYXk6ZGUsZ2V0SXRlcmF0aW9uczpsZSxnZXRFYXNpbmc6c2UsZ2V0RHVyYXRpb246dmUsYWZ0ZXJBZGRSZWFkOlgsYWZ0ZXJBZGRXcml0ZTpZLGFmdGVyQ2xlYXJTdHlsZXM6ZmUsYWZ0ZXJTdHlsZXM6b2UsYWZ0ZXJSZW1vdmVDbGFzczppZSxhZnRlckFkZENsYXNzOmFlLGJlZm9yZUFkZFJlYWQ6VSxiZWZvcmVBZGRXcml0ZTpWLGJlZm9yZUNsZWFyU3R5bGVzOnRlLGJlZm9yZVN0eWxlczpyZSxiZWZvcmVSZW1vdmVDbGFzczpuZSxiZWZvcmVBZGRDbGFzczplZSxvbkZpbmlzaDpCLHByb2dyZXNzU3RhcnQ6RmUscHJvZ3Jlc3NTdGVwOk9lLHByb2dyZXNzRW5kOldlfX07ZXhwb3J0e2NyZWF0ZUFuaW1hdGlvbiBhcyBjfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27434\n')},93544:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "g": () => (/* binding */ getTimeGivenProgression)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar getTimeGivenProgression=function(t,r,a,e,o){return solveCubicBezier(t[1],r[1],a[1],e[1],o).map((function(o){return solveCubicParametricEquation(t[0],r[0],a[0],e[0],o)}))};var solveCubicParametricEquation=function(t,r,a,e,o){var i=3*r*Math.pow(o-1,2);var n=-3*a*o+3*a+e*o;var u=t*Math.pow(o-1,3);return o*(i+o*n)-u};var solveCubicBezier=function(t,r,a,e,o){t-=o;r-=o;a-=o;e-=o;var i=solveCubicEquation(e-3*a+3*r-t,3*a-6*r+3*t,3*r-3*t,t);return i.filter((function(t){return t>=0&&t<=1}))};var solveQuadraticEquation=function(t,r,a){var e=r*r-4*t*a;if(e<0){return[]}else{return[(-r+Math.sqrt(e))/(2*t),(-r-Math.sqrt(e))/(2*t)]}};var solveCubicEquation=function(t,r,a,e){if(t===0){return solveQuadraticEquation(r,a,e)}r/=t;a/=t;e/=t;var o=(3*a-r*r)/3;var i=(2*r*r*r-9*r*a+27*e)/27;if(o===0){return[Math.pow(-i,1/3)]}else if(i===0){return[Math.sqrt(-o),-Math.sqrt(-o)]}var n=Math.pow(i/2,2)+Math.pow(o/3,3);if(n===0){return[Math.pow(i/2,1/2)-r/3]}else if(n>0){return[Math.pow(-(i/2)+Math.sqrt(n),1/3)-Math.pow(i/2+Math.sqrt(n),1/3)-r/3]}var u=Math.sqrt(Math.pow(-(o/3),3));var s=Math.acos(-(i/(2*Math.sqrt(Math.pow(-(o/3),3)))));var v=2*Math.pow(u,1/3);return[v*Math.cos(s/3)-r/3,v*Math.cos((s+2*Math.PI)/3)-r/3,v*Math.cos((s+4*Math.PI)/3)-r/3]};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM1NDQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnRUFBZ0UsMkRBQTJELElBQUkscURBQXFELDBCQUEwQixxQkFBcUIsd0JBQXdCLG9CQUFvQix5Q0FBeUMsS0FBSyxLQUFLLEtBQUssS0FBSyw0REFBNEQsNkJBQTZCLGtCQUFrQixJQUFJLDJDQUEyQyxnQkFBZ0IsUUFBUSxTQUFTLEtBQUssMERBQTBELHlDQUF5QyxVQUFVLHFDQUFxQyxLQUFLLEtBQUssS0FBSyxrQkFBa0IsOEJBQThCLFVBQVUseUJBQXlCLGVBQWUscUNBQXFDLHNDQUFzQyxVQUFVLDhCQUE4QixhQUFhLDZFQUE2RSxvQ0FBb0Msd0RBQXdELHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2N1YmljLWJlemllci0xNTRhNTNhNS5qcz8wNDc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG52YXIgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb249ZnVuY3Rpb24odCxyLGEsZSxvKXtyZXR1cm4gc29sdmVDdWJpY0Jlemllcih0WzFdLHJbMV0sYVsxXSxlWzFdLG8pLm1hcCgoZnVuY3Rpb24obyl7cmV0dXJuIHNvbHZlQ3ViaWNQYXJhbWV0cmljRXF1YXRpb24odFswXSxyWzBdLGFbMF0sZVswXSxvKX0pKX07dmFyIHNvbHZlQ3ViaWNQYXJhbWV0cmljRXF1YXRpb249ZnVuY3Rpb24odCxyLGEsZSxvKXt2YXIgaT0zKnIqTWF0aC5wb3coby0xLDIpO3ZhciBuPS0zKmEqbyszKmErZSpvO3ZhciB1PXQqTWF0aC5wb3coby0xLDMpO3JldHVybiBvKihpK28qbiktdX07dmFyIHNvbHZlQ3ViaWNCZXppZXI9ZnVuY3Rpb24odCxyLGEsZSxvKXt0LT1vO3ItPW87YS09bztlLT1vO3ZhciBpPXNvbHZlQ3ViaWNFcXVhdGlvbihlLTMqYSszKnItdCwzKmEtNipyKzMqdCwzKnItMyp0LHQpO3JldHVybiBpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTAmJnQ8PTF9KSl9O3ZhciBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uPWZ1bmN0aW9uKHQscixhKXt2YXIgZT1yKnItNCp0KmE7aWYoZTwwKXtyZXR1cm5bXX1lbHNle3JldHVyblsoLXIrTWF0aC5zcXJ0KGUpKS8oMip0KSwoLXItTWF0aC5zcXJ0KGUpKS8oMip0KV19fTt2YXIgc29sdmVDdWJpY0VxdWF0aW9uPWZ1bmN0aW9uKHQscixhLGUpe2lmKHQ9PT0wKXtyZXR1cm4gc29sdmVRdWFkcmF0aWNFcXVhdGlvbihyLGEsZSl9ci89dDthLz10O2UvPXQ7dmFyIG89KDMqYS1yKnIpLzM7dmFyIGk9KDIqcipyKnItOSpyKmErMjcqZSkvMjc7aWYobz09PTApe3JldHVybltNYXRoLnBvdygtaSwxLzMpXX1lbHNlIGlmKGk9PT0wKXtyZXR1cm5bTWF0aC5zcXJ0KC1vKSwtTWF0aC5zcXJ0KC1vKV19dmFyIG49TWF0aC5wb3coaS8yLDIpK01hdGgucG93KG8vMywzKTtpZihuPT09MCl7cmV0dXJuW01hdGgucG93KGkvMiwxLzIpLXIvM119ZWxzZSBpZihuPjApe3JldHVybltNYXRoLnBvdygtKGkvMikrTWF0aC5zcXJ0KG4pLDEvMyktTWF0aC5wb3coaS8yK01hdGguc3FydChuKSwxLzMpLXIvM119dmFyIHU9TWF0aC5zcXJ0KE1hdGgucG93KC0oby8zKSwzKSk7dmFyIHM9TWF0aC5hY29zKC0oaS8oMipNYXRoLnNxcnQoTWF0aC5wb3coLShvLzMpLDMpKSkpKTt2YXIgdj0yKk1hdGgucG93KHUsMS8zKTtyZXR1cm5bdipNYXRoLmNvcyhzLzMpLXIvMyx2Kk1hdGguY29zKChzKzIqTWF0aC5QSSkvMyktci8zLHYqTWF0aC5jb3MoKHMrNCpNYXRoLlBJKS8zKS1yLzNdfTtleHBvcnR7Z2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gYXMgZ307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///93544\n')},4988:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "G": () => (/* binding */ GESTURE_CONTROLLER)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar GestureController=function(){function t(){this.gestureId=0;this.requestedStart=new Map;this.disabledGestures=new Map;this.disabledScroll=new Set}t.prototype.createGesture=function(t){return new GestureDelegate(this,this.newID(),t.name,t.priority||0,!!t.disableScroll)};t.prototype.createBlocker=function(t){if(t===void 0){t={}}return new BlockerDelegate(this,this.newID(),t.disable,!!t.disableScroll)};t.prototype.start=function(t,e,r){if(!this.canStart(t)){this.requestedStart.delete(e);return false}this.requestedStart.set(e,r);return true};t.prototype.capture=function(t,e,r){if(!this.start(t,e,r)){return false}var i=this.requestedStart;var s=-1e4;i.forEach((function(t){s=Math.max(s,t)}));if(s===r){this.capturedId=e;i.clear();var l=new CustomEvent("ionGestureCaptured",{detail:{gestureName:t}});document.dispatchEvent(l);return true}i.delete(e);return false};t.prototype.release=function(t){this.requestedStart.delete(t);if(this.capturedId===t){this.capturedId=undefined}};t.prototype.disableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r===undefined){r=new Set;this.disabledGestures.set(t,r)}r.add(e)};t.prototype.enableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r!==undefined){r.delete(e)}};t.prototype.disableScroll=function(t){this.disabledScroll.add(t);if(this.disabledScroll.size===1){document.body.classList.add(BACKDROP_NO_SCROLL)}};t.prototype.enableScroll=function(t){this.disabledScroll.delete(t);if(this.disabledScroll.size===0){document.body.classList.remove(BACKDROP_NO_SCROLL)}};t.prototype.canStart=function(t){if(this.capturedId!==undefined){return false}if(this.isDisabled(t)){return false}return true};t.prototype.isCaptured=function(){return this.capturedId!==undefined};t.prototype.isScrollDisabled=function(){return this.disabledScroll.size>0};t.prototype.isDisabled=function(t){var e=this.disabledGestures.get(t);if(e&&e.size>0){return true}return false};t.prototype.newID=function(){this.gestureId++;return this.gestureId};return t}();var GestureDelegate=function(){function t(t,e,r,i,s){this.id=e;this.name=r;this.disableScroll=s;this.priority=i*1e6+e;this.ctrl=t}t.prototype.canStart=function(){if(!this.ctrl){return false}return this.ctrl.canStart(this.name)};t.prototype.start=function(){if(!this.ctrl){return false}return this.ctrl.start(this.name,this.id,this.priority)};t.prototype.capture=function(){if(!this.ctrl){return false}var t=this.ctrl.capture(this.name,this.id,this.priority);if(t&&this.disableScroll){this.ctrl.disableScroll(this.id)}return t};t.prototype.release=function(){if(this.ctrl){this.ctrl.release(this.id);if(this.disableScroll){this.ctrl.enableScroll(this.id)}}};t.prototype.destroy=function(){this.release();this.ctrl=undefined};return t}();var BlockerDelegate=function(){function t(t,e,r,i){this.id=e;this.disable=r;this.disableScroll=i;this.ctrl=t}t.prototype.block=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.disableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.disableScroll(this.id)}};t.prototype.unblock=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.enableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.enableScroll(this.id)}};t.prototype.destroy=function(){this.unblock();this.ctrl=undefined};return t}();var BACKDROP_NO_SCROLL="backdrop-no-scroll";var GESTURE_CONTROLLER=new GestureController;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk4OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsaUJBQWlCLDRCQUE0Qiw4QkFBOEIsNEJBQTRCLHNDQUFzQyxzRkFBc0Ysc0NBQXNDLGVBQWUsS0FBSywyRUFBMkUsa0NBQWtDLHNCQUFzQiw4QkFBOEIsYUFBYSw2QkFBNkIsYUFBYSxvQ0FBb0MsdUJBQXVCLGFBQWEsMEJBQTBCLFdBQVcsdUJBQXVCLGdCQUFnQixHQUFHLFVBQVUsa0JBQWtCLFVBQVUsNENBQTRDLFFBQVEsZUFBZSxFQUFFLDBCQUEwQixZQUFZLFlBQVksY0FBYyxnQ0FBZ0MsOEJBQThCLHdCQUF3Qiw0QkFBNEIseUNBQXlDLG1DQUFtQyxrQkFBa0IsVUFBVSwrQkFBK0IsVUFBVSx3Q0FBd0MsbUNBQW1DLGtCQUFrQixjQUFjLHNDQUFzQywyQkFBMkIsaUNBQWlDLGtEQUFrRCxxQ0FBcUMsOEJBQThCLGlDQUFpQyxxREFBcUQsaUNBQWlDLGdDQUFnQyxhQUFhLHVCQUF1QixhQUFhLGFBQWEsa0NBQWtDLG9DQUFvQyx3Q0FBd0MsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsZ0JBQWdCLFlBQVksY0FBYyw2QkFBNkIsaUJBQWlCLHVCQUF1QixTQUFTLEdBQUcsK0JBQStCLHNCQUFzQixVQUFVLFlBQVkscUJBQXFCLHNCQUFzQixZQUFZLGdDQUFnQyxlQUFlLGFBQWEsc0NBQXNDLDZCQUE2QixlQUFlLGFBQWEseURBQXlELCtCQUErQixlQUFlLGFBQWEseURBQXlELDBCQUEwQixpQ0FBaUMsVUFBVSwrQkFBK0IsY0FBYywyQkFBMkIsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxxQkFBcUIsU0FBUyxHQUFHLCtCQUErQixvQkFBb0IsVUFBVSxlQUFlLHFCQUFxQixZQUFZLDZCQUE2QixlQUFlLE9BQU8saUJBQWlCLDJCQUEyQixXQUFXLEtBQUssV0FBVyxxQ0FBcUMsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxPQUFPLGlCQUFpQiwyQkFBMkIsV0FBVyxLQUFLLFdBQVcsb0NBQW9DLHVCQUF1QixrQ0FBa0MsK0JBQStCLGVBQWUscUJBQXFCLFNBQVMsR0FBRyw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9nZXN0dXJlLWNvbnRyb2xsZXItNjhjMDIzYTQuanM/NGFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xudmFyIEdlc3R1cmVDb250cm9sbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuZ2VzdHVyZUlkPTA7dGhpcy5yZXF1ZXN0ZWRTdGFydD1uZXcgTWFwO3RoaXMuZGlzYWJsZWRHZXN0dXJlcz1uZXcgTWFwO3RoaXMuZGlzYWJsZWRTY3JvbGw9bmV3IFNldH10LnByb3RvdHlwZS5jcmVhdGVHZXN0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgR2VzdHVyZURlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQubmFtZSx0LnByaW9yaXR5fHwwLCEhdC5kaXNhYmxlU2Nyb2xsKX07dC5wcm90b3R5cGUuY3JlYXRlQmxvY2tlcj1mdW5jdGlvbih0KXtpZih0PT09dm9pZCAwKXt0PXt9fXJldHVybiBuZXcgQmxvY2tlckRlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQuZGlzYWJsZSwhIXQuZGlzYWJsZVNjcm9sbCl9O3QucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHQsZSxyKXtpZighdGhpcy5jYW5TdGFydCh0KSl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUoZSk7cmV0dXJuIGZhbHNlfXRoaXMucmVxdWVzdGVkU3RhcnQuc2V0KGUscik7cmV0dXJuIHRydWV9O3QucHJvdG90eXBlLmNhcHR1cmU9ZnVuY3Rpb24odCxlLHIpe2lmKCF0aGlzLnN0YXJ0KHQsZSxyKSl7cmV0dXJuIGZhbHNlfXZhciBpPXRoaXMucmVxdWVzdGVkU3RhcnQ7dmFyIHM9LTFlNDtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3M9TWF0aC5tYXgocyx0KX0pKTtpZihzPT09cil7dGhpcy5jYXB0dXJlZElkPWU7aS5jbGVhcigpO3ZhciBsPW5ldyBDdXN0b21FdmVudChcImlvbkdlc3R1cmVDYXB0dXJlZFwiLHtkZXRhaWw6e2dlc3R1cmVOYW1lOnR9fSk7ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChsKTtyZXR1cm4gdHJ1ZX1pLmRlbGV0ZShlKTtyZXR1cm4gZmFsc2V9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24odCl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUodCk7aWYodGhpcy5jYXB0dXJlZElkPT09dCl7dGhpcy5jYXB0dXJlZElkPXVuZGVmaW5lZH19O3QucHJvdG90eXBlLmRpc2FibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyPT09dW5kZWZpbmVkKXtyPW5ldyBTZXQ7dGhpcy5kaXNhYmxlZEdlc3R1cmVzLnNldCh0LHIpfXIuYWRkKGUpfTt0LnByb3RvdHlwZS5lbmFibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyIT09dW5kZWZpbmVkKXtyLmRlbGV0ZShlKX19O3QucHJvdG90eXBlLmRpc2FibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5hZGQodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MSl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5lbmFibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5kZWxldGUodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MCl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5jYW5TdGFydD1mdW5jdGlvbih0KXtpZih0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1pZih0aGlzLmlzRGlzYWJsZWQodCkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX07dC5wcm90b3R5cGUuaXNDYXB0dXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWR9O3QucHJvdG90eXBlLmlzU2Nyb2xsRGlzYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPjB9O3QucHJvdG90eXBlLmlzRGlzYWJsZWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihlJiZlLnNpemU+MCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LnByb3RvdHlwZS5uZXdJRD1mdW5jdGlvbigpe3RoaXMuZ2VzdHVyZUlkKys7cmV0dXJuIHRoaXMuZ2VzdHVyZUlkfTtyZXR1cm4gdH0oKTt2YXIgR2VzdHVyZURlbGVnYXRlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpLHMpe3RoaXMuaWQ9ZTt0aGlzLm5hbWU9cjt0aGlzLmRpc2FibGVTY3JvbGw9czt0aGlzLnByaW9yaXR5PWkqMWU2K2U7dGhpcy5jdHJsPXR9dC5wcm90b3R5cGUuY2FuU3RhcnQ9ZnVuY3Rpb24oKXtpZighdGhpcy5jdHJsKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRoaXMuY3RybC5jYW5TdGFydCh0aGlzLm5hbWUpfTt0LnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe2lmKCF0aGlzLmN0cmwpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5jdHJsLnN0YXJ0KHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpfTt0LnByb3RvdHlwZS5jYXB0dXJlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJuIGZhbHNlfXZhciB0PXRoaXMuY3RybC5jYXB0dXJlKHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpO2lmKHQmJnRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9cmV0dXJuIHR9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24oKXtpZih0aGlzLmN0cmwpe3RoaXMuY3RybC5yZWxlYXNlKHRoaXMuaWQpO2lmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmVuYWJsZVNjcm9sbCh0aGlzLmlkKX19fTt0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5yZWxlYXNlKCk7dGhpcy5jdHJsPXVuZGVmaW5lZH07cmV0dXJuIHR9KCk7dmFyIEJsb2NrZXJEZWxlZ2F0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsaSl7dGhpcy5pZD1lO3RoaXMuZGlzYWJsZT1yO3RoaXMuZGlzYWJsZVNjcm9sbD1pO3RoaXMuY3RybD10fXQucHJvdG90eXBlLmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmRpc2FibGVHZXN0dXJlKHIsdGhpcy5pZCl9fWlmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9fTt0LnByb3RvdHlwZS51bmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmVuYWJsZUdlc3R1cmUocix0aGlzLmlkKX19aWYodGhpcy5kaXNhYmxlU2Nyb2xsKXt0aGlzLmN0cmwuZW5hYmxlU2Nyb2xsKHRoaXMuaWQpfX07dC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5ibG9jaygpO3RoaXMuY3RybD11bmRlZmluZWR9O3JldHVybiB0fSgpO3ZhciBCQUNLRFJPUF9OT19TQ1JPTEw9XCJiYWNrZHJvcC1uby1zY3JvbGxcIjt2YXIgR0VTVFVSRV9DT05UUk9MTEVSPW5ldyBHZXN0dXJlQ29udHJvbGxlcjtleHBvcnR7R0VTVFVSRV9DT05UUk9MTEVSIGFzIEd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4988\n')},47292:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MENU_BACK_BUTTON_PRIORITY": () => (/* binding */ MENU_BACK_BUTTON_PRIORITY),\n/* harmony export */   "OVERLAY_BACK_BUTTON_PRIORITY": () => (/* binding */ OVERLAY_BACK_BUTTON_PRIORITY),\n/* harmony export */   "blockHardwareBackButton": () => (/* binding */ blockHardwareBackButton),\n/* harmony export */   "startHardwareBackButton": () => (/* binding */ startHardwareBackButton)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var blockHardwareBackButton=function(){document.addEventListener("backbutton",(function(){}))};var startHardwareBackButton=function(){var r=document;var t=false;r.addEventListener("backbutton",(function(){if(t){return}var n=0;var e=[];var a=new CustomEvent("ionBackButton",{bubbles:false,detail:{register:function(r,t){e.push({priority:r,handler:t,id:n++})}}});r.dispatchEvent(a);var i=function(r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(e){switch(e.label){case 0:e.trys.push([0,3,,4]);if(!(r&&r.handler))return[3,2];t=r.handler(o);if(!(t!=null))return[3,2];return[4,t];case 1:e.sent();e.label=2;case 2:return[3,4];case 3:n=e.sent();console.error(n);return[3,4];case 4:return[2]}}))}))};var o=function(){if(e.length>0){var r={priority:Number.MIN_SAFE_INTEGER,handler:function(){return undefined},id:-1};e.forEach((function(t){if(t.priority>=r.priority){r=t}}));t=true;e=e.filter((function(t){return t.id!==r.id}));i(r).then((function(){return t=false}))}};o()}))};var OVERLAY_BACK_BUTTON_PRIORITY=100;var MENU_BACK_BUTTON_PRIORITY=99;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcyOTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDekM7QUFDQTtBQUNBLDBDQUEwQyxvREFBb0QsSUFBSSx1Q0FBdUMsZUFBZSxZQUFZLDRDQUE0QyxNQUFNLE9BQU8sUUFBUSxTQUFTLHVDQUF1QyxzQkFBc0IsdUJBQXVCLFFBQVEsNEJBQTRCLElBQUksRUFBRSxtQkFBbUIsa0JBQWtCLE9BQU8sMERBQVMsa0NBQWtDLFFBQVEsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLDZCQUE2QiwrQkFBK0IsZUFBZSwwQkFBMEIsWUFBWSxnQkFBZ0IsVUFBVSxtQkFBbUIsa0JBQWtCLGlCQUFpQixZQUFZLGtCQUFrQixHQUFHLElBQUksaUJBQWlCLGVBQWUsT0FBTyxvREFBb0QsaUJBQWlCLFFBQVEsdUJBQXVCLDJCQUEyQixLQUFLLEdBQUcsT0FBTyx3QkFBd0IsbUJBQW1CLEdBQUcsc0JBQXNCLGVBQWUsS0FBSyxJQUFJLElBQUkscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaGFyZHdhcmUtYmFjay1idXR0b24tYWNlNmE3MWIuanM/OTVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZ2VuZXJhdG9yfWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL3ZhciBibG9ja0hhcmR3YXJlQmFja0J1dHRvbj1mdW5jdGlvbigpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJiYWNrYnV0dG9uXCIsKGZ1bmN0aW9uKCl7fSkpfTt2YXIgc3RhcnRIYXJkd2FyZUJhY2tCdXR0b249ZnVuY3Rpb24oKXt2YXIgcj1kb2N1bWVudDt2YXIgdD1mYWxzZTtyLmFkZEV2ZW50TGlzdGVuZXIoXCJiYWNrYnV0dG9uXCIsKGZ1bmN0aW9uKCl7aWYodCl7cmV0dXJufXZhciBuPTA7dmFyIGU9W107dmFyIGE9bmV3IEN1c3RvbUV2ZW50KFwiaW9uQmFja0J1dHRvblwiLHtidWJibGVzOmZhbHNlLGRldGFpbDp7cmVnaXN0ZXI6ZnVuY3Rpb24ocix0KXtlLnB1c2goe3ByaW9yaXR5OnIsaGFuZGxlcjp0LGlkOm4rK30pfX19KTtyLmRpc3BhdGNoRXZlbnQoYSk7dmFyIGk9ZnVuY3Rpb24ocil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOmUudHJ5cy5wdXNoKFswLDMsLDRdKTtpZighKHImJnIuaGFuZGxlcikpcmV0dXJuWzMsMl07dD1yLmhhbmRsZXIobyk7aWYoISh0IT1udWxsKSlyZXR1cm5bMywyXTtyZXR1cm5bNCx0XTtjYXNlIDE6ZS5zZW50KCk7ZS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMyw0XTtjYXNlIDM6bj1lLnNlbnQoKTtjb25zb2xlLmVycm9yKG4pO3JldHVyblszLDRdO2Nhc2UgNDpyZXR1cm5bMl19fSkpfSkpfTt2YXIgbz1mdW5jdGlvbigpe2lmKGUubGVuZ3RoPjApe3ZhciByPXtwcmlvcml0eTpOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixoYW5kbGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHVuZGVmaW5lZH0saWQ6LTF9O2UuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYodC5wcmlvcml0eT49ci5wcmlvcml0eSl7cj10fX0pKTt0PXRydWU7ZT1lLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWQhPT1yLmlkfSkpO2kocikudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gdD1mYWxzZX0pKX19O28oKX0pKX07dmFyIE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFk9MTAwO3ZhciBNRU5VX0JBQ0tfQlVUVE9OX1BSSU9SSVRZPTk5O2V4cG9ydHtNRU5VX0JBQ0tfQlVUVE9OX1BSSU9SSVRZLE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFksYmxvY2tIYXJkd2FyZUJhY2tCdXR0b24sc3RhcnRIYXJkd2FyZUJhY2tCdXR0b259OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47292\n')},17504:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ addEventListener),\n/* harmony export */   "b": () => (/* binding */ removeEventListener),\n/* harmony export */   "c": () => (/* binding */ componentOnReady),\n/* harmony export */   "d": () => (/* binding */ getAriaLabel),\n/* harmony export */   "e": () => (/* binding */ renderHiddenInput),\n/* harmony export */   "f": () => (/* binding */ focusElement),\n/* harmony export */   "g": () => (/* binding */ getElementRoot),\n/* harmony export */   "h": () => (/* binding */ debounceEvent),\n/* harmony export */   "i": () => (/* binding */ inheritAttributes),\n/* harmony export */   "j": () => (/* binding */ findItemLabel),\n/* harmony export */   "k": () => (/* binding */ clamp),\n/* harmony export */   "l": () => (/* binding */ hasShadowDom),\n/* harmony export */   "m": () => (/* binding */ assert),\n/* harmony export */   "n": () => (/* binding */ isEndSide),\n/* harmony export */   "o": () => (/* binding */ debounce),\n/* harmony export */   "p": () => (/* binding */ pointerCoord),\n/* harmony export */   "q": () => (/* binding */ now),\n/* harmony export */   "r": () => (/* binding */ raf),\n/* harmony export */   "s": () => (/* binding */ shallowEqualStringMap),\n/* harmony export */   "t": () => (/* binding */ transitionEndAsync)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var transitionEndAsync=function(e,n){if(n===void 0){n=0}return new Promise((function(t){transitionEnd(e,n,t)}))};var transitionEnd=function(e,n,t){if(n===void 0){n=0}var r;var i;var a={passive:true};var o=500;var u=function(){if(r){r()}};var s=function(n){if(n===undefined||e===n.target){u();t(n)}};if(e){e.addEventListener("webkitTransitionEnd",s,a);e.addEventListener("transitionend",s,a);i=setTimeout(s,n+o);r=function(){if(i){clearTimeout(i);i=undefined}e.removeEventListener("webkitTransitionEnd",s,a);e.removeEventListener("transitionend",s,a)}}return u};var componentOnReady=function(e,n){if(e.componentOnReady){e.componentOnReady().then((function(e){return n(e)}))}else{raf((function(){return n(e)}))}};var inheritAttributes=function(e,n){if(n===void 0){n=[]}var t={};n.forEach((function(n){if(e.hasAttribute(n)){var r=e.getAttribute(n);if(r!==null){t[n]=e.getAttribute(n)}e.removeAttribute(n)}}));return t};var addEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_ael");if(o){return o(e,n,t,r)}else if(a._ael){return a._ael(e,n,t,r)}}}return e.addEventListener(n,t,r)};var removeEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_rel");if(o){return o(e,n,t,r)}else if(a._rel){return a._rel(e,n,t,r)}}}return e.removeEventListener(n,t,r)};var getElementRoot=function(e,n){if(n===void 0){n=e}return e.shadowRoot||n};var raf=function(e){if(typeof __zone_symbol__requestAnimationFrame==="function"){return __zone_symbol__requestAnimationFrame(e)}if(typeof requestAnimationFrame==="function"){return requestAnimationFrame(e)}return setTimeout(e)};var hasShadowDom=function(e){return!!e.shadowRoot&&!!e.attachShadow};var findItemLabel=function(e){var n=e.closest("ion-item");if(n){return n.querySelector("ion-label")}return null};var focusElement=function(e){e.focus();if(e.classList.contains("ion-focusable")){var n=e.closest("ion-app");if(n){n.setFocus([e])}}};var getAriaLabel=function(e,n){var t;var r=e.getAttribute("aria-labelledby");var i=e.id;var a=r!==null&&r.trim()!==""?r:n+"-lbl";var o=r!==null&&r.trim()!==""?document.getElementById(r):findItemLabel(e);if(o){if(r===null){o.id=a}t=o.textContent;o.setAttribute("aria-hidden","true")}else if(i.trim()!==""){o=document.querySelector(\'label[for="\'.concat(i,\'"]\'));if(o){if(o.id!==""){a=o.id}else{o.id=a="".concat(i,"-lbl")}t=o.textContent}}return{label:o,labelId:a,labelText:t}};var renderHiddenInput=function(e,n,t,r,i){if(e||hasShadowDom(n)){var a=n.querySelector("input.aux-input");if(!a){a=n.ownerDocument.createElement("input");a.type="hidden";a.classList.add("aux-input");n.appendChild(a)}a.disabled=i;a.name=t;a.value=r||""}};var clamp=function(e,n,t){return Math.max(e,Math.min(n,t))};var assert=function(e,n){if(!e){var t="ASSERT: "+n;console.error(t);debugger;throw new Error(t)}};var now=function(e){return e.timeStamp||Date.now()};var pointerCoord=function(e){if(e){var n=e.changedTouches;if(n&&n.length>0){var t=n[0];return{x:t.clientX,y:t.clientY}}if(e.pageX!==undefined){return{x:e.pageX,y:e.pageY}}}return{x:0,y:0}};var isEndSide=function(e){var n=document.dir==="rtl";switch(e){case"start":return n;case"end":return!n;default:throw new Error(\'"\'.concat(e,\'" is not a valid value for [side]. Use "start" or "end" instead.\'))}};var debounceEvent=function(e,n){var t=e._original||e;return{_original:e,emit:debounce(t.emit.bind(t),n)}};var debounce=function(e,n){if(n===void 0){n=0}var t;return function(){var r=[];for(var i=0;i<arguments.length;i++){r[i]=arguments[i]}clearTimeout(t);t=setTimeout.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e,n],r,false))}};var shallowEqualStringMap=function(e,n){e!==null&&e!==void 0?e:e={};n!==null&&n!==void 0?n:n={};if(e===n){return true}var t=Object.keys(e);if(t.length!==Object.keys(n).length){return false}for(var r=0,i=t;r<i.length;r++){var a=i[r];if(!(a in n)){return false}if(e[a]!==n[a]){return false}}return true};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc1MDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZSxJQUFJLGdDQUFnQyxxQkFBcUIsSUFBSSxrQ0FBa0MsZUFBZSxJQUFJLE1BQU0sTUFBTSxPQUFPLGNBQWMsVUFBVSxpQkFBaUIsTUFBTSxNQUFNLGtCQUFrQixnQ0FBZ0MsSUFBSSxPQUFPLE1BQU0sOENBQThDLHdDQUF3QyxvQkFBb0IsYUFBYSxNQUFNLGdCQUFnQixZQUFZLGlEQUFpRCw0Q0FBNEMsVUFBVSxtQ0FBbUMsdUJBQXVCLHVDQUF1QyxZQUFZLEdBQUcsS0FBSyxnQkFBZ0IsWUFBWSxLQUFLLG9DQUFvQyxlQUFlLEtBQUssU0FBUyx1QkFBdUIsc0JBQXNCLHdCQUF3QixhQUFhLHVCQUF1QixzQkFBc0IsR0FBRyxVQUFVLHVDQUF1QyxnQ0FBZ0MsYUFBYSxpQ0FBaUMsTUFBTSxvQkFBb0IsTUFBTSxrQkFBa0IsZ0JBQWdCLHlCQUF5QixrQ0FBa0MsMENBQTBDLGdDQUFnQyxhQUFhLGlDQUFpQyxNQUFNLG9CQUFvQixNQUFNLGtCQUFrQixnQkFBZ0IseUJBQXlCLHFDQUFxQyxpQ0FBaUMsZUFBZSxJQUFJLHdCQUF3QixvQkFBb0IsNkRBQTZELCtDQUErQyw4Q0FBOEMsZ0NBQWdDLHNCQUFzQiw2QkFBNkIsd0NBQXdDLDhCQUE4Qiw0QkFBNEIsTUFBTSxvQ0FBb0MsYUFBYSw2QkFBNkIsVUFBVSwwQ0FBMEMsMkJBQTJCLE1BQU0sbUJBQW1CLCtCQUErQixNQUFNLHdDQUF3QyxXQUFXLHlDQUF5QywwRUFBMEUsTUFBTSxhQUFhLE9BQU8sZ0JBQWdCLHFDQUFxQyx1QkFBdUIsdURBQXVELE1BQU0sY0FBYyxPQUFPLEtBQUssMkJBQTJCLGlCQUFpQixPQUFPLGdDQUFnQywwQ0FBMEMsdUJBQXVCLHlDQUF5QyxPQUFPLHlDQUF5QyxnQkFBZ0IsNkJBQTZCLGlCQUFpQixhQUFhLFNBQVMsZ0JBQWdCLDBCQUEwQixrQ0FBa0MseUJBQXlCLE9BQU8sbUJBQW1CLGlCQUFpQixTQUFTLHFCQUFxQixvQkFBb0IsZ0NBQWdDLDZCQUE2QixNQUFNLHVCQUF1QixrQkFBa0IsV0FBVyxPQUFPLHlCQUF5Qix3QkFBd0IsT0FBTyxzQkFBc0IsT0FBTyxVQUFVLDBCQUEwQiwyQkFBMkIsVUFBVSxxQkFBcUIsbUJBQW1CLDRHQUE0RyxnQ0FBZ0MscUJBQXFCLE9BQU8sOENBQThDLDJCQUEyQixlQUFlLElBQUksTUFBTSxrQkFBa0IsU0FBUyxZQUFZLG1CQUFtQixLQUFLLGtCQUFrQixnQkFBZ0IsMEJBQTBCLDhEQUFhLG1CQUFtQix3Q0FBd0MsNEJBQTRCLDRCQUE0QixVQUFVLFlBQVkscUJBQXFCLHFDQUFxQyxhQUFhLGdCQUFnQixXQUFXLEtBQUssV0FBVyxjQUFjLGFBQWEsZ0JBQWdCLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9oZWxwZXJzLTZlMWU1YjY1LmpzP2E4ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fc3ByZWFkQXJyYXl9ZnJvbVwidHNsaWJcIjtcbi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovdmFyIHRyYW5zaXRpb25FbmRBc3luYz1mdW5jdGlvbihlLG4pe2lmKG49PT12b2lkIDApe249MH1yZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3RyYW5zaXRpb25FbmQoZSxuLHQpfSkpfTt2YXIgdHJhbnNpdGlvbkVuZD1mdW5jdGlvbihlLG4sdCl7aWYobj09PXZvaWQgMCl7bj0wfXZhciByO3ZhciBpO3ZhciBhPXtwYXNzaXZlOnRydWV9O3ZhciBvPTUwMDt2YXIgdT1mdW5jdGlvbigpe2lmKHIpe3IoKX19O3ZhciBzPWZ1bmN0aW9uKG4pe2lmKG49PT11bmRlZmluZWR8fGU9PT1uLnRhcmdldCl7dSgpO3Qobil9fTtpZihlKXtlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIscyxhKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIscyxhKTtpPXNldFRpbWVvdXQocyxuK28pO3I9ZnVuY3Rpb24oKXtpZihpKXtjbGVhclRpbWVvdXQoaSk7aT11bmRlZmluZWR9ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLHMsYSk7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLHMsYSl9fXJldHVybiB1fTt2YXIgY29tcG9uZW50T25SZWFkeT1mdW5jdGlvbihlLG4pe2lmKGUuY29tcG9uZW50T25SZWFkeSl7ZS5jb21wb25lbnRPblJlYWR5KCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSl9KSl9ZWxzZXtyYWYoKGZ1bmN0aW9uKCl7cmV0dXJuIG4oZSl9KSl9fTt2YXIgaW5oZXJpdEF0dHJpYnV0ZXM9ZnVuY3Rpb24oZSxuKXtpZihuPT09dm9pZCAwKXtuPVtdfXZhciB0PXt9O24uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoZS5oYXNBdHRyaWJ1dGUobikpe3ZhciByPWUuZ2V0QXR0cmlidXRlKG4pO2lmKHIhPT1udWxsKXt0W25dPWUuZ2V0QXR0cmlidXRlKG4pfWUucmVtb3ZlQXR0cmlidXRlKG4pfX0pKTtyZXR1cm4gdH07dmFyIGFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZSxuLHQscil7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe3ZhciBpPXdpbmRvdzt2YXIgYT1pJiZpLklvbmljJiZpLklvbmljLmNvbmZpZztpZihhKXt2YXIgbz1hLmdldChcIl9hZWxcIik7aWYobyl7cmV0dXJuIG8oZSxuLHQscil9ZWxzZSBpZihhLl9hZWwpe3JldHVybiBhLl9hZWwoZSxuLHQscil9fX1yZXR1cm4gZS5hZGRFdmVudExpc3RlbmVyKG4sdCxyKX07dmFyIHJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZSxuLHQscil7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe3ZhciBpPXdpbmRvdzt2YXIgYT1pJiZpLklvbmljJiZpLklvbmljLmNvbmZpZztpZihhKXt2YXIgbz1hLmdldChcIl9yZWxcIik7aWYobyl7cmV0dXJuIG8oZSxuLHQscil9ZWxzZSBpZihhLl9yZWwpe3JldHVybiBhLl9yZWwoZSxuLHQscil9fX1yZXR1cm4gZS5yZW1vdmVFdmVudExpc3RlbmVyKG4sdCxyKX07dmFyIGdldEVsZW1lbnRSb290PWZ1bmN0aW9uKGUsbil7aWYobj09PXZvaWQgMCl7bj1lfXJldHVybiBlLnNoYWRvd1Jvb3R8fG59O3ZhciByYWY9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIF9fem9uZV9zeW1ib2xfX3JlcXVlc3RBbmltYXRpb25GcmFtZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIF9fem9uZV9zeW1ib2xfX3JlcXVlc3RBbmltYXRpb25GcmFtZShlKX1pZih0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpfXJldHVybiBzZXRUaW1lb3V0KGUpfTt2YXIgaGFzU2hhZG93RG9tPWZ1bmN0aW9uKGUpe3JldHVybiEhZS5zaGFkb3dSb290JiYhIWUuYXR0YWNoU2hhZG93fTt2YXIgZmluZEl0ZW1MYWJlbD1mdW5jdGlvbihlKXt2YXIgbj1lLmNsb3Nlc3QoXCJpb24taXRlbVwiKTtpZihuKXtyZXR1cm4gbi5xdWVyeVNlbGVjdG9yKFwiaW9uLWxhYmVsXCIpfXJldHVybiBudWxsfTt2YXIgZm9jdXNFbGVtZW50PWZ1bmN0aW9uKGUpe2UuZm9jdXMoKTtpZihlLmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1mb2N1c2FibGVcIikpe3ZhciBuPWUuY2xvc2VzdChcImlvbi1hcHBcIik7aWYobil7bi5zZXRGb2N1cyhbZV0pfX19O3ZhciBnZXRBcmlhTGFiZWw9ZnVuY3Rpb24oZSxuKXt2YXIgdDt2YXIgcj1lLmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTt2YXIgaT1lLmlkO3ZhciBhPXIhPT1udWxsJiZyLnRyaW0oKSE9PVwiXCI/cjpuK1wiLWxibFwiO3ZhciBvPXIhPT1udWxsJiZyLnRyaW0oKSE9PVwiXCI/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocik6ZmluZEl0ZW1MYWJlbChlKTtpZihvKXtpZihyPT09bnVsbCl7by5pZD1hfXQ9by50ZXh0Q29udGVudDtvLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpfWVsc2UgaWYoaS50cmltKCkhPT1cIlwiKXtvPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj1cIicuY29uY2F0KGksJ1wiXScpKTtpZihvKXtpZihvLmlkIT09XCJcIil7YT1vLmlkfWVsc2V7by5pZD1hPVwiXCIuY29uY2F0KGksXCItbGJsXCIpfXQ9by50ZXh0Q29udGVudH19cmV0dXJue2xhYmVsOm8sbGFiZWxJZDphLGxhYmVsVGV4dDp0fX07dmFyIHJlbmRlckhpZGRlbklucHV0PWZ1bmN0aW9uKGUsbix0LHIsaSl7aWYoZXx8aGFzU2hhZG93RG9tKG4pKXt2YXIgYT1uLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dC5hdXgtaW5wdXRcIik7aWYoIWEpe2E9bi5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTthLnR5cGU9XCJoaWRkZW5cIjthLmNsYXNzTGlzdC5hZGQoXCJhdXgtaW5wdXRcIik7bi5hcHBlbmRDaGlsZChhKX1hLmRpc2FibGVkPWk7YS5uYW1lPXQ7YS52YWx1ZT1yfHxcIlwifX07dmFyIGNsYW1wPWZ1bmN0aW9uKGUsbix0KXtyZXR1cm4gTWF0aC5tYXgoZSxNYXRoLm1pbihuLHQpKX07dmFyIGFzc2VydD1mdW5jdGlvbihlLG4pe2lmKCFlKXt2YXIgdD1cIkFTU0VSVDogXCIrbjtjb25zb2xlLmVycm9yKHQpO2RlYnVnZ2VyO3Rocm93IG5ldyBFcnJvcih0KX19O3ZhciBub3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGltZVN0YW1wfHxEYXRlLm5vdygpfTt2YXIgcG9pbnRlckNvb3JkPWZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPWUuY2hhbmdlZFRvdWNoZXM7aWYobiYmbi5sZW5ndGg+MCl7dmFyIHQ9blswXTtyZXR1cm57eDp0LmNsaWVudFgseTp0LmNsaWVudFl9fWlmKGUucGFnZVghPT11bmRlZmluZWQpe3JldHVybnt4OmUucGFnZVgseTplLnBhZ2VZfX19cmV0dXJue3g6MCx5OjB9fTt2YXIgaXNFbmRTaWRlPWZ1bmN0aW9uKGUpe3ZhciBuPWRvY3VtZW50LmRpcj09PVwicnRsXCI7c3dpdGNoKGUpe2Nhc2VcInN0YXJ0XCI6cmV0dXJuIG47Y2FzZVwiZW5kXCI6cmV0dXJuIW47ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQoZSwnXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFtzaWRlXS4gVXNlIFwic3RhcnRcIiBvciBcImVuZFwiIGluc3RlYWQuJykpfX07dmFyIGRlYm91bmNlRXZlbnQ9ZnVuY3Rpb24oZSxuKXt2YXIgdD1lLl9vcmlnaW5hbHx8ZTtyZXR1cm57X29yaWdpbmFsOmUsZW1pdDpkZWJvdW5jZSh0LmVtaXQuYmluZCh0KSxuKX19O3ZhciBkZWJvdW5jZT1mdW5jdGlvbihlLG4pe2lmKG49PT12b2lkIDApe249MH12YXIgdDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcj1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtyW2ldPWFyZ3VtZW50c1tpXX1jbGVhclRpbWVvdXQodCk7dD1zZXRUaW1lb3V0LmFwcGx5KHZvaWQgMCxfX3NwcmVhZEFycmF5KFtlLG5dLHIsZmFsc2UpKX19O3ZhciBzaGFsbG93RXF1YWxTdHJpbmdNYXA9ZnVuY3Rpb24oZSxuKXtlIT09bnVsbCYmZSE9PXZvaWQgMD9lOmU9e307biE9PW51bGwmJm4hPT12b2lkIDA/bjpuPXt9O2lmKGU9PT1uKXtyZXR1cm4gdHJ1ZX12YXIgdD1PYmplY3Qua2V5cyhlKTtpZih0Lmxlbmd0aCE9PU9iamVjdC5rZXlzKG4pLmxlbmd0aCl7cmV0dXJuIGZhbHNlfWZvcih2YXIgcj0wLGk9dDtyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aVtyXTtpZighKGEgaW4gbikpe3JldHVybiBmYWxzZX1pZihlW2FdIT09blthXSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX07ZXhwb3J0e2FkZEV2ZW50TGlzdGVuZXIgYXMgYSxyZW1vdmVFdmVudExpc3RlbmVyIGFzIGIsY29tcG9uZW50T25SZWFkeSBhcyBjLGdldEFyaWFMYWJlbCBhcyBkLHJlbmRlckhpZGRlbklucHV0IGFzIGUsZm9jdXNFbGVtZW50IGFzIGYsZ2V0RWxlbWVudFJvb3QgYXMgZyxkZWJvdW5jZUV2ZW50IGFzIGgsaW5oZXJpdEF0dHJpYnV0ZXMgYXMgaSxmaW5kSXRlbUxhYmVsIGFzIGosY2xhbXAgYXMgayxoYXNTaGFkb3dEb20gYXMgbCxhc3NlcnQgYXMgbSxpc0VuZFNpZGUgYXMgbixkZWJvdW5jZSBhcyBvLHBvaW50ZXJDb29yZCBhcyBwLG5vdyBhcyBxLHJhZiBhcyByLHNoYWxsb3dFcXVhbFN0cmluZ01hcCBhcyBzLHRyYW5zaXRpb25FbmRBc3luYyBhcyB0fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17504\n')},23876:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "GESTURE_CONTROLLER": () => (/* reexport safe */ _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   "createGesture": () => (/* binding */ createGesture)\n/* harmony export */ });\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4988);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar addEventListener=function(e,r,t,a){var n=supportsPassive(e)?{capture:!!a.capture,passive:!!a.passive}:!!a.capture;var i;var u;if(e["__zone_symbol__addEventListener"]){i="__zone_symbol__addEventListener";u="__zone_symbol__removeEventListener"}else{i="addEventListener";u="removeEventListener"}e[i](r,t,n);return function(){e[u](r,t,n)}};var supportsPassive=function(e){if(_sPassive===undefined){try{var r=Object.defineProperty({},"passive",{get:function(){_sPassive=true}});e.addEventListener("optsTest",(function(){return}),r)}catch(e){_sPassive=false}}return!!_sPassive};var _sPassive;var MOUSE_WAIT=2e3;var createPointerEvents=function(e,r,t,a,n){var i;var u;var s;var v;var f;var o;var c;var l=0;var d=function(a){l=Date.now()+MOUSE_WAIT;if(!r(a)){return}if(!u&&t){u=addEventListener(e,"touchmove",t,n)}if(!s){s=addEventListener(a.target,"touchend",p,n)}if(!v){v=addEventListener(a.target,"touchcancel",p,n)}};var m=function(a){if(l>Date.now()){return}if(!r(a)){return}if(!o&&t){o=addEventListener(getDocument(e),"mousemove",t,n)}if(!c){c=addEventListener(getDocument(e),"mouseup",E,n)}};var p=function(e){_();if(a){a(e)}};var E=function(e){g();if(a){a(e)}};var _=function(){if(u){u()}if(s){s()}if(v){v()}u=s=v=undefined};var g=function(){if(o){o()}if(c){c()}o=c=undefined};var y=function(){_();g()};var X=function(r){if(r===void 0){r=true}if(!r){if(i){i()}if(f){f()}i=f=undefined;y()}else{if(!i){i=addEventListener(e,"touchstart",d,n)}if(!f){f=addEventListener(e,"mousedown",m,n)}}};var Y=function(){X(false);a=t=r=undefined};return{enable:X,stop:y,destroy:Y}};var getDocument=function(e){return e instanceof Document?e:e.ownerDocument};var createPanRecognizer=function(e,r,t){var a=t*(Math.PI/180);var n=e==="x";var i=Math.cos(a);var u=r*r;var s=0;var v=0;var f=false;var o=0;return{start:function(e,r){s=e;v=r;o=0;f=true},detect:function(e,r){if(!f){return false}var t=e-s;var a=r-v;var c=t*t+a*a;if(c<u){return false}var l=Math.sqrt(c);var d=(n?t:a)/l;if(d>i){o=1}else if(d<-i){o=-1}else{o=0}f=false;return true},isGesture:function(){return o!==0},getDirection:function(){return o}}};var createGesture=function(e){var r=false;var t=false;var a=true;var n=false;var i=Object.assign({disableScroll:false,direction:"x",gesturePriority:0,passive:true,maxAngle:40,threshold:10},e);var u=i.canStart;var s=i.onWillStart;var v=i.onStart;var f=i.onEnd;var o=i.notCaptured;var c=i.onMove;var l=i.threshold;var d=i.passive;var m=i.blurOnStart;var p={type:"pan",startX:0,startY:0,startTime:0,currentX:0,currentY:0,velocityX:0,velocityY:0,deltaX:0,deltaY:0,currentTime:0,event:undefined,data:undefined};var E=createPanRecognizer(i.direction,i.threshold,i.maxAngle);var _=_gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G.createGesture({name:e.gestureName,priority:e.gesturePriority,disableScroll:e.disableScroll});var g=function(e){var r=now(e);if(t||!a){return false}updateDetail(e,p);p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime=r;p.velocityX=p.velocityY=p.deltaX=p.deltaY=0;p.event=e;if(u&&u(p)===false){return false}_.release();if(!_.start()){return false}t=true;if(l===0){return Y()}E.start(p.startX,p.startY);return true};var y=function(e){if(r){if(!n&&a){n=true;calcGestureData(p,e);requestAnimationFrame(X)}return}calcGestureData(p,e);if(E.detect(p.currentX,p.currentY)){if(!E.isGesture()||!Y()){b()}}};var X=function(){if(!r){return}n=false;if(c){c(p)}};var Y=function(){if(_&&!_.capture()){return false}r=true;a=false;p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime;if(s){s(p).then(h)}else{h()}return true};var L=function(){if(typeof document!=="undefined"){var e=document.activeElement;if(e!==null&&e.blur){e.blur()}}};var h=function(){if(m){L()}if(v){v(p)}a=true};var T=function(){r=false;t=false;n=false;a=true;_.release()};var D=function(e){var t=r;var n=a;T();if(!n){return}calcGestureData(p,e);if(t){if(f){f(p)}return}if(o){o(p)}};var P=createPointerEvents(i.el,g,y,D,{capture:false,passive:d});var b=function(){T();P.stop();if(o){o(p)}};return{enable:function(e){if(e===void 0){e=true}if(!e){if(r){D(undefined)}T()}P.enable(e)},destroy:function(){_.destroy();P.destroy()}}};var calcGestureData=function(e,r){if(!r){return}var t=e.currentX;var a=e.currentY;var n=e.currentTime;updateDetail(r,e);var i=e.currentX;var u=e.currentY;var s=e.currentTime=now(r);var v=s-n;if(v>0&&v<100){var f=(i-t)/v;var o=(u-a)/v;e.velocityX=f*.7+e.velocityX*.3;e.velocityY=o*.7+e.velocityY*.3}e.deltaX=i-e.startX;e.deltaY=u-e.startY;e.event=r};var updateDetail=function(e,r){var t=0;var a=0;if(e){var n=e.changedTouches;if(n&&n.length>0){var i=n[0];t=i.clientX;a=i.clientY}else if(e.pageX!==undefined){t=e.pageX;a=e.pageY}}r.currentX=t;r.currentY=a};var now=function(e){return e.timeStamp||Date.now()};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LTQxYmY0MWYyLmpzP2M4YjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydHtHIGFzIEdFU1RVUkVfQ09OVFJPTExFUn1mcm9tXCIuL2dlc3R1cmUtY29udHJvbGxlci02OGMwMjNhNC5qc1wiO2V4cG9ydHtHIGFzIEdFU1RVUkVfQ09OVFJPTExFUn1mcm9tXCIuL2dlc3R1cmUtY29udHJvbGxlci02OGMwMjNhNC5qc1wiO3ZhciBhZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUscix0LGEpe3ZhciBuPXN1cHBvcnRzUGFzc2l2ZShlKT97Y2FwdHVyZTohIWEuY2FwdHVyZSxwYXNzaXZlOiEhYS5wYXNzaXZlfTohIWEuY2FwdHVyZTt2YXIgaTt2YXIgdTtpZihlW1wiX196b25lX3N5bWJvbF9fYWRkRXZlbnRMaXN0ZW5lclwiXSl7aT1cIl9fem9uZV9zeW1ib2xfX2FkZEV2ZW50TGlzdGVuZXJcIjt1PVwiX196b25lX3N5bWJvbF9fcmVtb3ZlRXZlbnRMaXN0ZW5lclwifWVsc2V7aT1cImFkZEV2ZW50TGlzdGVuZXJcIjt1PVwicmVtb3ZlRXZlbnRMaXN0ZW5lclwifWVbaV0ocix0LG4pO3JldHVybiBmdW5jdGlvbigpe2VbdV0ocix0LG4pfX07dmFyIHN1cHBvcnRzUGFzc2l2ZT1mdW5jdGlvbihlKXtpZihfc1Bhc3NpdmU9PT11bmRlZmluZWQpe3RyeXt2YXIgcj1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe19zUGFzc2l2ZT10cnVlfX0pO2UuYWRkRXZlbnRMaXN0ZW5lcihcIm9wdHNUZXN0XCIsKGZ1bmN0aW9uKCl7cmV0dXJufSkscil9Y2F0Y2goZSl7X3NQYXNzaXZlPWZhbHNlfX1yZXR1cm4hIV9zUGFzc2l2ZX07dmFyIF9zUGFzc2l2ZTt2YXIgTU9VU0VfV0FJVD0yZTM7dmFyIGNyZWF0ZVBvaW50ZXJFdmVudHM9ZnVuY3Rpb24oZSxyLHQsYSxuKXt2YXIgaTt2YXIgdTt2YXIgczt2YXIgdjt2YXIgZjt2YXIgbzt2YXIgYzt2YXIgbD0wO3ZhciBkPWZ1bmN0aW9uKGEpe2w9RGF0ZS5ub3coKStNT1VTRV9XQUlUO2lmKCFyKGEpKXtyZXR1cm59aWYoIXUmJnQpe3U9YWRkRXZlbnRMaXN0ZW5lcihlLFwidG91Y2htb3ZlXCIsdCxuKX1pZighcyl7cz1hZGRFdmVudExpc3RlbmVyKGEudGFyZ2V0LFwidG91Y2hlbmRcIixwLG4pfWlmKCF2KXt2PWFkZEV2ZW50TGlzdGVuZXIoYS50YXJnZXQsXCJ0b3VjaGNhbmNlbFwiLHAsbil9fTt2YXIgbT1mdW5jdGlvbihhKXtpZihsPkRhdGUubm93KCkpe3JldHVybn1pZighcihhKSl7cmV0dXJufWlmKCFvJiZ0KXtvPWFkZEV2ZW50TGlzdGVuZXIoZ2V0RG9jdW1lbnQoZSksXCJtb3VzZW1vdmVcIix0LG4pfWlmKCFjKXtjPWFkZEV2ZW50TGlzdGVuZXIoZ2V0RG9jdW1lbnQoZSksXCJtb3VzZXVwXCIsRSxuKX19O3ZhciBwPWZ1bmN0aW9uKGUpe18oKTtpZihhKXthKGUpfX07dmFyIEU9ZnVuY3Rpb24oZSl7ZygpO2lmKGEpe2EoZSl9fTt2YXIgXz1mdW5jdGlvbigpe2lmKHUpe3UoKX1pZihzKXtzKCl9aWYodil7digpfXU9cz12PXVuZGVmaW5lZH07dmFyIGc9ZnVuY3Rpb24oKXtpZihvKXtvKCl9aWYoYyl7YygpfW89Yz11bmRlZmluZWR9O3ZhciB5PWZ1bmN0aW9uKCl7XygpO2coKX07dmFyIFg9ZnVuY3Rpb24ocil7aWYocj09PXZvaWQgMCl7cj10cnVlfWlmKCFyKXtpZihpKXtpKCl9aWYoZil7ZigpfWk9Zj11bmRlZmluZWQ7eSgpfWVsc2V7aWYoIWkpe2k9YWRkRXZlbnRMaXN0ZW5lcihlLFwidG91Y2hzdGFydFwiLGQsbil9aWYoIWYpe2Y9YWRkRXZlbnRMaXN0ZW5lcihlLFwibW91c2Vkb3duXCIsbSxuKX19fTt2YXIgWT1mdW5jdGlvbigpe1goZmFsc2UpO2E9dD1yPXVuZGVmaW5lZH07cmV0dXJue2VuYWJsZTpYLHN0b3A6eSxkZXN0cm95Oll9fTt2YXIgZ2V0RG9jdW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBEb2N1bWVudD9lOmUub3duZXJEb2N1bWVudH07dmFyIGNyZWF0ZVBhblJlY29nbml6ZXI9ZnVuY3Rpb24oZSxyLHQpe3ZhciBhPXQqKE1hdGguUEkvMTgwKTt2YXIgbj1lPT09XCJ4XCI7dmFyIGk9TWF0aC5jb3MoYSk7dmFyIHU9cipyO3ZhciBzPTA7dmFyIHY9MDt2YXIgZj1mYWxzZTt2YXIgbz0wO3JldHVybntzdGFydDpmdW5jdGlvbihlLHIpe3M9ZTt2PXI7bz0wO2Y9dHJ1ZX0sZGV0ZWN0OmZ1bmN0aW9uKGUscil7aWYoIWYpe3JldHVybiBmYWxzZX12YXIgdD1lLXM7dmFyIGE9ci12O3ZhciBjPXQqdCthKmE7aWYoYzx1KXtyZXR1cm4gZmFsc2V9dmFyIGw9TWF0aC5zcXJ0KGMpO3ZhciBkPShuP3Q6YSkvbDtpZihkPmkpe289MX1lbHNlIGlmKGQ8LWkpe289LTF9ZWxzZXtvPTB9Zj1mYWxzZTtyZXR1cm4gdHJ1ZX0saXNHZXN0dXJlOmZ1bmN0aW9uKCl7cmV0dXJuIG8hPT0wfSxnZXREaXJlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gb319fTt2YXIgY3JlYXRlR2VzdHVyZT1mdW5jdGlvbihlKXt2YXIgcj1mYWxzZTt2YXIgdD1mYWxzZTt2YXIgYT10cnVlO3ZhciBuPWZhbHNlO3ZhciBpPU9iamVjdC5hc3NpZ24oe2Rpc2FibGVTY3JvbGw6ZmFsc2UsZGlyZWN0aW9uOlwieFwiLGdlc3R1cmVQcmlvcml0eTowLHBhc3NpdmU6dHJ1ZSxtYXhBbmdsZTo0MCx0aHJlc2hvbGQ6MTB9LGUpO3ZhciB1PWkuY2FuU3RhcnQ7dmFyIHM9aS5vbldpbGxTdGFydDt2YXIgdj1pLm9uU3RhcnQ7dmFyIGY9aS5vbkVuZDt2YXIgbz1pLm5vdENhcHR1cmVkO3ZhciBjPWkub25Nb3ZlO3ZhciBsPWkudGhyZXNob2xkO3ZhciBkPWkucGFzc2l2ZTt2YXIgbT1pLmJsdXJPblN0YXJ0O3ZhciBwPXt0eXBlOlwicGFuXCIsc3RhcnRYOjAsc3RhcnRZOjAsc3RhcnRUaW1lOjAsY3VycmVudFg6MCxjdXJyZW50WTowLHZlbG9jaXR5WDowLHZlbG9jaXR5WTowLGRlbHRhWDowLGRlbHRhWTowLGN1cnJlbnRUaW1lOjAsZXZlbnQ6dW5kZWZpbmVkLGRhdGE6dW5kZWZpbmVkfTt2YXIgRT1jcmVhdGVQYW5SZWNvZ25pemVyKGkuZGlyZWN0aW9uLGkudGhyZXNob2xkLGkubWF4QW5nbGUpO3ZhciBfPUdFU1RVUkVfQ09OVFJPTExFUi5jcmVhdGVHZXN0dXJlKHtuYW1lOmUuZ2VzdHVyZU5hbWUscHJpb3JpdHk6ZS5nZXN0dXJlUHJpb3JpdHksZGlzYWJsZVNjcm9sbDplLmRpc2FibGVTY3JvbGx9KTt2YXIgZz1mdW5jdGlvbihlKXt2YXIgcj1ub3coZSk7aWYodHx8IWEpe3JldHVybiBmYWxzZX11cGRhdGVEZXRhaWwoZSxwKTtwLnN0YXJ0WD1wLmN1cnJlbnRYO3Auc3RhcnRZPXAuY3VycmVudFk7cC5zdGFydFRpbWU9cC5jdXJyZW50VGltZT1yO3AudmVsb2NpdHlYPXAudmVsb2NpdHlZPXAuZGVsdGFYPXAuZGVsdGFZPTA7cC5ldmVudD1lO2lmKHUmJnUocCk9PT1mYWxzZSl7cmV0dXJuIGZhbHNlfV8ucmVsZWFzZSgpO2lmKCFfLnN0YXJ0KCkpe3JldHVybiBmYWxzZX10PXRydWU7aWYobD09PTApe3JldHVybiBZKCl9RS5zdGFydChwLnN0YXJ0WCxwLnN0YXJ0WSk7cmV0dXJuIHRydWV9O3ZhciB5PWZ1bmN0aW9uKGUpe2lmKHIpe2lmKCFuJiZhKXtuPXRydWU7Y2FsY0dlc3R1cmVEYXRhKHAsZSk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKFgpfXJldHVybn1jYWxjR2VzdHVyZURhdGEocCxlKTtpZihFLmRldGVjdChwLmN1cnJlbnRYLHAuY3VycmVudFkpKXtpZighRS5pc0dlc3R1cmUoKXx8IVkoKSl7YigpfX19O3ZhciBYPWZ1bmN0aW9uKCl7aWYoIXIpe3JldHVybn1uPWZhbHNlO2lmKGMpe2MocCl9fTt2YXIgWT1mdW5jdGlvbigpe2lmKF8mJiFfLmNhcHR1cmUoKSl7cmV0dXJuIGZhbHNlfXI9dHJ1ZTthPWZhbHNlO3Auc3RhcnRYPXAuY3VycmVudFg7cC5zdGFydFk9cC5jdXJyZW50WTtwLnN0YXJ0VGltZT1wLmN1cnJlbnRUaW1lO2lmKHMpe3MocCkudGhlbihoKX1lbHNle2goKX1yZXR1cm4gdHJ1ZX07dmFyIEw9ZnVuY3Rpb24oKXtpZih0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiKXt2YXIgZT1kb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKGUhPT1udWxsJiZlLmJsdXIpe2UuYmx1cigpfX19O3ZhciBoPWZ1bmN0aW9uKCl7aWYobSl7TCgpfWlmKHYpe3YocCl9YT10cnVlfTt2YXIgVD1mdW5jdGlvbigpe3I9ZmFsc2U7dD1mYWxzZTtuPWZhbHNlO2E9dHJ1ZTtfLnJlbGVhc2UoKX07dmFyIEQ9ZnVuY3Rpb24oZSl7dmFyIHQ9cjt2YXIgbj1hO1QoKTtpZighbil7cmV0dXJufWNhbGNHZXN0dXJlRGF0YShwLGUpO2lmKHQpe2lmKGYpe2YocCl9cmV0dXJufWlmKG8pe28ocCl9fTt2YXIgUD1jcmVhdGVQb2ludGVyRXZlbnRzKGkuZWwsZyx5LEQse2NhcHR1cmU6ZmFsc2UscGFzc2l2ZTpkfSk7dmFyIGI9ZnVuY3Rpb24oKXtUKCk7UC5zdG9wKCk7aWYobyl7byhwKX19O3JldHVybntlbmFibGU6ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT10cnVlfWlmKCFlKXtpZihyKXtEKHVuZGVmaW5lZCl9VCgpfVAuZW5hYmxlKGUpfSxkZXN0cm95OmZ1bmN0aW9uKCl7Xy5kZXN0cm95KCk7UC5kZXN0cm95KCl9fX07dmFyIGNhbGNHZXN0dXJlRGF0YT1mdW5jdGlvbihlLHIpe2lmKCFyKXtyZXR1cm59dmFyIHQ9ZS5jdXJyZW50WDt2YXIgYT1lLmN1cnJlbnRZO3ZhciBuPWUuY3VycmVudFRpbWU7dXBkYXRlRGV0YWlsKHIsZSk7dmFyIGk9ZS5jdXJyZW50WDt2YXIgdT1lLmN1cnJlbnRZO3ZhciBzPWUuY3VycmVudFRpbWU9bm93KHIpO3ZhciB2PXMtbjtpZih2PjAmJnY8MTAwKXt2YXIgZj0oaS10KS92O3ZhciBvPSh1LWEpL3Y7ZS52ZWxvY2l0eVg9ZiouNytlLnZlbG9jaXR5WCouMztlLnZlbG9jaXR5WT1vKi43K2UudmVsb2NpdHlZKi4zfWUuZGVsdGFYPWktZS5zdGFydFg7ZS5kZWx0YVk9dS1lLnN0YXJ0WTtlLmV2ZW50PXJ9O3ZhciB1cGRhdGVEZXRhaWw9ZnVuY3Rpb24oZSxyKXt2YXIgdD0wO3ZhciBhPTA7aWYoZSl7dmFyIG49ZS5jaGFuZ2VkVG91Y2hlcztpZihuJiZuLmxlbmd0aD4wKXt2YXIgaT1uWzBdO3Q9aS5jbGllbnRYO2E9aS5jbGllbnRZfWVsc2UgaWYoZS5wYWdlWCE9PXVuZGVmaW5lZCl7dD1lLnBhZ2VYO2E9ZS5wYWdlWX19ci5jdXJyZW50WD10O3IuY3VycmVudFk9YX07dmFyIG5vdz1mdW5jdGlvbihlKXtyZXR1cm4gZS50aW1lU3RhbXB8fERhdGUubm93KCl9O2V4cG9ydHtjcmVhdGVHZXN0dXJlfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23876\n')},82896:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ Build),\n/* harmony export */   "H": () => (/* binding */ Host),\n/* harmony export */   "N": () => (/* binding */ NAMESPACE),\n/* harmony export */   "a": () => (/* binding */ setMode),\n/* harmony export */   "b": () => (/* binding */ bootstrapLazy),\n/* harmony export */   "c": () => (/* binding */ writeTask),\n/* harmony export */   "d": () => (/* binding */ doc),\n/* harmony export */   "e": () => (/* binding */ createEvent),\n/* harmony export */   "f": () => (/* binding */ readTask),\n/* harmony export */   "g": () => (/* binding */ getMode),\n/* harmony export */   "h": () => (/* binding */ h),\n/* harmony export */   "i": () => (/* binding */ getElement),\n/* harmony export */   "j": () => (/* binding */ forceUpdate),\n/* harmony export */   "k": () => (/* binding */ getAssetPath),\n/* harmony export */   "p": () => (/* binding */ promiseResolve),\n/* harmony export */   "r": () => (/* binding */ registerInstance),\n/* harmony export */   "s": () => (/* binding */ setPlatformHelpers),\n/* harmony export */   "w": () => (/* binding */ win)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var NAMESPACE="ionic";var scopeId;var contentRef;var hostTagName;var useNativeShadowDom=false;var checkSlotFallbackVisibility=false;var checkSlotRelocate=false;var isSvgMode=false;var queuePending=false;var win=typeof window!=="undefined"?window:{};var doc=win.document||{head:{}};var plt={$flags$:0,$resourcesUrl$:"",jmp:function(e){return e()},raf:function(e){return requestAnimationFrame(e)},ael:function(e,t,r,n){return e.addEventListener(t,r,n)},rel:function(e,t,r,n){return e.removeEventListener(t,r,n)},ce:function(e,t){return new CustomEvent(e,t)}};var setPlatformHelpers=function(e){Object.assign(plt,e)};var supportsShadow=true;var promiseResolve=function(e){return Promise.resolve(e)};var supportsConstructibleStylesheets=function(){try{new CSSStyleSheet;return typeof(new CSSStyleSheet).replace==="function"}catch(e){}return false}();var addHostEventListeners=function(e,t,r,n){if(r){r.map((function(r){var n=r[0],a=r[1],o=r[2];var s=getHostListenerTarget(e,n);var i=hostListenerProxy(t,o);var l=hostListenerOpts(n);plt.ael(s,a,i,l);(t.$rmListeners$=t.$rmListeners$||[]).push((function(){return plt.rel(s,a,i,l)}))}))}};var hostListenerProxy=function(e,t){return function(r){try{{if(e.$flags$&256){e.$lazyInstance$[t](r)}else{(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,r])}}}catch(e){consoleError(e)}}};var getHostListenerTarget=function(e,t){if(t&4)return doc;if(t&8)return win;if(t&16)return doc.body;return e};var hostListenerOpts=function(e){return(e&2)!==0};var CONTENT_REF_ID="r";var ORG_LOCATION_ID="o";var SLOT_NODE_ID="s";var TEXT_NODE_ID="t";var HYDRATE_ID="s-id";var HYDRATED_STYLE_ID="sty-id";var HYDRATE_CHILD_ID="c-id";var HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}";var XLINK_NS="http://www.w3.org/1999/xlink";var createTime=function(e,t){if(t===void 0){t=""}{return function(){return}}};var uniqueTime=function(e,t){{return function(){return}}};var rootAppliedStyles=new WeakMap;var registerStyle=function(e,t,r){var n=styles.get(e);if(supportsConstructibleStylesheets&&r){n=n||new CSSStyleSheet;n.replace(t)}else{n=t}styles.set(e,n)};var addStyle=function(e,t,r,n){var a=getScopeId(t,r);var o=styles.get(a);e=e.nodeType===11?e:doc;if(o){if(typeof o==="string"){e=e.head||e;var s=rootAppliedStyles.get(e);var i=void 0;if(!s){rootAppliedStyles.set(e,s=new Set)}if(!s.has(a)){if(e.host&&(i=e.querySelector("[".concat(HYDRATED_STYLE_ID,\'="\').concat(a,\'"]\')))){i.innerHTML=o}else{{i=doc.createElement("style");i.innerHTML=o}e.insertBefore(i,e.querySelector("link"))}if(s){s.add(a)}}}else if(!e.adoptedStyleSheets.includes(o)){e.adoptedStyleSheets=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e.adoptedStyleSheets,true),[o],false)}}return a};var attachStyles=function(e){var t=e.$cmpMeta$;var r=e.$hostElement$;var n=t.$flags$;var a=createTime("attachStyles",t.$tagName$);var o=addStyle(r.shadowRoot?r.shadowRoot:r.getRootNode(),t,e.$modeName$);if(n&10){r["s-sc"]=o;r.classList.add(o+"-h");if(n&2){r.classList.add(o+"-s")}}a()};var getScopeId=function(e,t){return"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$)};var convertScopedToShadow=function(e){return e.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g,"$1{")};var computeMode=function(e){return modeResolutionChain.map((function(t){return t(e)})).find((function(e){return!!e}))};var setMode=function(e){return modeResolutionChain.push(e)};var getMode=function(e){return getHostRef(e).$modeName$};var EMPTY_OBJ={};var SVG_NS="http://www.w3.org/2000/svg";var HTML_NS="http://www.w3.org/1999/xhtml";var isDef=function(e){return e!=null};var isComplexType=function(e){e=typeof e;return e==="object"||e==="function"};var h=function(e,t){var r=[];for(var n=2;n<arguments.length;n++){r[n-2]=arguments[n]}var a=null;var o=null;var s=null;var i=false;var l=false;var $=[];var c=function(t){for(var r=0;r<t.length;r++){a=t[r];if(Array.isArray(a)){c(a)}else if(a!=null&&typeof a!=="boolean"){if(i=typeof e!=="function"&&!isComplexType(a)){a=String(a)}if(i&&l){$[$.length-1].$text$+=a}else{$.push(i?newVNode(null,a):a)}l=i}}};c(r);if(t){if(t.key){o=t.key}if(t.name){s=t.name}{var f=t.className||t.class;if(f){t.class=typeof f!=="object"?f:Object.keys(f).filter((function(e){return f[e]})).join(" ")}}}if(typeof e==="function"){return e(t===null?{}:t,$,vdomFnUtils)}var u=newVNode(e,null);u.$attrs$=t;if($.length>0){u.$children$=$}{u.$key$=o}{u.$name$=s}return u};var newVNode=function(e,t){var r={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};{r.$attrs$=null}{r.$key$=null}{r.$name$=null}return r};var Host={};var isHost=function(e){return e&&e.$tag$===Host};var vdomFnUtils={forEach:function(e,t){return e.map(convertToPublic).forEach(t)},map:function(e,t){return e.map(convertToPublic).map(t).map(convertToPrivate)}};var convertToPublic=function(e){return{vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}};var convertToPrivate=function(e){if(typeof e.vtag==="function"){var t=Object.assign({},e.vattrs);if(e.vkey){t.key=e.vkey}if(e.vname){t.name=e.vname}return h.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e.vtag,t],e.vchildren||[],false))}var r=newVNode(e.vtag,e.vtext);r.$attrs$=e.vattrs;r.$children$=e.vchildren;r.$key$=e.vkey;r.$name$=e.vname;return r};var setAccessor=function(e,t,r,n,a,o){if(r!==n){var s=isMemberInElement(e,t);var i=t.toLowerCase();if(t==="class"){var l=e.classList;var $=parseClassList(r);var c=parseClassList(n);l.remove.apply(l,$.filter((function(e){return e&&!c.includes(e)})));l.add.apply(l,c.filter((function(e){return e&&!$.includes(e)})))}else if(t==="style"){{for(var f in r){if(!n||n[f]==null){if(f.includes("-")){e.style.removeProperty(f)}else{e.style[f]=""}}}}for(var f in n){if(!r||n[f]!==r[f]){if(f.includes("-")){e.style.setProperty(f,n[f])}else{e.style[f]=n[f]}}}}else if(t==="key");else if(t==="ref"){if(n){n(e)}}else if(!s&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"){t=t.slice(3)}else if(isMemberInElement(win,i)){t=i.slice(2)}else{t=i[2]+t.slice(3)}if(r){plt.rel(e,t,r,false)}if(n){plt.ael(e,t,n,false)}}else{var u=isComplexType(n);if((s||u&&n!==null)&&!a){try{if(!e.tagName.includes("-")){var d=n==null?"":n;if(t==="list"){s=false}else if(r==null||e[t]!=d){e[t]=d}}else{e[t]=n}}catch(e){}}var v=false;{if(i!==(i=i.replace(/^xlink\\:?/,""))){t=i;v=true}}if(n==null||n===false){if(n!==false||e.getAttribute(t)===""){if(v){e.removeAttributeNS(XLINK_NS,t)}else{e.removeAttribute(t)}}}else if((!s||o&4||a)&&!u){n=n===true?"":n;if(v){e.setAttributeNS(XLINK_NS,t,n)}else{e.setAttribute(t,n)}}}}};var parseClassListRegex=/\\s/;var parseClassList=function(e){return!e?[]:e.split(parseClassListRegex)};var updateElement=function(e,t,r,n){var a=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$;var o=e&&e.$attrs$||EMPTY_OBJ;var s=t.$attrs$||EMPTY_OBJ;{for(n in o){if(!(n in s)){setAccessor(a,n,o[n],undefined,r,t.$flags$)}}}for(n in s){setAccessor(a,n,o[n],s[n],r,t.$flags$)}};var createElm=function(e,t,r,n){var a=t.$children$[r];var o=0;var s;var i;var l;if(!useNativeShadowDom){checkSlotRelocate=true;if(a.$tag$==="slot"){if(scopeId){n.classList.add(scopeId+"-s")}a.$flags$|=a.$children$?2:1}}if(a.$text$!==null){s=a.$elm$=doc.createTextNode(a.$text$)}else if(a.$flags$&1){s=a.$elm$=doc.createTextNode("")}else{if(!isSvgMode){isSvgMode=a.$tag$==="svg"}s=a.$elm$=doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,a.$flags$&2?"slot-fb":a.$tag$);if(isSvgMode&&a.$tag$==="foreignObject"){isSvgMode=false}{updateElement(null,a,isSvgMode)}if(isDef(scopeId)&&s["s-si"]!==scopeId){s.classList.add(s["s-si"]=scopeId)}if(a.$children$){for(o=0;o<a.$children$.length;++o){i=createElm(e,a,o,s);if(i){s.appendChild(i)}}}{if(a.$tag$==="svg"){isSvgMode=false}else if(s.tagName==="foreignObject"){isSvgMode=true}}}{s["s-hn"]=hostTagName;if(a.$flags$&(2|1)){s["s-sr"]=true;s["s-cr"]=contentRef;s["s-sn"]=a.$name$||"";l=e&&e.$children$&&e.$children$[r];if(l&&l.$tag$===a.$tag$&&e.$elm$){putBackInOriginalLocation(e.$elm$,false)}}}return s};var putBackInOriginalLocation=function(e,t){plt.$flags$|=1;var r=e.childNodes;for(var n=r.length-1;n>=0;n--){var a=r[n];if(a["s-hn"]!==hostTagName&&a["s-ol"]){parentReferenceNode(a).insertBefore(a,referenceNode(a));a["s-ol"].remove();a["s-ol"]=undefined;checkSlotRelocate=true}if(t){putBackInOriginalLocation(a,t)}}plt.$flags$&=~1};var addVnodes=function(e,t,r,n,a,o){var s=e["s-cr"]&&e["s-cr"].parentNode||e;var i;if(s.shadowRoot&&s.tagName===hostTagName){s=s.shadowRoot}for(;a<=o;++a){if(n[a]){i=createElm(null,r,a,e);if(i){n[a].$elm$=i;s.insertBefore(i,referenceNode(t))}}}};var removeVnodes=function(e,t,r,n,a){for(;t<=r;++t){if(n=e[t]){a=n.$elm$;callNodeRefs(n);{checkSlotFallbackVisibility=true;if(a["s-ol"]){a["s-ol"].remove()}else{putBackInOriginalLocation(a,true)}}a.remove()}}};var updateChildren=function(e,t,r,n){var a=0;var o=0;var s=0;var i=0;var l=t.length-1;var $=t[0];var c=t[l];var f=n.length-1;var u=n[0];var d=n[f];var v;var p;while(a<=l&&o<=f){if($==null){$=t[++a]}else if(c==null){c=t[--l]}else if(u==null){u=n[++o]}else if(d==null){d=n[--f]}else if(isSameVnode($,u)){patch($,u);$=t[++a];u=n[++o]}else if(isSameVnode(c,d)){patch(c,d);c=t[--l];d=n[--f]}else if(isSameVnode($,d)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation($.$elm$.parentNode,false)}patch($,d);e.insertBefore($.$elm$,c.$elm$.nextSibling);$=t[++a];d=n[--f]}else if(isSameVnode(c,u)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation(c.$elm$.parentNode,false)}patch(c,u);e.insertBefore(c.$elm$,$.$elm$);c=t[--l];u=n[++o]}else{s=-1;{for(i=a;i<=l;++i){if(t[i]&&t[i].$key$!==null&&t[i].$key$===u.$key$){s=i;break}}}if(s>=0){p=t[s];if(p.$tag$!==u.$tag$){v=createElm(t&&t[o],r,s,e)}else{patch(p,u);t[s]=undefined;v=p.$elm$}u=n[++o]}else{v=createElm(t&&t[o],r,o,e);u=n[++o]}if(v){{parentReferenceNode($.$elm$).insertBefore(v,referenceNode($.$elm$))}}}}if(a>l){addVnodes(e,n[f+1]==null?null:n[f+1].$elm$,r,n,o,f)}else if(o>f){removeVnodes(t,a,l)}};var isSameVnode=function(e,t){if(e.$tag$===t.$tag$){if(e.$tag$==="slot"){return e.$name$===t.$name$}{return e.$key$===t.$key$}}return false};var referenceNode=function(e){return e&&e["s-ol"]||e};var parentReferenceNode=function(e){return(e["s-ol"]?e["s-ol"]:e).parentNode};var patch=function(e,t){var r=t.$elm$=e.$elm$;var n=e.$children$;var a=t.$children$;var o=t.$tag$;var s=t.$text$;var i;if(s===null){{isSvgMode=o==="svg"?true:o==="foreignObject"?false:isSvgMode}{if(o==="slot");else{updateElement(e,t,isSvgMode)}}if(n!==null&&a!==null){updateChildren(r,n,t,a)}else if(a!==null){if(e.$text$!==null){r.textContent=""}addVnodes(r,null,t,a,0,a.length-1)}else if(n!==null){removeVnodes(n,0,n.length-1)}if(isSvgMode&&o==="svg"){isSvgMode=false}}else if(i=r["s-cr"]){i.parentNode.textContent=s}else if(e.$text$!==s){r.data=s}};var updateFallbackSlotVisibility=function(e){var t=e.childNodes;var r;var n;var a;var o;var s;var i;for(n=0,a=t.length;n<a;n++){r=t[n];if(r.nodeType===1){if(r["s-sr"]){s=r["s-sn"];r.hidden=false;for(o=0;o<a;o++){i=t[o].nodeType;if(t[o]["s-hn"]!==r["s-hn"]||s!==""){if(i===1&&s===t[o].getAttribute("slot")){r.hidden=true;break}}else{if(i===1||i===3&&t[o].textContent.trim()!==""){r.hidden=true;break}}}}updateFallbackSlotVisibility(r)}}};var relocateNodes=[];var relocateSlotContent=function(e){var t;var r;var n;var a;var o;var s;var i=0;var l=e.childNodes;var $=l.length;for(;i<$;i++){t=l[i];if(t["s-sr"]&&(r=t["s-cr"])&&r.parentNode){n=r.parentNode.childNodes;a=t["s-sn"];for(s=n.length-1;s>=0;s--){r=n[s];if(!r["s-cn"]&&!r["s-nr"]&&r["s-hn"]!==t["s-hn"]){if(isNodeLocatedInSlot(r,a)){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));checkSlotFallbackVisibility=true;r["s-sn"]=r["s-sn"]||a;if(o){o.$slotRefNode$=t}else{relocateNodes.push({$slotRefNode$:t,$nodeToRelocate$:r})}if(r["s-sr"]){relocateNodes.map((function(e){if(isNodeLocatedInSlot(e.$nodeToRelocate$,r["s-sn"])){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));if(o&&!e.$slotRefNode$){e.$slotRefNode$=o.$slotRefNode$}}}))}}else if(!relocateNodes.some((function(e){return e.$nodeToRelocate$===r}))){relocateNodes.push({$nodeToRelocate$:r})}}}}if(t.nodeType===1){relocateSlotContent(t)}}};var isNodeLocatedInSlot=function(e,t){if(e.nodeType===1){if(e.getAttribute("slot")===null&&t===""){return true}if(e.getAttribute("slot")===t){return true}return false}if(e["s-sn"]===t){return true}return t===""};var callNodeRefs=function(e){{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null);e.$children$&&e.$children$.map(callNodeRefs)}};var renderVdom=function(e,t){var r=e.$hostElement$;var n=e.$cmpMeta$;var a=e.$vnode$||newVNode(null,null);var o=isHost(t)?t:h(null,null,t);hostTagName=r.tagName;if(n.$attrsToReflect$){o.$attrs$=o.$attrs$||{};n.$attrsToReflect$.map((function(e){var t=e[0],n=e[1];return o.$attrs$[n]=r[t]}))}o.$tag$=null;o.$flags$|=4;e.$vnode$=o;o.$elm$=a.$elm$=r.shadowRoot||r;{scopeId=r["s-sc"]}{contentRef=r["s-cr"];useNativeShadowDom=(n.$flags$&1)!==0;checkSlotFallbackVisibility=false}patch(a,o);{plt.$flags$|=1;if(checkSlotRelocate){relocateSlotContent(o.$elm$);var s=void 0;var i=void 0;var l=void 0;var $=void 0;var c=void 0;var f=void 0;var u=0;for(;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(!i["s-ol"]){l=doc.createTextNode("");l["s-nr"]=i;i.parentNode.insertBefore(i["s-ol"]=l,i)}}for(u=0;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(s.$slotRefNode$){$=s.$slotRefNode$.parentNode;c=s.$slotRefNode$.nextSibling;l=i["s-ol"];while(l=l.previousSibling){f=l["s-nr"];if(f&&f["s-sn"]===i["s-sn"]&&$===f.parentNode){f=f.nextSibling;if(!f||!f["s-nr"]){c=f;break}}}if(!c&&$!==i.parentNode||i.nextSibling!==c){if(i!==c){if(!i["s-hn"]&&i["s-ol"]){i["s-hn"]=i["s-ol"].parentNode.nodeName}$.insertBefore(i,c)}}}else{if(i.nodeType===1){i.hidden=true}}}}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(o.$elm$)}plt.$flags$&=~1;relocateNodes.length=0}};var getElement=function(e){return getHostRef(e).$hostElement$};var createEvent=function(e,t,r){var n=getElement(e);return{emit:function(e){return emitEvent(n,t,{bubbles:!!(r&4),composed:!!(r&2),cancelable:!!(r&1),detail:e})}}};var emitEvent=function(e,t,r){var n=plt.ce(t,r);e.dispatchEvent(n);return n};var attachToAncestor=function(e,t){if(t&&!e.$onRenderResolve$&&t["s-p"]){t["s-p"].push(new Promise((function(t){return e.$onRenderResolve$=t})))}};var scheduleUpdate=function(e,t){{e.$flags$|=16}if(e.$flags$&4){e.$flags$|=512;return}attachToAncestor(e,e.$ancestorComponent$);var r=function(){return dispatchHooks(e,t)};return writeTask(r)};var dispatchHooks=function(e,t){var r=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$);var n=e.$lazyInstance$;var a;if(t){{e.$flags$|=256;if(e.$queuedListeners$){e.$queuedListeners$.map((function(e){var t=e[0],r=e[1];return safeCall(n,t,r)}));e.$queuedListeners$=null}}{a=safeCall(n,"componentWillLoad")}}{a=then(a,(function(){return safeCall(n,"componentWillRender")}))}r();return then(a,(function(){return updateComponent(e,n,t)}))};var updateComponent=function(e,t,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,a,o,s,i,l;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function($){n=e.$hostElement$;a=createTime("update",e.$cmpMeta$.$tagName$);o=n["s-rc"];if(r){attachStyles(e)}s=createTime("render",e.$cmpMeta$.$tagName$);{callRender(e,t)}if(o){o.map((function(e){return e()}));n["s-rc"]=undefined}s();a();{i=n["s-p"];l=function(){return postUpdateComponent(e)};if(i.length===0){l()}else{Promise.all(i).then(l);e.$flags$|=4;i.length=0}}return[2]}))}))};var callRender=function(e,t,r){try{t=t.render&&t.render();{e.$flags$&=~16}{e.$flags$|=2}{{{renderVdom(e,t)}}}}catch(t){consoleError(t,e.$hostElement$)}return null};var postUpdateComponent=function(e){var t=e.$cmpMeta$.$tagName$;var r=e.$hostElement$;var n=createTime("postUpdate",t);var a=e.$lazyInstance$;var o=e.$ancestorComponent$;{safeCall(a,"componentDidRender")}if(!(e.$flags$&64)){e.$flags$|=64;{addHydratedFlag(r)}{safeCall(a,"componentDidLoad")}n();{e.$onReadyResolve$(r);if(!o){appDidLoad()}}}else{{safeCall(a,"componentDidUpdate")}n()}{e.$onInstanceResolve$(r)}{if(e.$onRenderResolve$){e.$onRenderResolve$();e.$onRenderResolve$=undefined}if(e.$flags$&512){nextTick((function(){return scheduleUpdate(e,false)}))}e.$flags$&=~(4|512)}};var forceUpdate=function(e){{var t=getHostRef(e);var r=t.$hostElement$.isConnected;if(r&&(t.$flags$&(2|16))===2){scheduleUpdate(t,false)}return r}};var appDidLoad=function(e){{addHydratedFlag(doc.documentElement)}nextTick((function(){return emitEvent(win,"appload",{detail:{namespace:NAMESPACE}})}))};var safeCall=function(e,t,r){if(e&&e[t]){try{return e[t](r)}catch(e){consoleError(e)}}return undefined};var then=function(e,t){return e&&e.then?e.then(t):t()};var addHydratedFlag=function(e){return e.classList.add("hydrated")};var initializeClientHydrate=function(e,t,r,n){var a=createTime("hydrateClient",t);var o=e.shadowRoot;var s=[];var i=[];var l=o?[]:null;var $=n.$vnode$=newVNode(t,null);if(!plt.$orgLocNodes$){initializeDocumentHydrate(doc.body,plt.$orgLocNodes$=new Map)}e[HYDRATE_ID]=r;e.removeAttribute(HYDRATE_ID);clientHydrate($,s,i,l,e,e,r);s.map((function(e){var r=e.$hostId$+"."+e.$nodeId$;var n=plt.$orgLocNodes$.get(r);var a=e.$elm$;if(n&&supportsShadow&&n["s-en"]===""){n.parentNode.insertBefore(a,n.nextSibling)}if(!o){a["s-hn"]=t;if(n){a["s-ol"]=n;a["s-ol"]["s-nr"]=a}}plt.$orgLocNodes$.delete(r)}));if(o){l.map((function(e){if(e){o.appendChild(e)}}))}a()};var clientHydrate=function(e,t,r,n,a,o,s){var i;var l;var $;var c;if(o.nodeType===1){i=o.getAttribute(HYDRATE_CHILD_ID);if(i){l=i.split(".");if(l[0]===s||l[0]==="0"){$={$flags$:0,$hostId$:l[0],$nodeId$:l[1],$depth$:l[2],$index$:l[3],$tag$:o.tagName.toLowerCase(),$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null};t.push($);o.removeAttribute(HYDRATE_CHILD_ID);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;e=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}for(c=o.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.childNodes[c],s)}if(o.shadowRoot){for(c=o.shadowRoot.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.shadowRoot.childNodes[c],s)}}}else if(o.nodeType===8){l=o.nodeValue.split(".");if(l[1]===s||l[1]==="0"){i=l[0];$={$flags$:0,$hostId$:l[1],$nodeId$:l[2],$depth$:l[3],$index$:l[4],$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null};if(i===TEXT_NODE_ID){$.$elm$=o.nextSibling;if($.$elm$&&$.$elm$.nodeType===3){$.$text$=$.$elm$.textContent;t.push($);o.remove();if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}else if($.$hostId$===s){if(i===SLOT_NODE_ID){$.$tag$="slot";if(l[5]){o["s-sn"]=$.$name$=l[5]}else{o["s-sn"]=""}o["s-sr"]=true;if(n){$.$elm$=doc.createElement($.$tag$);if($.$name$){$.$elm$.setAttribute("name",$.$name$)}o.parentNode.insertBefore($.$elm$,o);o.remove();if($.$depth$==="0"){n[$.$index$]=$.$elm$}}r.push($);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$}else if(i===CONTENT_REF_ID){if(n){o.remove()}else{a["s-cr"]=o;o["s-cn"]=true}}}}}else if(e&&e.$tag$==="style"){var f=newVNode(null,o.textContent);f.$elm$=o;f.$index$="0";e.$children$=[f]}};var initializeDocumentHydrate=function(e,t){if(e.nodeType===1){var r=0;for(;r<e.childNodes.length;r++){initializeDocumentHydrate(e.childNodes[r],t)}if(e.shadowRoot){for(r=0;r<e.shadowRoot.childNodes.length;r++){initializeDocumentHydrate(e.shadowRoot.childNodes[r],t)}}}else if(e.nodeType===8){var n=e.nodeValue.split(".");if(n[0]===ORG_LOCATION_ID){t.set(n[1]+"."+n[2],e);e.nodeValue="";e["s-en"]=n[3]}}};var parsePropertyValue=function(e,t){if(e!=null&&!isComplexType(e)){if(t&4){return e==="false"?false:e===""||!!e}if(t&2){return parseFloat(e)}if(t&1){return String(e)}return e}return e};var getValue=function(e,t){return getHostRef(e).$instanceValues$.get(t)};var setValue=function(e,t,r,n){var a=getHostRef(e);var o=a.$hostElement$;var s=a.$instanceValues$.get(t);var i=a.$flags$;var l=a.$lazyInstance$;r=parsePropertyValue(r,n.$members$[t][0]);var $=Number.isNaN(s)&&Number.isNaN(r);var c=r!==s&&!$;if((!(i&8)||s===undefined)&&c){a.$instanceValues$.set(t,r);if(l){if(n.$watchers$&&i&128){var f=n.$watchers$[t];if(f){f.map((function(e){try{l[e](r,s,t)}catch(e){consoleError(e,o)}}))}}if((i&(2|16))===2){scheduleUpdate(a,false)}}}};var proxyComponent=function(e,t,r){if(t.$members$){if(e.watchers){t.$watchers$=e.watchers}var n=Object.entries(t.$members$);var a=e.prototype;n.map((function(e){var n=e[0],o=e[1][0];if(o&31||r&2&&o&32){Object.defineProperty(a,n,{get:function(){return getValue(this,n)},set:function(e){setValue(this,n,e,t)},configurable:true,enumerable:true})}else if(r&1&&o&64){Object.defineProperty(a,n,{value:function(){var e=[];for(var t=0;t<arguments.length;t++){e[t]=arguments[t]}var r=getHostRef(this);return r.$onInstancePromise$.then((function(){var t;return(t=r.$lazyInstance$)[n].apply(t,e)}))}})}}));if(r&1){var o=new Map;a.attributeChangedCallback=function(e,t,r){var n=this;plt.jmp((function(){var t=o.get(e);if(n.hasOwnProperty(t)){r=n[t];delete n[t]}else if(a.hasOwnProperty(t)&&typeof n[t]==="number"&&n[t]==r){return}n[t]=r===null&&typeof n[t]==="boolean"?false:r}))};e.observedAttributes=n.filter((function(e){var t=e[0],r=e[1];return r[0]&15})).map((function(e){var r=e[0],n=e[1];var a=n[1]||r;o.set(a,r);if(n[0]&512){t.$attrsToReflect$.push([r,a])}return a}))}}return e};var initializeComponent=function(e,t,r,n,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,o,s,i,l,$,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(f){switch(f.label){case 0:if(!((t.$flags$&32)===0))return[3,3];t.$flags$|=32;a=loadModule(r);if(!a.then)return[3,2];n=uniqueTime();return[4,a];case 1:a=f.sent();n();f.label=2;case 2:if(!a.isProxied){{r.$watchers$=a.watchers}proxyComponent(a,r,2);a.isProxied=true}o=createTime("createInstance",r.$tagName$);{t.$flags$|=8}try{new a(t)}catch(e){consoleError(e)}{t.$flags$&=~8}{t.$flags$|=128}o();fireConnectedCallback(t.$lazyInstance$);if(a.style){s=a.style;if(typeof s!=="string"){s=s[t.$modeName$=computeMode(e)]}i=getScopeId(r,t.$modeName$);if(!styles.has(i)){l=createTime("registerStyles",r.$tagName$);registerStyle(i,s,!!(r.$flags$&1));l()}}f.label=3;case 3:$=t.$ancestorComponent$;c=function(){return scheduleUpdate(t,true)};if($&&$["s-rc"]){$["s-rc"].push(c)}else{c()}return[2]}}))}))};var fireConnectedCallback=function(e){{safeCall(e,"connectedCallback")}};var connectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$cmpMeta$;var n=createTime("connectedCallback",r.$tagName$);if(!(t.$flags$&1)){t.$flags$|=1;var a=void 0;{a=e.getAttribute(HYDRATE_ID);if(a){if(r.$flags$&1){var o=addStyle(e.shadowRoot,r,e.getAttribute("s-mode"));e.classList.remove(o+"-h",o+"-s")}initializeClientHydrate(e,r.$tagName$,a,t)}}if(!a){if(r.$flags$&(4|8)){setContentReference(e)}}{var s=e;while(s=s.parentNode||s.host){if(s.nodeType===1&&s.hasAttribute("s-id")&&s["s-p"]||s["s-p"]){attachToAncestor(t,t.$ancestorComponent$=s);break}}}if(r.$members$){Object.entries(r.$members$).map((function(t){var r=t[0],n=t[1][0];if(n&31&&e.hasOwnProperty(r)){var a=e[r];delete e[r];e[r]=a}}))}{nextTick((function(){return initializeComponent(e,t,r)}))}}else{addHostEventListeners(e,t,r.$listeners$);fireConnectedCallback(t.$lazyInstance$)}n()}};var setContentReference=function(e){var t=e["s-cr"]=doc.createComment("");t["s-cn"]=true;e.insertBefore(t,e.firstChild)};var disconnectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$lazyInstance$;{if(t.$rmListeners$){t.$rmListeners$.map((function(e){return e()}));t.$rmListeners$=undefined}}{safeCall(r,"disconnectedCallback")}}};var bootstrapLazy=function(e,t){if(t===void 0){t={}}var r=createTime();var n=[];var a=t.exclude||[];var o=win.customElements;var s=doc.head;var i=s.querySelector("meta[charset]");var l=doc.createElement("style");var $=[];var c=doc.querySelectorAll("[".concat(HYDRATED_STYLE_ID,"]"));var f;var u=true;var d=0;Object.assign(plt,t);plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href;{plt.$flags$|=2}{for(;d<c.length;d++){registerStyle(c[d].getAttribute(HYDRATED_STYLE_ID),convertScopedToShadow(c[d].innerHTML),true)}}e.map((function(e){e[1].map((function(t){var r={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};{r.$members$=t[2]}{r.$listeners$=t[3]}{r.$attrsToReflect$=[]}{r.$watchers$={}}var s=r.$tagName$;var i=function(e){(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT)(t,e);function t(t){var n=e.call(this,t)||this;t=n;registerHost(t,r);if(r.$flags$&1){{{t.attachShadow({mode:"open",delegatesFocus:!!(r.$flags$&16)})}}}return n}t.prototype.connectedCallback=function(){var e=this;if(f){clearTimeout(f);f=null}if(u){$.push(this)}else{plt.jmp((function(){return connectedCallback(e)}))}};t.prototype.disconnectedCallback=function(){var e=this;plt.jmp((function(){return disconnectedCallback(e)}))};t.prototype.componentOnReady=function(){return getHostRef(this).$onReadyPromise$};return t}(HTMLElement);r.$lazyBundleId$=e[0];if(!a.includes(s)&&!o.get(s)){n.push(s);o.define(s,proxyComponent(i,r,1))}}))}));{l.innerHTML=n+HYDRATED_CSS;l.setAttribute("data-styles","");s.insertBefore(l,i?i.nextSibling:s.firstChild)}u=false;if($.length){$.map((function(e){return e.connectedCallback()}))}else{{plt.jmp((function(){return f=setTimeout(appDidLoad,30)}))}}r()};var getAssetPath=function(e){var t=new URL(e,plt.$resourcesUrl$);return t.origin!==win.location.origin?t.href:t.pathname};var hostRefs=new WeakMap;var getHostRef=function(e){return hostRefs.get(e)};var registerInstance=function(e,t){return hostRefs.set(t.$lazyInstance$=e,t)};var registerHost=function(e,t){var r={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};{r.$onInstancePromise$=new Promise((function(e){return r.$onInstanceResolve$=e}))}{r.$onReadyPromise$=new Promise((function(e){return r.$onReadyResolve$=e}));e["s-p"]=[];e["s-rc"]=[]}addHostEventListeners(e,r,t.$listeners$);return hostRefs.set(e,r)};var isMemberInElement=function(e,t){return t in e};var consoleError=function(e,t){return(0,console.error)(e,t)};var cmpModules=new Map;var loadModule=function(e,t,r){var n=e.$tagName$.replace(/-/g,"_");var a=e.$lazyBundleId$;var o=cmpModules.get(a);if(o){return o[n]}return __webpack_require__(73076)("./".concat(a,".entry.js").concat("")).then((function(e){{cmpModules.set(a,e)}return e[n]}),consoleError)};var styles=new Map;var modeResolutionChain=[];var queueDomReads=[];var queueDomWrites=[];var queueTask=function(e,t){return function(r){e.push(r);if(!queuePending){queuePending=true;if(t&&plt.$flags$&4){nextTick(flush)}else{plt.raf(flush)}}}};var consume=function(e){for(var t=0;t<e.length;t++){try{e[t](performance.now())}catch(e){consoleError(e)}}e.length=0};var flush=function(){consume(queueDomReads);{consume(queueDomWrites);if(queuePending=queueDomReads.length>0){plt.raf(flush)}}};var nextTick=function(e){return promiseResolve().then(e)};var readTask=queueTask(queueDomReads,false);var writeTask=queueTask(queueDomWrites,true);var Build={isDev:false,isBrowser:true,isServer:false,isTesting:false};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDRDQUE0Qyw2Q0FBNkMsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LWIzZWVjYjE0LmpzP2IzZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2V4dGVuZHMsX19nZW5lcmF0b3IsX19zcHJlYWRBcnJheX1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi92YXIgTkFNRVNQQUNFPVwiaW9uaWNcIjt2YXIgc2NvcGVJZDt2YXIgY29udGVudFJlZjt2YXIgaG9zdFRhZ05hbWU7dmFyIHVzZU5hdGl2ZVNoYWRvd0RvbT1mYWxzZTt2YXIgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5PWZhbHNlO3ZhciBjaGVja1Nsb3RSZWxvY2F0ZT1mYWxzZTt2YXIgaXNTdmdNb2RlPWZhbHNlO3ZhciBxdWV1ZVBlbmRpbmc9ZmFsc2U7dmFyIHdpbj10eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e307dmFyIGRvYz13aW4uZG9jdW1lbnR8fHtoZWFkOnt9fTt2YXIgcGx0PXskZmxhZ3MkOjAsJHJlc291cmNlc1VybCQ6XCJcIixqbXA6ZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0scmFmOmZ1bmN0aW9uKGUpe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSl9LGFlbDpmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gZS5hZGRFdmVudExpc3RlbmVyKHQscixuKX0scmVsOmZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxyLG4pfSxjZTpmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgQ3VzdG9tRXZlbnQoZSx0KX19O3ZhciBzZXRQbGF0Zm9ybUhlbHBlcnM9ZnVuY3Rpb24oZSl7T2JqZWN0LmFzc2lnbihwbHQsZSl9O3ZhciBzdXBwb3J0c1NoYWRvdz10cnVlO3ZhciBwcm9taXNlUmVzb2x2ZT1mdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpfTt2YXIgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHM9ZnVuY3Rpb24oKXt0cnl7bmV3IENTU1N0eWxlU2hlZXQ7cmV0dXJuIHR5cGVvZihuZXcgQ1NTU3R5bGVTaGVldCkucmVwbGFjZT09PVwiZnVuY3Rpb25cIn1jYXRjaChlKXt9cmV0dXJuIGZhbHNlfSgpO3ZhciBhZGRIb3N0RXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oZSx0LHIsbil7aWYocil7ci5tYXAoKGZ1bmN0aW9uKHIpe3ZhciBuPXJbMF0sYT1yWzFdLG89clsyXTt2YXIgcz1nZXRIb3N0TGlzdGVuZXJUYXJnZXQoZSxuKTt2YXIgaT1ob3N0TGlzdGVuZXJQcm94eSh0LG8pO3ZhciBsPWhvc3RMaXN0ZW5lck9wdHMobik7cGx0LmFlbChzLGEsaSxsKTsodC4kcm1MaXN0ZW5lcnMkPXQuJHJtTGlzdGVuZXJzJHx8W10pLnB1c2goKGZ1bmN0aW9uKCl7cmV0dXJuIHBsdC5yZWwocyxhLGksbCl9KSl9KSl9fTt2YXIgaG9zdExpc3RlbmVyUHJveHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24ocil7dHJ5e3tpZihlLiRmbGFncyQmMjU2KXtlLiRsYXp5SW5zdGFuY2UkW3RdKHIpfWVsc2V7KGUuJHF1ZXVlZExpc3RlbmVycyQ9ZS4kcXVldWVkTGlzdGVuZXJzJHx8W10pLnB1c2goW3Qscl0pfX19Y2F0Y2goZSl7Y29uc29sZUVycm9yKGUpfX19O3ZhciBnZXRIb3N0TGlzdGVuZXJUYXJnZXQ9ZnVuY3Rpb24oZSx0KXtpZih0JjQpcmV0dXJuIGRvYztpZih0JjgpcmV0dXJuIHdpbjtpZih0JjE2KXJldHVybiBkb2MuYm9keTtyZXR1cm4gZX07dmFyIGhvc3RMaXN0ZW5lck9wdHM9ZnVuY3Rpb24oZSl7cmV0dXJuKGUmMikhPT0wfTt2YXIgQ09OVEVOVF9SRUZfSUQ9XCJyXCI7dmFyIE9SR19MT0NBVElPTl9JRD1cIm9cIjt2YXIgU0xPVF9OT0RFX0lEPVwic1wiO3ZhciBURVhUX05PREVfSUQ9XCJ0XCI7dmFyIEhZRFJBVEVfSUQ9XCJzLWlkXCI7dmFyIEhZRFJBVEVEX1NUWUxFX0lEPVwic3R5LWlkXCI7dmFyIEhZRFJBVEVfQ0hJTERfSUQ9XCJjLWlkXCI7dmFyIEhZRFJBVEVEX0NTUz1cInt2aXNpYmlsaXR5OmhpZGRlbn0uaHlkcmF0ZWR7dmlzaWJpbGl0eTppbmhlcml0fVwiO3ZhciBYTElOS19OUz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjt2YXIgY3JlYXRlVGltZT1mdW5jdGlvbihlLHQpe2lmKHQ9PT12b2lkIDApe3Q9XCJcIn17cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJufX19O3ZhciB1bmlxdWVUaW1lPWZ1bmN0aW9uKGUsdCl7e3JldHVybiBmdW5jdGlvbigpe3JldHVybn19fTt2YXIgcm9vdEFwcGxpZWRTdHlsZXM9bmV3IFdlYWtNYXA7dmFyIHJlZ2lzdGVyU3R5bGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXN0eWxlcy5nZXQoZSk7aWYoc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMmJnIpe249bnx8bmV3IENTU1N0eWxlU2hlZXQ7bi5yZXBsYWNlKHQpfWVsc2V7bj10fXN0eWxlcy5zZXQoZSxuKX07dmFyIGFkZFN0eWxlPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPWdldFNjb3BlSWQodCxyKTt2YXIgbz1zdHlsZXMuZ2V0KGEpO2U9ZS5ub2RlVHlwZT09PTExP2U6ZG9jO2lmKG8pe2lmKHR5cGVvZiBvPT09XCJzdHJpbmdcIil7ZT1lLmhlYWR8fGU7dmFyIHM9cm9vdEFwcGxpZWRTdHlsZXMuZ2V0KGUpO3ZhciBpPXZvaWQgMDtpZighcyl7cm9vdEFwcGxpZWRTdHlsZXMuc2V0KGUscz1uZXcgU2V0KX1pZighcy5oYXMoYSkpe2lmKGUuaG9zdCYmKGk9ZS5xdWVyeVNlbGVjdG9yKFwiW1wiLmNvbmNhdChIWURSQVRFRF9TVFlMRV9JRCwnPVwiJykuY29uY2F0KGEsJ1wiXScpKSkpe2kuaW5uZXJIVE1MPW99ZWxzZXt7aT1kb2MuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2kuaW5uZXJIVE1MPW99ZS5pbnNlcnRCZWZvcmUoaSxlLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rXCIpKX1pZihzKXtzLmFkZChhKX19fWVsc2UgaWYoIWUuYWRvcHRlZFN0eWxlU2hlZXRzLmluY2x1ZGVzKG8pKXtlLmFkb3B0ZWRTdHlsZVNoZWV0cz1fX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sZS5hZG9wdGVkU3R5bGVTaGVldHMsdHJ1ZSksW29dLGZhbHNlKX19cmV0dXJuIGF9O3ZhciBhdHRhY2hTdHlsZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS4kY21wTWV0YSQ7dmFyIHI9ZS4kaG9zdEVsZW1lbnQkO3ZhciBuPXQuJGZsYWdzJDt2YXIgYT1jcmVhdGVUaW1lKFwiYXR0YWNoU3R5bGVzXCIsdC4kdGFnTmFtZSQpO3ZhciBvPWFkZFN0eWxlKHIuc2hhZG93Um9vdD9yLnNoYWRvd1Jvb3Q6ci5nZXRSb290Tm9kZSgpLHQsZS4kbW9kZU5hbWUkKTtpZihuJjEwKXtyW1wicy1zY1wiXT1vO3IuY2xhc3NMaXN0LmFkZChvK1wiLWhcIik7aWYobiYyKXtyLmNsYXNzTGlzdC5hZGQobytcIi1zXCIpfX1hKCl9O3ZhciBnZXRTY29wZUlkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJzYy1cIisodCYmZS4kZmxhZ3MkJjMyP2UuJHRhZ05hbWUkK1wiLVwiK3Q6ZS4kdGFnTmFtZSQpfTt2YXIgY29udmVydFNjb3BlZFRvU2hhZG93PWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoL1xcL1xcKiFAKFteXFwvXSspXFwqXFwvW15cXHtdK1xcey9nLFwiJDF7XCIpfTt2YXIgY29tcHV0ZU1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG1vZGVSZXNvbHV0aW9uQ2hhaW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdChlKX0pKS5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4hIWV9KSl9O3ZhciBzZXRNb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goZSl9O3ZhciBnZXRNb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBnZXRIb3N0UmVmKGUpLiRtb2RlTmFtZSR9O3ZhciBFTVBUWV9PQko9e307dmFyIFNWR19OUz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7dmFyIEhUTUxfTlM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7dmFyIGlzRGVmPWZ1bmN0aW9uKGUpe3JldHVybiBlIT1udWxsfTt2YXIgaXNDb21wbGV4VHlwZT1mdW5jdGlvbihlKXtlPXR5cGVvZiBlO3JldHVybiBlPT09XCJvYmplY3RcInx8ZT09PVwiZnVuY3Rpb25cIn07dmFyIGg9ZnVuY3Rpb24oZSx0KXt2YXIgcj1bXTtmb3IodmFyIG49MjtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXtyW24tMl09YXJndW1lbnRzW25dfXZhciBhPW51bGw7dmFyIG89bnVsbDt2YXIgcz1udWxsO3ZhciBpPWZhbHNlO3ZhciBsPWZhbHNlO3ZhciAkPVtdO3ZhciBjPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXthPXRbcl07aWYoQXJyYXkuaXNBcnJheShhKSl7YyhhKX1lbHNlIGlmKGEhPW51bGwmJnR5cGVvZiBhIT09XCJib29sZWFuXCIpe2lmKGk9dHlwZW9mIGUhPT1cImZ1bmN0aW9uXCImJiFpc0NvbXBsZXhUeXBlKGEpKXthPVN0cmluZyhhKX1pZihpJiZsKXskWyQubGVuZ3RoLTFdLiR0ZXh0JCs9YX1lbHNleyQucHVzaChpP25ld1ZOb2RlKG51bGwsYSk6YSl9bD1pfX19O2Mocik7aWYodCl7aWYodC5rZXkpe289dC5rZXl9aWYodC5uYW1lKXtzPXQubmFtZX17dmFyIGY9dC5jbGFzc05hbWV8fHQuY2xhc3M7aWYoZil7dC5jbGFzcz10eXBlb2YgZiE9PVwib2JqZWN0XCI/ZjpPYmplY3Qua2V5cyhmKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBmW2VdfSkpLmpvaW4oXCIgXCIpfX19aWYodHlwZW9mIGU9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlKHQ9PT1udWxsP3t9OnQsJCx2ZG9tRm5VdGlscyl9dmFyIHU9bmV3Vk5vZGUoZSxudWxsKTt1LiRhdHRycyQ9dDtpZigkLmxlbmd0aD4wKXt1LiRjaGlsZHJlbiQ9JH17dS4ka2V5JD1vfXt1LiRuYW1lJD1zfXJldHVybiB1fTt2YXIgbmV3Vk5vZGU9ZnVuY3Rpb24oZSx0KXt2YXIgcj17JGZsYWdzJDowLCR0YWckOmUsJHRleHQkOnQsJGVsbSQ6bnVsbCwkY2hpbGRyZW4kOm51bGx9O3tyLiRhdHRycyQ9bnVsbH17ci4ka2V5JD1udWxsfXtyLiRuYW1lJD1udWxsfXJldHVybiByfTt2YXIgSG9zdD17fTt2YXIgaXNIb3N0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLiR0YWckPT09SG9zdH07dmFyIHZkb21GblV0aWxzPXtmb3JFYWNoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaCh0KX0sbWFwOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKHQpLm1hcChjb252ZXJ0VG9Qcml2YXRlKX19O3ZhciBjb252ZXJ0VG9QdWJsaWM9ZnVuY3Rpb24oZSl7cmV0dXJue3ZhdHRyczplLiRhdHRycyQsdmNoaWxkcmVuOmUuJGNoaWxkcmVuJCx2a2V5OmUuJGtleSQsdm5hbWU6ZS4kbmFtZSQsdnRhZzplLiR0YWckLHZ0ZXh0OmUuJHRleHQkfX07dmFyIGNvbnZlcnRUb1ByaXZhdGU9ZnVuY3Rpb24oZSl7aWYodHlwZW9mIGUudnRhZz09PVwiZnVuY3Rpb25cIil7dmFyIHQ9T2JqZWN0LmFzc2lnbih7fSxlLnZhdHRycyk7aWYoZS52a2V5KXt0LmtleT1lLnZrZXl9aWYoZS52bmFtZSl7dC5uYW1lPWUudm5hbWV9cmV0dXJuIGguYXBwbHkodm9pZCAwLF9fc3ByZWFkQXJyYXkoW2UudnRhZyx0XSxlLnZjaGlsZHJlbnx8W10sZmFsc2UpKX12YXIgcj1uZXdWTm9kZShlLnZ0YWcsZS52dGV4dCk7ci4kYXR0cnMkPWUudmF0dHJzO3IuJGNoaWxkcmVuJD1lLnZjaGlsZHJlbjtyLiRrZXkkPWUudmtleTtyLiRuYW1lJD1lLnZuYW1lO3JldHVybiByfTt2YXIgc2V0QWNjZXNzb3I9ZnVuY3Rpb24oZSx0LHIsbixhLG8pe2lmKHIhPT1uKXt2YXIgcz1pc01lbWJlckluRWxlbWVudChlLHQpO3ZhciBpPXQudG9Mb3dlckNhc2UoKTtpZih0PT09XCJjbGFzc1wiKXt2YXIgbD1lLmNsYXNzTGlzdDt2YXIgJD1wYXJzZUNsYXNzTGlzdChyKTt2YXIgYz1wYXJzZUNsYXNzTGlzdChuKTtsLnJlbW92ZS5hcHBseShsLCQuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZSYmIWMuaW5jbHVkZXMoZSl9KSkpO2wuYWRkLmFwcGx5KGwsYy5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiYhJC5pbmNsdWRlcyhlKX0pKSl9ZWxzZSBpZih0PT09XCJzdHlsZVwiKXt7Zm9yKHZhciBmIGluIHIpe2lmKCFufHxuW2ZdPT1udWxsKXtpZihmLmluY2x1ZGVzKFwiLVwiKSl7ZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShmKX1lbHNle2Uuc3R5bGVbZl09XCJcIn19fX1mb3IodmFyIGYgaW4gbil7aWYoIXJ8fG5bZl0hPT1yW2ZdKXtpZihmLmluY2x1ZGVzKFwiLVwiKSl7ZS5zdHlsZS5zZXRQcm9wZXJ0eShmLG5bZl0pfWVsc2V7ZS5zdHlsZVtmXT1uW2ZdfX19fWVsc2UgaWYodD09PVwia2V5XCIpO2Vsc2UgaWYodD09PVwicmVmXCIpe2lmKG4pe24oZSl9fWVsc2UgaWYoIXMmJnRbMF09PT1cIm9cIiYmdFsxXT09PVwiblwiKXtpZih0WzJdPT09XCItXCIpe3Q9dC5zbGljZSgzKX1lbHNlIGlmKGlzTWVtYmVySW5FbGVtZW50KHdpbixpKSl7dD1pLnNsaWNlKDIpfWVsc2V7dD1pWzJdK3Quc2xpY2UoMyl9aWYocil7cGx0LnJlbChlLHQscixmYWxzZSl9aWYobil7cGx0LmFlbChlLHQsbixmYWxzZSl9fWVsc2V7dmFyIHU9aXNDb21wbGV4VHlwZShuKTtpZigoc3x8dSYmbiE9PW51bGwpJiYhYSl7dHJ5e2lmKCFlLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpKXt2YXIgZD1uPT1udWxsP1wiXCI6bjtpZih0PT09XCJsaXN0XCIpe3M9ZmFsc2V9ZWxzZSBpZihyPT1udWxsfHxlW3RdIT1kKXtlW3RdPWR9fWVsc2V7ZVt0XT1ufX1jYXRjaChlKXt9fXZhciB2PWZhbHNlO3tpZihpIT09KGk9aS5yZXBsYWNlKC9eeGxpbmtcXDo/LyxcIlwiKSkpe3Q9aTt2PXRydWV9fWlmKG49PW51bGx8fG49PT1mYWxzZSl7aWYobiE9PWZhbHNlfHxlLmdldEF0dHJpYnV0ZSh0KT09PVwiXCIpe2lmKHYpe2UucmVtb3ZlQXR0cmlidXRlTlMoWExJTktfTlMsdCl9ZWxzZXtlLnJlbW92ZUF0dHJpYnV0ZSh0KX19fWVsc2UgaWYoKCFzfHxvJjR8fGEpJiYhdSl7bj1uPT09dHJ1ZT9cIlwiOm47aWYodil7ZS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUyx0LG4pfWVsc2V7ZS5zZXRBdHRyaWJ1dGUodCxuKX19fX19O3ZhciBwYXJzZUNsYXNzTGlzdFJlZ2V4PS9cXHMvO3ZhciBwYXJzZUNsYXNzTGlzdD1mdW5jdGlvbihlKXtyZXR1cm4hZT9bXTplLnNwbGl0KHBhcnNlQ2xhc3NMaXN0UmVnZXgpfTt2YXIgdXBkYXRlRWxlbWVudD1mdW5jdGlvbihlLHQscixuKXt2YXIgYT10LiRlbG0kLm5vZGVUeXBlPT09MTEmJnQuJGVsbSQuaG9zdD90LiRlbG0kLmhvc3Q6dC4kZWxtJDt2YXIgbz1lJiZlLiRhdHRycyR8fEVNUFRZX09CSjt2YXIgcz10LiRhdHRycyR8fEVNUFRZX09CSjt7Zm9yKG4gaW4gbyl7aWYoIShuIGluIHMpKXtzZXRBY2Nlc3NvcihhLG4sb1tuXSx1bmRlZmluZWQscix0LiRmbGFncyQpfX19Zm9yKG4gaW4gcyl7c2V0QWNjZXNzb3IoYSxuLG9bbl0sc1tuXSxyLHQuJGZsYWdzJCl9fTt2YXIgY3JlYXRlRWxtPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPXQuJGNoaWxkcmVuJFtyXTt2YXIgbz0wO3ZhciBzO3ZhciBpO3ZhciBsO2lmKCF1c2VOYXRpdmVTaGFkb3dEb20pe2NoZWNrU2xvdFJlbG9jYXRlPXRydWU7aWYoYS4kdGFnJD09PVwic2xvdFwiKXtpZihzY29wZUlkKXtuLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCtcIi1zXCIpfWEuJGZsYWdzJHw9YS4kY2hpbGRyZW4kPzI6MX19aWYoYS4kdGV4dCQhPT1udWxsKXtzPWEuJGVsbSQ9ZG9jLmNyZWF0ZVRleHROb2RlKGEuJHRleHQkKX1lbHNlIGlmKGEuJGZsYWdzJCYxKXtzPWEuJGVsbSQ9ZG9jLmNyZWF0ZVRleHROb2RlKFwiXCIpfWVsc2V7aWYoIWlzU3ZnTW9kZSl7aXNTdmdNb2RlPWEuJHRhZyQ9PT1cInN2Z1wifXM9YS4kZWxtJD1kb2MuY3JlYXRlRWxlbWVudE5TKGlzU3ZnTW9kZT9TVkdfTlM6SFRNTF9OUyxhLiRmbGFncyQmMj9cInNsb3QtZmJcIjphLiR0YWckKTtpZihpc1N2Z01vZGUmJmEuJHRhZyQ9PT1cImZvcmVpZ25PYmplY3RcIil7aXNTdmdNb2RlPWZhbHNlfXt1cGRhdGVFbGVtZW50KG51bGwsYSxpc1N2Z01vZGUpfWlmKGlzRGVmKHNjb3BlSWQpJiZzW1wicy1zaVwiXSE9PXNjb3BlSWQpe3MuY2xhc3NMaXN0LmFkZChzW1wicy1zaVwiXT1zY29wZUlkKX1pZihhLiRjaGlsZHJlbiQpe2ZvcihvPTA7bzxhLiRjaGlsZHJlbiQubGVuZ3RoOysrbyl7aT1jcmVhdGVFbG0oZSxhLG8scyk7aWYoaSl7cy5hcHBlbmRDaGlsZChpKX19fXtpZihhLiR0YWckPT09XCJzdmdcIil7aXNTdmdNb2RlPWZhbHNlfWVsc2UgaWYocy50YWdOYW1lPT09XCJmb3JlaWduT2JqZWN0XCIpe2lzU3ZnTW9kZT10cnVlfX19e3NbXCJzLWhuXCJdPWhvc3RUYWdOYW1lO2lmKGEuJGZsYWdzJCYoMnwxKSl7c1tcInMtc3JcIl09dHJ1ZTtzW1wicy1jclwiXT1jb250ZW50UmVmO3NbXCJzLXNuXCJdPWEuJG5hbWUkfHxcIlwiO2w9ZSYmZS4kY2hpbGRyZW4kJiZlLiRjaGlsZHJlbiRbcl07aWYobCYmbC4kdGFnJD09PWEuJHRhZyQmJmUuJGVsbSQpe3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oZS4kZWxtJCxmYWxzZSl9fX1yZXR1cm4gc307dmFyIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb249ZnVuY3Rpb24oZSx0KXtwbHQuJGZsYWdzJHw9MTt2YXIgcj1lLmNoaWxkTm9kZXM7Zm9yKHZhciBuPXIubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBhPXJbbl07aWYoYVtcInMtaG5cIl0hPT1ob3N0VGFnTmFtZSYmYVtcInMtb2xcIl0pe3BhcmVudFJlZmVyZW5jZU5vZGUoYSkuaW5zZXJ0QmVmb3JlKGEscmVmZXJlbmNlTm9kZShhKSk7YVtcInMtb2xcIl0ucmVtb3ZlKCk7YVtcInMtb2xcIl09dW5kZWZpbmVkO2NoZWNrU2xvdFJlbG9jYXRlPXRydWV9aWYodCl7cHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihhLHQpfX1wbHQuJGZsYWdzJCY9fjF9O3ZhciBhZGRWbm9kZXM9ZnVuY3Rpb24oZSx0LHIsbixhLG8pe3ZhciBzPWVbXCJzLWNyXCJdJiZlW1wicy1jclwiXS5wYXJlbnROb2RlfHxlO3ZhciBpO2lmKHMuc2hhZG93Um9vdCYmcy50YWdOYW1lPT09aG9zdFRhZ05hbWUpe3M9cy5zaGFkb3dSb290fWZvcig7YTw9bzsrK2Epe2lmKG5bYV0pe2k9Y3JlYXRlRWxtKG51bGwscixhLGUpO2lmKGkpe25bYV0uJGVsbSQ9aTtzLmluc2VydEJlZm9yZShpLHJlZmVyZW5jZU5vZGUodCkpfX19fTt2YXIgcmVtb3ZlVm5vZGVzPWZ1bmN0aW9uKGUsdCxyLG4sYSl7Zm9yKDt0PD1yOysrdCl7aWYobj1lW3RdKXthPW4uJGVsbSQ7Y2FsbE5vZGVSZWZzKG4pO3tjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHk9dHJ1ZTtpZihhW1wicy1vbFwiXSl7YVtcInMtb2xcIl0ucmVtb3ZlKCl9ZWxzZXtwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGEsdHJ1ZSl9fWEucmVtb3ZlKCl9fX07dmFyIHVwZGF0ZUNoaWxkcmVuPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPTA7dmFyIG89MDt2YXIgcz0wO3ZhciBpPTA7dmFyIGw9dC5sZW5ndGgtMTt2YXIgJD10WzBdO3ZhciBjPXRbbF07dmFyIGY9bi5sZW5ndGgtMTt2YXIgdT1uWzBdO3ZhciBkPW5bZl07dmFyIHY7dmFyIHA7d2hpbGUoYTw9bCYmbzw9Zil7aWYoJD09bnVsbCl7JD10WysrYV19ZWxzZSBpZihjPT1udWxsKXtjPXRbLS1sXX1lbHNlIGlmKHU9PW51bGwpe3U9blsrK29dfWVsc2UgaWYoZD09bnVsbCl7ZD1uWy0tZl19ZWxzZSBpZihpc1NhbWVWbm9kZSgkLHUpKXtwYXRjaCgkLHUpOyQ9dFsrK2FdO3U9blsrK29dfWVsc2UgaWYoaXNTYW1lVm5vZGUoYyxkKSl7cGF0Y2goYyxkKTtjPXRbLS1sXTtkPW5bLS1mXX1lbHNlIGlmKGlzU2FtZVZub2RlKCQsZCkpe2lmKCQuJHRhZyQ9PT1cInNsb3RcInx8ZC4kdGFnJD09PVwic2xvdFwiKXtwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKCQuJGVsbSQucGFyZW50Tm9kZSxmYWxzZSl9cGF0Y2goJCxkKTtlLmluc2VydEJlZm9yZSgkLiRlbG0kLGMuJGVsbSQubmV4dFNpYmxpbmcpOyQ9dFsrK2FdO2Q9blstLWZdfWVsc2UgaWYoaXNTYW1lVm5vZGUoYyx1KSl7aWYoJC4kdGFnJD09PVwic2xvdFwifHxkLiR0YWckPT09XCJzbG90XCIpe3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oYy4kZWxtJC5wYXJlbnROb2RlLGZhbHNlKX1wYXRjaChjLHUpO2UuaW5zZXJ0QmVmb3JlKGMuJGVsbSQsJC4kZWxtJCk7Yz10Wy0tbF07dT1uWysrb119ZWxzZXtzPS0xO3tmb3IoaT1hO2k8PWw7KytpKXtpZih0W2ldJiZ0W2ldLiRrZXkkIT09bnVsbCYmdFtpXS4ka2V5JD09PXUuJGtleSQpe3M9aTticmVha319fWlmKHM+PTApe3A9dFtzXTtpZihwLiR0YWckIT09dS4kdGFnJCl7dj1jcmVhdGVFbG0odCYmdFtvXSxyLHMsZSl9ZWxzZXtwYXRjaChwLHUpO3Rbc109dW5kZWZpbmVkO3Y9cC4kZWxtJH11PW5bKytvXX1lbHNle3Y9Y3JlYXRlRWxtKHQmJnRbb10scixvLGUpO3U9blsrK29dfWlmKHYpe3twYXJlbnRSZWZlcmVuY2VOb2RlKCQuJGVsbSQpLmluc2VydEJlZm9yZSh2LHJlZmVyZW5jZU5vZGUoJC4kZWxtJCkpfX19fWlmKGE+bCl7YWRkVm5vZGVzKGUsbltmKzFdPT1udWxsP251bGw6bltmKzFdLiRlbG0kLHIsbixvLGYpfWVsc2UgaWYobz5mKXtyZW1vdmVWbm9kZXModCxhLGwpfX07dmFyIGlzU2FtZVZub2RlPWZ1bmN0aW9uKGUsdCl7aWYoZS4kdGFnJD09PXQuJHRhZyQpe2lmKGUuJHRhZyQ9PT1cInNsb3RcIil7cmV0dXJuIGUuJG5hbWUkPT09dC4kbmFtZSR9e3JldHVybiBlLiRrZXkkPT09dC4ka2V5JH19cmV0dXJuIGZhbHNlfTt2YXIgcmVmZXJlbmNlTm9kZT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZVtcInMtb2xcIl18fGV9O3ZhciBwYXJlbnRSZWZlcmVuY2VOb2RlPWZ1bmN0aW9uKGUpe3JldHVybihlW1wicy1vbFwiXT9lW1wicy1vbFwiXTplKS5wYXJlbnROb2RlfTt2YXIgcGF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LiRlbG0kPWUuJGVsbSQ7dmFyIG49ZS4kY2hpbGRyZW4kO3ZhciBhPXQuJGNoaWxkcmVuJDt2YXIgbz10LiR0YWckO3ZhciBzPXQuJHRleHQkO3ZhciBpO2lmKHM9PT1udWxsKXt7aXNTdmdNb2RlPW89PT1cInN2Z1wiP3RydWU6bz09PVwiZm9yZWlnbk9iamVjdFwiP2ZhbHNlOmlzU3ZnTW9kZX17aWYobz09PVwic2xvdFwiKTtlbHNle3VwZGF0ZUVsZW1lbnQoZSx0LGlzU3ZnTW9kZSl9fWlmKG4hPT1udWxsJiZhIT09bnVsbCl7dXBkYXRlQ2hpbGRyZW4ocixuLHQsYSl9ZWxzZSBpZihhIT09bnVsbCl7aWYoZS4kdGV4dCQhPT1udWxsKXtyLnRleHRDb250ZW50PVwiXCJ9YWRkVm5vZGVzKHIsbnVsbCx0LGEsMCxhLmxlbmd0aC0xKX1lbHNlIGlmKG4hPT1udWxsKXtyZW1vdmVWbm9kZXMobiwwLG4ubGVuZ3RoLTEpfWlmKGlzU3ZnTW9kZSYmbz09PVwic3ZnXCIpe2lzU3ZnTW9kZT1mYWxzZX19ZWxzZSBpZihpPXJbXCJzLWNyXCJdKXtpLnBhcmVudE5vZGUudGV4dENvbnRlbnQ9c31lbHNlIGlmKGUuJHRleHQkIT09cyl7ci5kYXRhPXN9fTt2YXIgdXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eT1mdW5jdGlvbihlKXt2YXIgdD1lLmNoaWxkTm9kZXM7dmFyIHI7dmFyIG47dmFyIGE7dmFyIG87dmFyIHM7dmFyIGk7Zm9yKG49MCxhPXQubGVuZ3RoO248YTtuKyspe3I9dFtuXTtpZihyLm5vZGVUeXBlPT09MSl7aWYocltcInMtc3JcIl0pe3M9cltcInMtc25cIl07ci5oaWRkZW49ZmFsc2U7Zm9yKG89MDtvPGE7bysrKXtpPXRbb10ubm9kZVR5cGU7aWYodFtvXVtcInMtaG5cIl0hPT1yW1wicy1oblwiXXx8cyE9PVwiXCIpe2lmKGk9PT0xJiZzPT09dFtvXS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpKXtyLmhpZGRlbj10cnVlO2JyZWFrfX1lbHNle2lmKGk9PT0xfHxpPT09MyYmdFtvXS50ZXh0Q29udGVudC50cmltKCkhPT1cIlwiKXtyLmhpZGRlbj10cnVlO2JyZWFrfX19fXVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocil9fX07dmFyIHJlbG9jYXRlTm9kZXM9W107dmFyIHJlbG9jYXRlU2xvdENvbnRlbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ7dmFyIHI7dmFyIG47dmFyIGE7dmFyIG87dmFyIHM7dmFyIGk9MDt2YXIgbD1lLmNoaWxkTm9kZXM7dmFyICQ9bC5sZW5ndGg7Zm9yKDtpPCQ7aSsrKXt0PWxbaV07aWYodFtcInMtc3JcIl0mJihyPXRbXCJzLWNyXCJdKSYmci5wYXJlbnROb2RlKXtuPXIucGFyZW50Tm9kZS5jaGlsZE5vZGVzO2E9dFtcInMtc25cIl07Zm9yKHM9bi5sZW5ndGgtMTtzPj0wO3MtLSl7cj1uW3NdO2lmKCFyW1wicy1jblwiXSYmIXJbXCJzLW5yXCJdJiZyW1wicy1oblwiXSE9PXRbXCJzLWhuXCJdKXtpZihpc05vZGVMb2NhdGVkSW5TbG90KHIsYSkpe289cmVsb2NhdGVOb2Rlcy5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gZS4kbm9kZVRvUmVsb2NhdGUkPT09cn0pKTtjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHk9dHJ1ZTtyW1wicy1zblwiXT1yW1wicy1zblwiXXx8YTtpZihvKXtvLiRzbG90UmVmTm9kZSQ9dH1lbHNle3JlbG9jYXRlTm9kZXMucHVzaCh7JHNsb3RSZWZOb2RlJDp0LCRub2RlVG9SZWxvY2F0ZSQ6cn0pfWlmKHJbXCJzLXNyXCJdKXtyZWxvY2F0ZU5vZGVzLm1hcCgoZnVuY3Rpb24oZSl7aWYoaXNOb2RlTG9jYXRlZEluU2xvdChlLiRub2RlVG9SZWxvY2F0ZSQscltcInMtc25cIl0pKXtvPXJlbG9jYXRlTm9kZXMuZmluZCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuJG5vZGVUb1JlbG9jYXRlJD09PXJ9KSk7aWYobyYmIWUuJHNsb3RSZWZOb2RlJCl7ZS4kc2xvdFJlZk5vZGUkPW8uJHNsb3RSZWZOb2RlJH19fSkpfX1lbHNlIGlmKCFyZWxvY2F0ZU5vZGVzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLiRub2RlVG9SZWxvY2F0ZSQ9PT1yfSkpKXtyZWxvY2F0ZU5vZGVzLnB1c2goeyRub2RlVG9SZWxvY2F0ZSQ6cn0pfX19fWlmKHQubm9kZVR5cGU9PT0xKXtyZWxvY2F0ZVNsb3RDb250ZW50KHQpfX19O3ZhciBpc05vZGVMb2NhdGVkSW5TbG90PWZ1bmN0aW9uKGUsdCl7aWYoZS5ub2RlVHlwZT09PTEpe2lmKGUuZ2V0QXR0cmlidXRlKFwic2xvdFwiKT09PW51bGwmJnQ9PT1cIlwiKXtyZXR1cm4gdHJ1ZX1pZihlLmdldEF0dHJpYnV0ZShcInNsb3RcIik9PT10KXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9aWYoZVtcInMtc25cIl09PT10KXtyZXR1cm4gdHJ1ZX1yZXR1cm4gdD09PVwiXCJ9O3ZhciBjYWxsTm9kZVJlZnM9ZnVuY3Rpb24oZSl7e2UuJGF0dHJzJCYmZS4kYXR0cnMkLnJlZiYmZS4kYXR0cnMkLnJlZihudWxsKTtlLiRjaGlsZHJlbiQmJmUuJGNoaWxkcmVuJC5tYXAoY2FsbE5vZGVSZWZzKX19O3ZhciByZW5kZXJWZG9tPWZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS4kaG9zdEVsZW1lbnQkO3ZhciBuPWUuJGNtcE1ldGEkO3ZhciBhPWUuJHZub2RlJHx8bmV3Vk5vZGUobnVsbCxudWxsKTt2YXIgbz1pc0hvc3QodCk/dDpoKG51bGwsbnVsbCx0KTtob3N0VGFnTmFtZT1yLnRhZ05hbWU7aWYobi4kYXR0cnNUb1JlZmxlY3QkKXtvLiRhdHRycyQ9by4kYXR0cnMkfHx7fTtuLiRhdHRyc1RvUmVmbGVjdCQubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXTtyZXR1cm4gby4kYXR0cnMkW25dPXJbdF19KSl9by4kdGFnJD1udWxsO28uJGZsYWdzJHw9NDtlLiR2bm9kZSQ9bztvLiRlbG0kPWEuJGVsbSQ9ci5zaGFkb3dSb290fHxyO3tzY29wZUlkPXJbXCJzLXNjXCJdfXtjb250ZW50UmVmPXJbXCJzLWNyXCJdO3VzZU5hdGl2ZVNoYWRvd0RvbT0obi4kZmxhZ3MkJjEpIT09MDtjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHk9ZmFsc2V9cGF0Y2goYSxvKTt7cGx0LiRmbGFncyR8PTE7aWYoY2hlY2tTbG90UmVsb2NhdGUpe3JlbG9jYXRlU2xvdENvbnRlbnQoby4kZWxtJCk7dmFyIHM9dm9pZCAwO3ZhciBpPXZvaWQgMDt2YXIgbD12b2lkIDA7dmFyICQ9dm9pZCAwO3ZhciBjPXZvaWQgMDt2YXIgZj12b2lkIDA7dmFyIHU9MDtmb3IoO3U8cmVsb2NhdGVOb2Rlcy5sZW5ndGg7dSsrKXtzPXJlbG9jYXRlTm9kZXNbdV07aT1zLiRub2RlVG9SZWxvY2F0ZSQ7aWYoIWlbXCJzLW9sXCJdKXtsPWRvYy5jcmVhdGVUZXh0Tm9kZShcIlwiKTtsW1wicy1uclwiXT1pO2kucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaVtcInMtb2xcIl09bCxpKX19Zm9yKHU9MDt1PHJlbG9jYXRlTm9kZXMubGVuZ3RoO3UrKyl7cz1yZWxvY2F0ZU5vZGVzW3VdO2k9cy4kbm9kZVRvUmVsb2NhdGUkO2lmKHMuJHNsb3RSZWZOb2RlJCl7JD1zLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtjPXMuJHNsb3RSZWZOb2RlJC5uZXh0U2libGluZztsPWlbXCJzLW9sXCJdO3doaWxlKGw9bC5wcmV2aW91c1NpYmxpbmcpe2Y9bFtcInMtbnJcIl07aWYoZiYmZltcInMtc25cIl09PT1pW1wicy1zblwiXSYmJD09PWYucGFyZW50Tm9kZSl7Zj1mLm5leHRTaWJsaW5nO2lmKCFmfHwhZltcInMtbnJcIl0pe2M9ZjticmVha319fWlmKCFjJiYkIT09aS5wYXJlbnROb2RlfHxpLm5leHRTaWJsaW5nIT09Yyl7aWYoaSE9PWMpe2lmKCFpW1wicy1oblwiXSYmaVtcInMtb2xcIl0pe2lbXCJzLWhuXCJdPWlbXCJzLW9sXCJdLnBhcmVudE5vZGUubm9kZU5hbWV9JC5pbnNlcnRCZWZvcmUoaSxjKX19fWVsc2V7aWYoaS5ub2RlVHlwZT09PTEpe2kuaGlkZGVuPXRydWV9fX19aWYoY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5KXt1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KG8uJGVsbSQpfXBsdC4kZmxhZ3MkJj1+MTtyZWxvY2F0ZU5vZGVzLmxlbmd0aD0wfX07dmFyIGdldEVsZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGdldEhvc3RSZWYoZSkuJGhvc3RFbGVtZW50JH07dmFyIGNyZWF0ZUV2ZW50PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1nZXRFbGVtZW50KGUpO3JldHVybntlbWl0OmZ1bmN0aW9uKGUpe3JldHVybiBlbWl0RXZlbnQobix0LHtidWJibGVzOiEhKHImNCksY29tcG9zZWQ6ISEociYyKSxjYW5jZWxhYmxlOiEhKHImMSksZGV0YWlsOmV9KX19fTt2YXIgZW1pdEV2ZW50PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1wbHQuY2UodCxyKTtlLmRpc3BhdGNoRXZlbnQobik7cmV0dXJuIG59O3ZhciBhdHRhY2hUb0FuY2VzdG9yPWZ1bmN0aW9uKGUsdCl7aWYodCYmIWUuJG9uUmVuZGVyUmVzb2x2ZSQmJnRbXCJzLXBcIl0pe3RbXCJzLXBcIl0ucHVzaChuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUuJG9uUmVuZGVyUmVzb2x2ZSQ9dH0pKSl9fTt2YXIgc2NoZWR1bGVVcGRhdGU9ZnVuY3Rpb24oZSx0KXt7ZS4kZmxhZ3MkfD0xNn1pZihlLiRmbGFncyQmNCl7ZS4kZmxhZ3MkfD01MTI7cmV0dXJufWF0dGFjaFRvQW5jZXN0b3IoZSxlLiRhbmNlc3RvckNvbXBvbmVudCQpO3ZhciByPWZ1bmN0aW9uKCl7cmV0dXJuIGRpc3BhdGNoSG9va3MoZSx0KX07cmV0dXJuIHdyaXRlVGFzayhyKX07dmFyIGRpc3BhdGNoSG9va3M9ZnVuY3Rpb24oZSx0KXt2YXIgcj1jcmVhdGVUaW1lKFwic2NoZWR1bGVVcGRhdGVcIixlLiRjbXBNZXRhJC4kdGFnTmFtZSQpO3ZhciBuPWUuJGxhenlJbnN0YW5jZSQ7dmFyIGE7aWYodCl7e2UuJGZsYWdzJHw9MjU2O2lmKGUuJHF1ZXVlZExpc3RlbmVycyQpe2UuJHF1ZXVlZExpc3RlbmVycyQubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLHI9ZVsxXTtyZXR1cm4gc2FmZUNhbGwobix0LHIpfSkpO2UuJHF1ZXVlZExpc3RlbmVycyQ9bnVsbH19e2E9c2FmZUNhbGwobixcImNvbXBvbmVudFdpbGxMb2FkXCIpfX17YT10aGVuKGEsKGZ1bmN0aW9uKCl7cmV0dXJuIHNhZmVDYWxsKG4sXCJjb21wb25lbnRXaWxsUmVuZGVyXCIpfSkpfXIoKTtyZXR1cm4gdGhlbihhLChmdW5jdGlvbigpe3JldHVybiB1cGRhdGVDb21wb25lbnQoZSxuLHQpfSkpfTt2YXIgdXBkYXRlQ29tcG9uZW50PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGEsbyxzLGksbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24oJCl7bj1lLiRob3N0RWxlbWVudCQ7YT1jcmVhdGVUaW1lKFwidXBkYXRlXCIsZS4kY21wTWV0YSQuJHRhZ05hbWUkKTtvPW5bXCJzLXJjXCJdO2lmKHIpe2F0dGFjaFN0eWxlcyhlKX1zPWNyZWF0ZVRpbWUoXCJyZW5kZXJcIixlLiRjbXBNZXRhJC4kdGFnTmFtZSQpO3tjYWxsUmVuZGVyKGUsdCl9aWYobyl7by5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7bltcInMtcmNcIl09dW5kZWZpbmVkfXMoKTthKCk7e2k9bltcInMtcFwiXTtsPWZ1bmN0aW9uKCl7cmV0dXJuIHBvc3RVcGRhdGVDb21wb25lbnQoZSl9O2lmKGkubGVuZ3RoPT09MCl7bCgpfWVsc2V7UHJvbWlzZS5hbGwoaSkudGhlbihsKTtlLiRmbGFncyR8PTQ7aS5sZW5ndGg9MH19cmV0dXJuWzJdfSkpfSkpfTt2YXIgY2FsbFJlbmRlcj1mdW5jdGlvbihlLHQscil7dHJ5e3Q9dC5yZW5kZXImJnQucmVuZGVyKCk7e2UuJGZsYWdzJCY9fjE2fXtlLiRmbGFncyR8PTJ9e3t7cmVuZGVyVmRvbShlLHQpfX19fWNhdGNoKHQpe2NvbnNvbGVFcnJvcih0LGUuJGhvc3RFbGVtZW50JCl9cmV0dXJuIG51bGx9O3ZhciBwb3N0VXBkYXRlQ29tcG9uZW50PWZ1bmN0aW9uKGUpe3ZhciB0PWUuJGNtcE1ldGEkLiR0YWdOYW1lJDt2YXIgcj1lLiRob3N0RWxlbWVudCQ7dmFyIG49Y3JlYXRlVGltZShcInBvc3RVcGRhdGVcIix0KTt2YXIgYT1lLiRsYXp5SW5zdGFuY2UkO3ZhciBvPWUuJGFuY2VzdG9yQ29tcG9uZW50JDt7c2FmZUNhbGwoYSxcImNvbXBvbmVudERpZFJlbmRlclwiKX1pZighKGUuJGZsYWdzJCY2NCkpe2UuJGZsYWdzJHw9NjQ7e2FkZEh5ZHJhdGVkRmxhZyhyKX17c2FmZUNhbGwoYSxcImNvbXBvbmVudERpZExvYWRcIil9bigpO3tlLiRvblJlYWR5UmVzb2x2ZSQocik7aWYoIW8pe2FwcERpZExvYWQoKX19fWVsc2V7e3NhZmVDYWxsKGEsXCJjb21wb25lbnREaWRVcGRhdGVcIil9bigpfXtlLiRvbkluc3RhbmNlUmVzb2x2ZSQocil9e2lmKGUuJG9uUmVuZGVyUmVzb2x2ZSQpe2UuJG9uUmVuZGVyUmVzb2x2ZSQoKTtlLiRvblJlbmRlclJlc29sdmUkPXVuZGVmaW5lZH1pZihlLiRmbGFncyQmNTEyKXtuZXh0VGljaygoZnVuY3Rpb24oKXtyZXR1cm4gc2NoZWR1bGVVcGRhdGUoZSxmYWxzZSl9KSl9ZS4kZmxhZ3MkJj1+KDR8NTEyKX19O3ZhciBmb3JjZVVwZGF0ZT1mdW5jdGlvbihlKXt7dmFyIHQ9Z2V0SG9zdFJlZihlKTt2YXIgcj10LiRob3N0RWxlbWVudCQuaXNDb25uZWN0ZWQ7aWYociYmKHQuJGZsYWdzJCYoMnwxNikpPT09Mil7c2NoZWR1bGVVcGRhdGUodCxmYWxzZSl9cmV0dXJuIHJ9fTt2YXIgYXBwRGlkTG9hZD1mdW5jdGlvbihlKXt7YWRkSHlkcmF0ZWRGbGFnKGRvYy5kb2N1bWVudEVsZW1lbnQpfW5leHRUaWNrKChmdW5jdGlvbigpe3JldHVybiBlbWl0RXZlbnQod2luLFwiYXBwbG9hZFwiLHtkZXRhaWw6e25hbWVzcGFjZTpOQU1FU1BBQ0V9fSl9KSl9O3ZhciBzYWZlQ2FsbD1mdW5jdGlvbihlLHQscil7aWYoZSYmZVt0XSl7dHJ5e3JldHVybiBlW3RdKHIpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlKX19cmV0dXJuIHVuZGVmaW5lZH07dmFyIHRoZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSYmZS50aGVuP2UudGhlbih0KTp0KCl9O3ZhciBhZGRIeWRyYXRlZEZsYWc9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NMaXN0LmFkZChcImh5ZHJhdGVkXCIpfTt2YXIgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGU9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9Y3JlYXRlVGltZShcImh5ZHJhdGVDbGllbnRcIix0KTt2YXIgbz1lLnNoYWRvd1Jvb3Q7dmFyIHM9W107dmFyIGk9W107dmFyIGw9bz9bXTpudWxsO3ZhciAkPW4uJHZub2RlJD1uZXdWTm9kZSh0LG51bGwpO2lmKCFwbHQuJG9yZ0xvY05vZGVzJCl7aW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShkb2MuYm9keSxwbHQuJG9yZ0xvY05vZGVzJD1uZXcgTWFwKX1lW0hZRFJBVEVfSURdPXI7ZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9JRCk7Y2xpZW50SHlkcmF0ZSgkLHMsaSxsLGUsZSxyKTtzLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHI9ZS4kaG9zdElkJCtcIi5cIitlLiRub2RlSWQkO3ZhciBuPXBsdC4kb3JnTG9jTm9kZXMkLmdldChyKTt2YXIgYT1lLiRlbG0kO2lmKG4mJnN1cHBvcnRzU2hhZG93JiZuW1wicy1lblwiXT09PVwiXCIpe24ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxuLm5leHRTaWJsaW5nKX1pZighbyl7YVtcInMtaG5cIl09dDtpZihuKXthW1wicy1vbFwiXT1uO2FbXCJzLW9sXCJdW1wicy1uclwiXT1hfX1wbHQuJG9yZ0xvY05vZGVzJC5kZWxldGUocil9KSk7aWYobyl7bC5tYXAoKGZ1bmN0aW9uKGUpe2lmKGUpe28uYXBwZW5kQ2hpbGQoZSl9fSkpfWEoKX07dmFyIGNsaWVudEh5ZHJhdGU9ZnVuY3Rpb24oZSx0LHIsbixhLG8scyl7dmFyIGk7dmFyIGw7dmFyICQ7dmFyIGM7aWYoby5ub2RlVHlwZT09PTEpe2k9by5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7aWYoaSl7bD1pLnNwbGl0KFwiLlwiKTtpZihsWzBdPT09c3x8bFswXT09PVwiMFwiKXskPXskZmxhZ3MkOjAsJGhvc3RJZCQ6bFswXSwkbm9kZUlkJDpsWzFdLCRkZXB0aCQ6bFsyXSwkaW5kZXgkOmxbM10sJHRhZyQ6by50YWdOYW1lLnRvTG93ZXJDYXNlKCksJGVsbSQ6bywkYXR0cnMkOm51bGwsJGNoaWxkcmVuJDpudWxsLCRrZXkkOm51bGwsJG5hbWUkOm51bGwsJHRleHQkOm51bGx9O3QucHVzaCgkKTtvLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtpZighZS4kY2hpbGRyZW4kKXtlLiRjaGlsZHJlbiQ9W119ZS4kY2hpbGRyZW4kWyQuJGluZGV4JF09JDtlPSQ7aWYobiYmJC4kZGVwdGgkPT09XCIwXCIpe25bJC4kaW5kZXgkXT0kLiRlbG0kfX19Zm9yKGM9by5jaGlsZE5vZGVzLmxlbmd0aC0xO2M+PTA7Yy0tKXtjbGllbnRIeWRyYXRlKGUsdCxyLG4sYSxvLmNoaWxkTm9kZXNbY10scyl9aWYoby5zaGFkb3dSb290KXtmb3IoYz1vLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGgtMTtjPj0wO2MtLSl7Y2xpZW50SHlkcmF0ZShlLHQscixuLGEsby5zaGFkb3dSb290LmNoaWxkTm9kZXNbY10scyl9fX1lbHNlIGlmKG8ubm9kZVR5cGU9PT04KXtsPW8ubm9kZVZhbHVlLnNwbGl0KFwiLlwiKTtpZihsWzFdPT09c3x8bFsxXT09PVwiMFwiKXtpPWxbMF07JD17JGZsYWdzJDowLCRob3N0SWQkOmxbMV0sJG5vZGVJZCQ6bFsyXSwkZGVwdGgkOmxbM10sJGluZGV4JDpsWzRdLCRlbG0kOm8sJGF0dHJzJDpudWxsLCRjaGlsZHJlbiQ6bnVsbCwka2V5JDpudWxsLCRuYW1lJDpudWxsLCR0YWckOm51bGwsJHRleHQkOm51bGx9O2lmKGk9PT1URVhUX05PREVfSUQpeyQuJGVsbSQ9by5uZXh0U2libGluZztpZigkLiRlbG0kJiYkLiRlbG0kLm5vZGVUeXBlPT09Myl7JC4kdGV4dCQ9JC4kZWxtJC50ZXh0Q29udGVudDt0LnB1c2goJCk7by5yZW1vdmUoKTtpZighZS4kY2hpbGRyZW4kKXtlLiRjaGlsZHJlbiQ9W119ZS4kY2hpbGRyZW4kWyQuJGluZGV4JF09JDtpZihuJiYkLiRkZXB0aCQ9PT1cIjBcIil7blskLiRpbmRleCRdPSQuJGVsbSR9fX1lbHNlIGlmKCQuJGhvc3RJZCQ9PT1zKXtpZihpPT09U0xPVF9OT0RFX0lEKXskLiR0YWckPVwic2xvdFwiO2lmKGxbNV0pe29bXCJzLXNuXCJdPSQuJG5hbWUkPWxbNV19ZWxzZXtvW1wicy1zblwiXT1cIlwifW9bXCJzLXNyXCJdPXRydWU7aWYobil7JC4kZWxtJD1kb2MuY3JlYXRlRWxlbWVudCgkLiR0YWckKTtpZigkLiRuYW1lJCl7JC4kZWxtJC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsJC4kbmFtZSQpfW8ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoJC4kZWxtJCxvKTtvLnJlbW92ZSgpO2lmKCQuJGRlcHRoJD09PVwiMFwiKXtuWyQuJGluZGV4JF09JC4kZWxtJH19ci5wdXNoKCQpO2lmKCFlLiRjaGlsZHJlbiQpe2UuJGNoaWxkcmVuJD1bXX1lLiRjaGlsZHJlbiRbJC4kaW5kZXgkXT0kfWVsc2UgaWYoaT09PUNPTlRFTlRfUkVGX0lEKXtpZihuKXtvLnJlbW92ZSgpfWVsc2V7YVtcInMtY3JcIl09bztvW1wicy1jblwiXT10cnVlfX19fX1lbHNlIGlmKGUmJmUuJHRhZyQ9PT1cInN0eWxlXCIpe3ZhciBmPW5ld1ZOb2RlKG51bGwsby50ZXh0Q29udGVudCk7Zi4kZWxtJD1vO2YuJGluZGV4JD1cIjBcIjtlLiRjaGlsZHJlbiQ9W2ZdfX07dmFyIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGU9ZnVuY3Rpb24oZSx0KXtpZihlLm5vZGVUeXBlPT09MSl7dmFyIHI9MDtmb3IoO3I8ZS5jaGlsZE5vZGVzLmxlbmd0aDtyKyspe2luaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZS5jaGlsZE5vZGVzW3JdLHQpfWlmKGUuc2hhZG93Um9vdCl7Zm9yKHI9MDtyPGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aDtyKyspe2luaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbcl0sdCl9fX1lbHNlIGlmKGUubm9kZVR5cGU9PT04KXt2YXIgbj1lLm5vZGVWYWx1ZS5zcGxpdChcIi5cIik7aWYoblswXT09PU9SR19MT0NBVElPTl9JRCl7dC5zZXQoblsxXStcIi5cIituWzJdLGUpO2Uubm9kZVZhbHVlPVwiXCI7ZVtcInMtZW5cIl09blszXX19fTt2YXIgcGFyc2VQcm9wZXJ0eVZhbHVlPWZ1bmN0aW9uKGUsdCl7aWYoZSE9bnVsbCYmIWlzQ29tcGxleFR5cGUoZSkpe2lmKHQmNCl7cmV0dXJuIGU9PT1cImZhbHNlXCI/ZmFsc2U6ZT09PVwiXCJ8fCEhZX1pZih0JjIpe3JldHVybiBwYXJzZUZsb2F0KGUpfWlmKHQmMSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX1yZXR1cm4gZX07dmFyIGdldFZhbHVlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGdldEhvc3RSZWYoZSkuJGluc3RhbmNlVmFsdWVzJC5nZXQodCl9O3ZhciBzZXRWYWx1ZT1mdW5jdGlvbihlLHQscixuKXt2YXIgYT1nZXRIb3N0UmVmKGUpO3ZhciBvPWEuJGhvc3RFbGVtZW50JDt2YXIgcz1hLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHQpO3ZhciBpPWEuJGZsYWdzJDt2YXIgbD1hLiRsYXp5SW5zdGFuY2UkO3I9cGFyc2VQcm9wZXJ0eVZhbHVlKHIsbi4kbWVtYmVycyRbdF1bMF0pO3ZhciAkPU51bWJlci5pc05hTihzKSYmTnVtYmVyLmlzTmFOKHIpO3ZhciBjPXIhPT1zJiYhJDtpZigoIShpJjgpfHxzPT09dW5kZWZpbmVkKSYmYyl7YS4kaW5zdGFuY2VWYWx1ZXMkLnNldCh0LHIpO2lmKGwpe2lmKG4uJHdhdGNoZXJzJCYmaSYxMjgpe3ZhciBmPW4uJHdhdGNoZXJzJFt0XTtpZihmKXtmLm1hcCgoZnVuY3Rpb24oZSl7dHJ5e2xbZV0ocixzLHQpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlLG8pfX0pKX19aWYoKGkmKDJ8MTYpKT09PTIpe3NjaGVkdWxlVXBkYXRlKGEsZmFsc2UpfX19fTt2YXIgcHJveHlDb21wb25lbnQ9ZnVuY3Rpb24oZSx0LHIpe2lmKHQuJG1lbWJlcnMkKXtpZihlLndhdGNoZXJzKXt0LiR3YXRjaGVycyQ9ZS53YXRjaGVyc312YXIgbj1PYmplY3QuZW50cmllcyh0LiRtZW1iZXJzJCk7dmFyIGE9ZS5wcm90b3R5cGU7bi5tYXAoKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0sbz1lWzFdWzBdO2lmKG8mMzF8fHImMiYmbyYzMil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsbix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGdldFZhbHVlKHRoaXMsbil9LHNldDpmdW5jdGlvbihlKXtzZXRWYWx1ZSh0aGlzLG4sZSx0KX0sY29uZmlndXJhYmxlOnRydWUsZW51bWVyYWJsZTp0cnVlfSl9ZWxzZSBpZihyJjEmJm8mNjQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLG4se3ZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZVt0XT1hcmd1bWVudHNbdF19dmFyIHI9Z2V0SG9zdFJlZih0aGlzKTtyZXR1cm4gci4kb25JbnN0YW5jZVByb21pc2UkLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuKHQ9ci4kbGF6eUluc3RhbmNlJClbbl0uYXBwbHkodCxlKX0pKX19KX19KSk7aWYociYxKXt2YXIgbz1uZXcgTWFwO2EuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzO3BsdC5qbXAoKGZ1bmN0aW9uKCl7dmFyIHQ9by5nZXQoZSk7aWYobi5oYXNPd25Qcm9wZXJ0eSh0KSl7cj1uW3RdO2RlbGV0ZSBuW3RdfWVsc2UgaWYoYS5oYXNPd25Qcm9wZXJ0eSh0KSYmdHlwZW9mIG5bdF09PT1cIm51bWJlclwiJiZuW3RdPT1yKXtyZXR1cm59blt0XT1yPT09bnVsbCYmdHlwZW9mIG5bdF09PT1cImJvb2xlYW5cIj9mYWxzZTpyfSkpfTtlLm9ic2VydmVkQXR0cmlidXRlcz1uLmZpbHRlcigoZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxyPWVbMV07cmV0dXJuIHJbMF0mMTV9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgcj1lWzBdLG49ZVsxXTt2YXIgYT1uWzFdfHxyO28uc2V0KGEscik7aWYoblswXSY1MTIpe3QuJGF0dHJzVG9SZWZsZWN0JC5wdXNoKFtyLGFdKX1yZXR1cm4gYX0pKX19cmV0dXJuIGV9O3ZhciBpbml0aWFsaXplQ29tcG9uZW50PWZ1bmN0aW9uKGUsdCxyLG4sYSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixvLHMsaSxsLCQsYztyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24oZil7c3dpdGNoKGYubGFiZWwpe2Nhc2UgMDppZighKCh0LiRmbGFncyQmMzIpPT09MCkpcmV0dXJuWzMsM107dC4kZmxhZ3MkfD0zMjthPWxvYWRNb2R1bGUocik7aWYoIWEudGhlbilyZXR1cm5bMywyXTtuPXVuaXF1ZVRpbWUoKTtyZXR1cm5bNCxhXTtjYXNlIDE6YT1mLnNlbnQoKTtuKCk7Zi5sYWJlbD0yO2Nhc2UgMjppZighYS5pc1Byb3hpZWQpe3tyLiR3YXRjaGVycyQ9YS53YXRjaGVyc31wcm94eUNvbXBvbmVudChhLHIsMik7YS5pc1Byb3hpZWQ9dHJ1ZX1vPWNyZWF0ZVRpbWUoXCJjcmVhdGVJbnN0YW5jZVwiLHIuJHRhZ05hbWUkKTt7dC4kZmxhZ3MkfD04fXRyeXtuZXcgYSh0KX1jYXRjaChlKXtjb25zb2xlRXJyb3IoZSl9e3QuJGZsYWdzJCY9fjh9e3QuJGZsYWdzJHw9MTI4fW8oKTtmaXJlQ29ubmVjdGVkQ2FsbGJhY2sodC4kbGF6eUluc3RhbmNlJCk7aWYoYS5zdHlsZSl7cz1hLnN0eWxlO2lmKHR5cGVvZiBzIT09XCJzdHJpbmdcIil7cz1zW3QuJG1vZGVOYW1lJD1jb21wdXRlTW9kZShlKV19aT1nZXRTY29wZUlkKHIsdC4kbW9kZU5hbWUkKTtpZighc3R5bGVzLmhhcyhpKSl7bD1jcmVhdGVUaW1lKFwicmVnaXN0ZXJTdHlsZXNcIixyLiR0YWdOYW1lJCk7cmVnaXN0ZXJTdHlsZShpLHMsISEoci4kZmxhZ3MkJjEpKTtsKCl9fWYubGFiZWw9MztjYXNlIDM6JD10LiRhbmNlc3RvckNvbXBvbmVudCQ7Yz1mdW5jdGlvbigpe3JldHVybiBzY2hlZHVsZVVwZGF0ZSh0LHRydWUpfTtpZigkJiYkW1wicy1yY1wiXSl7JFtcInMtcmNcIl0ucHVzaChjKX1lbHNle2MoKX1yZXR1cm5bMl19fSkpfSkpfTt2YXIgZmlyZUNvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGUpe3tzYWZlQ2FsbChlLFwiY29ubmVjdGVkQ2FsbGJhY2tcIil9fTt2YXIgY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7aWYoKHBsdC4kZmxhZ3MkJjEpPT09MCl7dmFyIHQ9Z2V0SG9zdFJlZihlKTt2YXIgcj10LiRjbXBNZXRhJDt2YXIgbj1jcmVhdGVUaW1lKFwiY29ubmVjdGVkQ2FsbGJhY2tcIixyLiR0YWdOYW1lJCk7aWYoISh0LiRmbGFncyQmMSkpe3QuJGZsYWdzJHw9MTt2YXIgYT12b2lkIDA7e2E9ZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7aWYoYSl7aWYoci4kZmxhZ3MkJjEpe3ZhciBvPWFkZFN0eWxlKGUuc2hhZG93Um9vdCxyLGUuZ2V0QXR0cmlidXRlKFwicy1tb2RlXCIpKTtlLmNsYXNzTGlzdC5yZW1vdmUobytcIi1oXCIsbytcIi1zXCIpfWluaXRpYWxpemVDbGllbnRIeWRyYXRlKGUsci4kdGFnTmFtZSQsYSx0KX19aWYoIWEpe2lmKHIuJGZsYWdzJCYoNHw4KSl7c2V0Q29udGVudFJlZmVyZW5jZShlKX19e3ZhciBzPWU7d2hpbGUocz1zLnBhcmVudE5vZGV8fHMuaG9zdCl7aWYocy5ub2RlVHlwZT09PTEmJnMuaGFzQXR0cmlidXRlKFwicy1pZFwiKSYmc1tcInMtcFwiXXx8c1tcInMtcFwiXSl7YXR0YWNoVG9BbmNlc3Rvcih0LHQuJGFuY2VzdG9yQ29tcG9uZW50JD1zKTticmVha319fWlmKHIuJG1lbWJlcnMkKXtPYmplY3QuZW50cmllcyhyLiRtZW1iZXJzJCkubWFwKChmdW5jdGlvbih0KXt2YXIgcj10WzBdLG49dFsxXVswXTtpZihuJjMxJiZlLmhhc093blByb3BlcnR5KHIpKXt2YXIgYT1lW3JdO2RlbGV0ZSBlW3JdO2Vbcl09YX19KSl9e25leHRUaWNrKChmdW5jdGlvbigpe3JldHVybiBpbml0aWFsaXplQ29tcG9uZW50KGUsdCxyKX0pKX19ZWxzZXthZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZSx0LHIuJGxpc3RlbmVycyQpO2ZpcmVDb25uZWN0ZWRDYWxsYmFjayh0LiRsYXp5SW5zdGFuY2UkKX1uKCl9fTt2YXIgc2V0Q29udGVudFJlZmVyZW5jZT1mdW5jdGlvbihlKXt2YXIgdD1lW1wicy1jclwiXT1kb2MuY3JlYXRlQ29tbWVudChcIlwiKTt0W1wicy1jblwiXT10cnVlO2UuaW5zZXJ0QmVmb3JlKHQsZS5maXJzdENoaWxkKX07dmFyIGRpc2Nvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGUpe2lmKChwbHQuJGZsYWdzJCYxKT09PTApe3ZhciB0PWdldEhvc3RSZWYoZSk7dmFyIHI9dC4kbGF6eUluc3RhbmNlJDt7aWYodC4kcm1MaXN0ZW5lcnMkKXt0LiRybUxpc3RlbmVycyQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpO3QuJHJtTGlzdGVuZXJzJD11bmRlZmluZWR9fXtzYWZlQ2FsbChyLFwiZGlzY29ubmVjdGVkQ2FsbGJhY2tcIil9fX07dmFyIGJvb3RzdHJhcExhenk9ZnVuY3Rpb24oZSx0KXtpZih0PT09dm9pZCAwKXt0PXt9fXZhciByPWNyZWF0ZVRpbWUoKTt2YXIgbj1bXTt2YXIgYT10LmV4Y2x1ZGV8fFtdO3ZhciBvPXdpbi5jdXN0b21FbGVtZW50czt2YXIgcz1kb2MuaGVhZDt2YXIgaT1zLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW2NoYXJzZXRdXCIpO3ZhciBsPWRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7dmFyICQ9W107dmFyIGM9ZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIuY29uY2F0KEhZRFJBVEVEX1NUWUxFX0lELFwiXVwiKSk7dmFyIGY7dmFyIHU9dHJ1ZTt2YXIgZD0wO09iamVjdC5hc3NpZ24ocGx0LHQpO3BsdC4kcmVzb3VyY2VzVXJsJD1uZXcgVVJMKHQucmVzb3VyY2VzVXJsfHxcIi4vXCIsZG9jLmJhc2VVUkkpLmhyZWY7e3BsdC4kZmxhZ3MkfD0yfXtmb3IoO2Q8Yy5sZW5ndGg7ZCsrKXtyZWdpc3RlclN0eWxlKGNbZF0uZ2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lEKSxjb252ZXJ0U2NvcGVkVG9TaGFkb3coY1tkXS5pbm5lckhUTUwpLHRydWUpfX1lLm1hcCgoZnVuY3Rpb24oZSl7ZVsxXS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciByPXskZmxhZ3MkOnRbMF0sJHRhZ05hbWUkOnRbMV0sJG1lbWJlcnMkOnRbMl0sJGxpc3RlbmVycyQ6dFszXX07e3IuJG1lbWJlcnMkPXRbMl19e3IuJGxpc3RlbmVycyQ9dFszXX17ci4kYXR0cnNUb1JlZmxlY3QkPVtdfXtyLiR3YXRjaGVycyQ9e319dmFyIHM9ci4kdGFnTmFtZSQ7dmFyIGk9ZnVuY3Rpb24oZSl7X19leHRlbmRzKHQsZSk7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpczt0PW47cmVnaXN0ZXJIb3N0KHQscik7aWYoci4kZmxhZ3MkJjEpe3t7dC5hdHRhY2hTaGFkb3coe21vZGU6XCJvcGVuXCIsZGVsZWdhdGVzRm9jdXM6ISEoci4kZmxhZ3MkJjE2KX0pfX19cmV0dXJuIG59dC5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKGYpe2NsZWFyVGltZW91dChmKTtmPW51bGx9aWYodSl7JC5wdXNoKHRoaXMpfWVsc2V7cGx0LmptcCgoZnVuY3Rpb24oKXtyZXR1cm4gY29ubmVjdGVkQ2FsbGJhY2soZSl9KSl9fTt0LnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cGx0LmptcCgoZnVuY3Rpb24oKXtyZXR1cm4gZGlzY29ubmVjdGVkQ2FsbGJhY2soZSl9KSl9O3QucHJvdG90eXBlLmNvbXBvbmVudE9uUmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkfTtyZXR1cm4gdH0oSFRNTEVsZW1lbnQpO3IuJGxhenlCdW5kbGVJZCQ9ZVswXTtpZighYS5pbmNsdWRlcyhzKSYmIW8uZ2V0KHMpKXtuLnB1c2gocyk7by5kZWZpbmUocyxwcm94eUNvbXBvbmVudChpLHIsMSkpfX0pKX0pKTt7bC5pbm5lckhUTUw9bitIWURSQVRFRF9DU1M7bC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlc1wiLFwiXCIpO3MuaW5zZXJ0QmVmb3JlKGwsaT9pLm5leHRTaWJsaW5nOnMuZmlyc3RDaGlsZCl9dT1mYWxzZTtpZigkLmxlbmd0aCl7JC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbm5lY3RlZENhbGxiYWNrKCl9KSl9ZWxzZXt7cGx0LmptcCgoZnVuY3Rpb24oKXtyZXR1cm4gZj1zZXRUaW1lb3V0KGFwcERpZExvYWQsMzApfSkpfX1yKCl9O3ZhciBnZXRBc3NldFBhdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVSTChlLHBsdC4kcmVzb3VyY2VzVXJsJCk7cmV0dXJuIHQub3JpZ2luIT09d2luLmxvY2F0aW9uLm9yaWdpbj90LmhyZWY6dC5wYXRobmFtZX07dmFyIGhvc3RSZWZzPW5ldyBXZWFrTWFwO3ZhciBnZXRIb3N0UmVmPWZ1bmN0aW9uKGUpe3JldHVybiBob3N0UmVmcy5nZXQoZSl9O3ZhciByZWdpc3Rlckluc3RhbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGhvc3RSZWZzLnNldCh0LiRsYXp5SW5zdGFuY2UkPWUsdCl9O3ZhciByZWdpc3Rlckhvc3Q9ZnVuY3Rpb24oZSx0KXt2YXIgcj17JGZsYWdzJDowLCRob3N0RWxlbWVudCQ6ZSwkY21wTWV0YSQ6dCwkaW5zdGFuY2VWYWx1ZXMkOm5ldyBNYXB9O3tyLiRvbkluc3RhbmNlUHJvbWlzZSQ9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiByLiRvbkluc3RhbmNlUmVzb2x2ZSQ9ZX0pKX17ci4kb25SZWFkeVByb21pc2UkPW5ldyBQcm9taXNlKChmdW5jdGlvbihlKXtyZXR1cm4gci4kb25SZWFkeVJlc29sdmUkPWV9KSk7ZVtcInMtcFwiXT1bXTtlW1wicy1yY1wiXT1bXX1hZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZSxyLHQuJGxpc3RlbmVycyQpO3JldHVybiBob3N0UmVmcy5zZXQoZSxyKX07dmFyIGlzTWVtYmVySW5FbGVtZW50PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQgaW4gZX07dmFyIGNvbnNvbGVFcnJvcj1mdW5jdGlvbihlLHQpe3JldHVybigwLGNvbnNvbGUuZXJyb3IpKGUsdCl9O3ZhciBjbXBNb2R1bGVzPW5ldyBNYXA7dmFyIGxvYWRNb2R1bGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZyxcIl9cIik7dmFyIGE9ZS4kbGF6eUJ1bmRsZUlkJDt2YXIgbz1jbXBNb2R1bGVzLmdldChhKTtpZihvKXtyZXR1cm4gb1tuXX1yZXR1cm4gaW1wb3J0KFwiLi9cIi5jb25jYXQoYSxcIi5lbnRyeS5qc1wiKS5jb25jYXQoXCJcIikpLnRoZW4oKGZ1bmN0aW9uKGUpe3tjbXBNb2R1bGVzLnNldChhLGUpfXJldHVybiBlW25dfSksY29uc29sZUVycm9yKX07dmFyIHN0eWxlcz1uZXcgTWFwO3ZhciBtb2RlUmVzb2x1dGlvbkNoYWluPVtdO3ZhciBxdWV1ZURvbVJlYWRzPVtdO3ZhciBxdWV1ZURvbVdyaXRlcz1bXTt2YXIgcXVldWVUYXNrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKHIpe2UucHVzaChyKTtpZighcXVldWVQZW5kaW5nKXtxdWV1ZVBlbmRpbmc9dHJ1ZTtpZih0JiZwbHQuJGZsYWdzJCY0KXtuZXh0VGljayhmbHVzaCl9ZWxzZXtwbHQucmFmKGZsdXNoKX19fX07dmFyIGNvbnN1bWU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3RyeXtlW3RdKHBlcmZvcm1hbmNlLm5vdygpKX1jYXRjaChlKXtjb25zb2xlRXJyb3IoZSl9fWUubGVuZ3RoPTB9O3ZhciBmbHVzaD1mdW5jdGlvbigpe2NvbnN1bWUocXVldWVEb21SZWFkcyk7e2NvbnN1bWUocXVldWVEb21Xcml0ZXMpO2lmKHF1ZXVlUGVuZGluZz1xdWV1ZURvbVJlYWRzLmxlbmd0aD4wKXtwbHQucmFmKGZsdXNoKX19fTt2YXIgbmV4dFRpY2s9ZnVuY3Rpb24oZSl7cmV0dXJuIHByb21pc2VSZXNvbHZlKCkudGhlbihlKX07dmFyIHJlYWRUYXNrPXF1ZXVlVGFzayhxdWV1ZURvbVJlYWRzLGZhbHNlKTt2YXIgd3JpdGVUYXNrPXF1ZXVlVGFzayhxdWV1ZURvbVdyaXRlcyx0cnVlKTt2YXIgQnVpbGQ9e2lzRGV2OmZhbHNlLGlzQnJvd3Nlcjp0cnVlLGlzU2VydmVyOmZhbHNlLGlzVGVzdGluZzpmYWxzZX07ZXhwb3J0e0J1aWxkIGFzIEIsSG9zdCBhcyBILE5BTUVTUEFDRSBhcyBOLHNldE1vZGUgYXMgYSxib290c3RyYXBMYXp5IGFzIGIsd3JpdGVUYXNrIGFzIGMsZG9jIGFzIGQsY3JlYXRlRXZlbnQgYXMgZSxyZWFkVGFzayBhcyBmLGdldE1vZGUgYXMgZyxoLGdldEVsZW1lbnQgYXMgaSxmb3JjZVVwZGF0ZSBhcyBqLGdldEFzc2V0UGF0aCBhcyBrLHByb21pc2VSZXNvbHZlIGFzIHAscmVnaXN0ZXJJbnN0YW5jZSBhcyByLHNldFBsYXRmb3JtSGVscGVycyBhcyBzLHdpbiBhcyB3fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82896\n')},48186:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "I": () => (/* binding */ IonicSafeString),\n/* harmony export */   "s": () => (/* binding */ sanitizeDOMString)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar sanitizeDOMString=function(e){try{if(e instanceof IonicSafeString){return e.value}if(!isSanitizerEnabled()||typeof e!=="string"||e===""){return e}var r=document.createDocumentFragment();var n=document.createElement("div");r.appendChild(n);n.innerHTML=e;blockedTags.forEach((function(e){var n=r.querySelectorAll(e);for(var t=n.length-1;t>=0;t--){var i=n[t];if(i.parentNode){i.parentNode.removeChild(i)}else{r.removeChild(i)}var a=getElementChildren(i);for(var l=0;l<a.length;l++){sanitizeElement(a[l])}}}));var t=getElementChildren(r);for(var i=0;i<t.length;i++){sanitizeElement(t[i])}var a=document.createElement("div");a.appendChild(r);var l=a.querySelector("div");return l!==null?l.innerHTML:a.innerHTML}catch(e){console.error(e);return""}};var sanitizeElement=function(e){if(e.nodeType&&e.nodeType!==1){return}for(var r=e.attributes.length-1;r>=0;r--){var n=e.attributes.item(r);var t=n.name;if(!allowedAttributes.includes(t.toLowerCase())){e.removeAttribute(t);continue}var i=n.value;if(i!=null&&i.toLowerCase().includes("javascript:")){e.removeAttribute(t)}}var a=getElementChildren(e);for(var r=0;r<a.length;r++){sanitizeElement(a[r])}};var getElementChildren=function(e){return e.children!=null?e.children:e.childNodes};var isSanitizerEnabled=function(){var e=window;var r=e&&e.Ionic&&e.Ionic.config;if(r){if(r.get){return r.get("sanitizerEnabled",true)}else{return r.sanitizerEnabled===true||r.sanitizerEnabled===undefined}}return true};var allowedAttributes=["class","id","href","src","name","slot"];var blockedTags=["script","style","iframe","meta","link","object","embed"];var IonicSafeString=function(){function e(e){this.value=e}return e}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgxODYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSSxpQ0FBaUMsZUFBZSx1REFBdUQsU0FBUyx3Q0FBd0Msb0NBQW9DLGlCQUFpQixjQUFjLGlDQUFpQyw0QkFBNEIscUJBQXFCLEtBQUssS0FBSyxXQUFXLGlCQUFpQiw0QkFBNEIsS0FBSyxpQkFBaUIsNEJBQTRCLFlBQVksV0FBVyxLQUFLLHdCQUF3QixHQUFHLDRCQUE0QixZQUFZLFdBQVcsS0FBSyxzQkFBc0Isb0NBQW9DLGlCQUFpQiw2QkFBNkIsd0NBQXdDLFNBQVMsaUJBQWlCLFdBQVcsZ0NBQWdDLCtCQUErQixPQUFPLGdDQUFnQyxLQUFLLEtBQUssMkJBQTJCLGFBQWEsaURBQWlELHFCQUFxQixTQUFTLGNBQWMscURBQXFELHNCQUFzQiw0QkFBNEIsWUFBWSxXQUFXLEtBQUssd0JBQXdCLG1DQUFtQyxpREFBaUQsa0NBQWtDLGFBQWEsaUNBQWlDLE1BQU0sVUFBVSxzQ0FBc0MsS0FBSyxrRUFBa0UsYUFBYSxnRUFBZ0UsMkVBQTJFLCtCQUErQixjQUFjLGFBQWEsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LWM4NDFjOTMzLmpzPzFiZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbnZhciBzYW5pdGl6ZURPTVN0cmluZz1mdW5jdGlvbihlKXt0cnl7aWYoZSBpbnN0YW5jZW9mIElvbmljU2FmZVN0cmluZyl7cmV0dXJuIGUudmFsdWV9aWYoIWlzU2FuaXRpemVyRW5hYmxlZCgpfHx0eXBlb2YgZSE9PVwic3RyaW5nXCJ8fGU9PT1cIlwiKXtyZXR1cm4gZX12YXIgcj1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyLmFwcGVuZENoaWxkKG4pO24uaW5uZXJIVE1MPWU7YmxvY2tlZFRhZ3MuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ci5xdWVyeVNlbGVjdG9yQWxsKGUpO2Zvcih2YXIgdD1uLmxlbmd0aC0xO3Q+PTA7dC0tKXt2YXIgaT1uW3RdO2lmKGkucGFyZW50Tm9kZSl7aS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGkpfWVsc2V7ci5yZW1vdmVDaGlsZChpKX12YXIgYT1nZXRFbGVtZW50Q2hpbGRyZW4oaSk7Zm9yKHZhciBsPTA7bDxhLmxlbmd0aDtsKyspe3Nhbml0aXplRWxlbWVudChhW2xdKX19fSkpO3ZhciB0PWdldEVsZW1lbnRDaGlsZHJlbihyKTtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl7c2FuaXRpemVFbGVtZW50KHRbaV0pfXZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5hcHBlbmRDaGlsZChyKTt2YXIgbD1hLnF1ZXJ5U2VsZWN0b3IoXCJkaXZcIik7cmV0dXJuIGwhPT1udWxsP2wuaW5uZXJIVE1MOmEuaW5uZXJIVE1MfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoZSk7cmV0dXJuXCJcIn19O3ZhciBzYW5pdGl6ZUVsZW1lbnQ9ZnVuY3Rpb24oZSl7aWYoZS5ub2RlVHlwZSYmZS5ub2RlVHlwZSE9PTEpe3JldHVybn1mb3IodmFyIHI9ZS5hdHRyaWJ1dGVzLmxlbmd0aC0xO3I+PTA7ci0tKXt2YXIgbj1lLmF0dHJpYnV0ZXMuaXRlbShyKTt2YXIgdD1uLm5hbWU7aWYoIWFsbG93ZWRBdHRyaWJ1dGVzLmluY2x1ZGVzKHQudG9Mb3dlckNhc2UoKSkpe2UucmVtb3ZlQXR0cmlidXRlKHQpO2NvbnRpbnVlfXZhciBpPW4udmFsdWU7aWYoaSE9bnVsbCYmaS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiamF2YXNjcmlwdDpcIikpe2UucmVtb3ZlQXR0cmlidXRlKHQpfX12YXIgYT1nZXRFbGVtZW50Q2hpbGRyZW4oZSk7Zm9yKHZhciByPTA7cjxhLmxlbmd0aDtyKyspe3Nhbml0aXplRWxlbWVudChhW3JdKX19O3ZhciBnZXRFbGVtZW50Q2hpbGRyZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2hpbGRyZW4hPW51bGw/ZS5jaGlsZHJlbjplLmNoaWxkTm9kZXN9O3ZhciBpc1Nhbml0aXplckVuYWJsZWQ9ZnVuY3Rpb24oKXt2YXIgZT13aW5kb3c7dmFyIHI9ZSYmZS5Jb25pYyYmZS5Jb25pYy5jb25maWc7aWYocil7aWYoci5nZXQpe3JldHVybiByLmdldChcInNhbml0aXplckVuYWJsZWRcIix0cnVlKX1lbHNle3JldHVybiByLnNhbml0aXplckVuYWJsZWQ9PT10cnVlfHxyLnNhbml0aXplckVuYWJsZWQ9PT11bmRlZmluZWR9fXJldHVybiB0cnVlfTt2YXIgYWxsb3dlZEF0dHJpYnV0ZXM9W1wiY2xhc3NcIixcImlkXCIsXCJocmVmXCIsXCJzcmNcIixcIm5hbWVcIixcInNsb3RcIl07dmFyIGJsb2NrZWRUYWdzPVtcInNjcmlwdFwiLFwic3R5bGVcIixcImlmcmFtZVwiLFwibWV0YVwiLFwibGlua1wiLFwib2JqZWN0XCIsXCJlbWJlZFwiXTt2YXIgSW9uaWNTYWZlU3RyaW5nPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLnZhbHVlPWV9cmV0dXJuIGV9KCk7ZXhwb3J0e0lvbmljU2FmZVN0cmluZyBhcyBJLHNhbml0aXplRE9NU3RyaW5nIGFzIHN9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48186\n')},90114:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "m": () => (/* binding */ menuController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70655);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17504);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75001);\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27434);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var baseAnimation=function(n){return (0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().duration(n?400:300)};var menuOverlayAnimation=function(n){var e;var r;var t=n.width+8;var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();if(n.isEndSide){e=t+"px";r="0px"}else{e=-t+"px";r="0px"}i.addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(e,")"),"translateX(".concat(r,")"));var o=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var u=o==="ios";var s=u?.2:.25;a.addElement(n.backdropEl).fromTo("opacity",.01,s);return baseAnimation(u).addAnimation([i,a])};var menuPushAnimation=function(n){var e;var r;var t=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var i=n.width;if(n.isEndSide){e=-i+"px";r=i+"px"}else{e=i+"px";r=-i+"px"}var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(r,")"),"translateX(0px)");var o=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(e,")"));var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.backdropEl).fromTo("opacity",.01,.32);return baseAnimation(t==="ios").addAnimation([a,o,u])};var menuRevealAnimation=function(n){var e=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var r=n.width*(n.isEndSide?-1:1)+"px";var t=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(r,")"));return baseAnimation(e==="ios").addAnimation(t)};var createMenuController=function(){var n=new Map;var e=[];var r=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.open()]}return[2,false]}}))}))};var t=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,n!==undefined?c(n):f()];case 1:e=r.sent();if(e!==undefined){return[2,e.close()]}return[2,false]}}))}))};var i=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.toggle()]}return[2,false]}}))}))};var a=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.disabled=!n}return[2,r]}}))}))};var o=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.swipeGesture=n}return[2,r]}}))}))};var u=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e,e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!(n!=null))return[3,2];return[4,c(n)];case 1:e=r.sent();return[2,e!==undefined&&e.isOpen()];case 2:return[4,f()];case 3:e=r.sent();return[2,e!==undefined]}}))}))};var s=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,!e.disabled]}return[2,false]}}))}))};var c=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r,t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:return[4,O()];case 1:i.sent();if(n==="start"||n==="end"){r=E((function(e){return e.side===n&&!e.disabled}));if(r){return[2,r]}return[2,E((function(e){return e.side===n}))]}else if(n!=null){return[2,E((function(e){return e.menuId===n}))]}t=E((function(n){return!n.disabled}));if(t){return[2,t]}return[2,e.length>0?e[0].el:undefined]}}))}))};var f=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,g()]}}))}))};var d=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,w()]}}))}))};var v=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,A()]}}))}))};var l=function(e,r){n.set(e,r)};var m=function(n){if(e.indexOf(n)<0){if(!n.disabled){p(n)}e.push(n)}};var _=function(n){var r=e.indexOf(n);if(r>-1){e.splice(r,1)}};var p=function(n){var r=n.side;e.filter((function(e){return e.side===r&&e!==n})).forEach((function(n){return n.disabled=true}))};var b=function(n,e,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(A()){return[2,false]}if(!e)return[3,3];return[4,f()];case 1:t=i.sent();if(!(t&&n.el!==t))return[3,3];return[4,t.setOpen(false,false)];case 2:i.sent();i.label=3;case 3:return[2,n._setOpen(e,r)]}}))}))};var h=function(e,r){var t=n.get(e);if(!t){throw new Error("animation not registered")}var i=t(r);return i};var g=function(){return E((function(n){return n._isOpen}))};var w=function(){return e.map((function(n){return n.el}))};var A=function(){return e.some((function(n){return n.isAnimating}))};var E=function(n){var r=e.find(n);if(r!==undefined){return r.el}return undefined};var O=function(){return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((function(n){return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__.c)(n,e)}))})))};l("reveal",menuRevealAnimation);l("push",menuPushAnimation);l("overlay",menuOverlayAnimation);if(typeof document!=="undefined"){document.addEventListener("ionBackButton",(function(n){var e=g();if(e){n.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__.MENU_BACK_BUTTON_PRIORITY,(function(){return e.close()}))}}))}return{registerAnimation:l,get:c,getMenus:d,getOpen:f,isEnabled:s,swipeGesture:o,isAnimating:v,isOpen:u,enable:a,toggle:i,close:t,open:r,_getOpenSync:g,_createAnimation:h,_register:m,_unregister:_,_setOpen:b,_setActiveMenu:p}};var menuController=createMenuController();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0NBQWtDLEdBQUcsSUFBSSxvQkFBb0IsZUFBZSxPQUFPLDRDQUE0QyxXQUFXLFVBQVUsaUJBQWlCLHNCQUFzQixpQkFBaUIsSUFBSSxpQkFBaUIsMEJBQTBCLFlBQVksSUFBSSxpQkFBaUIsMkJBQTJCLHFCQUFxQixJQUFJLGtCQUFrQixnQkFBZ0Isa0JBQWtCLFlBQVksa0JBQWtCLGlCQUFpQixzRkFBc0YsZ0NBQWdDLE9BQU8sdURBQWdCLE1BQU0sR0FBRyxLQUFLLGdDQUFnQyw0QkFBNEIsa0NBQWtDLGtDQUFrQyx1REFBdUQsVUFBVSxNQUFNLGtCQUFrQix3RkFBeUIsYUFBYSxpQkFBaUIsSUFBSSxHQUFHLE9BQU8sNE5BQTROIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtY2RiMWNmOTQuanM/Njk0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZ2VuZXJhdG9yfWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtNRU5VX0JBQ0tfQlVUVE9OX1BSSU9SSVRZfWZyb21cIi4vaGFyZHdhcmUtYmFjay1idXR0b24tYWNlNmE3MWIuanNcIjtpbXBvcnR7YyBhcyBjb21wb25lbnRPblJlYWR5fWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO2ltcG9ydHtiIGFzIGdldElvbk1vZGV9ZnJvbVwiLi9pb25pYy1nbG9iYWwtMGViZTMyMWMuanNcIjtpbXBvcnR7YyBhcyBjcmVhdGVBbmltYXRpb259ZnJvbVwiLi9hbmltYXRpb24tMTlkYmY5YmYuanNcIjt2YXIgYmFzZUFuaW1hdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gY3JlYXRlQW5pbWF0aW9uKCkuZHVyYXRpb24obj80MDA6MzAwKX07dmFyIG1lbnVPdmVybGF5QW5pbWF0aW9uPWZ1bmN0aW9uKG4pe3ZhciBlO3ZhciByO3ZhciB0PW4ud2lkdGgrODt2YXIgaT1jcmVhdGVBbmltYXRpb24oKTt2YXIgYT1jcmVhdGVBbmltYXRpb24oKTtpZihuLmlzRW5kU2lkZSl7ZT10K1wicHhcIjtyPVwiMHB4XCJ9ZWxzZXtlPS10K1wicHhcIjtyPVwiMHB4XCJ9aS5hZGRFbGVtZW50KG4ubWVudUlubmVyRWwpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQoZSxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChyLFwiKVwiKSk7dmFyIG89Z2V0SW9uTW9kZShuKTt2YXIgdT1vPT09XCJpb3NcIjt2YXIgcz11Py4yOi4yNTthLmFkZEVsZW1lbnQobi5iYWNrZHJvcEVsKS5mcm9tVG8oXCJvcGFjaXR5XCIsLjAxLHMpO3JldHVybiBiYXNlQW5pbWF0aW9uKHUpLmFkZEFuaW1hdGlvbihbaSxhXSl9O3ZhciBtZW51UHVzaEFuaW1hdGlvbj1mdW5jdGlvbihuKXt2YXIgZTt2YXIgcjt2YXIgdD1nZXRJb25Nb2RlKG4pO3ZhciBpPW4ud2lkdGg7aWYobi5pc0VuZFNpZGUpe2U9LWkrXCJweFwiO3I9aStcInB4XCJ9ZWxzZXtlPWkrXCJweFwiO3I9LWkrXCJweFwifXZhciBhPWNyZWF0ZUFuaW1hdGlvbigpLmFkZEVsZW1lbnQobi5tZW51SW5uZXJFbCkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChyLFwiKVwiKSxcInRyYW5zbGF0ZVgoMHB4KVwiKTt2YXIgbz1jcmVhdGVBbmltYXRpb24oKS5hZGRFbGVtZW50KG4uY29udGVudEVsKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoMHB4KVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQoZSxcIilcIikpO3ZhciB1PWNyZWF0ZUFuaW1hdGlvbigpLmFkZEVsZW1lbnQobi5iYWNrZHJvcEVsKS5mcm9tVG8oXCJvcGFjaXR5XCIsLjAxLC4zMik7cmV0dXJuIGJhc2VBbmltYXRpb24odD09PVwiaW9zXCIpLmFkZEFuaW1hdGlvbihbYSxvLHVdKX07dmFyIG1lbnVSZXZlYWxBbmltYXRpb249ZnVuY3Rpb24obil7dmFyIGU9Z2V0SW9uTW9kZShuKTt2YXIgcj1uLndpZHRoKihuLmlzRW5kU2lkZT8tMToxKStcInB4XCI7dmFyIHQ9Y3JlYXRlQW5pbWF0aW9uKCkuYWRkRWxlbWVudChuLmNvbnRlbnRFbCkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKDBweClcIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHIsXCIpXCIpKTtyZXR1cm4gYmFzZUFuaW1hdGlvbihlPT09XCJpb3NcIikuYWRkQW5pbWF0aW9uKHQpfTt2YXIgY3JlYXRlTWVudUNvbnRyb2xsZXI9ZnVuY3Rpb24oKXt2YXIgbj1uZXcgTWFwO3ZhciBlPVtdO3ZhciByPWZ1bmN0aW9uKG4pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsYyhuKV07Y2FzZSAxOmU9ci5zZW50KCk7aWYoZSl7cmV0dXJuWzIsZS5vcGVuKCldfXJldHVyblsyLGZhbHNlXX19KSl9KSl9O3ZhciB0PWZ1bmN0aW9uKG4pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsbiE9PXVuZGVmaW5lZD9jKG4pOmYoKV07Y2FzZSAxOmU9ci5zZW50KCk7aWYoZSE9PXVuZGVmaW5lZCl7cmV0dXJuWzIsZS5jbG9zZSgpXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgaT1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMobildO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUpe3JldHVyblsyLGUudG9nZ2xlKCldfXJldHVyblsyLGZhbHNlXX19KSl9KSl9O3ZhciBhPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgcjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxjKGUpXTtjYXNlIDE6cj10LnNlbnQoKTtpZihyKXtyLmRpc2FibGVkPSFufXJldHVyblsyLHJdfX0pKX0pKX07dmFyIG89ZnVuY3Rpb24obixlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMoZSldO2Nhc2UgMTpyPXQuc2VudCgpO2lmKHIpe3Iuc3dpcGVHZXN0dXJlPW59cmV0dXJuWzIscl19fSkpfSkpfTt2YXIgdT1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYoIShuIT1udWxsKSlyZXR1cm5bMywyXTtyZXR1cm5bNCxjKG4pXTtjYXNlIDE6ZT1yLnNlbnQoKTtyZXR1cm5bMixlIT09dW5kZWZpbmVkJiZlLmlzT3BlbigpXTtjYXNlIDI6cmV0dXJuWzQsZigpXTtjYXNlIDM6ZT1yLnNlbnQoKTtyZXR1cm5bMixlIT09dW5kZWZpbmVkXX19KSl9KSl9O3ZhciBzPWZ1bmN0aW9uKG4pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsYyhuKV07Y2FzZSAxOmU9ci5zZW50KCk7aWYoZSl7cmV0dXJuWzIsIWUuZGlzYWJsZWRdfXJldHVyblsyLGZhbHNlXX19KSl9KSl9O3ZhciBjPWZ1bmN0aW9uKG4pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHIsdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxPKCldO2Nhc2UgMTppLnNlbnQoKTtpZihuPT09XCJzdGFydFwifHxuPT09XCJlbmRcIil7cj1FKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaWRlPT09biYmIWUuZGlzYWJsZWR9KSk7aWYocil7cmV0dXJuWzIscl19cmV0dXJuWzIsRSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lkZT09PW59KSldfWVsc2UgaWYobiE9bnVsbCl7cmV0dXJuWzIsRSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUubWVudUlkPT09bn0pKV19dD1FKChmdW5jdGlvbihuKXtyZXR1cm4hbi5kaXNhYmxlZH0pKTtpZih0KXtyZXR1cm5bMix0XX1yZXR1cm5bMixlLmxlbmd0aD4wP2VbMF0uZWw6dW5kZWZpbmVkXX19KSl9KSl9O3ZhciBmPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxPKCldO2Nhc2UgMTpuLnNlbnQoKTtyZXR1cm5bMixnKCldfX0pKX0pKX07dmFyIGQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LE8oKV07Y2FzZSAxOm4uc2VudCgpO3JldHVyblsyLHcoKV19fSkpfSkpfTt2YXIgdj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsTygpXTtjYXNlIDE6bi5zZW50KCk7cmV0dXJuWzIsQSgpXX19KSl9KSl9O3ZhciBsPWZ1bmN0aW9uKGUscil7bi5zZXQoZSxyKX07dmFyIG09ZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKG4pPDApe2lmKCFuLmRpc2FibGVkKXtwKG4pfWUucHVzaChuKX19O3ZhciBfPWZ1bmN0aW9uKG4pe3ZhciByPWUuaW5kZXhPZihuKTtpZihyPi0xKXtlLnNwbGljZShyLDEpfX07dmFyIHA9ZnVuY3Rpb24obil7dmFyIHI9bi5zaWRlO2UuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaWRlPT09ciYmZSE9PW59KSkuZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIG4uZGlzYWJsZWQ9dHJ1ZX0pKX07dmFyIGI9ZnVuY3Rpb24obixlLHIpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6aWYoQSgpKXtyZXR1cm5bMixmYWxzZV19aWYoIWUpcmV0dXJuWzMsM107cmV0dXJuWzQsZigpXTtjYXNlIDE6dD1pLnNlbnQoKTtpZighKHQmJm4uZWwhPT10KSlyZXR1cm5bMywzXTtyZXR1cm5bNCx0LnNldE9wZW4oZmFsc2UsZmFsc2UpXTtjYXNlIDI6aS5zZW50KCk7aS5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMixuLl9zZXRPcGVuKGUscildfX0pKX0pKX07dmFyIGg9ZnVuY3Rpb24oZSxyKXt2YXIgdD1uLmdldChlKTtpZighdCl7dGhyb3cgbmV3IEVycm9yKFwiYW5pbWF0aW9uIG5vdCByZWdpc3RlcmVkXCIpfXZhciBpPXQocik7cmV0dXJuIGl9O3ZhciBnPWZ1bmN0aW9uKCl7cmV0dXJuIEUoKGZ1bmN0aW9uKG4pe3JldHVybiBuLl9pc09wZW59KSl9O3ZhciB3PWZ1bmN0aW9uKCl7cmV0dXJuIGUubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gbi5lbH0pKX07dmFyIEE9ZnVuY3Rpb24oKXtyZXR1cm4gZS5zb21lKChmdW5jdGlvbihuKXtyZXR1cm4gbi5pc0FuaW1hdGluZ30pKX07dmFyIEU9ZnVuY3Rpb24obil7dmFyIHI9ZS5maW5kKG4pO2lmKHIhPT11bmRlZmluZWQpe3JldHVybiByLmVsfXJldHVybiB1bmRlZmluZWR9O3ZhciBPPWZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlvbi1tZW51XCIpKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbXBvbmVudE9uUmVhZHkobixlKX0pKX0pKSl9O2woXCJyZXZlYWxcIixtZW51UmV2ZWFsQW5pbWF0aW9uKTtsKFwicHVzaFwiLG1lbnVQdXNoQW5pbWF0aW9uKTtsKFwib3ZlcmxheVwiLG1lbnVPdmVybGF5QW5pbWF0aW9uKTtpZih0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiKXtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW9uQmFja0J1dHRvblwiLChmdW5jdGlvbihuKXt2YXIgZT1nKCk7aWYoZSl7bi5kZXRhaWwucmVnaXN0ZXIoTUVOVV9CQUNLX0JVVFRPTl9QUklPUklUWSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5jbG9zZSgpfSkpfX0pKX1yZXR1cm57cmVnaXN0ZXJBbmltYXRpb246bCxnZXQ6YyxnZXRNZW51czpkLGdldE9wZW46Zixpc0VuYWJsZWQ6cyxzd2lwZUdlc3R1cmU6byxpc0FuaW1hdGluZzp2LGlzT3Blbjp1LGVuYWJsZTphLHRvZ2dsZTppLGNsb3NlOnQsb3BlbjpyLF9nZXRPcGVuU3luYzpnLF9jcmVhdGVBbmltYXRpb246aCxfcmVnaXN0ZXI6bSxfdW5yZWdpc3RlcjpfLF9zZXRPcGVuOmIsX3NldEFjdGl2ZU1lbnU6cH19O3ZhciBtZW51Q29udHJvbGxlcj1jcmVhdGVNZW51Q29udHJvbGxlcigpO2V4cG9ydHttZW51Q29udHJvbGxlciBhcyBtfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///90114\n')},92032:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ LIFECYCLE_WILL_ENTER),\n/* harmony export */   "a": () => (/* binding */ LIFECYCLE_DID_ENTER),\n/* harmony export */   "b": () => (/* binding */ LIFECYCLE_WILL_LEAVE),\n/* harmony export */   "c": () => (/* binding */ LIFECYCLE_DID_LEAVE),\n/* harmony export */   "d": () => (/* binding */ LIFECYCLE_WILL_UNLOAD),\n/* harmony export */   "e": () => (/* binding */ deepReady),\n/* harmony export */   "g": () => (/* binding */ getIonPageElement),\n/* harmony export */   "l": () => (/* binding */ lifecycle),\n/* harmony export */   "s": () => (/* binding */ setPageHidden),\n/* harmony export */   "t": () => (/* binding */ transition)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70655);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82896);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var LIFECYCLE_WILL_ENTER="ionViewWillEnter";var LIFECYCLE_DID_ENTER="ionViewDidEnter";var LIFECYCLE_WILL_LEAVE="ionViewWillLeave";var LIFECYCLE_DID_LEAVE="ionViewDidLeave";var LIFECYCLE_WILL_UNLOAD="ionViewWillUnload";var iosTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 48360))};var mdTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 92782))};var transition=function(e){return new Promise((function(n,i){(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.c)((function(){beforeTransition(e);runTransition(e).then((function(i){if(i.animation){i.animation.destroy()}afterTransition(e);n(i)}),(function(n){afterTransition(e);i(n)}))}))}))};var beforeTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;setZIndex(n,i,e.direction);if(e.showGoBack){n.classList.add("can-go-back")}else{n.classList.remove("can-go-back")}setPageHidden(n,false);n.style.setProperty("pointer-events","none");if(i){setPageHidden(i,false);i.style.setProperty("pointer-events","none")}};var runTransition=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,getAnimationBuilder(e)];case 1:n=r.sent();i=n&&_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.B.isBrowser?animation(n,e):noAnimation(e);return[2,i]}}))}))};var afterTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;n.classList.remove("ion-page-invisible");n.style.removeProperty("pointer-events");if(i!==undefined){i.classList.remove("ion-page-invisible");i.style.removeProperty("pointer-events")}};var getAnimationBuilder=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!e.leavingEl||!e.animated||e.duration===0){return[2,undefined]}if(e.animationBuilder){return[2,e.animationBuilder]}if(!(e.mode==="ios"))return[3,2];return[4,iosTransitionAnimation()];case 1:i=r.sent().iosTransitionAnimation;return[3,4];case 2:return[4,mdTransitionAnimation()];case 3:i=r.sent().mdTransitionAnimation;r.label=4;case 4:n=i;return[2,n]}}))}))};var animation=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,waitForReady(n,true)];case 1:t.sent();i=e(n.baseEl,n);fireWillEvents(n.enteringEl,n.leavingEl);return[4,playTransition(i,n)];case 2:r=t.sent();if(n.progressCallback){n.progressCallback(undefined)}if(r){fireDidEvents(n.enteringEl,n.leavingEl)}return[2,{hasCompleted:r,animation:i}]}}))}))};var noAnimation=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:n=e.enteringEl;i=e.leavingEl;return[4,waitForReady(e,false)];case 1:r.sent();fireWillEvents(n,i);fireDidEvents(n,i);return[2,{hasCompleted:true}]}}))}))};var waitForReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:i=e.deepWait!==undefined?e.deepWait:n;r=i?[deepReady(e.enteringEl),deepReady(e.leavingEl)]:[shallowReady(e.enteringEl),shallowReady(e.leavingEl)];return[4,Promise.all(r)];case 1:t.sent();return[4,notifyViewReady(e.viewIsReady,e.enteringEl)];case 2:t.sent();return[2]}}))}))};var notifyViewReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(!e)return[3,2];return[4,e(n)];case 1:i.sent();i.label=2;case 2:return[2]}}))}))};var playTransition=function(e,n){var i=n.progressCallback;var r=new Promise((function(n){e.onFinish((function(e){return n(e===1)}))}));if(i){e.progressStart(true);i(e)}else{e.play()}return r};var fireWillEvents=function(e,n){lifecycle(n,LIFECYCLE_WILL_LEAVE);lifecycle(e,LIFECYCLE_WILL_ENTER)};var fireDidEvents=function(e,n){lifecycle(e,LIFECYCLE_DID_ENTER);lifecycle(n,LIFECYCLE_DID_LEAVE)};var lifecycle=function(e,n){if(e){var i=new CustomEvent(n,{bubbles:false,cancelable:false});e.dispatchEvent(i)}};var shallowReady=function(e){if(e){return new Promise((function(n){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(e,n)}))}return Promise.resolve()};var deepReady=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:n=e;if(!n)return[3,6];if(!(n.componentOnReady!=null))return[3,2];return[4,n.componentOnReady()];case 1:i=t.sent();if(i!=null){return[2]}return[3,4];case 2:if(!(n.__registerHost!=null))return[3,4];r=new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.r)(e)}));return[4,r];case 3:t.sent();return[2];case 4:return[4,Promise.all(Array.from(n.children).map(deepReady))];case 5:t.sent();t.label=6;case 6:return[2]}}))}))};var setPageHidden=function(e,n){if(n){e.setAttribute("aria-hidden","true");e.classList.add("ion-page-hidden")}else{e.hidden=false;e.removeAttribute("aria-hidden");e.classList.remove("ion-page-hidden")}};var setZIndex=function(e,n,i){if(e!==undefined){e.style.zIndex=i==="back"?"99":"101"}if(n!==undefined){n.style.zIndex="100"}};var getIonPageElement=function(e){if(e.classList.contains("ion-page")){return e}var n=e.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");if(n){return n}return e};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIwMzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0EsR0FBZ0ksNENBQTRDLDBDQUEwQyw0Q0FBNEMsMENBQTBDLDhDQUE4QyxzQ0FBc0MsT0FBTywwRkFBc0MsRUFBRSxxQ0FBcUMsT0FBTywwRkFBcUMsRUFBRSwyQkFBMkIsa0NBQWtDLHFEQUFTLGFBQWEsb0JBQW9CLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLG1CQUFtQixLQUFLLGVBQWUsbUJBQW1CLEtBQUssR0FBRyxHQUFHLElBQUksaUNBQWlDLG1CQUFtQixrQkFBa0IsMkJBQTJCLGlCQUFpQiwrQkFBK0IsS0FBSyxrQ0FBa0MsdUJBQXVCLDZDQUE2QyxNQUFNLHVCQUF1QiwrQ0FBK0MsOEJBQThCLE9BQU8sMERBQVMsa0NBQWtDLFFBQVEsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLHdDQUF3QyxrQkFBa0IsS0FBSywyREFBZSwrQkFBK0IsYUFBYSxHQUFHLElBQUksZ0NBQWdDLG1CQUFtQixrQkFBa0IseUNBQXlDLHlDQUF5QyxrQkFBa0IseUNBQXlDLDJDQUEyQyxvQ0FBb0MsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0IscURBQXFELG9CQUFvQix1QkFBdUIsNkJBQTZCLGlDQUFpQyxtQ0FBbUMseUNBQXlDLFlBQVkseUNBQXlDLHdDQUF3QyxVQUFVLFdBQVcsYUFBYSxHQUFHLElBQUksNEJBQTRCLE9BQU8sMERBQVMsa0NBQWtDLFFBQVEsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLHNDQUFzQyxnQkFBZ0IsZ0JBQWdCLHlDQUF5Qyw4QkFBOEIsa0JBQWtCLHVCQUF1Qiw4QkFBOEIsTUFBTSx3Q0FBd0MsVUFBVSwyQkFBMkIsR0FBRyxHQUFHLElBQUksNEJBQTRCLE9BQU8sMERBQVMsa0NBQWtDLFFBQVEsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLHNCQUFzQixjQUFjLGdDQUFnQyxnQkFBZ0Isb0JBQW9CLG1CQUFtQixVQUFVLGtCQUFrQixHQUFHLEdBQUcsSUFBSSwrQkFBK0IsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0IsNkNBQTZDLDRHQUE0Ryx5QkFBeUIsZ0JBQWdCLHNEQUFzRCxnQkFBZ0IsV0FBVyxHQUFHLElBQUksa0NBQWtDLE9BQU8sMERBQVMsa0NBQWtDLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQix5QkFBeUIsZUFBZSxnQkFBZ0IsVUFBVSxrQkFBa0IsR0FBRyxJQUFJLGlDQUFpQyx5QkFBeUIsK0JBQStCLHdCQUF3QixnQkFBZ0IsR0FBRyxHQUFHLE1BQU0sc0JBQXNCLEtBQUssS0FBSyxTQUFTLFVBQVUsaUNBQWlDLGtDQUFrQyxtQ0FBbUMsZ0NBQWdDLGlDQUFpQyxrQ0FBa0MsNEJBQTRCLE1BQU0seUJBQXlCLCtCQUErQixFQUFFLHFCQUFxQiw2QkFBNkIsTUFBTSxnQ0FBZ0MsT0FBTyx1REFBZ0IsTUFBTSxHQUFHLDBCQUEwQiwwQkFBMEIsT0FBTywwREFBUyxrQ0FBa0MsVUFBVSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0IsV0FBVyxrQkFBa0IsMkNBQTJDLCtCQUErQixrQkFBa0IsWUFBWSxVQUFVLFlBQVksZ0RBQWdELDJCQUEyQixPQUFPLHVEQUFHLElBQUksR0FBRyxZQUFZLGdCQUFnQixVQUFVLG9FQUFvRSxnQkFBZ0IsVUFBVSxrQkFBa0IsR0FBRyxJQUFJLGdDQUFnQyxNQUFNLHFDQUFxQyxtQ0FBbUMsS0FBSyxlQUFlLGlDQUFpQyx3Q0FBd0MsOEJBQThCLGtCQUFrQixxQ0FBcUMsa0JBQWtCLHVCQUF1QixrQ0FBa0MscUNBQXFDLFNBQVMsaUZBQWlGLE1BQU0sU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LWU2YzJjODIyLmpzP2RhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2dlbmVyYXRvcn1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9pbXBvcnR7YyBhcyB3cml0ZVRhc2ssQiBhcyBCdWlsZH1mcm9tXCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7aW1wb3J0e2MgYXMgY29tcG9uZW50T25SZWFkeSxyIGFzIHJhZn1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjt2YXIgTElGRUNZQ0xFX1dJTExfRU5URVI9XCJpb25WaWV3V2lsbEVudGVyXCI7dmFyIExJRkVDWUNMRV9ESURfRU5URVI9XCJpb25WaWV3RGlkRW50ZXJcIjt2YXIgTElGRUNZQ0xFX1dJTExfTEVBVkU9XCJpb25WaWV3V2lsbExlYXZlXCI7dmFyIExJRkVDWUNMRV9ESURfTEVBVkU9XCJpb25WaWV3RGlkTGVhdmVcIjt2YXIgTElGRUNZQ0xFX1dJTExfVU5MT0FEPVwiaW9uVmlld1dpbGxVbmxvYWRcIjt2YXIgaW9zVHJhbnNpdGlvbkFuaW1hdGlvbj1mdW5jdGlvbigpe3JldHVybiBpbXBvcnQoXCIuL2lvcy50cmFuc2l0aW9uLThiNmE3NzZhLmpzXCIpfTt2YXIgbWRUcmFuc2l0aW9uQW5pbWF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGltcG9ydChcIi4vbWQudHJhbnNpdGlvbi1kYTg2NjExOS5qc1wiKX07dmFyIHRyYW5zaXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe3dyaXRlVGFzaygoZnVuY3Rpb24oKXtiZWZvcmVUcmFuc2l0aW9uKGUpO3J1blRyYW5zaXRpb24oZSkudGhlbigoZnVuY3Rpb24oaSl7aWYoaS5hbmltYXRpb24pe2kuYW5pbWF0aW9uLmRlc3Ryb3koKX1hZnRlclRyYW5zaXRpb24oZSk7bihpKX0pLChmdW5jdGlvbihuKXthZnRlclRyYW5zaXRpb24oZSk7aShuKX0pKX0pKX0pKX07dmFyIGJlZm9yZVRyYW5zaXRpb249ZnVuY3Rpb24oZSl7dmFyIG49ZS5lbnRlcmluZ0VsO3ZhciBpPWUubGVhdmluZ0VsO3NldFpJbmRleChuLGksZS5kaXJlY3Rpb24pO2lmKGUuc2hvd0dvQmFjayl7bi5jbGFzc0xpc3QuYWRkKFwiY2FuLWdvLWJhY2tcIil9ZWxzZXtuLmNsYXNzTGlzdC5yZW1vdmUoXCJjYW4tZ28tYmFja1wiKX1zZXRQYWdlSGlkZGVuKG4sZmFsc2UpO24uc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKTtpZihpKXtzZXRQYWdlSGlkZGVuKGksZmFsc2UpO2kuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKX19O3ZhciBydW5UcmFuc2l0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4saTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxnZXRBbmltYXRpb25CdWlsZGVyKGUpXTtjYXNlIDE6bj1yLnNlbnQoKTtpPW4mJkJ1aWxkLmlzQnJvd3Nlcj9hbmltYXRpb24obixlKTpub0FuaW1hdGlvbihlKTtyZXR1cm5bMixpXX19KSl9KSl9O3ZhciBhZnRlclRyYW5zaXRpb249ZnVuY3Rpb24oZSl7dmFyIG49ZS5lbnRlcmluZ0VsO3ZhciBpPWUubGVhdmluZ0VsO24uY2xhc3NMaXN0LnJlbW92ZShcImlvbi1wYWdlLWludmlzaWJsZVwiKTtuLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIik7aWYoaSE9PXVuZGVmaW5lZCl7aS5jbGFzc0xpc3QucmVtb3ZlKFwiaW9uLXBhZ2UtaW52aXNpYmxlXCIpO2kuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiKX19O3ZhciBnZXRBbmltYXRpb25CdWlsZGVyPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4saTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZighZS5sZWF2aW5nRWx8fCFlLmFuaW1hdGVkfHxlLmR1cmF0aW9uPT09MCl7cmV0dXJuWzIsdW5kZWZpbmVkXX1pZihlLmFuaW1hdGlvbkJ1aWxkZXIpe3JldHVyblsyLGUuYW5pbWF0aW9uQnVpbGRlcl19aWYoIShlLm1vZGU9PT1cImlvc1wiKSlyZXR1cm5bMywyXTtyZXR1cm5bNCxpb3NUcmFuc2l0aW9uQW5pbWF0aW9uKCldO2Nhc2UgMTppPXIuc2VudCgpLmlvc1RyYW5zaXRpb25BbmltYXRpb247cmV0dXJuWzMsNF07Y2FzZSAyOnJldHVybls0LG1kVHJhbnNpdGlvbkFuaW1hdGlvbigpXTtjYXNlIDM6aT1yLnNlbnQoKS5tZFRyYW5zaXRpb25BbmltYXRpb247ci5sYWJlbD00O2Nhc2UgNDpuPWk7cmV0dXJuWzIsbl19fSkpfSkpfTt2YXIgYW5pbWF0aW9uPWZ1bmN0aW9uKGUsbil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgaSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHdhaXRGb3JSZWFkeShuLHRydWUpXTtjYXNlIDE6dC5zZW50KCk7aT1lKG4uYmFzZUVsLG4pO2ZpcmVXaWxsRXZlbnRzKG4uZW50ZXJpbmdFbCxuLmxlYXZpbmdFbCk7cmV0dXJuWzQscGxheVRyYW5zaXRpb24oaSxuKV07Y2FzZSAyOnI9dC5zZW50KCk7aWYobi5wcm9ncmVzc0NhbGxiYWNrKXtuLnByb2dyZXNzQ2FsbGJhY2sodW5kZWZpbmVkKX1pZihyKXtmaXJlRGlkRXZlbnRzKG4uZW50ZXJpbmdFbCxuLmxlYXZpbmdFbCl9cmV0dXJuWzIse2hhc0NvbXBsZXRlZDpyLGFuaW1hdGlvbjppfV19fSkpfSkpfTt2YXIgbm9BbmltYXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOm49ZS5lbnRlcmluZ0VsO2k9ZS5sZWF2aW5nRWw7cmV0dXJuWzQsd2FpdEZvclJlYWR5KGUsZmFsc2UpXTtjYXNlIDE6ci5zZW50KCk7ZmlyZVdpbGxFdmVudHMobixpKTtmaXJlRGlkRXZlbnRzKG4saSk7cmV0dXJuWzIse2hhc0NvbXBsZXRlZDp0cnVlfV19fSkpfSkpfTt2YXIgd2FpdEZvclJlYWR5PWZ1bmN0aW9uKGUsbil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgaSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmk9ZS5kZWVwV2FpdCE9PXVuZGVmaW5lZD9lLmRlZXBXYWl0Om47cj1pP1tkZWVwUmVhZHkoZS5lbnRlcmluZ0VsKSxkZWVwUmVhZHkoZS5sZWF2aW5nRWwpXTpbc2hhbGxvd1JlYWR5KGUuZW50ZXJpbmdFbCksc2hhbGxvd1JlYWR5KGUubGVhdmluZ0VsKV07cmV0dXJuWzQsUHJvbWlzZS5hbGwocildO2Nhc2UgMTp0LnNlbnQoKTtyZXR1cm5bNCxub3RpZnlWaWV3UmVhZHkoZS52aWV3SXNSZWFkeSxlLmVudGVyaW5nRWwpXTtjYXNlIDI6dC5zZW50KCk7cmV0dXJuWzJdfX0pKX0pKX07dmFyIG5vdGlmeVZpZXdSZWFkeT1mdW5jdGlvbihlLG4pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6aWYoIWUpcmV0dXJuWzMsMl07cmV0dXJuWzQsZShuKV07Y2FzZSAxOmkuc2VudCgpO2kubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzJdfX0pKX0pKX07dmFyIHBsYXlUcmFuc2l0aW9uPWZ1bmN0aW9uKGUsbil7dmFyIGk9bi5wcm9ncmVzc0NhbGxiYWNrO3ZhciByPW5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtlLm9uRmluaXNoKChmdW5jdGlvbihlKXtyZXR1cm4gbihlPT09MSl9KSl9KSk7aWYoaSl7ZS5wcm9ncmVzc1N0YXJ0KHRydWUpO2koZSl9ZWxzZXtlLnBsYXkoKX1yZXR1cm4gcn07dmFyIGZpcmVXaWxsRXZlbnRzPWZ1bmN0aW9uKGUsbil7bGlmZWN5Y2xlKG4sTElGRUNZQ0xFX1dJTExfTEVBVkUpO2xpZmVjeWNsZShlLExJRkVDWUNMRV9XSUxMX0VOVEVSKX07dmFyIGZpcmVEaWRFdmVudHM9ZnVuY3Rpb24oZSxuKXtsaWZlY3ljbGUoZSxMSUZFQ1lDTEVfRElEX0VOVEVSKTtsaWZlY3ljbGUobixMSUZFQ1lDTEVfRElEX0xFQVZFKX07dmFyIGxpZmVjeWNsZT1mdW5jdGlvbihlLG4pe2lmKGUpe3ZhciBpPW5ldyBDdXN0b21FdmVudChuLHtidWJibGVzOmZhbHNlLGNhbmNlbGFibGU6ZmFsc2V9KTtlLmRpc3BhdGNoRXZlbnQoaSl9fTt2YXIgc2hhbGxvd1JlYWR5PWZ1bmN0aW9uKGUpe2lmKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obil7cmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoZSxuKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9O3ZhciBkZWVwUmVhZHk9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6bj1lO2lmKCFuKXJldHVyblszLDZdO2lmKCEobi5jb21wb25lbnRPblJlYWR5IT1udWxsKSlyZXR1cm5bMywyXTtyZXR1cm5bNCxuLmNvbXBvbmVudE9uUmVhZHkoKV07Y2FzZSAxOmk9dC5zZW50KCk7aWYoaSE9bnVsbCl7cmV0dXJuWzJdfXJldHVyblszLDRdO2Nhc2UgMjppZighKG4uX19yZWdpc3Rlckhvc3QhPW51bGwpKXJldHVyblszLDRdO3I9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiByYWYoZSl9KSk7cmV0dXJuWzQscl07Y2FzZSAzOnQuc2VudCgpO3JldHVyblsyXTtjYXNlIDQ6cmV0dXJuWzQsUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShuLmNoaWxkcmVuKS5tYXAoZGVlcFJlYWR5KSldO2Nhc2UgNTp0LnNlbnQoKTt0LmxhYmVsPTY7Y2FzZSA2OnJldHVyblsyXX19KSl9KSl9O3ZhciBzZXRQYWdlSGlkZGVuPWZ1bmN0aW9uKGUsbil7aWYobil7ZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKTtlLmNsYXNzTGlzdC5hZGQoXCJpb24tcGFnZS1oaWRkZW5cIil9ZWxzZXtlLmhpZGRlbj1mYWxzZTtlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO2UuY2xhc3NMaXN0LnJlbW92ZShcImlvbi1wYWdlLWhpZGRlblwiKX19O3ZhciBzZXRaSW5kZXg9ZnVuY3Rpb24oZSxuLGkpe2lmKGUhPT11bmRlZmluZWQpe2Uuc3R5bGUuekluZGV4PWk9PT1cImJhY2tcIj9cIjk5XCI6XCIxMDFcIn1pZihuIT09dW5kZWZpbmVkKXtuLnN0eWxlLnpJbmRleD1cIjEwMFwifX07dmFyIGdldElvblBhZ2VFbGVtZW50PWZ1bmN0aW9uKGUpe2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaW9uLXBhZ2VcIikpe3JldHVybiBlfXZhciBuPWUucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IC5pb24tcGFnZSwgOnNjb3BlID4gaW9uLW5hdiwgOnNjb3BlID4gaW9uLXRhYnNcIik7aWYobil7cmV0dXJuIG59cmV0dXJuIGV9O2V4cG9ydHtMSUZFQ1lDTEVfV0lMTF9FTlRFUiBhcyBMLExJRkVDWUNMRV9ESURfRU5URVIgYXMgYSxMSUZFQ1lDTEVfV0lMTF9MRUFWRSBhcyBiLExJRkVDWUNMRV9ESURfTEVBVkUgYXMgYyxMSUZFQ1lDTEVfV0lMTF9VTkxPQUQgYXMgZCxkZWVwUmVhZHkgYXMgZSxnZXRJb25QYWdlRWxlbWVudCBhcyBnLGxpZmVjeWNsZSBhcyBsLHNldFBhZ2VIaWRkZW4gYXMgcyx0cmFuc2l0aW9uIGFzIHR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92032\n')},53774:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createAnimation": () => (/* reexport safe */ _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   "iosTransitionAnimation": () => (/* reexport safe */ _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__.iosTransitionAnimation),\n/* harmony export */   "mdTransitionAnimation": () => (/* reexport safe */ _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__.mdTransitionAnimation),\n/* harmony export */   "getTimeGivenProgression": () => (/* reexport safe */ _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__.g),\n/* harmony export */   "createGesture": () => (/* reexport safe */ _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__.createGesture),\n/* harmony export */   "getPlatforms": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.g),\n/* harmony export */   "initialize": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.i),\n/* harmony export */   "isPlatform": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.a),\n/* harmony export */   "componentOnReady": () => (/* reexport safe */ _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.c),\n/* harmony export */   "IonicSafeString": () => (/* reexport safe */ _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__.I),\n/* harmony export */   "LIFECYCLE_DID_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.a),\n/* harmony export */   "LIFECYCLE_DID_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.c),\n/* harmony export */   "LIFECYCLE_WILL_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.L),\n/* harmony export */   "LIFECYCLE_WILL_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.b),\n/* harmony export */   "LIFECYCLE_WILL_UNLOAD": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.d),\n/* harmony export */   "menuController": () => (/* reexport safe */ _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__.m),\n/* harmony export */   "actionSheetController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.b),\n/* harmony export */   "alertController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.a),\n/* harmony export */   "loadingController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.l),\n/* harmony export */   "modalController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.m),\n/* harmony export */   "pickerController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.p),\n/* harmony export */   "popoverController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.c),\n/* harmony export */   "toastController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.t),\n/* harmony export */   "IonicSlides": () => (/* binding */ IonicSlides),\n/* harmony export */   "IonicSwiper": () => (/* binding */ IonicSwiper),\n/* harmony export */   "getMode": () => (/* binding */ getMode),\n/* harmony export */   "setupConfig": () => (/* binding */ setupConfig)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27434);\n/* harmony import */ var _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48360);\n/* harmony import */ var _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(92782);\n/* harmony import */ var _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93544);\n/* harmony import */ var _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23876);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(75001);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17504);\n/* harmony import */ var _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(48186);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(92032);\n/* harmony import */ var _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(90114);\n/* harmony import */ var _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(46250);\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4988);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(82896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar setupConfig=function(e){var i=window;var o=i.Ionic;if(o&&o.config&&o.config.constructor.name!=="Object"){return}i.Ionic=i.Ionic||{};i.Ionic.config=Object.assign(Object.assign({},i.Ionic.config),e);return i.Ionic.config};var getMode=function(){var e=window;var i=e&&e.Ionic&&e.Ionic.config;if(i){if(i.mode){return i.mode}else{return i.get("mode")}}return"md"};var setupSwiperInIonic=function(e,i){if(i===void 0){i=true}if(typeof window==="undefined"){return}var o=e.el;var t=o.closest(".ion-page");if(!t){if(i){var r=o.getRootNode();if(r.tagName==="DIV"){var a=new MutationObserver((function(i){var o=i[0];var t=o.oldValue===null;var s=r.classList.contains("ion-page");if(t&&s){a.disconnect();setupSwiperInIonic(e,false)}}));a.observe(r,{attributeFilter:["class"],attributeOldValue:true})}}return}var s=o.closest("ion-modal, ion-popover");if(s){var n=s.tagName==="ION-MODAL"?"ionModalWillPresent":"ionPopoverWillPresent";var l=function(){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.r)((function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(s,n,l)}))};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(s,n,l)}else{var c=new MutationObserver((function(e){var i;var r=e[0];var a=(i=r.oldValue)===null||i===void 0?void 0:i.includes("ion-page-invisible");var s=t.classList.contains("ion-page-invisible");if(!s&&s!==a){o.swiper.update()}}));c.observe(t,{attributeFilter:["class"],attributeOldValue:true})}var d=function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(window,"appload",d)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(window,"appload",d)};var IonicSwiper={name:"ionic",on:{afterInit:function(e){console.warn("[Deprecation Warning]: The IonicSwiper module has been deprecated in favor of the IonSlides module. This change was made to better support the Swiper 7 release. The IonicSwiper module will be removed in Ionic 7.0. See https://ionicframework.com/docs/api/slides#migration for revised migration steps.");setupSwiperInIonic(e)}}};var IonicSlides=function(e){var i=e.swiper,o=e.extendParams;var t={effect:undefined,direction:"horizontal",initialSlide:0,loop:false,parallax:false,slidesPerView:1,spaceBetween:0,speed:300,slidesPerColumn:1,slidesPerColumnFill:"column",slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0,touchEventsTarget:"container",autoplay:false,freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:false,freeModeMinimumVelocity:.02,autoHeight:false,setWrapperSize:false,zoom:{maxRatio:3,minRatio:1,toggle:false},touchRatio:1,touchAngle:45,simulateTouch:true,touchStartPreventDefault:false,shortSwipes:true,longSwipes:true,longSwipesRatio:.5,longSwipesMs:300,followFinger:true,threshold:0,touchMoveStopPropagation:true,touchReleaseOnEdges:false,iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20,resistance:true,resistanceRatio:.85,watchSlidesProgress:false,watchSlidesVisibility:false,preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false,loopAdditionalSlides:0,noSwiping:true,runCallbacksOnInit:true,coverflowEffect:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},flipEffect:{slideShadows:true,limitRotation:true},cubeEffect:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:.94},fadeEffect:{crossFade:false},a11y:{prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide"}};if(i.pagination){t.pagination={type:"bullets",clickable:false,hideOnClick:false}}if(i.scrollbar){t.scrollbar={hide:true}}o(t)};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3NzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUMybEMsNEJBQTRCLGFBQWEsY0FBYyxzREFBc0QsT0FBTyxvQkFBb0IsNkNBQTZDLG9CQUFvQix1QkFBdUIsdUJBQXVCLGFBQWEsaUNBQWlDLE1BQU0sV0FBVyxjQUFjLEtBQUssc0JBQXNCLFlBQVkscUNBQXFDLGVBQWUsT0FBTyxnQ0FBZ0MsT0FBTyxXQUFXLDZCQUE2QixPQUFPLE1BQU0sc0JBQXNCLHNCQUFzQix3Q0FBd0MsV0FBVyx3QkFBd0IsdUNBQXVDLFNBQVMsZUFBZSw2QkFBNkIsR0FBRyxhQUFhLGlEQUFpRCxHQUFHLE9BQU8sMENBQTBDLE1BQU0sNEVBQTRFLGlCQUFpQix1REFBRyxhQUFhLGtCQUFrQix1REFBbUIsUUFBUSxJQUFJLHVEQUFnQixRQUFRLEtBQUssd0NBQXdDLE1BQU0sV0FBVyxnRkFBZ0YsaURBQWlELGNBQWMsbUJBQW1CLEdBQUcsYUFBYSxpREFBaUQsRUFBRSxpQkFBaUIsa0JBQWtCLHVEQUFtQixzQkFBc0IsdURBQWdCLHNCQUFzQixpQkFBaUIsaUJBQWlCLHNCQUFzQiw0VEFBNFQseUJBQXlCLDRCQUE0QixnQ0FBZ0MsT0FBTyx5aEJBQXloQixtQ0FBbUMsa2hCQUFraEIsMkRBQTJELGFBQWEscUNBQXFDLGFBQWEsOERBQThELGFBQWEsZ0JBQWdCLE9BQU8sd0pBQXdKLGlCQUFpQixjQUFjLGtEQUFrRCxnQkFBZ0IsYUFBYSxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXguanM/NjI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuZXhwb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7ZXhwb3J0e2lvc1RyYW5zaXRpb25BbmltYXRpb259ZnJvbVwiLi9pb3MudHJhbnNpdGlvbi04YjZhNzc2YS5qc1wiO2V4cG9ydHttZFRyYW5zaXRpb25BbmltYXRpb259ZnJvbVwiLi9tZC50cmFuc2l0aW9uLWRhODY2MTE5LmpzXCI7ZXhwb3J0e2cgYXMgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb259ZnJvbVwiLi9jdWJpYy1iZXppZXItMTU0YTUzYTUuanNcIjtleHBvcnR7Y3JlYXRlR2VzdHVyZX1mcm9tXCIuL2luZGV4LTQxYmY0MWYyLmpzXCI7ZXhwb3J0e2cgYXMgZ2V0UGxhdGZvcm1zLGkgYXMgaW5pdGlhbGl6ZSxhIGFzIGlzUGxhdGZvcm19ZnJvbVwiLi9pb25pYy1nbG9iYWwtMGViZTMyMWMuanNcIjtpbXBvcnR7YSBhcyBhZGRFdmVudExpc3RlbmVyLHIgYXMgcmFmLGIgYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lcn1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjtleHBvcnR7YyBhcyBjb21wb25lbnRPblJlYWR5fWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO2V4cG9ydHtJIGFzIElvbmljU2FmZVN0cmluZ31mcm9tXCIuL2luZGV4LWM4NDFjOTMzLmpzXCI7ZXhwb3J0e2EgYXMgTElGRUNZQ0xFX0RJRF9FTlRFUixjIGFzIExJRkVDWUNMRV9ESURfTEVBVkUsTCBhcyBMSUZFQ1lDTEVfV0lMTF9FTlRFUixiIGFzIExJRkVDWUNMRV9XSUxMX0xFQVZFLGQgYXMgTElGRUNZQ0xFX1dJTExfVU5MT0FEfWZyb21cIi4vaW5kZXgtZTZjMmM4MjIuanNcIjtleHBvcnR7bSBhcyBtZW51Q29udHJvbGxlcn1mcm9tXCIuL2luZGV4LWNkYjFjZjk0LmpzXCI7ZXhwb3J0e2IgYXMgYWN0aW9uU2hlZXRDb250cm9sbGVyLGEgYXMgYWxlcnRDb250cm9sbGVyLGwgYXMgbG9hZGluZ0NvbnRyb2xsZXIsbSBhcyBtb2RhbENvbnRyb2xsZXIscCBhcyBwaWNrZXJDb250cm9sbGVyLGMgYXMgcG9wb3ZlckNvbnRyb2xsZXIsdCBhcyB0b2FzdENvbnRyb2xsZXJ9ZnJvbVwiLi9vdmVybGF5cy0zNmQzNDc1ZC5qc1wiO2ltcG9ydFwiLi9nZXN0dXJlLWNvbnRyb2xsZXItNjhjMDIzYTQuanNcIjtpbXBvcnRcIi4vaW5kZXgtYjNlZWNiMTQuanNcIjtpbXBvcnRcIi4vaGFyZHdhcmUtYmFjay1idXR0b24tYWNlNmE3MWIuanNcIjt2YXIgc2V0dXBDb25maWc9ZnVuY3Rpb24oZSl7dmFyIGk9d2luZG93O3ZhciBvPWkuSW9uaWM7aWYobyYmby5jb25maWcmJm8uY29uZmlnLmNvbnN0cnVjdG9yLm5hbWUhPT1cIk9iamVjdFwiKXtyZXR1cm59aS5Jb25pYz1pLklvbmljfHx7fTtpLklvbmljLmNvbmZpZz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saS5Jb25pYy5jb25maWcpLGUpO3JldHVybiBpLklvbmljLmNvbmZpZ307dmFyIGdldE1vZGU9ZnVuY3Rpb24oKXt2YXIgZT13aW5kb3c7dmFyIGk9ZSYmZS5Jb25pYyYmZS5Jb25pYy5jb25maWc7aWYoaSl7aWYoaS5tb2RlKXtyZXR1cm4gaS5tb2RlfWVsc2V7cmV0dXJuIGkuZ2V0KFwibW9kZVwiKX19cmV0dXJuXCJtZFwifTt2YXIgc2V0dXBTd2lwZXJJbklvbmljPWZ1bmN0aW9uKGUsaSl7aWYoaT09PXZvaWQgMCl7aT10cnVlfWlmKHR5cGVvZiB3aW5kb3c9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm59dmFyIG89ZS5lbDt2YXIgdD1vLmNsb3Nlc3QoXCIuaW9uLXBhZ2VcIik7aWYoIXQpe2lmKGkpe3ZhciByPW8uZ2V0Um9vdE5vZGUoKTtpZihyLnRhZ05hbWU9PT1cIkRJVlwiKXt2YXIgYT1uZXcgTXV0YXRpb25PYnNlcnZlcigoZnVuY3Rpb24oaSl7dmFyIG89aVswXTt2YXIgdD1vLm9sZFZhbHVlPT09bnVsbDt2YXIgcz1yLmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1wYWdlXCIpO2lmKHQmJnMpe2EuZGlzY29ubmVjdCgpO3NldHVwU3dpcGVySW5Jb25pYyhlLGZhbHNlKX19KSk7YS5vYnNlcnZlKHIse2F0dHJpYnV0ZUZpbHRlcjpbXCJjbGFzc1wiXSxhdHRyaWJ1dGVPbGRWYWx1ZTp0cnVlfSl9fXJldHVybn12YXIgcz1vLmNsb3Nlc3QoXCJpb24tbW9kYWwsIGlvbi1wb3BvdmVyXCIpO2lmKHMpe3ZhciBuPXMudGFnTmFtZT09PVwiSU9OLU1PREFMXCI/XCJpb25Nb2RhbFdpbGxQcmVzZW50XCI6XCJpb25Qb3BvdmVyV2lsbFByZXNlbnRcIjt2YXIgbD1mdW5jdGlvbigpe3JhZigoZnVuY3Rpb24oKXtvLnN3aXBlci51cGRhdGUoKTtyZW1vdmVFdmVudExpc3RlbmVyKHMsbixsKX0pKX07YWRkRXZlbnRMaXN0ZW5lcihzLG4sbCl9ZWxzZXt2YXIgYz1uZXcgTXV0YXRpb25PYnNlcnZlcigoZnVuY3Rpb24oZSl7dmFyIGk7dmFyIHI9ZVswXTt2YXIgYT0oaT1yLm9sZFZhbHVlKT09PW51bGx8fGk9PT12b2lkIDA/dm9pZCAwOmkuaW5jbHVkZXMoXCJpb24tcGFnZS1pbnZpc2libGVcIik7dmFyIHM9dC5jbGFzc0xpc3QuY29udGFpbnMoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aWYoIXMmJnMhPT1hKXtvLnN3aXBlci51cGRhdGUoKX19KSk7Yy5vYnNlcnZlKHQse2F0dHJpYnV0ZUZpbHRlcjpbXCJjbGFzc1wiXSxhdHRyaWJ1dGVPbGRWYWx1ZTp0cnVlfSl9dmFyIGQ9ZnVuY3Rpb24oKXtvLnN3aXBlci51cGRhdGUoKTtyZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdyxcImFwcGxvYWRcIixkKX07YWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csXCJhcHBsb2FkXCIsZCl9O3ZhciBJb25pY1N3aXBlcj17bmFtZTpcImlvbmljXCIsb246e2FmdGVySW5pdDpmdW5jdGlvbihlKXtjb25zb2xlLndhcm4oXCJbRGVwcmVjYXRpb24gV2FybmluZ106IFRoZSBJb25pY1N3aXBlciBtb2R1bGUgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgSW9uU2xpZGVzIG1vZHVsZS4gVGhpcyBjaGFuZ2Ugd2FzIG1hZGUgdG8gYmV0dGVyIHN1cHBvcnQgdGhlIFN3aXBlciA3IHJlbGVhc2UuIFRoZSBJb25pY1N3aXBlciBtb2R1bGUgd2lsbCBiZSByZW1vdmVkIGluIElvbmljIDcuMC4gU2VlIGh0dHBzOi8vaW9uaWNmcmFtZXdvcmsuY29tL2RvY3MvYXBpL3NsaWRlcyNtaWdyYXRpb24gZm9yIHJldmlzZWQgbWlncmF0aW9uIHN0ZXBzLlwiKTtzZXR1cFN3aXBlckluSW9uaWMoZSl9fX07dmFyIElvbmljU2xpZGVzPWZ1bmN0aW9uKGUpe3ZhciBpPWUuc3dpcGVyLG89ZS5leHRlbmRQYXJhbXM7dmFyIHQ9e2VmZmVjdDp1bmRlZmluZWQsZGlyZWN0aW9uOlwiaG9yaXpvbnRhbFwiLGluaXRpYWxTbGlkZTowLGxvb3A6ZmFsc2UscGFyYWxsYXg6ZmFsc2Usc2xpZGVzUGVyVmlldzoxLHNwYWNlQmV0d2VlbjowLHNwZWVkOjMwMCxzbGlkZXNQZXJDb2x1bW46MSxzbGlkZXNQZXJDb2x1bW5GaWxsOlwiY29sdW1uXCIsc2xpZGVzUGVyR3JvdXA6MSxjZW50ZXJlZFNsaWRlczpmYWxzZSxzbGlkZXNPZmZzZXRCZWZvcmU6MCxzbGlkZXNPZmZzZXRBZnRlcjowLHRvdWNoRXZlbnRzVGFyZ2V0OlwiY29udGFpbmVyXCIsYXV0b3BsYXk6ZmFsc2UsZnJlZU1vZGU6ZmFsc2UsZnJlZU1vZGVNb21lbnR1bTp0cnVlLGZyZWVNb2RlTW9tZW50dW1SYXRpbzoxLGZyZWVNb2RlTW9tZW50dW1Cb3VuY2U6dHJ1ZSxmcmVlTW9kZU1vbWVudHVtQm91bmNlUmF0aW86MSxmcmVlTW9kZU1vbWVudHVtVmVsb2NpdHlSYXRpbzoxLGZyZWVNb2RlU3RpY2t5OmZhbHNlLGZyZWVNb2RlTWluaW11bVZlbG9jaXR5Oi4wMixhdXRvSGVpZ2h0OmZhbHNlLHNldFdyYXBwZXJTaXplOmZhbHNlLHpvb206e21heFJhdGlvOjMsbWluUmF0aW86MSx0b2dnbGU6ZmFsc2V9LHRvdWNoUmF0aW86MSx0b3VjaEFuZ2xlOjQ1LHNpbXVsYXRlVG91Y2g6dHJ1ZSx0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6ZmFsc2Usc2hvcnRTd2lwZXM6dHJ1ZSxsb25nU3dpcGVzOnRydWUsbG9uZ1N3aXBlc1JhdGlvOi41LGxvbmdTd2lwZXNNczozMDAsZm9sbG93RmluZ2VyOnRydWUsdGhyZXNob2xkOjAsdG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uOnRydWUsdG91Y2hSZWxlYXNlT25FZGdlczpmYWxzZSxpT1NFZGdlU3dpcGVEZXRlY3Rpb246ZmFsc2UsaU9TRWRnZVN3aXBlVGhyZXNob2xkOjIwLHJlc2lzdGFuY2U6dHJ1ZSxyZXNpc3RhbmNlUmF0aW86Ljg1LHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ZmFsc2Usd2F0Y2hTbGlkZXNWaXNpYmlsaXR5OmZhbHNlLHByZXZlbnRDbGlja3M6dHJ1ZSxwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246dHJ1ZSxzbGlkZVRvQ2xpY2tlZFNsaWRlOmZhbHNlLGxvb3BBZGRpdGlvbmFsU2xpZGVzOjAsbm9Td2lwaW5nOnRydWUscnVuQ2FsbGJhY2tzT25Jbml0OnRydWUsY292ZXJmbG93RWZmZWN0Ontyb3RhdGU6NTAsc3RyZXRjaDowLGRlcHRoOjEwMCxtb2RpZmllcjoxLHNsaWRlU2hhZG93czp0cnVlfSxmbGlwRWZmZWN0OntzbGlkZVNoYWRvd3M6dHJ1ZSxsaW1pdFJvdGF0aW9uOnRydWV9LGN1YmVFZmZlY3Q6e3NsaWRlU2hhZG93czp0cnVlLHNoYWRvdzp0cnVlLHNoYWRvd09mZnNldDoyMCxzaGFkb3dTY2FsZTouOTR9LGZhZGVFZmZlY3Q6e2Nyb3NzRmFkZTpmYWxzZX0sYTExeTp7cHJldlNsaWRlTWVzc2FnZTpcIlByZXZpb3VzIHNsaWRlXCIsbmV4dFNsaWRlTWVzc2FnZTpcIk5leHQgc2xpZGVcIixmaXJzdFNsaWRlTWVzc2FnZTpcIlRoaXMgaXMgdGhlIGZpcnN0IHNsaWRlXCIsbGFzdFNsaWRlTWVzc2FnZTpcIlRoaXMgaXMgdGhlIGxhc3Qgc2xpZGVcIn19O2lmKGkucGFnaW5hdGlvbil7dC5wYWdpbmF0aW9uPXt0eXBlOlwiYnVsbGV0c1wiLGNsaWNrYWJsZTpmYWxzZSxoaWRlT25DbGljazpmYWxzZX19aWYoaS5zY3JvbGxiYXIpe3Quc2Nyb2xsYmFyPXtoaWRlOnRydWV9fW8odCl9O2V4cG9ydHtJb25pY1NsaWRlcyxJb25pY1N3aXBlcixnZXRNb2RlLHNldHVwQ29uZmlnfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53774\n')},75001:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ isPlatform),\n/* harmony export */   "b": () => (/* binding */ getIonMode),\n/* harmony export */   "c": () => (/* binding */ config),\n/* harmony export */   "g": () => (/* binding */ getPlatforms),\n/* harmony export */   "i": () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar Config=function(){function e(){this.m=new Map}e.prototype.reset=function(e){this.m=new Map(Object.entries(e))};e.prototype.get=function(e,t){var n=this.m.get(e);return n!==undefined?n:t};e.prototype.getBoolean=function(e,t){if(t===void 0){t=false}var n=this.m.get(e);if(n===undefined){return t}if(typeof n==="string"){return n==="true"}return!!n};e.prototype.getNumber=function(e,t){var n=parseFloat(this.m.get(e));return isNaN(n)?t!==undefined?t:NaN:n};e.prototype.set=function(e,t){this.m.set(e,t)};return e}();var config=new Config;var configFromSession=function(e){try{var t=e.sessionStorage.getItem(IONIC_SESSION_KEY);return t!==null?JSON.parse(t):{}}catch(e){return{}}};var saveConfig=function(e,t){try{e.sessionStorage.setItem(IONIC_SESSION_KEY,JSON.stringify(t))}catch(e){return}};var configFromURL=function(e){var t={};e.location.search.slice(1).split("&").map((function(e){return e.split("=")})).map((function(e){var t=e[0],n=e[1];return[decodeURIComponent(t),decodeURIComponent(n)]})).filter((function(e){var t=e[0];return startsWith(t,IONIC_PREFIX)})).map((function(e){var t=e[0],n=e[1];return[t.slice(IONIC_PREFIX.length),n]})).forEach((function(e){var n=e[0],i=e[1];t[n]=i}));return t};var startsWith=function(e,t){return e.substr(0,t.length)===t};var IONIC_PREFIX="ionic:";var IONIC_SESSION_KEY="ionic-persist-config";var getPlatforms=function(e){return setupPlatforms(e)};var isPlatform=function(e,t){if(typeof e==="string"){t=e;e=undefined}return getPlatforms(e).includes(t)};var setupPlatforms=function(e){if(e===void 0){e=window}if(typeof e==="undefined"){return[]}e.Ionic=e.Ionic||{};var t=e.Ionic.platforms;if(t==null){t=e.Ionic.platforms=detectPlatforms(e);t.forEach((function(t){return e.document.documentElement.classList.add("plt-".concat(t))}))}return t};var detectPlatforms=function(e){var t=config.get("platform");return Object.keys(PLATFORMS_MAP).filter((function(n){var i=t&&t[n];return typeof i==="function"?i(e):PLATFORMS_MAP[n](e)}))};var isMobileWeb=function(e){return isMobile(e)&&!isHybrid(e)};var isIpad=function(e){if(testUserAgent(e,/iPad/i)){return true}if(testUserAgent(e,/Macintosh/i)&&isMobile(e)){return true}return false};var isIphone=function(e){return testUserAgent(e,/iPhone/i)};var isIOS=function(e){return testUserAgent(e,/iPhone|iPod/i)||isIpad(e)};var isAndroid=function(e){return testUserAgent(e,/android|sink/i)};var isAndroidTablet=function(e){return isAndroid(e)&&!testUserAgent(e,/mobile/i)};var isPhablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return i>390&&i<520&&(r>620&&r<800)};var isTablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return isIpad(e)||isAndroidTablet(e)||i>460&&i<820&&(r>780&&r<1400)};var isMobile=function(e){return matchMedia(e,"(any-pointer:coarse)")};var isDesktop=function(e){return!isMobile(e)};var isHybrid=function(e){return isCordova(e)||isCapacitorNative(e)};var isCordova=function(e){return!!(e["cordova"]||e["phonegap"]||e["PhoneGap"])};var isCapacitorNative=function(e){var t=e["Capacitor"];return!!(t&&t.isNative)};var isElectron=function(e){return testUserAgent(e,/electron/i)};var isPWA=function(e){return!!(e.matchMedia&&e.matchMedia("(display-mode: standalone)").matches||e.navigator.standalone)};var testUserAgent=function(e,t){return t.test(e.navigator.userAgent)};var matchMedia=function(e,t){return e.matchMedia&&e.matchMedia(t).matches};var PLATFORMS_MAP={ipad:isIpad,iphone:isIphone,ios:isIOS,android:isAndroid,phablet:isPhablet,tablet:isTablet,cordova:isCordova,capacitor:isCapacitorNative,electron:isElectron,pwa:isPWA,mobile:isMobile,mobileweb:isMobileWeb,desktop:isDesktop,hybrid:isHybrid};var defaultMode;var getIonMode=function(e){return e&&(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.g)(e)||defaultMode};var initialize=function(e){if(e===void 0){e={}}if(typeof window==="undefined"){return}var t=window.document;var n=window;var i=n.Ionic=n.Ionic||{};var r={};if(e._ael){r.ael=e._ael}if(e._rel){r.rel=e._rel}if(e._ce){r.ce=e._ce}(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.s)(r);var o=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},configFromSession(n)),{persistConfig:false}),i.config),configFromURL(n)),e);config.reset(o);if(config.getBoolean("persistConfig")){saveConfig(n,o)}setupPlatforms(n);i.config=config;i.mode=defaultMode=config.get("mode",t.documentElement.getAttribute("mode")||(isPlatform(n,"ios")?"ios":"md"));config.set("mode",defaultMode);t.documentElement.setAttribute("mode",defaultMode);t.documentElement.classList.add(defaultMode);if(config.getBoolean("_testing")){config.set("animated",false)}var a=function(e){return e.tagName&&e.tagName.startsWith("ION-")};var s=function(e){return["ios","md"].includes(e)};(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.a)((function(e){while(e){var t=e.mode||e.getAttribute("mode");if(t){if(s(t)){return t}else if(a(e)){console.warn(\'Invalid ionic mode: "\'+t+\'", expected: "ios" or "md"\')}}e=e.parentElement}return defaultMode}))};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUwMDEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ21GLHNCQUFzQixhQUFhLGVBQWUsOEJBQThCLG1DQUFtQyw4QkFBOEIsb0JBQW9CLDBCQUEwQixxQ0FBcUMsZUFBZSxRQUFRLG9CQUFvQixrQkFBa0IsU0FBUyx3QkFBd0Isa0JBQWtCLFdBQVcsb0NBQW9DLGdDQUFnQyx1Q0FBdUMsOEJBQThCLGlCQUFpQixTQUFTLEdBQUcsc0JBQXNCLGtDQUFrQyxJQUFJLGtEQUFrRCxpQ0FBaUMsU0FBUyxXQUFXLDZCQUE2QixJQUFJLDhEQUE4RCxTQUFTLFNBQVMsOEJBQThCLFNBQVMsdURBQXVELG9CQUFvQixvQkFBb0Isa0JBQWtCLG9EQUFvRCx1QkFBdUIsV0FBVyxrQ0FBa0Msb0JBQW9CLGtCQUFrQix1Q0FBdUMsd0JBQXdCLGtCQUFrQixPQUFPLEdBQUcsVUFBVSw2QkFBNkIsaUNBQWlDLDBCQUEwQiw2Q0FBNkMsNkJBQTZCLDBCQUEwQiw2QkFBNkIsd0JBQXdCLElBQUksWUFBWSxvQ0FBb0MsK0JBQStCLGVBQWUsU0FBUywyQkFBMkIsU0FBUyxvQkFBb0Isd0JBQXdCLFlBQVksdUNBQXVDLHVCQUF1QixrRUFBa0UsR0FBRyxVQUFVLGdDQUFnQyw2QkFBNkIsc0RBQXNELGNBQWMsc0RBQXNELElBQUksNEJBQTRCLGtDQUFrQyx1QkFBdUIsNkJBQTZCLFlBQVksK0NBQStDLFlBQVksY0FBYyx5QkFBeUIsbUNBQW1DLHNCQUFzQixtREFBbUQsMEJBQTBCLHlDQUF5QyxnQ0FBZ0Msa0RBQWtELDBCQUEwQixtQkFBbUIsb0JBQW9CLG9CQUFvQixvQkFBb0IscUNBQXFDLHlCQUF5QixtQkFBbUIsb0JBQW9CLG9CQUFvQixvQkFBb0IscUVBQXFFLHlCQUF5Qiw2Q0FBNkMsMEJBQTBCLG9CQUFvQix5QkFBeUIsMkNBQTJDLDBCQUEwQixzREFBc0Qsa0NBQWtDLHFCQUFxQix5QkFBeUIsMkJBQTJCLHFDQUFxQyxzQkFBc0Isb0dBQW9HLGdDQUFnQyxzQ0FBc0MsNkJBQTZCLDhDQUE4QyxtQkFBbUIsK09BQStPLGdCQUFnQiwyQkFBMkIsVUFBVSxxREFBTyxrQkFBa0IsMkJBQTJCLGVBQWUsS0FBSyxnQ0FBZ0MsT0FBTyxzQkFBc0IsYUFBYSwwQkFBMEIsU0FBUyxXQUFXLGFBQWEsV0FBVyxhQUFhLFVBQVUsV0FBVyxxREFBa0IsSUFBSSw4RUFBOEUsd0JBQXdCLG9CQUFvQixpQ0FBaUMsZ0JBQWdCLHVDQUF1QyxnQkFBZ0Isa0JBQWtCLGdCQUFnQiwrR0FBK0csK0JBQStCLG1EQUFtRCw2Q0FBNkMsa0NBQWtDLDZCQUE2QixrQkFBa0IsZ0RBQWdELGtCQUFrQixnQ0FBZ0MscURBQU8sY0FBYyxTQUFTLHFDQUFxQyxNQUFNLFNBQVMsU0FBUyxjQUFjLHNFQUFzRSxrQkFBa0IsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW9uaWMtZ2xvYmFsLTBlYmUzMjFjLmpzP2EzYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydHtzIGFzIHNldFBsYXRmb3JtSGVscGVycyxnIGFzIGdldE1vZGUsYSBhcyBzZXRNb2RlfWZyb21cIi4vaW5kZXgtYjNlZWNiMTQuanNcIjt2YXIgQ29uZmlnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMubT1uZXcgTWFwfWUucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGUpe3RoaXMubT1uZXcgTWFwKE9iamVjdC5lbnRyaWVzKGUpKX07ZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5tLmdldChlKTtyZXR1cm4gbiE9PXVuZGVmaW5lZD9uOnR9O2UucHJvdG90eXBlLmdldEJvb2xlYW49ZnVuY3Rpb24oZSx0KXtpZih0PT09dm9pZCAwKXt0PWZhbHNlfXZhciBuPXRoaXMubS5nZXQoZSk7aWYobj09PXVuZGVmaW5lZCl7cmV0dXJuIHR9aWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtyZXR1cm4gbj09PVwidHJ1ZVwifXJldHVybiEhbn07ZS5wcm90b3R5cGUuZ2V0TnVtYmVyPWZ1bmN0aW9uKGUsdCl7dmFyIG49cGFyc2VGbG9hdCh0aGlzLm0uZ2V0KGUpKTtyZXR1cm4gaXNOYU4obik/dCE9PXVuZGVmaW5lZD90Ok5hTjpufTtlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSx0KXt0aGlzLm0uc2V0KGUsdCl9O3JldHVybiBlfSgpO3ZhciBjb25maWc9bmV3IENvbmZpZzt2YXIgY29uZmlnRnJvbVNlc3Npb249ZnVuY3Rpb24oZSl7dHJ5e3ZhciB0PWUuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShJT05JQ19TRVNTSU9OX0tFWSk7cmV0dXJuIHQhPT1udWxsP0pTT04ucGFyc2UodCk6e319Y2F0Y2goZSl7cmV0dXJue319fTt2YXIgc2F2ZUNvbmZpZz1mdW5jdGlvbihlLHQpe3RyeXtlLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oSU9OSUNfU0VTU0lPTl9LRVksSlNPTi5zdHJpbmdpZnkodCkpfWNhdGNoKGUpe3JldHVybn19O3ZhciBjb25maWdGcm9tVVJMPWZ1bmN0aW9uKGUpe3ZhciB0PXt9O2UubG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpLnNwbGl0KFwiJlwiKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGl0KFwiPVwiKX0pKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVybltkZWNvZGVVUklDb21wb25lbnQodCksZGVjb2RlVVJJQ29tcG9uZW50KG4pXX0pKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF07cmV0dXJuIHN0YXJ0c1dpdGgodCxJT05JQ19QUkVGSVgpfSkpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZVswXSxuPWVbMV07cmV0dXJuW3Quc2xpY2UoSU9OSUNfUFJFRklYLmxlbmd0aCksbl19KSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZVswXSxpPWVbMV07dFtuXT1pfSkpO3JldHVybiB0fTt2YXIgc3RhcnRzV2l0aD1mdW5jdGlvbihlLHQpe3JldHVybiBlLnN1YnN0cigwLHQubGVuZ3RoKT09PXR9O3ZhciBJT05JQ19QUkVGSVg9XCJpb25pYzpcIjt2YXIgSU9OSUNfU0VTU0lPTl9LRVk9XCJpb25pYy1wZXJzaXN0LWNvbmZpZ1wiO3ZhciBnZXRQbGF0Zm9ybXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHNldHVwUGxhdGZvcm1zKGUpfTt2YXIgaXNQbGF0Zm9ybT1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7dD1lO2U9dW5kZWZpbmVkfXJldHVybiBnZXRQbGF0Zm9ybXMoZSkuaW5jbHVkZXModCl9O3ZhciBzZXR1cFBsYXRmb3Jtcz1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXdpbmRvd31pZih0eXBlb2YgZT09PVwidW5kZWZpbmVkXCIpe3JldHVybltdfWUuSW9uaWM9ZS5Jb25pY3x8e307dmFyIHQ9ZS5Jb25pYy5wbGF0Zm9ybXM7aWYodD09bnVsbCl7dD1lLklvbmljLnBsYXRmb3Jtcz1kZXRlY3RQbGF0Zm9ybXMoZSk7dC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBsdC1cIi5jb25jYXQodCkpfSkpfXJldHVybiB0fTt2YXIgZGV0ZWN0UGxhdGZvcm1zPWZ1bmN0aW9uKGUpe3ZhciB0PWNvbmZpZy5nZXQoXCJwbGF0Zm9ybVwiKTtyZXR1cm4gT2JqZWN0LmtleXMoUExBVEZPUk1TX01BUCkuZmlsdGVyKChmdW5jdGlvbihuKXt2YXIgaT10JiZ0W25dO3JldHVybiB0eXBlb2YgaT09PVwiZnVuY3Rpb25cIj9pKGUpOlBMQVRGT1JNU19NQVBbbl0oZSl9KSl9O3ZhciBpc01vYmlsZVdlYj1mdW5jdGlvbihlKXtyZXR1cm4gaXNNb2JpbGUoZSkmJiFpc0h5YnJpZChlKX07dmFyIGlzSXBhZD1mdW5jdGlvbihlKXtpZih0ZXN0VXNlckFnZW50KGUsL2lQYWQvaSkpe3JldHVybiB0cnVlfWlmKHRlc3RVc2VyQWdlbnQoZSwvTWFjaW50b3NoL2kpJiZpc01vYmlsZShlKSl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt2YXIgaXNJcGhvbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvaVBob25lL2kpfTt2YXIgaXNJT1M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvaVBob25lfGlQb2QvaSl8fGlzSXBhZChlKX07dmFyIGlzQW5kcm9pZD1mdW5jdGlvbihlKXtyZXR1cm4gdGVzdFVzZXJBZ2VudChlLC9hbmRyb2lkfHNpbmsvaSl9O3ZhciBpc0FuZHJvaWRUYWJsZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGlzQW5kcm9pZChlKSYmIXRlc3RVc2VyQWdlbnQoZSwvbW9iaWxlL2kpfTt2YXIgaXNQaGFibGV0PWZ1bmN0aW9uKGUpe3ZhciB0PWUuaW5uZXJXaWR0aDt2YXIgbj1lLmlubmVySGVpZ2h0O3ZhciBpPU1hdGgubWluKHQsbik7dmFyIHI9TWF0aC5tYXgodCxuKTtyZXR1cm4gaT4zOTAmJmk8NTIwJiYocj42MjAmJnI8ODAwKX07dmFyIGlzVGFibGV0PWZ1bmN0aW9uKGUpe3ZhciB0PWUuaW5uZXJXaWR0aDt2YXIgbj1lLmlubmVySGVpZ2h0O3ZhciBpPU1hdGgubWluKHQsbik7dmFyIHI9TWF0aC5tYXgodCxuKTtyZXR1cm4gaXNJcGFkKGUpfHxpc0FuZHJvaWRUYWJsZXQoZSl8fGk+NDYwJiZpPDgyMCYmKHI+NzgwJiZyPDE0MDApfTt2YXIgaXNNb2JpbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG1hdGNoTWVkaWEoZSxcIihhbnktcG9pbnRlcjpjb2Fyc2UpXCIpfTt2YXIgaXNEZXNrdG9wPWZ1bmN0aW9uKGUpe3JldHVybiFpc01vYmlsZShlKX07dmFyIGlzSHlicmlkPWZ1bmN0aW9uKGUpe3JldHVybiBpc0NvcmRvdmEoZSl8fGlzQ2FwYWNpdG9yTmF0aXZlKGUpfTt2YXIgaXNDb3Jkb3ZhPWZ1bmN0aW9uKGUpe3JldHVybiEhKGVbXCJjb3Jkb3ZhXCJdfHxlW1wicGhvbmVnYXBcIl18fGVbXCJQaG9uZUdhcFwiXSl9O3ZhciBpc0NhcGFjaXRvck5hdGl2ZT1mdW5jdGlvbihlKXt2YXIgdD1lW1wiQ2FwYWNpdG9yXCJdO3JldHVybiEhKHQmJnQuaXNOYXRpdmUpfTt2YXIgaXNFbGVjdHJvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGVzdFVzZXJBZ2VudChlLC9lbGVjdHJvbi9pKX07dmFyIGlzUFdBPWZ1bmN0aW9uKGUpe3JldHVybiEhKGUubWF0Y2hNZWRpYSYmZS5tYXRjaE1lZGlhKFwiKGRpc3BsYXktbW9kZTogc3RhbmRhbG9uZSlcIikubWF0Y2hlc3x8ZS5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSl9O3ZhciB0ZXN0VXNlckFnZW50PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQudGVzdChlLm5hdmlnYXRvci51c2VyQWdlbnQpfTt2YXIgbWF0Y2hNZWRpYT1mdW5jdGlvbihlLHQpe3JldHVybiBlLm1hdGNoTWVkaWEmJmUubWF0Y2hNZWRpYSh0KS5tYXRjaGVzfTt2YXIgUExBVEZPUk1TX01BUD17aXBhZDppc0lwYWQsaXBob25lOmlzSXBob25lLGlvczppc0lPUyxhbmRyb2lkOmlzQW5kcm9pZCxwaGFibGV0OmlzUGhhYmxldCx0YWJsZXQ6aXNUYWJsZXQsY29yZG92YTppc0NvcmRvdmEsY2FwYWNpdG9yOmlzQ2FwYWNpdG9yTmF0aXZlLGVsZWN0cm9uOmlzRWxlY3Ryb24scHdhOmlzUFdBLG1vYmlsZTppc01vYmlsZSxtb2JpbGV3ZWI6aXNNb2JpbGVXZWIsZGVza3RvcDppc0Rlc2t0b3AsaHlicmlkOmlzSHlicmlkfTt2YXIgZGVmYXVsdE1vZGU7dmFyIGdldElvbk1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmdldE1vZGUoZSl8fGRlZmF1bHRNb2RlfTt2YXIgaW5pdGlhbGl6ZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXt9fWlmKHR5cGVvZiB3aW5kb3c9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm59dmFyIHQ9d2luZG93LmRvY3VtZW50O3ZhciBuPXdpbmRvdzt2YXIgaT1uLklvbmljPW4uSW9uaWN8fHt9O3ZhciByPXt9O2lmKGUuX2FlbCl7ci5hZWw9ZS5fYWVsfWlmKGUuX3JlbCl7ci5yZWw9ZS5fcmVsfWlmKGUuX2NlKXtyLmNlPWUuX2NlfXNldFBsYXRmb3JtSGVscGVycyhyKTt2YXIgbz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sY29uZmlnRnJvbVNlc3Npb24obikpLHtwZXJzaXN0Q29uZmlnOmZhbHNlfSksaS5jb25maWcpLGNvbmZpZ0Zyb21VUkwobikpLGUpO2NvbmZpZy5yZXNldChvKTtpZihjb25maWcuZ2V0Qm9vbGVhbihcInBlcnNpc3RDb25maWdcIikpe3NhdmVDb25maWcobixvKX1zZXR1cFBsYXRmb3JtcyhuKTtpLmNvbmZpZz1jb25maWc7aS5tb2RlPWRlZmF1bHRNb2RlPWNvbmZpZy5nZXQoXCJtb2RlXCIsdC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibW9kZVwiKXx8KGlzUGxhdGZvcm0obixcImlvc1wiKT9cImlvc1wiOlwibWRcIikpO2NvbmZpZy5zZXQoXCJtb2RlXCIsZGVmYXVsdE1vZGUpO3QuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1vZGVcIixkZWZhdWx0TW9kZSk7dC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkZWZhdWx0TW9kZSk7aWYoY29uZmlnLmdldEJvb2xlYW4oXCJfdGVzdGluZ1wiKSl7Y29uZmlnLnNldChcImFuaW1hdGVkXCIsZmFsc2UpfXZhciBhPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZ05hbWUmJmUudGFnTmFtZS5zdGFydHNXaXRoKFwiSU9OLVwiKX07dmFyIHM9ZnVuY3Rpb24oZSl7cmV0dXJuW1wiaW9zXCIsXCJtZFwiXS5pbmNsdWRlcyhlKX07c2V0TW9kZSgoZnVuY3Rpb24oZSl7d2hpbGUoZSl7dmFyIHQ9ZS5tb2RlfHxlLmdldEF0dHJpYnV0ZShcIm1vZGVcIik7aWYodCl7aWYocyh0KSl7cmV0dXJuIHR9ZWxzZSBpZihhKGUpKXtjb25zb2xlLndhcm4oJ0ludmFsaWQgaW9uaWMgbW9kZTogXCInK3QrJ1wiLCBleHBlY3RlZDogXCJpb3NcIiBvciBcIm1kXCInKX19ZT1lLnBhcmVudEVsZW1lbnR9cmV0dXJuIGRlZmF1bHRNb2RlfSkpfTtleHBvcnR7aXNQbGF0Zm9ybSBhcyBhLGdldElvbk1vZGUgYXMgYixjb25maWcgYXMgYyxnZXRQbGF0Zm9ybXMgYXMgZyxpbml0aWFsaXplIGFzIGl9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75001\n')},48360:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "iosTransitionAnimation": () => (/* binding */ iosTransitionAnimation),\n/* harmony export */   "shadow": () => (/* binding */ shadow)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar DURATION=540;var getClonedElement=function(t){return document.querySelector("".concat(t,".ion-cloned-element"))};var shadow=function(t){return t.shadowRoot||t};var getLargeTitle=function(t){var e=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var a="ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large";if(e!=null){var o=e.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");return o!=null?o.querySelector(a):null}return t.querySelector(a)};var getBackButton=function(t,e){var a=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var o=[];if(a!=null){var r=a.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");if(r!=null){o=r.querySelectorAll("ion-buttons")}}else{o=t.querySelectorAll("ion-buttons")}for(var n=0,i=o;n<i.length;n++){var l=i[n];var c=l.closest("ion-header");var s=c&&!c.classList.contains("header-collapse-condense-inactive");var f=l.querySelector("ion-back-button");var d=l.classList.contains("buttons-collapse");var m=l.slot==="start"||l.slot==="";if(f!==null&&m&&(d&&s&&e||!d)){return f}}return null};var createLargeTitleTransition=function(t,e,a,o,r){var n=getBackButton(o,a);var i=getLargeTitle(r);var l=getLargeTitle(o);var c=getBackButton(r,a);var s=n!==null&&i!==null&&!a;var f=l!==null&&c!==null&&a;if(s){var d=i.getBoundingClientRect();var m=n.getBoundingClientRect();animateLargeTitle(t,e,a,i,d,m);animateBackButton(t,e,a,n,d,m)}else if(f){var v=l.getBoundingClientRect();var p=c.getBoundingClientRect();animateLargeTitle(t,e,a,l,v,p);animateBackButton(t,e,a,c,v,p)}return{forward:s,backward:f}};var animateBackButton=function(t,e,a,o,r,n){var i=e?"calc(100% - ".concat(n.right+4,"px)"):"".concat(n.left-4,"px");var l=e?"7px":"-7px";var c=e?"-4px":"4px";var s=e?"-4px":"4px";var f=e?"right":"left";var d=e?"left":"right";var m=[{offset:0,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")},{offset:1,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")}];var v=[{offset:0,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")}];var p=a?v:m;var y=[{offset:0,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")}];var u=[{offset:0,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.2,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")}];var b=a?u:y;var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var S=getClonedElement("ion-back-button");var T=shadow(S).querySelector(".button-text");var h=shadow(S).querySelector("ion-icon");S.text=o.text;S.mode=o.mode;S.icon=o.icon;S.color=o.color;S.disabled=o.disabled;S.style.setProperty("display","block");S.style.setProperty("position","fixed");A.addElement(h);g.addElement(T);g.beforeStyles({"transform-origin":"".concat(f," center")}).beforeAddWrite((function(){o.style.setProperty("display","none");S.style.setProperty(f,i)})).afterAddWrite((function(){o.style.setProperty("display","");S.style.setProperty("display","none");S.style.removeProperty(f)})).keyframes(p);A.beforeStyles({"transform-origin":"".concat(d," center")}).keyframes(b);t.addAnimation([g,A])};var animateLargeTitle=function(t,e,a,o,r,n){var i;var l=e?"calc(100% - ".concat(r.right,"px)"):"".concat(r.left,"px");var c=e?"-18px":"18px";var s=e?"right":"left";var f=[{offset:0,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.49)")},{offset:.1,opacity:0},{offset:1,opacity:1,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")}];var d=[{offset:0,opacity:.99,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.5)")}];var m=a?f:d;var v=getClonedElement("ion-title");var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();v.innerText=o.innerText;v.size=o.size;v.color=o.color;p.addElement(v);p.beforeStyles((i={"transform-origin":"".concat(s," center"),height:"46px",display:"",position:"relative"},i[s]=l,i)).beforeAddWrite((function(){o.style.setProperty("display","none")})).afterAddWrite((function(){o.style.setProperty("display","");v.style.setProperty("display","none")})).keyframes(m);t.addAnimation(p)};var iosTransitionAnimation=function(t,e){try{var a="cubic-bezier(0.32,0.72,0,1)";var o="opacity";var r="transform";var n="0%";var i=.8;var l=t.ownerDocument.dir==="rtl";var c=l?"-99.5%":"99.5%";var s=l?"33%":"-33%";var f=e.enteringEl;var d=e.leavingEl;var m=e.direction==="back";var v=f.querySelector(":scope > ion-content");var p=f.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");var y=f.querySelectorAll(":scope > ion-header > ion-toolbar");var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();u.addElement(f).duration(e.duration||DURATION).easing(e.easing||a).fill("both").beforeRemoveClass("ion-page-invisible");if(d&&t){var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();g.addElement(t);u.addAnimation(g)}if(!v&&y.length===0&&p.length===0){b.addElement(f.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{b.addElement(v);b.addElement(p)}u.addAnimation(b);if(m){b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,i,1)}else{b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"))}if(v){var A=shadow(v).querySelector(".transition-effect");if(A){var S=A.querySelector(".transition-cover");var T=A.querySelector(".transition-shadow");var h=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var x=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var E=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();h.addElement(A).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});x.addElement(S).beforeClearStyles([o]).fromTo(o,0,.1);E.addElement(T).beforeClearStyles([o]).fromTo(o,.03,.7);h.addAnimation([x,E]);b.addAnimation([h])}}var q=f.querySelector("ion-header.header-collapse-condense");var X=createLargeTitleTransition(u,l,m,f,d),C=X.forward,k=X.backward;y.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);u.addAnimation(e);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var r=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var i=Array.from(t.querySelectorAll("ion-buttons,[menuToggle]"));var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v;if(m){v=i.filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}))}else{v=i.filter((function(t){return!t.classList.contains("buttons-collapse")}))}r.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();p.addElement(t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"));var y=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();y.addElement(shadow(t).querySelector(".toolbar-background"));var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var g=t.querySelector("ion-back-button");if(g){b.addElement(g)}e.addAnimation([a,r,p,y,b]);r.fromTo(o,.01,1);p.fromTo(o,.01,1);if(m){if(!d){a.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")"));b.fromTo(o,.01,1)}else{if(!q){a.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"));y.beforeClearStyles([o,"transform"]);var A=f===null||f===void 0?void 0:f.translucent;if(!A){y.fromTo(o,.01,"var(--opacity)")}else{y.fromTo("transform",l?"translateX(-100%)":"translateX(100%)","translateX(0px)")}if(!C){b.fromTo(o,.01,1)}if(g&&!C){var S=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();S.addElement(shadow(g).querySelector(".button-text")).fromTo("transform",l?"translateX(-100px)":"translateX(100px)","translateX(0px)");e.addAnimation(S)}}}));if(d){var w=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var B=d.querySelector(":scope > ion-content");var L=d.querySelectorAll(":scope > ion-header > ion-toolbar");var P=d.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");if(!B&&L.length===0&&P.length===0){w.addElement(d.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{w.addElement(B);w.addElement(P)}u.addAnimation(w);if(m){w.beforeClearStyles([o]).fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");var R=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(d);u.afterAddWrite((function(){if(u.getDirection()==="normal"){R.style.setProperty("display","none")}}))}else{w.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,1,i)}if(B){var I=shadow(B).querySelector(".transition-effect");if(I){var N=I.querySelector(".transition-cover");var W=I.querySelector(".transition-shadow");var j=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var D=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var O=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();j.addElement(I).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});D.addElement(N).beforeClearStyles([o]).fromTo(o,.1,0);O.addElement(W).beforeClearStyles([o]).fromTo(o,.7,.03);j.addAnimation([D,O]);w.addAnimation([j])}}L.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var c=t.querySelectorAll("ion-buttons,[menuToggle]");var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v=Array.from(c).filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}));i.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var y=t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])");if(y.length>0){p.addElement(y)}var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();b.addElement(shadow(t).querySelector(".toolbar-background"));var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=t.querySelector("ion-back-button");if(A){g.addElement(A)}e.addAnimation([a,i,p,g,b]);u.addAnimation(e);g.fromTo(o,.99,0);i.fromTo(o,.99,0);p.fromTo(o,.99,0);if(m){if(!d){a.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)").fromTo(o,.99,0)}p.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");b.beforeClearStyles([o,"transform"]);var S=f===null||f===void 0?void 0:f.translucent;if(!S){b.fromTo(o,"var(--opacity)",0)}else{b.fromTo("transform","translateX(0px)",l?"translateX(-100%)":"translateX(100%)")}if(A&&!k){var T=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();T.addElement(shadow(A).querySelector(".button-text")).fromTo("transform","translateX(".concat(n,")"),"translateX(".concat((l?-124:124)+"px",")"));e.addAnimation(T)}}else{if(!d){a.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,.99,0).afterClearStyles([r,o])}p.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).afterClearStyles([r,o]);g.afterClearStyles([o]);a.afterClearStyles([o]);i.afterClearStyles([o])}}))}return u}catch(t){throw t}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixPQUFPLGtCQUFrQixVQUFVLE1BQU0seURBQWUsR0FBRyx1SUFBdUksb0JBQW9CLEdBQUcsTUFBTSxNQUFNLHlEQUFlLEdBQUcsOENBQThDLDhEQUE4RCw4RkFBOEYsbUNBQW1DLHlGQUF5RixLQUFLLGdCQUFnQixnQkFBZ0Isa0JBQWtCLE1BQU0sa0hBQWtILE1BQU0scURBQWlCLElBQUksNEJBQTRCLGdDQUFnQyx1Q0FBdUMsR0FBRyxLQUFLLDRGQUE0RixNQUFNLG9EQUFvRCxNQUFNLDJDQUEyQyw0Q0FBNEMsTUFBTSx5REFBZSxHQUFHLE1BQU0seURBQWUsR0FBRyxNQUFNLHlEQUFlLEdBQUcsOEJBQThCLDRCQUE0QixlQUFlLHNCQUFzQixFQUFFLHNEQUFzRCx3REFBd0Qsc0JBQXNCLHFCQUFxQix1QkFBdUIsTUFBTSx5REFBZSxHQUFHLGdCQUFnQixNQUFNLHlEQUFlLEdBQUcsMkNBQTJDLE1BQU0seURBQWUsR0FBRyxxREFBcUQsOEJBQThCLG1FQUFtRSx3Q0FBd0MsK0NBQStDLGlCQUFpQixHQUFHLGdCQUFnQixNQUFNLHlEQUFlLEdBQUcseUZBQXlGLGVBQWUsZ0JBQWdCLE1BQU0seURBQWUsR0FBRyw2REFBNkQsTUFBTSx5REFBZSxHQUFHLHlDQUF5QyxNQUFNLGdCQUFnQiw0QkFBNEIsa0JBQWtCLGtCQUFrQixrQkFBa0Isa0JBQWtCLE1BQU0sT0FBTywyR0FBMkcsMkZBQTJGLHFDQUFxQyxnREFBZ0QsT0FBTywrQkFBK0IsS0FBSyxpRkFBaUYsVUFBVSxNQUFNLHlEQUFlLEdBQUcsa0pBQWtKLG1CQUFtQixLQUFLLE9BQU8sc0hBQXNILHNHQUFzRyx3QkFBd0Isd0JBQXdCLHlCQUF5QixHQUFHLFNBQVMsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2lvcy50cmFuc2l0aW9uLThiNmE3NzZhLmpzPzNiOWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydHtjIGFzIGNyZWF0ZUFuaW1hdGlvbn1mcm9tXCIuL2FuaW1hdGlvbi0xOWRiZjliZi5qc1wiO2ltcG9ydHtnIGFzIGdldElvblBhZ2VFbGVtZW50fWZyb21cIi4vaW5kZXgtZTZjMmM4MjIuanNcIjtpbXBvcnRcIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO2ltcG9ydFwiLi9pbmRleC1iM2VlY2IxNC5qc1wiO3ZhciBEVVJBVElPTj01NDA7dmFyIGdldENsb25lZEVsZW1lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJcIi5jb25jYXQodCxcIi5pb24tY2xvbmVkLWVsZW1lbnRcIikpfTt2YXIgc2hhZG93PWZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYWRvd1Jvb3R8fHR9O3ZhciBnZXRMYXJnZVRpdGxlPWZ1bmN0aW9uKHQpe3ZhciBlPXQudGFnTmFtZT09PVwiSU9OLVRBQlNcIj90OnQucXVlcnlTZWxlY3RvcihcImlvbi10YWJzXCIpO3ZhciBhPVwiaW9uLWNvbnRlbnQgaW9uLWhlYWRlcjpub3QoLmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZSkgaW9uLXRpdGxlLnRpdGxlLWxhcmdlXCI7aWYoZSE9bnVsbCl7dmFyIG89ZS5xdWVyeVNlbGVjdG9yKFwiaW9uLXRhYjpub3QoLnRhYi1oaWRkZW4pLCAuaW9uLXBhZ2U6bm90KC5pb24tcGFnZS1oaWRkZW4pXCIpO3JldHVybiBvIT1udWxsP28ucXVlcnlTZWxlY3RvcihhKTpudWxsfXJldHVybiB0LnF1ZXJ5U2VsZWN0b3IoYSl9O3ZhciBnZXRCYWNrQnV0dG9uPWZ1bmN0aW9uKHQsZSl7dmFyIGE9dC50YWdOYW1lPT09XCJJT04tVEFCU1wiP3Q6dC5xdWVyeVNlbGVjdG9yKFwiaW9uLXRhYnNcIik7dmFyIG89W107aWYoYSE9bnVsbCl7dmFyIHI9YS5xdWVyeVNlbGVjdG9yKFwiaW9uLXRhYjpub3QoLnRhYi1oaWRkZW4pLCAuaW9uLXBhZ2U6bm90KC5pb24tcGFnZS1oaWRkZW4pXCIpO2lmKHIhPW51bGwpe289ci5xdWVyeVNlbGVjdG9yQWxsKFwiaW9uLWJ1dHRvbnNcIil9fWVsc2V7bz10LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tYnV0dG9uc1wiKX1mb3IodmFyIG49MCxpPW87bjxpLmxlbmd0aDtuKyspe3ZhciBsPWlbbl07dmFyIGM9bC5jbG9zZXN0KFwiaW9uLWhlYWRlclwiKTt2YXIgcz1jJiYhYy5jbGFzc0xpc3QuY29udGFpbnMoXCJoZWFkZXItY29sbGFwc2UtY29uZGVuc2UtaW5hY3RpdmVcIik7dmFyIGY9bC5xdWVyeVNlbGVjdG9yKFwiaW9uLWJhY2stYnV0dG9uXCIpO3ZhciBkPWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYnV0dG9ucy1jb2xsYXBzZVwiKTt2YXIgbT1sLnNsb3Q9PT1cInN0YXJ0XCJ8fGwuc2xvdD09PVwiXCI7aWYoZiE9PW51bGwmJm0mJihkJiZzJiZlfHwhZCkpe3JldHVybiBmfX1yZXR1cm4gbnVsbH07dmFyIGNyZWF0ZUxhcmdlVGl0bGVUcmFuc2l0aW9uPWZ1bmN0aW9uKHQsZSxhLG8scil7dmFyIG49Z2V0QmFja0J1dHRvbihvLGEpO3ZhciBpPWdldExhcmdlVGl0bGUocik7dmFyIGw9Z2V0TGFyZ2VUaXRsZShvKTt2YXIgYz1nZXRCYWNrQnV0dG9uKHIsYSk7dmFyIHM9biE9PW51bGwmJmkhPT1udWxsJiYhYTt2YXIgZj1sIT09bnVsbCYmYyE9PW51bGwmJmE7aWYocyl7dmFyIGQ9aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2YXIgbT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2FuaW1hdGVMYXJnZVRpdGxlKHQsZSxhLGksZCxtKTthbmltYXRlQmFja0J1dHRvbih0LGUsYSxuLGQsbSl9ZWxzZSBpZihmKXt2YXIgdj1sLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBwPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7YW5pbWF0ZUxhcmdlVGl0bGUodCxlLGEsbCx2LHApO2FuaW1hdGVCYWNrQnV0dG9uKHQsZSxhLGMsdixwKX1yZXR1cm57Zm9yd2FyZDpzLGJhY2t3YXJkOmZ9fTt2YXIgYW5pbWF0ZUJhY2tCdXR0b249ZnVuY3Rpb24odCxlLGEsbyxyLG4pe3ZhciBpPWU/XCJjYWxjKDEwMCUgLSBcIi5jb25jYXQobi5yaWdodCs0LFwicHgpXCIpOlwiXCIuY29uY2F0KG4ubGVmdC00LFwicHhcIik7dmFyIGw9ZT9cIjdweFwiOlwiLTdweFwiO3ZhciBjPWU/XCItNHB4XCI6XCI0cHhcIjt2YXIgcz1lP1wiLTRweFwiOlwiNHB4XCI7dmFyIGY9ZT9cInJpZ2h0XCI6XCJsZWZ0XCI7dmFyIGQ9ZT9cImxlZnRcIjpcInJpZ2h0XCI7dmFyIG09W3tvZmZzZXQ6MCxvcGFjaXR5OjAsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KGwsXCIsIFwiKS5jb25jYXQoci50b3AtNDAsXCJweCwgMCkgc2NhbGUoMi4xKVwiKX0se29mZnNldDoxLG9wYWNpdHk6MSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoYyxcIiwgXCIpLmNvbmNhdChuLnRvcC00NixcInB4LCAwKSBzY2FsZSgxKVwiKX1dO3ZhciB2PVt7b2Zmc2V0OjAsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChjLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfSx7b2Zmc2V0Oi42LG9wYWNpdHk6MH0se29mZnNldDoxLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQobCxcIiwgXCIpLmNvbmNhdChyLnRvcC00MCxcInB4LCAwKSBzY2FsZSgyLjEpXCIpfV07dmFyIHA9YT92Om07dmFyIHk9W3tvZmZzZXQ6MCxvcGFjaXR5OjAsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHMsXCIsIFwiKS5jb25jYXQobi50b3AtNDEsXCJweCwgMCkgc2NhbGUoMC42KVwiKX0se29mZnNldDoxLG9wYWNpdHk6MSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQocyxcIiwgXCIpLmNvbmNhdChuLnRvcC00NixcInB4LCAwKSBzY2FsZSgxKVwiKX1dO3ZhciB1PVt7b2Zmc2V0OjAsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfSx7b2Zmc2V0Oi4yLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQocyxcIiwgXCIpLmNvbmNhdChuLnRvcC00MSxcInB4LCAwKSBzY2FsZSgwLjYpXCIpfSx7b2Zmc2V0OjEsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQxLFwicHgsIDApIHNjYWxlKDAuNilcIil9XTt2YXIgYj1hP3U6eTt2YXIgZz1jcmVhdGVBbmltYXRpb24oKTt2YXIgQT1jcmVhdGVBbmltYXRpb24oKTt2YXIgUz1nZXRDbG9uZWRFbGVtZW50KFwiaW9uLWJhY2stYnV0dG9uXCIpO3ZhciBUPXNoYWRvdyhTKS5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvbi10ZXh0XCIpO3ZhciBoPXNoYWRvdyhTKS5xdWVyeVNlbGVjdG9yKFwiaW9uLWljb25cIik7Uy50ZXh0PW8udGV4dDtTLm1vZGU9by5tb2RlO1MuaWNvbj1vLmljb247Uy5jb2xvcj1vLmNvbG9yO1MuZGlzYWJsZWQ9by5kaXNhYmxlZDtTLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiYmxvY2tcIik7Uy5zdHlsZS5zZXRQcm9wZXJ0eShcInBvc2l0aW9uXCIsXCJmaXhlZFwiKTtBLmFkZEVsZW1lbnQoaCk7Zy5hZGRFbGVtZW50KFQpO2cuYmVmb3JlU3R5bGVzKHtcInRyYW5zZm9ybS1vcmlnaW5cIjpcIlwiLmNvbmNhdChmLFwiIGNlbnRlclwiKX0pLmJlZm9yZUFkZFdyaXRlKChmdW5jdGlvbigpe28uc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIpO1Muc3R5bGUuc2V0UHJvcGVydHkoZixpKX0pKS5hZnRlckFkZFdyaXRlKChmdW5jdGlvbigpe28uc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJcIik7Uy5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIik7Uy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShmKX0pKS5rZXlmcmFtZXMocCk7QS5iZWZvcmVTdHlsZXMoe1widHJhbnNmb3JtLW9yaWdpblwiOlwiXCIuY29uY2F0KGQsXCIgY2VudGVyXCIpfSkua2V5ZnJhbWVzKGIpO3QuYWRkQW5pbWF0aW9uKFtnLEFdKX07dmFyIGFuaW1hdGVMYXJnZVRpdGxlPWZ1bmN0aW9uKHQsZSxhLG8scixuKXt2YXIgaTt2YXIgbD1lP1wiY2FsYygxMDAlIC0gXCIuY29uY2F0KHIucmlnaHQsXCJweClcIik6XCJcIi5jb25jYXQoci5sZWZ0LFwicHhcIik7dmFyIGM9ZT9cIi0xOHB4XCI6XCIxOHB4XCI7dmFyIHM9ZT9cInJpZ2h0XCI6XCJsZWZ0XCI7dmFyIGY9W3tvZmZzZXQ6MCxvcGFjaXR5OjAsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KGMsXCIsIFwiKS5jb25jYXQobi50b3AtNCxcInB4LCAwKSBzY2FsZSgwLjQ5KVwiKX0se29mZnNldDouMSxvcGFjaXR5OjB9LHtvZmZzZXQ6MSxvcGFjaXR5OjEsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoMCwgXCIuY29uY2F0KHIudG9wLTIsXCJweCwgMCkgc2NhbGUoMSlcIil9XTt2YXIgZD1be29mZnNldDowLG9wYWNpdHk6Ljk5LHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKDAsIFwiLmNvbmNhdChyLnRvcC0yLFwicHgsIDApIHNjYWxlKDEpXCIpfSx7b2Zmc2V0Oi42LG9wYWNpdHk6MH0se29mZnNldDoxLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoYyxcIiwgXCIpLmNvbmNhdChuLnRvcC00LFwicHgsIDApIHNjYWxlKDAuNSlcIil9XTt2YXIgbT1hP2Y6ZDt2YXIgdj1nZXRDbG9uZWRFbGVtZW50KFwiaW9uLXRpdGxlXCIpO3ZhciBwPWNyZWF0ZUFuaW1hdGlvbigpO3YuaW5uZXJUZXh0PW8uaW5uZXJUZXh0O3Yuc2l6ZT1vLnNpemU7di5jb2xvcj1vLmNvbG9yO3AuYWRkRWxlbWVudCh2KTtwLmJlZm9yZVN0eWxlcygoaT17XCJ0cmFuc2Zvcm0tb3JpZ2luXCI6XCJcIi5jb25jYXQocyxcIiBjZW50ZXJcIiksaGVpZ2h0OlwiNDZweFwiLGRpc3BsYXk6XCJcIixwb3NpdGlvbjpcInJlbGF0aXZlXCJ9LGlbc109bCxpKSkuYmVmb3JlQWRkV3JpdGUoKGZ1bmN0aW9uKCl7by5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9KSkuYWZ0ZXJBZGRXcml0ZSgoZnVuY3Rpb24oKXtvLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiXCIpO3Yuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIpfSkpLmtleWZyYW1lcyhtKTt0LmFkZEFuaW1hdGlvbihwKX07dmFyIGlvc1RyYW5zaXRpb25BbmltYXRpb249ZnVuY3Rpb24odCxlKXt0cnl7dmFyIGE9XCJjdWJpYy1iZXppZXIoMC4zMiwwLjcyLDAsMSlcIjt2YXIgbz1cIm9wYWNpdHlcIjt2YXIgcj1cInRyYW5zZm9ybVwiO3ZhciBuPVwiMCVcIjt2YXIgaT0uODt2YXIgbD10Lm93bmVyRG9jdW1lbnQuZGlyPT09XCJydGxcIjt2YXIgYz1sP1wiLTk5LjUlXCI6XCI5OS41JVwiO3ZhciBzPWw/XCIzMyVcIjpcIi0zMyVcIjt2YXIgZj1lLmVudGVyaW5nRWw7dmFyIGQ9ZS5sZWF2aW5nRWw7dmFyIG09ZS5kaXJlY3Rpb249PT1cImJhY2tcIjt2YXIgdj1mLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiBpb24tY29udGVudFwiKTt2YXIgcD1mLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBpb24taGVhZGVyID4gKjpub3QoaW9uLXRvb2xiYXIpLCA6c2NvcGUgPiBpb24tZm9vdGVyID4gKlwiKTt2YXIgeT1mLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBpb24taGVhZGVyID4gaW9uLXRvb2xiYXJcIik7dmFyIHU9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIGI9Y3JlYXRlQW5pbWF0aW9uKCk7dS5hZGRFbGVtZW50KGYpLmR1cmF0aW9uKGUuZHVyYXRpb258fERVUkFUSU9OKS5lYXNpbmcoZS5lYXNpbmd8fGEpLmZpbGwoXCJib3RoXCIpLmJlZm9yZVJlbW92ZUNsYXNzKFwiaW9uLXBhZ2UtaW52aXNpYmxlXCIpO2lmKGQmJnQpe3ZhciBnPWNyZWF0ZUFuaW1hdGlvbigpO2cuYWRkRWxlbWVudCh0KTt1LmFkZEFuaW1hdGlvbihnKX1pZighdiYmeS5sZW5ndGg9PT0wJiZwLmxlbmd0aD09PTApe2IuYWRkRWxlbWVudChmLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiAuaW9uLXBhZ2UsIDpzY29wZSA+IGlvbi1uYXYsIDpzY29wZSA+IGlvbi10YWJzXCIpKX1lbHNle2IuYWRkRWxlbWVudCh2KTtiLmFkZEVsZW1lbnQocCl9dS5hZGRBbmltYXRpb24oYik7aWYobSl7Yi5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSkuZnJvbVRvKG8saSwxKX1lbHNle2IuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGMsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIikpfWlmKHYpe3ZhciBBPXNoYWRvdyh2KS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tZWZmZWN0XCIpO2lmKEEpe3ZhciBTPUEucXVlcnlTZWxlY3RvcihcIi50cmFuc2l0aW9uLWNvdmVyXCIpO3ZhciBUPUEucXVlcnlTZWxlY3RvcihcIi50cmFuc2l0aW9uLXNoYWRvd1wiKTt2YXIgaD1jcmVhdGVBbmltYXRpb24oKTt2YXIgeD1jcmVhdGVBbmltYXRpb24oKTt2YXIgRT1jcmVhdGVBbmltYXRpb24oKTtoLmFkZEVsZW1lbnQoQSkuYmVmb3JlU3R5bGVzKHtvcGFjaXR5OlwiMVwiLGRpc3BsYXk6XCJibG9ja1wifSkuYWZ0ZXJTdHlsZXMoe29wYWNpdHk6XCJcIixkaXNwbGF5OlwiXCJ9KTt4LmFkZEVsZW1lbnQoUykuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8obywwLC4xKTtFLmFkZEVsZW1lbnQoVCkuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8obywuMDMsLjcpO2guYWRkQW5pbWF0aW9uKFt4LEVdKTtiLmFkZEFuaW1hdGlvbihbaF0pfX12YXIgcT1mLnF1ZXJ5U2VsZWN0b3IoXCJpb24taGVhZGVyLmhlYWRlci1jb2xsYXBzZS1jb25kZW5zZVwiKTt2YXIgWD1jcmVhdGVMYXJnZVRpdGxlVHJhbnNpdGlvbih1LGwsbSxmLGQpLEM9WC5mb3J3YXJkLGs9WC5iYWNrd2FyZDt5LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWNyZWF0ZUFuaW1hdGlvbigpO2UuYWRkRWxlbWVudCh0KTt1LmFkZEFuaW1hdGlvbihlKTt2YXIgYT1jcmVhdGVBbmltYXRpb24oKTthLmFkZEVsZW1lbnQodC5xdWVyeVNlbGVjdG9yKFwiaW9uLXRpdGxlXCIpKTt2YXIgcj1jcmVhdGVBbmltYXRpb24oKTt2YXIgaT1BcnJheS5mcm9tKHQucXVlcnlTZWxlY3RvckFsbChcImlvbi1idXR0b25zLFttZW51VG9nZ2xlXVwiKSk7dmFyIGY9dC5jbG9zZXN0KFwiaW9uLWhlYWRlclwiKTt2YXIgZD1mJiZmLmNsYXNzTGlzdC5jb250YWlucyhcImhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZVwiKTt2YXIgdjtpZihtKXt2PWkuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZT10LmNsYXNzTGlzdC5jb250YWlucyhcImJ1dHRvbnMtY29sbGFwc2VcIik7cmV0dXJuIGUmJiFkfHwhZX0pKX1lbHNle3Y9aS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0LmNsYXNzTGlzdC5jb250YWlucyhcImJ1dHRvbnMtY29sbGFwc2VcIil9KSl9ci5hZGRFbGVtZW50KHYpO3ZhciBwPWNyZWF0ZUFuaW1hdGlvbigpO3AuYWRkRWxlbWVudCh0LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiAqOm5vdChpb24tdGl0bGUpOm5vdChpb24tYnV0dG9ucyk6bm90KFttZW51VG9nZ2xlXSlcIikpO3ZhciB5PWNyZWF0ZUFuaW1hdGlvbigpO3kuYWRkRWxlbWVudChzaGFkb3codCkucXVlcnlTZWxlY3RvcihcIi50b29sYmFyLWJhY2tncm91bmRcIikpO3ZhciBiPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBnPXQucXVlcnlTZWxlY3RvcihcImlvbi1iYWNrLWJ1dHRvblwiKTtpZihnKXtiLmFkZEVsZW1lbnQoZyl9ZS5hZGRBbmltYXRpb24oW2EscixwLHksYl0pO3IuZnJvbVRvKG8sLjAxLDEpO3AuZnJvbVRvKG8sLjAxLDEpO2lmKG0pe2lmKCFkKXthLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSkuZnJvbVRvKG8sLjAxLDEpfXAuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKTtiLmZyb21UbyhvLC4wMSwxKX1lbHNle2lmKCFxKXthLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQoYyxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSkuZnJvbVRvKG8sLjAxLDEpfXAuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChjLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKTt5LmJlZm9yZUNsZWFyU3R5bGVzKFtvLFwidHJhbnNmb3JtXCJdKTt2YXIgQT1mPT09bnVsbHx8Zj09PXZvaWQgMD92b2lkIDA6Zi50cmFuc2x1Y2VudDtpZighQSl7eS5mcm9tVG8obywuMDEsXCJ2YXIoLS1vcGFjaXR5KVwiKX1lbHNle3kuZnJvbVRvKFwidHJhbnNmb3JtXCIsbD9cInRyYW5zbGF0ZVgoLTEwMCUpXCI6XCJ0cmFuc2xhdGVYKDEwMCUpXCIsXCJ0cmFuc2xhdGVYKDBweClcIil9aWYoIUMpe2IuZnJvbVRvKG8sLjAxLDEpfWlmKGcmJiFDKXt2YXIgUz1jcmVhdGVBbmltYXRpb24oKTtTLmFkZEVsZW1lbnQoc2hhZG93KGcpLnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uLXRleHRcIikpLmZyb21UbyhcInRyYW5zZm9ybVwiLGw/XCJ0cmFuc2xhdGVYKC0xMDBweClcIjpcInRyYW5zbGF0ZVgoMTAwcHgpXCIsXCJ0cmFuc2xhdGVYKDBweClcIik7ZS5hZGRBbmltYXRpb24oUyl9fX0pKTtpZihkKXt2YXIgdz1jcmVhdGVBbmltYXRpb24oKTt2YXIgQj1kLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiBpb24tY29udGVudFwiKTt2YXIgTD1kLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBpb24taGVhZGVyID4gaW9uLXRvb2xiYXJcIik7dmFyIFA9ZC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gaW9uLWhlYWRlciA+ICo6bm90KGlvbi10b29sYmFyKSwgOnNjb3BlID4gaW9uLWZvb3RlciA+ICpcIik7aWYoIUImJkwubGVuZ3RoPT09MCYmUC5sZW5ndGg9PT0wKXt3LmFkZEVsZW1lbnQoZC5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gLmlvbi1wYWdlLCA6c2NvcGUgPiBpb24tbmF2LCA6c2NvcGUgPiBpb24tdGFic1wiKSl9ZWxzZXt3LmFkZEVsZW1lbnQoQik7dy5hZGRFbGVtZW50KFApfXUuYWRkQW5pbWF0aW9uKHcpO2lmKG0pe3cuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKTt2YXIgUj1nZXRJb25QYWdlRWxlbWVudChkKTt1LmFmdGVyQWRkV3JpdGUoKGZ1bmN0aW9uKCl7aWYodS5nZXREaXJlY3Rpb24oKT09PVwibm9ybWFsXCIpe1Iuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIpfX0pKX1lbHNle3cuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpKS5mcm9tVG8obywxLGkpfWlmKEIpe3ZhciBJPXNoYWRvdyhCKS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tZWZmZWN0XCIpO2lmKEkpe3ZhciBOPUkucXVlcnlTZWxlY3RvcihcIi50cmFuc2l0aW9uLWNvdmVyXCIpO3ZhciBXPUkucXVlcnlTZWxlY3RvcihcIi50cmFuc2l0aW9uLXNoYWRvd1wiKTt2YXIgaj1jcmVhdGVBbmltYXRpb24oKTt2YXIgRD1jcmVhdGVBbmltYXRpb24oKTt2YXIgTz1jcmVhdGVBbmltYXRpb24oKTtqLmFkZEVsZW1lbnQoSSkuYmVmb3JlU3R5bGVzKHtvcGFjaXR5OlwiMVwiLGRpc3BsYXk6XCJibG9ja1wifSkuYWZ0ZXJTdHlsZXMoe29wYWNpdHk6XCJcIixkaXNwbGF5OlwiXCJ9KTtELmFkZEVsZW1lbnQoTikuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8obywuMSwwKTtPLmFkZEVsZW1lbnQoVykuYmVmb3JlQ2xlYXJTdHlsZXMoW29dKS5mcm9tVG8obywuNywuMDMpO2ouYWRkQW5pbWF0aW9uKFtELE9dKTt3LmFkZEFuaW1hdGlvbihbal0pfX1MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWNyZWF0ZUFuaW1hdGlvbigpO2UuYWRkRWxlbWVudCh0KTt2YXIgYT1jcmVhdGVBbmltYXRpb24oKTthLmFkZEVsZW1lbnQodC5xdWVyeVNlbGVjdG9yKFwiaW9uLXRpdGxlXCIpKTt2YXIgaT1jcmVhdGVBbmltYXRpb24oKTt2YXIgYz10LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tYnV0dG9ucyxbbWVudVRvZ2dsZV1cIik7dmFyIGY9dC5jbG9zZXN0KFwiaW9uLWhlYWRlclwiKTt2YXIgZD1mJiZmLmNsYXNzTGlzdC5jb250YWlucyhcImhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZVwiKTt2YXIgdj1BcnJheS5mcm9tKGMpLmZpbHRlcigoZnVuY3Rpb24odCl7dmFyIGU9dC5jbGFzc0xpc3QuY29udGFpbnMoXCJidXR0b25zLWNvbGxhcHNlXCIpO3JldHVybiBlJiYhZHx8IWV9KSk7aS5hZGRFbGVtZW50KHYpO3ZhciBwPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciB5PXQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+ICo6bm90KGlvbi10aXRsZSk6bm90KGlvbi1idXR0b25zKTpub3QoW21lbnVUb2dnbGVdKVwiKTtpZih5Lmxlbmd0aD4wKXtwLmFkZEVsZW1lbnQoeSl9dmFyIGI9Y3JlYXRlQW5pbWF0aW9uKCk7Yi5hZGRFbGVtZW50KHNoYWRvdyh0KS5xdWVyeVNlbGVjdG9yKFwiLnRvb2xiYXItYmFja2dyb3VuZFwiKSk7dmFyIGc9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIEE9dC5xdWVyeVNlbGVjdG9yKFwiaW9uLWJhY2stYnV0dG9uXCIpO2lmKEEpe2cuYWRkRWxlbWVudChBKX1lLmFkZEFuaW1hdGlvbihbYSxpLHAsZyxiXSk7dS5hZGRBbmltYXRpb24oZSk7Zy5mcm9tVG8obywuOTksMCk7aS5mcm9tVG8obywuOTksMCk7cC5mcm9tVG8obywuOTksMCk7aWYobSl7aWYoIWQpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxsP1widHJhbnNsYXRlWCgtMTAwJSlcIjpcInRyYW5zbGF0ZVgoMTAwJSlcIikuZnJvbVRvKG8sLjk5LDApfXAuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxsP1widHJhbnNsYXRlWCgtMTAwJSlcIjpcInRyYW5zbGF0ZVgoMTAwJSlcIik7Yi5iZWZvcmVDbGVhclN0eWxlcyhbbyxcInRyYW5zZm9ybVwiXSk7dmFyIFM9Zj09PW51bGx8fGY9PT12b2lkIDA/dm9pZCAwOmYudHJhbnNsdWNlbnQ7aWYoIVMpe2IuZnJvbVRvKG8sXCJ2YXIoLS1vcGFjaXR5KVwiLDApfWVsc2V7Yi5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoMHB4KVwiLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKX1pZihBJiYhayl7dmFyIFQ9Y3JlYXRlQW5pbWF0aW9uKCk7VC5hZGRFbGVtZW50KHNoYWRvdyhBKS5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvbi10ZXh0XCIpKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQoKGw/LTEyNDoxMjQpK1wicHhcIixcIilcIikpO2UuYWRkQW5pbWF0aW9uKFQpfX1lbHNle2lmKCFkKXthLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSkuZnJvbVRvKG8sLjk5LDApLmFmdGVyQ2xlYXJTdHlsZXMoW3Isb10pfXAuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpKS5hZnRlckNsZWFyU3R5bGVzKFtyLG9dKTtnLmFmdGVyQ2xlYXJTdHlsZXMoW29dKTthLmFmdGVyQ2xlYXJTdHlsZXMoW29dKTtpLmFmdGVyQ2xlYXJTdHlsZXMoW29dKX19KSl9cmV0dXJuIHV9Y2F0Y2godCl7dGhyb3cgdH19O2V4cG9ydHtpb3NUcmFuc2l0aW9uQW5pbWF0aW9uLHNoYWRvd307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48360\n')},92782:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mdTransitionAnimation": () => (/* binding */ mdTransitionAnimation)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar mdTransitionAnimation=function(e,n){var a="40px";var t="0px";var i=n.direction==="back";var o=n.enteringEl;var r=n.leavingEl;var m=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(o);var c=m.querySelector("ion-toolbar");var s=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();s.addElement(m).fill("both").beforeRemoveClass("ion-page-invisible");if(i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)")}else{s.duration(n.duration||280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform","translateY(".concat(a,")"),"translateY(".concat(t,")")).fromTo("opacity",.01,1)}if(c){var l=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();l.addElement(c);s.addAnimation(l)}if(r&&i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)");var d=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();d.addElement((0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(r)).onFinish((function(e){if(e===1&&d.elements.length>0){d.elements[0].style.setProperty("display","none")}})).fromTo("transform","translateY(".concat(t,")"),"translateY(".concat(a,")")).fromTo("opacity",1,0);s.addAnimation(d)}return s};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI3ODIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUM0Syx3Q0FBd0MsYUFBYSxZQUFZLDJCQUEyQixtQkFBbUIsa0JBQWtCLE1BQU0scURBQWlCLElBQUkscUNBQXFDLE1BQU0seURBQWUsR0FBRyxxRUFBcUUsTUFBTSx1RUFBdUUsS0FBSyx5S0FBeUssTUFBTSxNQUFNLHlEQUFlLEdBQUcsZ0JBQWdCLGtCQUFrQixTQUFTLHVFQUF1RSxNQUFNLHlEQUFlLEdBQUcsYUFBYSxxREFBaUIsMkJBQTJCLCtCQUErQixtREFBbUQscUdBQXFHLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L21kLnRyYW5zaXRpb24tZGE4NjYxMTkuanM/OWQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7aW1wb3J0e2cgYXMgZ2V0SW9uUGFnZUVsZW1lbnR9ZnJvbVwiLi9pbmRleC1lNmMyYzgyMi5qc1wiO2ltcG9ydFwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7aW1wb3J0XCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7dmFyIG1kVHJhbnNpdGlvbkFuaW1hdGlvbj1mdW5jdGlvbihlLG4pe3ZhciBhPVwiNDBweFwiO3ZhciB0PVwiMHB4XCI7dmFyIGk9bi5kaXJlY3Rpb249PT1cImJhY2tcIjt2YXIgbz1uLmVudGVyaW5nRWw7dmFyIHI9bi5sZWF2aW5nRWw7dmFyIG09Z2V0SW9uUGFnZUVsZW1lbnQobyk7dmFyIGM9bS5xdWVyeVNlbGVjdG9yKFwiaW9uLXRvb2xiYXJcIik7dmFyIHM9Y3JlYXRlQW5pbWF0aW9uKCk7cy5hZGRFbGVtZW50KG0pLmZpbGwoXCJib3RoXCIpLmJlZm9yZVJlbW92ZUNsYXNzKFwiaW9uLXBhZ2UtaW52aXNpYmxlXCIpO2lmKGkpe3MuZHVyYXRpb24obi5kdXJhdGlvbnx8MjAwKS5lYXNpbmcoXCJjdWJpYy1iZXppZXIoMC40NywwLDAuNzQ1LDAuNzE1KVwiKX1lbHNle3MuZHVyYXRpb24obi5kdXJhdGlvbnx8MjgwKS5lYXNpbmcoXCJjdWJpYy1iZXppZXIoMC4zNiwwLjY2LDAuMDQsMSlcIikuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdChhLFwiKVwiKSxcInRyYW5zbGF0ZVkoXCIuY29uY2F0KHQsXCIpXCIpKS5mcm9tVG8oXCJvcGFjaXR5XCIsLjAxLDEpfWlmKGMpe3ZhciBsPWNyZWF0ZUFuaW1hdGlvbigpO2wuYWRkRWxlbWVudChjKTtzLmFkZEFuaW1hdGlvbihsKX1pZihyJiZpKXtzLmR1cmF0aW9uKG4uZHVyYXRpb258fDIwMCkuZWFzaW5nKFwiY3ViaWMtYmV6aWVyKDAuNDcsMCwwLjc0NSwwLjcxNSlcIik7dmFyIGQ9Y3JlYXRlQW5pbWF0aW9uKCk7ZC5hZGRFbGVtZW50KGdldElvblBhZ2VFbGVtZW50KHIpKS5vbkZpbmlzaCgoZnVuY3Rpb24oZSl7aWYoZT09PTEmJmQuZWxlbWVudHMubGVuZ3RoPjApe2QuZWxlbWVudHNbMF0uc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIpfX0pKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVkoXCIuY29uY2F0KHQsXCIpXCIpLFwidHJhbnNsYXRlWShcIi5jb25jYXQoYSxcIilcIikpLmZyb21UbyhcIm9wYWNpdHlcIiwxLDApO3MuYWRkQW5pbWF0aW9uKGQpfXJldHVybiBzfTtleHBvcnR7bWRUcmFuc2l0aW9uQW5pbWF0aW9ufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92782\n')},46250:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ BACKDROP),\n/* harmony export */   "a": () => (/* binding */ alertController),\n/* harmony export */   "b": () => (/* binding */ actionSheetController),\n/* harmony export */   "c": () => (/* binding */ popoverController),\n/* harmony export */   "d": () => (/* binding */ present),\n/* harmony export */   "e": () => (/* binding */ prepareOverlay),\n/* harmony export */   "f": () => (/* binding */ dismiss),\n/* harmony export */   "g": () => (/* binding */ eventMethod),\n/* harmony export */   "h": () => (/* binding */ activeAnimations),\n/* harmony export */   "i": () => (/* binding */ isCancel),\n/* harmony export */   "j": () => (/* binding */ focusFirstDescendant),\n/* harmony export */   "k": () => (/* binding */ getOverlay),\n/* harmony export */   "l": () => (/* binding */ loadingController),\n/* harmony export */   "m": () => (/* binding */ modalController),\n/* harmony export */   "p": () => (/* binding */ pickerController),\n/* harmony export */   "s": () => (/* binding */ safeCall),\n/* harmony export */   "t": () => (/* binding */ toastController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70655);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75001);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var lastId=0;var activeAnimations=new WeakMap;var createController=function(e){return{create:function(t){return createOverlay(e,t)},dismiss:function(t,n,r){return dismissOverlay(document,t,n,e,r)},getTop:function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(this,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){return[2,getOverlay(document,e)]}))}))}}};var alertController=createController("ion-alert");var actionSheetController=createController("ion-action-sheet");var loadingController=createController("ion-loading");var modalController=createController("ion-modal");var pickerController=createController("ion-picker");var popoverController=createController("ion-popover");var toastController=createController("ion-toast");var prepareOverlay=function(e){if(typeof document!=="undefined"){connectListeners(document)}var t=lastId++;e.overlayIndex=t;if(!e.hasAttribute("id")){e.id="ion-overlay-".concat(t)}};var createOverlay=function(e,t){if(typeof window!=="undefined"&&typeof window.customElements!=="undefined"){return window.customElements.whenDefined(e).then((function(){var n=document.createElement(e);n.classList.add("overlay-hidden");Object.assign(n,Object.assign(Object.assign({},t),{hasController:true}));getAppRoot(document).appendChild(n);return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(n,e)}))}))}return Promise.resolve()};var focusableQueryString=\'[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])\';var innerFocusableQueryString="input:not([type=hidden]), textarea, button, select";var focusFirstDescendant=function(e,t){var n=e.querySelector(focusableQueryString);var r=n&&n.shadowRoot;if(r){n=r.querySelector(innerFocusableQueryString)||n}if(n){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.f)(n)}else{t.focus()}};var isOverlayHidden=function(e){return e.classList.contains("overlay-hidden")};var focusLastDescendant=function(e,t){var n=Array.from(e.querySelectorAll(focusableQueryString));var r=n.length>0?n[n.length-1]:null;var o=r&&r.shadowRoot;if(o){r=o.querySelector(innerFocusableQueryString)||r}if(r){r.focus()}else{t.focus()}};var trapKeyboardFocus=function(e,t){var n=getOverlay(t,"ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover");var r=e.target;if(!n||!r){return}if(n.classList.contains("ion-disable-focus-trap")){return}var o=function(){if(n===r){n.lastFocus=undefined}else{var e=(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.g)(n);if(!e.contains(r)){return}var o=e.querySelector(".ion-overlay-wrapper");if(!o){return}if(o.contains(r)){n.lastFocus=r}else{var i=n.lastFocus;focusFirstDescendant(o,n);if(i===t.activeElement){focusLastDescendant(o,n)}n.lastFocus=t.activeElement}}};var i=function(){if(n.contains(r)){n.lastFocus=r}else{var e=n.lastFocus;focusFirstDescendant(n,n);if(e===t.activeElement){focusLastDescendant(n,n)}n.lastFocus=t.activeElement}};if(n.shadowRoot){i()}else{o()}};var connectListeners=function(e){if(lastId===0){lastId=1;e.addEventListener("focus",(function(t){trapKeyboardFocus(t,e)}),true);e.addEventListener("ionBackButton",(function(t){var n=getOverlay(e);if(n&&n.backdropDismiss){t.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__.OVERLAY_BACK_BUTTON_PRIORITY,(function(){return n.dismiss(undefined,BACKDROP)}))}}));e.addEventListener("keyup",(function(t){if(t.key==="Escape"){var n=getOverlay(e);if(n&&n.backdropDismiss){n.dismiss(undefined,BACKDROP)}}}))}};var dismissOverlay=function(e,t,n,r,o){var i=getOverlay(e,r,o);if(!i){return Promise.reject("overlay does not exist")}return i.dismiss(t,n)};var getOverlays=function(e,t){if(t===undefined){t="ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast"}return Array.from(e.querySelectorAll(t)).filter((function(e){return e.overlayIndex>0}))};var getOverlay=function(e,t,n){var r=getOverlays(e,t).filter((function(e){return!isOverlayHidden(e)}));return n===undefined?r[r.length-1]:r.find((function(e){return e.id===n}))};var setRootAriaHidden=function(e){if(e===void 0){e=false}var t=getAppRoot(document);var n=t.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");if(!n){return}if(e){n.setAttribute("aria-hidden","true")}else{n.removeAttribute("aria-hidden")}};var present=function(e,t,n,r,o){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,a,s,l,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(u){switch(u.label){case 0:if(e.presented){return[2]}setRootAriaHidden(true);e.presented=true;e.willPresent.emit();(i=e.willPresentShorthand)===null||i===void 0?void 0:i.emit();s=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);l=e.enterAnimation?e.enterAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(t,s==="ios"?n:r);return[4,overlayAnimation(e,l,e.el,o)];case 1:c=u.sent();if(c){e.didPresent.emit();(a=e.didPresentShorthand)===null||a===void 0?void 0:a.emit()}if(e.el.tagName!=="ION-TOAST"){focusPreviousElementOnDismiss(e.el)}if(e.keyboardClose){e.el.focus()}return[2]}}))}))};var focusPreviousElementOnDismiss=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:t=document.activeElement;if(!t){return[2]}n=t&&t.shadowRoot;if(n){t=n.querySelector(innerFocusableQueryString)||t}return[4,e.onDidDismiss()];case 1:r.sent();t.focus();return[2]}}))}))};var dismiss=function(e,t,n,r,o,i,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var s,l,c,u,d;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(v){switch(v.label){case 0:if(!e.presented){return[2,false]}setRootAriaHidden(false);e.presented=false;v.label=1;case 1:v.trys.push([1,4,,5]);e.el.style.setProperty("pointer-events","none");e.willDismiss.emit({data:t,role:n});(s=e.willDismissShorthand)===null||s===void 0?void 0:s.emit({data:t,role:n});c=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);u=e.leaveAnimation?e.leaveAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(r,c==="ios"?o:i);if(!(n!=="gesture"))return[3,3];return[4,overlayAnimation(e,u,e.el,a)];case 2:v.sent();v.label=3;case 3:e.didDismiss.emit({data:t,role:n});(l=e.didDismissShorthand)===null||l===void 0?void 0:l.emit({data:t,role:n});activeAnimations.delete(e);e.el.classList.add("overlay-hidden");e.el.style.removeProperty("pointer-events");return[3,5];case 4:d=v.sent();console.error(d);return[3,5];case 5:e.el.remove();return[2,true]}}))}))};var getAppRoot=function(e){return e.querySelector("ion-app")||e.body};var overlayAnimation=function(e,t,n,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var o,i,a;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(s){switch(s.label){case 0:n.classList.remove("overlay-hidden");o=e.el;i=t(o,r);if(!e.animated||!_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.getBoolean("animated",true)){i.duration(0)}if(e.keyboardClose){i.beforeAddWrite((function(){var e=n.ownerDocument.activeElement;if(e&&e.matches("input,ion-input, ion-textarea")){e.blur()}}))}a=activeAnimations.get(e)||[];activeAnimations.set(e,(0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)([],a,true),[i],false));return[4,i.play()];case 1:s.sent();return[2,true]}}))}))};var eventMethod=function(e,t){var n;var r=new Promise((function(e){return n=e}));onceEvent(e,t,(function(e){n(e.detail)}));return r};var onceEvent=function(e,t,n){var r=function(o){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.b)(e,t,r);n(o)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.a)(e,t,r)};var isCancel=function(e){return e==="cancel"||e===BACKDROP};var defaultGate=function(e){return e()};var safeCall=function(e,t){if(typeof e==="function"){var n=_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get("_zoneGate",defaultGate);return n((function(){try{return e(t)}catch(e){throw e}}))}return undefined};var BACKDROP="backdrop";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VyxtQkFBbUIsZ0JBQWdCLDRDQUE0QyxPQUFPLFNBQVMsaUJBQWlCLG1FQUFpQixtQkFBbUIsY0FBYyxvQkFBb0IsNkJBQTZCLG9DQUFvQyxrREFBa0QsVUFBVSxHQUFHLDhCQUE4Qix1QkFBdUIsOERBQWEsQ0FBQyw4REFBYSx3QkFBd0IsbUJBQW1CLGdCQUFnQixnQkFBZ0IsR0FBRyxJQUFJLDhCQUE4QixNQUFNLCtCQUErQixXQUFXLEdBQUcsMkJBQTJCLFlBQVksR0FBRyxVQUFVLDhCQUE4QixrQkFBa0IsdURBQW1CLFFBQVEsTUFBTSx1REFBZ0IsU0FBUyx5QkFBeUIsbUNBQW1DLDRCQUE0QixZQUFZLDJCQUEyQiwwQkFBMEIsTUFBTSw0REFBVSwwQkFBMEIscUJBQXFCLElBQUksWUFBWSxTQUFTLFNBQVMsR0FBRyxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9vdmVybGF5cy0zNmQzNDc1ZC5qcz80ZDM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtfX2F3YWl0ZXIsX19nZW5lcmF0b3IsX19zcHJlYWRBcnJheX1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9pbXBvcnR7YiBhcyBnZXRJb25Nb2RlLGMgYXMgY29uZmlnfWZyb21cIi4vaW9uaWMtZ2xvYmFsLTBlYmUzMjFjLmpzXCI7aW1wb3J0e09WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFl9ZnJvbVwiLi9oYXJkd2FyZS1iYWNrLWJ1dHRvbi1hY2U2YTcxYi5qc1wiO2ltcG9ydHtjIGFzIGNvbXBvbmVudE9uUmVhZHksZiBhcyBmb2N1c0VsZW1lbnQsYSBhcyBhZGRFdmVudExpc3RlbmVyLGIgYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lcixnIGFzIGdldEVsZW1lbnRSb290fWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO3ZhciBsYXN0SWQ9MDt2YXIgYWN0aXZlQW5pbWF0aW9ucz1uZXcgV2Vha01hcDt2YXIgY3JlYXRlQ29udHJvbGxlcj1mdW5jdGlvbihlKXtyZXR1cm57Y3JlYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBjcmVhdGVPdmVybGF5KGUsdCl9LGRpc21pc3M6ZnVuY3Rpb24odCxuLHIpe3JldHVybiBkaXNtaXNzT3ZlcmxheShkb2N1bWVudCx0LG4sZSxyKX0sZ2V0VG9wOmZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3JldHVyblsyLGdldE92ZXJsYXkoZG9jdW1lbnQsZSldfSkpfSkpfX19O3ZhciBhbGVydENvbnRyb2xsZXI9Y3JlYXRlQ29udHJvbGxlcihcImlvbi1hbGVydFwiKTt2YXIgYWN0aW9uU2hlZXRDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tYWN0aW9uLXNoZWV0XCIpO3ZhciBsb2FkaW5nQ29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLWxvYWRpbmdcIik7dmFyIG1vZGFsQ29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLW1vZGFsXCIpO3ZhciBwaWNrZXJDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tcGlja2VyXCIpO3ZhciBwb3BvdmVyQ29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLXBvcG92ZXJcIik7dmFyIHRvYXN0Q29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLXRvYXN0XCIpO3ZhciBwcmVwYXJlT3ZlcmxheT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiKXtjb25uZWN0TGlzdGVuZXJzKGRvY3VtZW50KX12YXIgdD1sYXN0SWQrKztlLm92ZXJsYXlJbmRleD10O2lmKCFlLmhhc0F0dHJpYnV0ZShcImlkXCIpKXtlLmlkPVwiaW9uLW92ZXJsYXktXCIuY29uY2F0KHQpfX07dmFyIGNyZWF0ZU92ZXJsYXk9ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHdpbmRvdy5jdXN0b21FbGVtZW50cyE9PVwidW5kZWZpbmVkXCIpe3JldHVybiB3aW5kb3cuY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoZSkudGhlbigoZnVuY3Rpb24oKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO24uY2xhc3NMaXN0LmFkZChcIm92ZXJsYXktaGlkZGVuXCIpO09iamVjdC5hc3NpZ24obixPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse2hhc0NvbnRyb2xsZXI6dHJ1ZX0pKTtnZXRBcHBSb290KGRvY3VtZW50KS5hcHBlbmRDaGlsZChuKTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wb25lbnRPblJlYWR5KG4sZSl9KSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfTt2YXIgZm9jdXNhYmxlUXVlcnlTdHJpbmc9J1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKSwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIHRleHRhcmVhOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIGJ1dHRvbjpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBzZWxlY3Q6bm90KFt0YWJpbmRleF49XCItXCJdKSwgLmlvbi1mb2N1c2FibGU6bm90KFt0YWJpbmRleF49XCItXCJdKSc7dmFyIGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmc9XCJpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFwiO3ZhciBmb2N1c0ZpcnN0RGVzY2VuZGFudD1mdW5jdGlvbihlLHQpe3ZhciBuPWUucXVlcnlTZWxlY3Rvcihmb2N1c2FibGVRdWVyeVN0cmluZyk7dmFyIHI9biYmbi5zaGFkb3dSb290O2lmKHIpe249ci5xdWVyeVNlbGVjdG9yKGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmcpfHxufWlmKG4pe2ZvY3VzRWxlbWVudChuKX1lbHNle3QuZm9jdXMoKX19O3ZhciBpc092ZXJsYXlIaWRkZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3ZlcmxheS1oaWRkZW5cIil9O3ZhciBmb2N1c0xhc3REZXNjZW5kYW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49QXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlUXVlcnlTdHJpbmcpKTt2YXIgcj1uLmxlbmd0aD4wP25bbi5sZW5ndGgtMV06bnVsbDt2YXIgbz1yJiZyLnNoYWRvd1Jvb3Q7aWYobyl7cj1vLnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZyl8fHJ9aWYocil7ci5mb2N1cygpfWVsc2V7dC5mb2N1cygpfX07dmFyIHRyYXBLZXlib2FyZEZvY3VzPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0T3ZlcmxheSh0LFwiaW9uLWFsZXJ0LGlvbi1hY3Rpb24tc2hlZXQsaW9uLWxvYWRpbmcsaW9uLW1vZGFsLGlvbi1waWNrZXIsaW9uLXBvcG92ZXJcIik7dmFyIHI9ZS50YXJnZXQ7aWYoIW58fCFyKXtyZXR1cm59aWYobi5jbGFzc0xpc3QuY29udGFpbnMoXCJpb24tZGlzYWJsZS1mb2N1cy10cmFwXCIpKXtyZXR1cm59dmFyIG89ZnVuY3Rpb24oKXtpZihuPT09cil7bi5sYXN0Rm9jdXM9dW5kZWZpbmVkfWVsc2V7dmFyIGU9Z2V0RWxlbWVudFJvb3Qobik7aWYoIWUuY29udGFpbnMocikpe3JldHVybn12YXIgbz1lLnF1ZXJ5U2VsZWN0b3IoXCIuaW9uLW92ZXJsYXktd3JhcHBlclwiKTtpZighbyl7cmV0dXJufWlmKG8uY29udGFpbnMocikpe24ubGFzdEZvY3VzPXJ9ZWxzZXt2YXIgaT1uLmxhc3RGb2N1cztmb2N1c0ZpcnN0RGVzY2VuZGFudChvLG4pO2lmKGk9PT10LmFjdGl2ZUVsZW1lbnQpe2ZvY3VzTGFzdERlc2NlbmRhbnQobyxuKX1uLmxhc3RGb2N1cz10LmFjdGl2ZUVsZW1lbnR9fX07dmFyIGk9ZnVuY3Rpb24oKXtpZihuLmNvbnRhaW5zKHIpKXtuLmxhc3RGb2N1cz1yfWVsc2V7dmFyIGU9bi5sYXN0Rm9jdXM7Zm9jdXNGaXJzdERlc2NlbmRhbnQobixuKTtpZihlPT09dC5hY3RpdmVFbGVtZW50KXtmb2N1c0xhc3REZXNjZW5kYW50KG4sbil9bi5sYXN0Rm9jdXM9dC5hY3RpdmVFbGVtZW50fX07aWYobi5zaGFkb3dSb290KXtpKCl9ZWxzZXtvKCl9fTt2YXIgY29ubmVjdExpc3RlbmVycz1mdW5jdGlvbihlKXtpZihsYXN0SWQ9PT0wKXtsYXN0SWQ9MTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLChmdW5jdGlvbih0KXt0cmFwS2V5Ym9hcmRGb2N1cyh0LGUpfSksdHJ1ZSk7ZS5hZGRFdmVudExpc3RlbmVyKFwiaW9uQmFja0J1dHRvblwiLChmdW5jdGlvbih0KXt2YXIgbj1nZXRPdmVybGF5KGUpO2lmKG4mJm4uYmFja2Ryb3BEaXNtaXNzKXt0LmRldGFpbC5yZWdpc3RlcihPVkVSTEFZX0JBQ0tfQlVUVE9OX1BSSU9SSVRZLChmdW5jdGlvbigpe3JldHVybiBuLmRpc21pc3ModW5kZWZpbmVkLEJBQ0tEUk9QKX0pKX19KSk7ZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwoZnVuY3Rpb24odCl7aWYodC5rZXk9PT1cIkVzY2FwZVwiKXt2YXIgbj1nZXRPdmVybGF5KGUpO2lmKG4mJm4uYmFja2Ryb3BEaXNtaXNzKXtuLmRpc21pc3ModW5kZWZpbmVkLEJBQ0tEUk9QKX19fSkpfX07dmFyIGRpc21pc3NPdmVybGF5PWZ1bmN0aW9uKGUsdCxuLHIsbyl7dmFyIGk9Z2V0T3ZlcmxheShlLHIsbyk7aWYoIWkpe3JldHVybiBQcm9taXNlLnJlamVjdChcIm92ZXJsYXkgZG9lcyBub3QgZXhpc3RcIil9cmV0dXJuIGkuZGlzbWlzcyh0LG4pfTt2YXIgZ2V0T3ZlcmxheXM9ZnVuY3Rpb24oZSx0KXtpZih0PT09dW5kZWZpbmVkKXt0PVwiaW9uLWFsZXJ0LGlvbi1hY3Rpb24tc2hlZXQsaW9uLWxvYWRpbmcsaW9uLW1vZGFsLGlvbi1waWNrZXIsaW9uLXBvcG92ZXIsaW9uLXRvYXN0XCJ9cmV0dXJuIEFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKHQpKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm92ZXJsYXlJbmRleD4wfSkpfTt2YXIgZ2V0T3ZlcmxheT1mdW5jdGlvbihlLHQsbil7dmFyIHI9Z2V0T3ZlcmxheXMoZSx0KS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiFpc092ZXJsYXlIaWRkZW4oZSl9KSk7cmV0dXJuIG49PT11bmRlZmluZWQ/cltyLmxlbmd0aC0xXTpyLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09bn0pKX07dmFyIHNldFJvb3RBcmlhSGlkZGVuPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9ZmFsc2V9dmFyIHQ9Z2V0QXBwUm9vdChkb2N1bWVudCk7dmFyIG49dC5xdWVyeVNlbGVjdG9yKFwiaW9uLXJvdXRlci1vdXRsZXQsIGlvbi1uYXYsICNpb24tdmlldy1jb250YWluZXItcm9vdFwiKTtpZighbil7cmV0dXJufWlmKGUpe24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIil9ZWxzZXtuLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpfX07dmFyIHByZXNlbnQ9ZnVuY3Rpb24oZSx0LG4scixvKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBpLGEscyxsLGM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6aWYoZS5wcmVzZW50ZWQpe3JldHVyblsyXX1zZXRSb290QXJpYUhpZGRlbih0cnVlKTtlLnByZXNlbnRlZD10cnVlO2Uud2lsbFByZXNlbnQuZW1pdCgpOyhpPWUud2lsbFByZXNlbnRTaG9ydGhhbmQpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5lbWl0KCk7cz1nZXRJb25Nb2RlKGUpO2w9ZS5lbnRlckFuaW1hdGlvbj9lLmVudGVyQW5pbWF0aW9uOmNvbmZpZy5nZXQodCxzPT09XCJpb3NcIj9uOnIpO3JldHVybls0LG92ZXJsYXlBbmltYXRpb24oZSxsLGUuZWwsbyldO2Nhc2UgMTpjPXUuc2VudCgpO2lmKGMpe2UuZGlkUHJlc2VudC5lbWl0KCk7KGE9ZS5kaWRQcmVzZW50U2hvcnRoYW5kKT09PW51bGx8fGE9PT12b2lkIDA/dm9pZCAwOmEuZW1pdCgpfWlmKGUuZWwudGFnTmFtZSE9PVwiSU9OLVRPQVNUXCIpe2ZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzKGUuZWwpfWlmKGUua2V5Ym9hcmRDbG9zZSl7ZS5lbC5mb2N1cygpfXJldHVyblsyXX19KSl9KSl9O3ZhciBmb2N1c1ByZXZpb3VzRWxlbWVudE9uRGlzbWlzcz1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6dD1kb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKCF0KXtyZXR1cm5bMl19bj10JiZ0LnNoYWRvd1Jvb3Q7aWYobil7dD1uLnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZyl8fHR9cmV0dXJuWzQsZS5vbkRpZERpc21pc3MoKV07Y2FzZSAxOnIuc2VudCgpO3QuZm9jdXMoKTtyZXR1cm5bMl19fSkpfSkpfTt2YXIgZGlzbWlzcz1mdW5jdGlvbihlLHQsbixyLG8saSxhKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBzLGwsYyx1LGQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHYpe3N3aXRjaCh2LmxhYmVsKXtjYXNlIDA6aWYoIWUucHJlc2VudGVkKXtyZXR1cm5bMixmYWxzZV19c2V0Um9vdEFyaWFIaWRkZW4oZmFsc2UpO2UucHJlc2VudGVkPWZhbHNlO3YubGFiZWw9MTtjYXNlIDE6di50cnlzLnB1c2goWzEsNCwsNV0pO2UuZWwuc3R5bGUuc2V0UHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiLFwibm9uZVwiKTtlLndpbGxEaXNtaXNzLmVtaXQoe2RhdGE6dCxyb2xlOm59KTsocz1lLndpbGxEaXNtaXNzU2hvcnRoYW5kKT09PW51bGx8fHM9PT12b2lkIDA/dm9pZCAwOnMuZW1pdCh7ZGF0YTp0LHJvbGU6bn0pO2M9Z2V0SW9uTW9kZShlKTt1PWUubGVhdmVBbmltYXRpb24/ZS5sZWF2ZUFuaW1hdGlvbjpjb25maWcuZ2V0KHIsYz09PVwiaW9zXCI/bzppKTtpZighKG4hPT1cImdlc3R1cmVcIikpcmV0dXJuWzMsM107cmV0dXJuWzQsb3ZlcmxheUFuaW1hdGlvbihlLHUsZS5lbCxhKV07Y2FzZSAyOnYuc2VudCgpO3YubGFiZWw9MztjYXNlIDM6ZS5kaWREaXNtaXNzLmVtaXQoe2RhdGE6dCxyb2xlOm59KTsobD1lLmRpZERpc21pc3NTaG9ydGhhbmQpPT09bnVsbHx8bD09PXZvaWQgMD92b2lkIDA6bC5lbWl0KHtkYXRhOnQscm9sZTpufSk7YWN0aXZlQW5pbWF0aW9ucy5kZWxldGUoZSk7ZS5lbC5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheS1oaWRkZW5cIik7ZS5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIpO3JldHVyblszLDVdO2Nhc2UgNDpkPXYuc2VudCgpO2NvbnNvbGUuZXJyb3IoZCk7cmV0dXJuWzMsNV07Y2FzZSA1OmUuZWwucmVtb3ZlKCk7cmV0dXJuWzIsdHJ1ZV19fSkpfSkpfTt2YXIgZ2V0QXBwUm9vdD1mdW5jdGlvbihlKXtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW9uLWFwcFwiKXx8ZS5ib2R5fTt2YXIgb3ZlcmxheUFuaW1hdGlvbj1mdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBvLGksYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocyl7c3dpdGNoKHMubGFiZWwpe2Nhc2UgMDpuLmNsYXNzTGlzdC5yZW1vdmUoXCJvdmVybGF5LWhpZGRlblwiKTtvPWUuZWw7aT10KG8scik7aWYoIWUuYW5pbWF0ZWR8fCFjb25maWcuZ2V0Qm9vbGVhbihcImFuaW1hdGVkXCIsdHJ1ZSkpe2kuZHVyYXRpb24oMCl9aWYoZS5rZXlib2FyZENsb3NlKXtpLmJlZm9yZUFkZFdyaXRlKChmdW5jdGlvbigpe3ZhciBlPW4ub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKGUmJmUubWF0Y2hlcyhcImlucHV0LGlvbi1pbnB1dCwgaW9uLXRleHRhcmVhXCIpKXtlLmJsdXIoKX19KSl9YT1hY3RpdmVBbmltYXRpb25zLmdldChlKXx8W107YWN0aXZlQW5pbWF0aW9ucy5zZXQoZSxfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sYSx0cnVlKSxbaV0sZmFsc2UpKTtyZXR1cm5bNCxpLnBsYXkoKV07Y2FzZSAxOnMuc2VudCgpO3JldHVyblsyLHRydWVdfX0pKX0pKX07dmFyIGV2ZW50TWV0aG9kPWZ1bmN0aW9uKGUsdCl7dmFyIG47dmFyIHI9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiBuPWV9KSk7b25jZUV2ZW50KGUsdCwoZnVuY3Rpb24oZSl7bihlLmRldGFpbCl9KSk7cmV0dXJuIHJ9O3ZhciBvbmNlRXZlbnQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWZ1bmN0aW9uKG8pe3JlbW92ZUV2ZW50TGlzdGVuZXIoZSx0LHIpO24obyl9O2FkZEV2ZW50TGlzdGVuZXIoZSx0LHIpfTt2YXIgaXNDYW5jZWw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1cImNhbmNlbFwifHxlPT09QkFDS0RST1B9O3ZhciBkZWZhdWx0R2F0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZSgpfTt2YXIgc2FmZUNhbGw9ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgZT09PVwiZnVuY3Rpb25cIil7dmFyIG49Y29uZmlnLmdldChcIl96b25lR2F0ZVwiLGRlZmF1bHRHYXRlKTtyZXR1cm4gbigoZnVuY3Rpb24oKXt0cnl7cmV0dXJuIGUodCl9Y2F0Y2goZSl7dGhyb3cgZX19KSl9cmV0dXJuIHVuZGVmaW5lZH07dmFyIEJBQ0tEUk9QPVwiYmFja2Ryb3BcIjtleHBvcnR7QkFDS0RST1AgYXMgQixhbGVydENvbnRyb2xsZXIgYXMgYSxhY3Rpb25TaGVldENvbnRyb2xsZXIgYXMgYixwb3BvdmVyQ29udHJvbGxlciBhcyBjLHByZXNlbnQgYXMgZCxwcmVwYXJlT3ZlcmxheSBhcyBlLGRpc21pc3MgYXMgZixldmVudE1ldGhvZCBhcyBnLGFjdGl2ZUFuaW1hdGlvbnMgYXMgaCxpc0NhbmNlbCBhcyBpLGZvY3VzRmlyc3REZXNjZW5kYW50IGFzIGosZ2V0T3ZlcmxheSBhcyBrLGxvYWRpbmdDb250cm9sbGVyIGFzIGwsbW9kYWxDb250cm9sbGVyIGFzIG0scGlja2VyQ29udHJvbGxlciBhcyBwLHNhZmVDYWxsIGFzIHMsdG9hc3RDb250cm9sbGVyIGFzIHR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46250\n')},75087:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// UNUSED EXPORTS: CreateAnimation, DefaultIonLifeCycleContext, IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonLifeCycleContext, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRedirect, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRoute, IonRouterContext, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonTabsContext, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicSafeString, IonicSlides, IonicSwiper, LocationHistory, NavContext, NavManager, RouteManagerContext, StackContext, ViewLifeCycleManager, ViewStacks, createAnimation, createGesture, generateId, getConfig, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation, setupIonicReact, useIonActionSheet, useIonAlert, useIonLoading, useIonModal, useIonPicker, useIonPopover, useIonRouter, useIonToast, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n// EXTERNAL MODULE: ./node_modules/@stencil/core/internal/client/index.js + 1 modules\nvar client = __webpack_require__(77210);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ionic-global.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nclass Config {\n  constructor() {\n    this.m = new Map();\n  }\n  reset(configObj) {\n    this.m = new Map(Object.entries(configObj));\n  }\n  get(key, fallback) {\n    const value = this.m.get(key);\n    return value !== undefined ? value : fallback;\n  }\n  getBoolean(key, fallback = false) {\n    const val = this.m.get(key);\n    if (val === undefined) {\n      return fallback;\n    }\n    if (typeof val === 'string') {\n      return val === 'true';\n    }\n    return !!val;\n  }\n  getNumber(key, fallback) {\n    const val = parseFloat(this.m.get(key));\n    return isNaN(val) ? (fallback !== undefined ? fallback : NaN) : val;\n  }\n  set(key, value) {\n    this.m.set(key, value);\n  }\n}\nconst ionic_global_config = /*@__PURE__*/ new Config();\nconst configFromSession = (win) => {\n  try {\n    const configStr = win.sessionStorage.getItem(IONIC_SESSION_KEY);\n    return configStr !== null ? JSON.parse(configStr) : {};\n  }\n  catch (e) {\n    return {};\n  }\n};\nconst saveConfig = (win, c) => {\n  try {\n    win.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c));\n  }\n  catch (e) {\n    return;\n  }\n};\nconst configFromURL = (win) => {\n  const configObj = {};\n  win.location.search\n    .slice(1)\n    .split('&')\n    .map(entry => entry.split('='))\n    .map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)])\n    .filter(([key]) => startsWith(key, IONIC_PREFIX))\n    .map(([key, value]) => [key.slice(IONIC_PREFIX.length), value])\n    .forEach(([key, value]) => {\n    configObj[key] = value;\n  });\n  return configObj;\n};\nconst startsWith = (input, search) => {\n  return input.substr(0, search.length) === search;\n};\nconst IONIC_PREFIX = 'ionic:';\nconst IONIC_SESSION_KEY = 'ionic-persist-config';\n\nconst getPlatforms = (win) => setupPlatforms(win);\nconst isPlatform = (winOrPlatform, platform) => {\n  if (typeof winOrPlatform === 'string') {\n    platform = winOrPlatform;\n    winOrPlatform = undefined;\n  }\n  return getPlatforms(winOrPlatform).includes(platform);\n};\nconst setupPlatforms = (win = window) => {\n  if (typeof win === 'undefined') {\n    return [];\n  }\n  win.Ionic = win.Ionic || {};\n  let platforms = win.Ionic.platforms;\n  if (platforms == null) {\n    platforms = win.Ionic.platforms = detectPlatforms(win);\n    platforms.forEach(p => win.document.documentElement.classList.add(`plt-${p}`));\n  }\n  return platforms;\n};\nconst detectPlatforms = (win) => {\n  const customPlatformMethods = ionic_global_config.get('platform');\n  return Object.keys(PLATFORMS_MAP).filter(p => {\n    const customMethod = customPlatformMethods && customPlatformMethods[p];\n    return typeof customMethod === 'function' ? customMethod(win) : PLATFORMS_MAP[p](win);\n  });\n};\nconst isMobileWeb = (win) => isMobile(win) && !isHybrid(win);\nconst isIpad = (win) => {\n  // iOS 12 and below\n  if (testUserAgent(win, /iPad/i)) {\n    return true;\n  }\n  // iOS 13+\n  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {\n    return true;\n  }\n  return false;\n};\nconst isIphone = (win) => testUserAgent(win, /iPhone/i);\nconst isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);\nconst isAndroid = (win) => testUserAgent(win, /android|sink/i);\nconst isAndroidTablet = (win) => {\n  return isAndroid(win) && !testUserAgent(win, /mobile/i);\n};\nconst isPhablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (smallest > 390 && smallest < 520) &&\n    (largest > 620 && largest < 800);\n};\nconst isTablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (isIpad(win) ||\n    isAndroidTablet(win) ||\n    ((smallest > 460 && smallest < 820) &&\n      (largest > 780 && largest < 1400)));\n};\nconst isMobile = (win) => matchMedia(win, '(any-pointer:coarse)');\nconst isDesktop = (win) => !isMobile(win);\nconst isHybrid = (win) => isCordova(win) || isCapacitorNative(win);\nconst isCordova = (win) => !!(win['cordova'] || win['phonegap'] || win['PhoneGap']);\nconst isCapacitorNative = (win) => {\n  const capacitor = win['Capacitor'];\n  return !!(capacitor && capacitor.isNative);\n};\nconst isElectron = (win) => testUserAgent(win, /electron/i);\nconst isPWA = (win) => !!((win.matchMedia && win.matchMedia('(display-mode: standalone)').matches) || win.navigator.standalone);\nconst testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);\nconst matchMedia = (win, query) => win.matchMedia && win.matchMedia(query).matches;\nconst PLATFORMS_MAP = {\n  'ipad': isIpad,\n  'iphone': isIphone,\n  'ios': isIOS,\n  'android': isAndroid,\n  'phablet': isPhablet,\n  'tablet': isTablet,\n  'cordova': isCordova,\n  'capacitor': isCapacitorNative,\n  'electron': isElectron,\n  'pwa': isPWA,\n  'mobile': isMobile,\n  'mobileweb': isMobileWeb,\n  'desktop': isDesktop,\n  'hybrid': isHybrid\n};\n\nlet defaultMode;\nconst ionic_global_getIonMode = (ref) => {\n  return (ref && (0,client/* getMode */.iJ)(ref)) || defaultMode;\n};\nconst ionic_global_initialize = (userConfig = {}) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const doc = window.document;\n  const win = window;\n  Context.config = ionic_global_config;\n  const Ionic = win.Ionic = win.Ionic || {};\n  const platformHelpers = {};\n  if (userConfig._ael) {\n    platformHelpers.ael = userConfig._ael;\n  }\n  if (userConfig._rel) {\n    platformHelpers.rel = userConfig._rel;\n  }\n  if (userConfig._ce) {\n    platformHelpers.ce = userConfig._ce;\n  }\n  setPlatformHelpers(platformHelpers);\n  // create the Ionic.config from raw config object (if it exists)\n  // and convert Ionic.config into a ConfigApi that has a get() fn\n  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win)), { persistConfig: false }), Ionic.config), configFromURL(win)), userConfig);\n  ionic_global_config.reset(configObj);\n  if (ionic_global_config.getBoolean('persistConfig')) {\n    saveConfig(win, configObj);\n  }\n  // Setup platforms\n  setupPlatforms(win);\n  // first see if the mode was set as an attribute on <html>\n  // which could have been set by the user, or by pre-rendering\n  // otherwise get the mode via config settings, and fallback to md\n  Ionic.config = ionic_global_config;\n  Ionic.mode = defaultMode = ionic_global_config.get('mode', (doc.documentElement.getAttribute('mode')) || (isPlatform(win, 'ios') ? 'ios' : 'md'));\n  ionic_global_config.set('mode', defaultMode);\n  doc.documentElement.setAttribute('mode', defaultMode);\n  doc.documentElement.classList.add(defaultMode);\n  if (ionic_global_config.getBoolean('_testing')) {\n    ionic_global_config.set('animated', false);\n  }\n  const isIonicElement = (elm) => elm.tagName && elm.tagName.startsWith('ION-');\n  const isAllowedIonicModeValue = (elmMode) => ['ios', 'md'].includes(elmMode);\n  setMode((elm) => {\n    while (elm) {\n      const elmMode = elm.mode || elm.getAttribute('mode');\n      if (elmMode) {\n        if (isAllowedIonicModeValue(elmMode)) {\n          return elmMode;\n        }\n        else if (isIonicElement(elm)) {\n          console.warn('Invalid ionic mode: \"' + elmMode + '\", expected: \"ios\" or \"md\"');\n        }\n      }\n      elm = elm.parentElement;\n    }\n    return defaultMode;\n  });\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/helpers.js\nvar helpers = __webpack_require__(96587);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/overlays.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getOverlay(document, tagName);\n    }\n  };\n};\nconst overlays_alertController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-alert')));\nconst actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nconst overlays_loadingController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-loading')));\nconst overlays_modalController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-modal')));\nconst overlays_pickerController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-picker')));\nconst overlays_popoverController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-popover')));\nconst toastController = /*@__PURE__*/ createController('ion-toast');\nconst prepareOverlay = (el) => {\n  /* tslint:disable-next-line */\n  if (typeof document !== 'undefined') {\n    connectListeners(document);\n  }\n  const overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${overlayIndex}`;\n  }\n};\nconst createOverlay = (tagName, opts) => {\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise(resolve => (0,helpers.c)(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]), input:not([type=hidden]):not([tabindex^=\"-\"]), textarea:not([tabindex^=\"-\"]), button:not([tabindex^=\"-\"]), select:not([tabindex^=\"-\"]), .ion-focusable:not([tabindex^=\"-\"])';\nconst innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';\nconst focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput && firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput && lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    }\n    else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      }\n      else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    }\n    else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  }\n  else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = (doc) => {\n  if (lastId === 0) {\n    lastId = 1;\n    doc.addEventListener('focus', (ev) => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', ev => {\n      const lastOverlay = getOverlay(doc);\n      if (lastOverlay && lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keyup', ev => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getOverlay(doc);\n        if (lastOverlay && lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\nconst getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector))\n    .filter(c => c.overlayIndex > 0);\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getOverlay = (doc, overlayTag, id) => {\n  const overlays = getOverlays(doc, overlayTag).filter(o => !isOverlayHidden(o));\n  return (id === undefined)\n    ? overlays[overlays.length - 1]\n    : overlays.find(o => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  }\n  else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = (overlay.enterAnimation)\n    ? overlay.enterAnimation\n    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  if (overlay.keyboardClose) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement && previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  setRootAriaHidden(false);\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({ data, role });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n    const mode = getIonMode(overlay);\n    const animationBuilder = (overlay.leaveAnimation)\n      ? overlay.leaveAnimation\n      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== 'gesture') {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({ data, role });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n  }\n  catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = (doc) => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement && activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nconst eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise(r => resolve = r);\n  onceEvent(element, eventName, (event) => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n  const handler = (ev) => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nconst isCancel = (role) => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      }\n      catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nconst BACKDROP = 'backdrop';\n\n\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(70655);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(73935);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/cubic-bezier.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Based on:\n * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier\n * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves\n * TODO: Reduce rounding error\n */\n/**\n * EXPERIMENTAL\n * Given a cubic-bezier curve, get the x value (time) given\n * the y value (progression).\n * Ex: cubic-bezier(0.32, 0.72, 0, 1);\n * P0: (0, 0)\n * P1: (0.32, 0.72)\n * P2: (0, 1)\n * P3: (1, 1)\n *\n * If you give a cubic bezier curve that never reaches the\n * provided progression, this function will return an empty array.\n */\nconst getTimeGivenProgression = (p0, p1, p2, p3, progression) => {\n  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {\n    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);\n  });\n};\n/**\n * Solve a cubic equation in one dimension (time)\n */\nconst solveCubicParametricEquation = (p0, p1, p2, p3, t) => {\n  const partA = (3 * p1) * Math.pow(t - 1, 2);\n  const partB = (-3 * p2 * t) + (3 * p2) + (p3 * t);\n  const partC = p0 * Math.pow(t - 1, 3);\n  return t * (partA + (t * partB)) - partC;\n};\n/**\n * Find the `t` value for a cubic bezier using Cardano's formula\n */\nconst solveCubicBezier = (p0, p1, p2, p3, refPoint) => {\n  p0 -= refPoint;\n  p1 -= refPoint;\n  p2 -= refPoint;\n  p3 -= refPoint;\n  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);\n  return roots.filter(root => root >= 0 && root <= 1);\n};\nconst solveQuadraticEquation = (a, b, c) => {\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant < 0) {\n    return [];\n  }\n  else {\n    return [\n      (-b + Math.sqrt(discriminant)) / (2 * a),\n      (-b - Math.sqrt(discriminant)) / (2 * a)\n    ];\n  }\n};\nconst solveCubicEquation = (a, b, c, d) => {\n  if (a === 0) {\n    return solveQuadraticEquation(b, c, d);\n  }\n  b /= a;\n  c /= a;\n  d /= a;\n  const p = (3 * c - b * b) / 3;\n  const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;\n  if (p === 0) {\n    return [Math.pow(-q, 1 / 3)];\n  }\n  else if (q === 0) {\n    return [Math.sqrt(-p), -Math.sqrt(-p)];\n  }\n  const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);\n  if (discriminant === 0) {\n    return [Math.pow(q / 2, 1 / 2) - b / 3];\n  }\n  else if (discriminant > 0) {\n    return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow((q / 2) + Math.sqrt(discriminant), 1 / 3) - b / 3];\n  }\n  const r = Math.sqrt(Math.pow(-(p / 3), 3));\n  const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));\n  const s = 2 * Math.pow(r, 1 / 3);\n  return [\n    s * Math.cos(phi / 3) - b / 3,\n    s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3,\n    s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3\n  ];\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/framework-delegate.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {\n  if (delegate) {\n    return delegate.attachViewToDom(container, component, componentProps, cssClasses);\n  }\n  if (!inline && typeof component !== 'string' && !(component instanceof HTMLElement)) {\n    throw new Error('framework delegate is missing');\n  }\n  const el = (typeof component === 'string')\n    ? container.ownerDocument && container.ownerDocument.createElement(component)\n    : component;\n  if (cssClasses) {\n    cssClasses.forEach(c => el.classList.add(c));\n  }\n  if (componentProps) {\n    Object.assign(el, componentProps);\n  }\n  container.appendChild(el);\n  await new Promise(resolve => (0,helpers.c)(el, resolve));\n  return el;\n};\nconst detachComponent = (delegate, element) => {\n  if (element) {\n    if (delegate) {\n      const container = element.parentElement;\n      return delegate.removeViewFromDom(container, element);\n    }\n    element.remove();\n  }\n  return Promise.resolve();\n};\nconst CoreDelegate = () => {\n  let BaseComponent;\n  let Reference;\n  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {\n    BaseComponent = parentElement;\n    /**\n     * If passing in a component via the `component` props\n     * we need to append it inside of our overlay component.\n     */\n    if (userComponent) {\n      /**\n       * If passing in the tag name, create\n       * the element otherwise just get a reference\n       * to the component.\n       */\n      const el = (typeof userComponent === 'string')\n        ? BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement(userComponent)\n        : userComponent;\n      /**\n       * Add any css classes passed in\n       * via the cssClasses prop on the overlay.\n       */\n      cssClasses.forEach(c => el.classList.add(c));\n      /**\n       * Add any props passed in\n       * via the componentProps prop on the overlay.\n       */\n      Object.assign(el, userComponentProps);\n      /**\n       * Finally, append the component\n       * inside of the overlay component.\n       */\n      BaseComponent.appendChild(el);\n      await new Promise(resolve => componentOnReady(el, resolve));\n    }\n    else if (BaseComponent.children.length > 0) {\n      // If there is no component, then we need to create a new parent\n      // element to apply the css classes to.\n      const el = BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement('div');\n      cssClasses.forEach(c => el.classList.add(c));\n      // Move each child from the original template to the new parent element.\n      el.append(...BaseComponent.children);\n      // Append the new parent element to the original parent element.\n      BaseComponent.appendChild(el);\n    }\n    /**\n     * Get the root of the app and\n     * add the overlay there.\n     */\n    const app = document.querySelector('ion-app') || document.body;\n    /**\n     * Create a placeholder comment so that\n     * we can return this component to where\n     * it was previously.\n     */\n    Reference = document.createComment('ionic teleport');\n    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);\n    app.appendChild(BaseComponent);\n    return BaseComponent;\n  };\n  const removeViewFromDom = () => {\n    /**\n     * Return component to where it was previously in the DOM.\n     */\n    if (BaseComponent && Reference) {\n      Reference.parentNode.insertBefore(BaseComponent, Reference);\n      Reference.remove();\n    }\n    return Promise.resolve();\n  };\n  return { attachViewToDom, removeViewFromDom };\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/index4.js\nvar index4 = __webpack_require__(55026);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-router-outlet.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\n\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\n\nconst RouterOutlet = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = (0,client/* createEvent */.yM)(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = (0,client/* createEvent */.yM)(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = (0,client/* createEvent */.yM)(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ionic_global_getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await __webpack_require__.e(/* import() */ 6167).then(__webpack_require__.bind(__webpack_require__, 86167))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => this.ani && this.ani.progressStep(step), (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = (shouldComplete) ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation\n    });\n    return {\n      changed,\n      element: this.activeEl\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active ? {\n      id: active.tagName,\n      element: active,\n      params: this.activeParams,\n    } : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && (0,helpers.s)(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && ionic_global_config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || ionic_global_config.get('navAnimation');\n    await (0,index4.t)(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el, progressCallback: (opts.progressAnimation\n        ? ani => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined) }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return ((0,client.h)(\"slot\", null));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"swipeHandler\": [\"swipeHandlerChanged\"]\n  }; }\n  static get style() { return routeOutletCss; }\n}, [1, \"ion-router-outlet\", {\n    \"mode\": [1025],\n    \"delegate\": [16],\n    \"animated\": [4],\n    \"animation\": [16],\n    \"swipeHandler\": [16],\n    \"commit\": [64],\n    \"setRouteId\": [64],\n    \"getRouteId\": [64]\n  }]);\nfunction ion_router_outlet_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router-outlet\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RouterOutlet);\n      }\n      break;\n  } });\n}\n\nconst IonRouterOutlet = (/* unused pure expression or super */ null && (RouterOutlet));\nconst defineCustomElement = ion_router_outlet_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/theme.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return (typeof color === 'string' && color.length > 0) ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter(c => c != null)\n      .map(c => c.trim())\n      .filter(c => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach(c => map[c] = true);\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-bar.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabBarIosCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-400, #999999));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}\";\n\nconst tabBarMdCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}\";\n\nconst TabBar = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabBarChanged = (0,client/* createEvent */.yM)(this, \"ionTabBarChanged\", 7);\n    this.keyboardVisible = false;\n    /**\n     * If `true`, the tab bar will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n    this.translucent = false;\n  }\n  selectedTabChanged() {\n    if (this.selectedTab !== undefined) {\n      this.ionTabBarChanged.emit({\n        tab: this.selectedTab\n      });\n    }\n  }\n  componentWillLoad() {\n    this.selectedTabChanged();\n  }\n  connectedCallback() {\n    if (typeof window !== 'undefined') {\n      this.keyboardWillShowHandler = () => {\n        if (this.el.getAttribute('slot') !== 'top') {\n          this.keyboardVisible = true;\n        }\n      };\n      this.keyboardWillHideHandler = () => {\n        setTimeout(() => this.keyboardVisible = false, 50);\n      };\n      window.addEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.addEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n    }\n  }\n  disconnectedCallback() {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.removeEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n      this.keyboardWillShowHandler = this.keyboardWillHideHandler = undefined;\n    }\n  }\n  render() {\n    const { color, translucent, keyboardVisible } = this;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"tablist\", \"aria-hidden\": keyboardVisible ? 'true' : null, class: createColorClasses(color, {\n        [mode]: true,\n        'tab-bar-translucent': translucent,\n        'tab-bar-hidden': keyboardVisible,\n      }) }, (0,client.h)(\"slot\", null)));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"selectedTab\": [\"selectedTabChanged\"]\n  }; }\n  static get style() { return {\n    ios: tabBarIosCss,\n    md: tabBarMdCss\n  }; }\n}, [33, \"ion-tab-bar\", {\n    \"color\": [513],\n    \"selectedTab\": [1, \"selected-tab\"],\n    \"translucent\": [4],\n    \"keyboardVisible\": [32]\n  }]);\nfunction ion_tab_bar_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-bar\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-bar\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabBar);\n      }\n      break;\n  } });\n}\n\nconst IonTabBar = (/* unused pure expression or super */ null && (TabBar));\nconst ion_tab_bar_defineCustomElement = ion_tab_bar_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ripple-effect.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst rippleEffectCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}\";\n\nconst RippleEffect = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    /**\n     * Sets the type of ripple-effect:\n     *\n     * - `bounded`: the ripple effect expands from the user's click position\n     * - `unbounded`: the ripple effect expands from the center of the button and overflows the container.\n     *\n     * NOTE: Surfaces for bounded ripples should have the overflow property set to hidden,\n     * while surfaces for unbounded ripples should have it set to visible.\n     */\n    this.type = 'bounded';\n  }\n  /**\n   * Adds the ripple effect to the parent element.\n   *\n   * @param x The horizontal coordinate of where the ripple should start.\n   * @param y The vertical coordinate of where the ripple should start.\n   */\n  async addRipple(x, y) {\n    return new Promise(resolve => {\n      (0,client/* readTask */.wj)(() => {\n        const rect = this.el.getBoundingClientRect();\n        const width = rect.width;\n        const height = rect.height;\n        const hypotenuse = Math.sqrt(width * width + height * height);\n        const maxDim = Math.max(height, width);\n        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;\n        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n        const finalScale = maxRadius / initialSize;\n        let posX = x - rect.left;\n        let posY = y - rect.top;\n        if (this.unbounded) {\n          posX = width * 0.5;\n          posY = height * 0.5;\n        }\n        const styleX = posX - initialSize * 0.5;\n        const styleY = posY - initialSize * 0.5;\n        const moveX = width * 0.5 - posX;\n        const moveY = height * 0.5 - posY;\n        (0,client/* writeTask */.Iu)(() => {\n          const div = document.createElement('div');\n          div.classList.add('ripple-effect');\n          const style = div.style;\n          style.top = styleY + 'px';\n          style.left = styleX + 'px';\n          style.width = style.height = initialSize + 'px';\n          style.setProperty('--final-scale', `${finalScale}`);\n          style.setProperty('--translate-end', `${moveX}px, ${moveY}px`);\n          const container = this.el.shadowRoot || this.el;\n          container.appendChild(div);\n          setTimeout(() => {\n            resolve(() => {\n              removeRipple(div);\n            });\n          }, 225 + 100);\n        });\n      });\n    });\n  }\n  get unbounded() {\n    return this.type === 'unbounded';\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"presentation\", class: {\n        [mode]: true,\n        'unbounded': this.unbounded\n      } }));\n  }\n  get el() { return this; }\n  static get style() { return rippleEffectCss; }\n}, [1, \"ion-ripple-effect\", {\n    \"type\": [1],\n    \"addRipple\": [64]\n  }]);\nconst removeRipple = (ripple) => {\n  ripple.classList.add('fade-out');\n  setTimeout(() => {\n    ripple.remove();\n  }, 200);\n};\nconst PADDING = 10;\nconst INITIAL_ORIGIN_SCALE = 0.5;\nfunction ripple_effect_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RippleEffect);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-button.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabButtonIosCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){padding-left:6px;padding-right:6px;padding-top:1px;padding-bottom:1px;left:calc(50% + 6px);top:4px;height:auto;font-size:12px;line-height:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\n\nconst tabButtonMdCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}[dir=rtl] ::slotted(ion-icon),:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}::slotted(ion-badge){border-radius:8px;padding-left:2px;padding-right:2px;padding-top:3px;padding-bottom:2px;left:calc(50% + 6px);top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%;top:8px}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:unset;-webkit-margin-end:6px;margin-inline-end:6px}}:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:unset;-webkit-margin-start:6px;margin-inline-start:6px}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}\";\n\nconst TabButton = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabButtonClick = (0,client/* createEvent */.yM)(this, \"ionTabButtonClick\", 7);\n    /**\n     * If `true`, the user cannot interact with the tab button.\n     */\n    this.disabled = false;\n    /**\n     * The selected tab component\n     */\n    this.selected = false;\n    this.onKeyUp = (ev) => {\n      if (ev.key === 'Enter' || ev.key === ' ') {\n        this.selectTab(ev);\n      }\n    };\n    this.onClick = (ev) => {\n      this.selectTab(ev);\n    };\n  }\n  onTabBarChanged(ev) {\n    const dispatchedFrom = ev.target;\n    const parent = this.el.parentElement;\n    if ((ev.composedPath && ev.composedPath().includes(parent)) || (dispatchedFrom && dispatchedFrom.contains(this.el))) {\n      this.selected = this.tab === ev.detail.tab;\n    }\n  }\n  componentWillLoad() {\n    if (this.layout === undefined) {\n      this.layout = ionic_global_config.get('tabButtonLayout', 'icon-top');\n    }\n  }\n  selectTab(ev) {\n    if (this.tab !== undefined) {\n      if (!this.disabled) {\n        this.ionTabButtonClick.emit({\n          tab: this.tab,\n          href: this.href,\n          selected: this.selected\n        });\n      }\n      ev.preventDefault();\n    }\n  }\n  get hasLabel() {\n    return !!this.el.querySelector('ion-label');\n  }\n  get hasIcon() {\n    return !!this.el.querySelector('ion-icon');\n  }\n  get tabIndex() {\n    if (this.disabled) {\n      return -1;\n    }\n    const hasTabIndex = this.el.hasAttribute('tabindex');\n    if (hasTabIndex) {\n      return this.el.getAttribute('tabindex');\n    }\n    return 0;\n  }\n  render() {\n    const { disabled, hasIcon, hasLabel, tabIndex, href, rel, target, layout, selected, tab } = this;\n    const mode = ionic_global_getIonMode(this);\n    const attrs = {\n      download: this.download,\n      href,\n      rel,\n      target\n    };\n    return ((0,client.h)(client/* Host */.AA, { onClick: this.onClick, onKeyup: this.onKeyUp, role: \"tab\", tabindex: tabIndex, \"aria-selected\": selected ? 'true' : null, id: tab !== undefined ? `tab-button-${tab}` : null, class: {\n        [mode]: true,\n        'tab-selected': selected,\n        'tab-disabled': disabled,\n        'tab-has-label': hasLabel,\n        'tab-has-icon': hasIcon,\n        'tab-has-label-only': hasLabel && !hasIcon,\n        'tab-has-icon-only': hasIcon && !hasLabel,\n        [`tab-layout-${layout}`]: true,\n        'ion-activatable': true,\n        'ion-selectable': true,\n        'ion-focusable': true\n      } }, (0,client.h)(\"a\", Object.assign({}, attrs, { tabIndex: -1, class: \"button-native\", part: \"native\" }), (0,client.h)(\"span\", { class: \"button-inner\" }, (0,client.h)(\"slot\", null)), mode === 'md' && (0,client.h)(\"ion-ripple-effect\", { type: \"unbounded\" }))));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: tabButtonIosCss,\n    md: tabButtonMdCss\n  }; }\n}, [33, \"ion-tab-button\", {\n    \"disabled\": [4],\n    \"download\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"layout\": [1025],\n    \"selected\": [1028],\n    \"tab\": [1],\n    \"target\": [1]\n  }, [[8, \"ionTabBarChanged\", \"onTabBarChanged\"]]]);\nfunction ion_tab_button_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-button\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-button\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabButton);\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        ripple_effect_defineCustomElement();\n      }\n      break;\n  } });\n}\n\nconst IonTabButton = (/* unused pure expression or super */ null && (TabButton));\nconst ion_tab_button_defineCustomElement = ion_tab_button_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.12.1 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst client_setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst client_Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst client_setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => client_safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = client_safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = client_safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => client_safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        client_safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            client_safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            client_safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst client_safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && newVal !== oldVal) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 5880).then(__webpack_require__.bind(__webpack_require__, 5880)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        client_safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            client_safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            client_safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst client_defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in client_Context) {\n        return client_Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst client_Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(11875)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ (/* unused pure expression or super */ null && (queueTask(queueDomReads, false)));\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/utils.js\n\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  }\n  else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = (icons) => {\n  const map = getIconMap();\n  Object.keys(icons).forEach(name => map.set(name, icons[name]));\n};\nconst getUrl = (i) => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  return getAssetPath(`svg/${iconName}.svg`);\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  }\n  else if (md && mode === 'md') {\n    iconName = toLower(md);\n  }\n  else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = (src) => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/ion-icon.js\n\n\n\nconst validateContent = (svgContent) => {\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // setup this way to ensure it works on our buddy IE\n  for (let i = div.childNodes.length - 1; i >= 0; i--) {\n    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n      div.removeChild(div.childNodes[i]);\n    }\n  }\n  // must only have 1 root element\n  const svgElm = div.firstElementChild;\n  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n    const svgClass = svgElm.getAttribute('class') || '';\n    svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());\n    // root element must be an svg\n    // lets double check we've got valid elements\n    // do not allow scripts\n    if (isValid(svgElm)) {\n      return div.innerHTML;\n    }\n  }\n  return '';\n};\nconst isValid = (elm) => {\n  if (elm.nodeType === 1) {\n    if (elm.nodeName.toLowerCase() === 'script') {\n      return false;\n    }\n    for (let i = 0; i < elm.attributes.length; i++) {\n      const val = elm.attributes[i].value;\n      if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\n        return false;\n      }\n    }\n    for (let i = 0; i < elm.childNodes.length; i++) {\n      if (!isValid(elm.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconst ioniconContent = new Map();\nconst requests = new Map();\nconst getSvgContent = (url, sanitize) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            ioniconContent.set(url, svgContent || '');\n          });\n        }\n        ioniconContent.set(url, '');\n      });\n      // cache for the same requests\n      requests.set(url, req);\n    }\n    else {\n      // set to empty for ssr scenarios and resolve promise\n      ioniconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n  return req;\n};\n\nconst iconCss = \":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}\";\n\nlet Icon = class extends H {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.iconName = null;\n    this.inheritedAttributes = {};\n    this.isVisible = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ion_icon_getIonMode();\n    /**\n     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\n     * Default, `false`.\n     */\n    this.lazy = false;\n    /**\n     * When set to `false`, SVG content that is HTTP fetched will not be checked\n     * if the response SVG content has any `<script>` elements, or any attributes\n     * that start with `on`, such as `onclick`.\n     * @default true\n     */\n    this.sanitize = true;\n    this.hasAriaHidden = () => {\n      const { el } = this;\n      return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';\n    };\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n  }\n  connectedCallback() {\n    // purposely do not return the promise here because loading\n    // the svg file should not hold up loading the app\n    // only load the svg if it's visible\n    this.waitUntilVisible(this.el, '50px', () => {\n      this.isVisible = true;\n      this.loadIcon();\n    });\n  }\n  disconnectedCallback() {\n    if (this.io) {\n      this.io.disconnect();\n      this.io = undefined;\n    }\n  }\n  waitUntilVisible(el, rootMargin, cb) {\n    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {\n      const io = (this.io = new window.IntersectionObserver((data) => {\n        if (data[0].isIntersecting) {\n          io.disconnect();\n          this.io = undefined;\n          cb();\n        }\n      }, { rootMargin }));\n      io.observe(el);\n    }\n    else {\n      // browser doesn't support IntersectionObserver\n      // so just fallback to always show it\n      cb();\n    }\n  }\n  loadIcon() {\n    if (Build.isBrowser && this.isVisible) {\n      const url = getUrl(this);\n      if (url) {\n        if (ioniconContent.has(url)) {\n          // sync if it's already loaded\n          this.svgContent = ioniconContent.get(url);\n        }\n        else {\n          // async if it hasn't been loaded\n          getSvgContent(url, this.sanitize).then(() => (this.svgContent = ioniconContent.get(url)));\n        }\n      }\n    }\n    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);\n    /**\n     * Come up with a default label\n     * in case user does not provide their own.\n     */\n    if (label) {\n      this.ariaLabel = label.replace(/\\-/g, ' ');\n    }\n  }\n  render() {\n    const { iconName, ariaLabel, inheritedAttributes } = this;\n    const mode = this.mode || 'md';\n    const flipRtl = this.flipRtl ||\n      (iconName &&\n        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&\n        this.flipRtl !== false);\n    /**\n     * Only set the aria-label if a) we have generated\n     * one for the icon and if aria-hidden is not set to \"true\".\n     * If developer wants to set their own aria-label, then\n     * inheritedAttributes down below will override whatever\n     * default label we have set.\n     */\n    return (h(Host, Object.assign({ \"aria-label\": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: \"img\", class: Object.assign(Object.assign({ [mode]: true }, ion_icon_createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, inheritedAttributes), Build.isBrowser && this.svgContent ? (h(\"div\", { class: \"icon-inner\", innerHTML: this.svgContent })) : (h(\"div\", { class: \"icon-inner\" }))));\n  }\n  static get assetsDirs() { return [\"svg\"]; }\n  get el() { return this; }\n  static get watchers() { return {\n    \"name\": [\"loadIcon\"],\n    \"src\": [\"loadIcon\"],\n    \"icon\": [\"loadIcon\"]\n  }; }\n  static get style() { return iconCss; }\n};\nconst ion_icon_getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';\nconst ion_icon_createColorClasses = (color) => {\n  return color\n    ? {\n      'ion-color': true,\n      [`ion-color-${color}`]: true,\n    }\n    : null;\n};\nIcon = /*@__PURE__*/ proxyCustomElement(Icon, [1, \"ion-icon\", {\n    \"mode\": [1025],\n    \"color\": [1],\n    \"ios\": [1],\n    \"md\": [1],\n    \"flipRtl\": [4, \"flip-rtl\"],\n    \"name\": [513],\n    \"src\": [1],\n    \"icon\": [8],\n    \"size\": [1],\n    \"lazy\": [4],\n    \"sanitize\": [4],\n    \"svgContent\": [32],\n    \"isVisible\": [32],\n    \"ariaLabel\": [32]\n  }]);\nfunction ion_icon_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-icon\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-icon\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Icon);\n      }\n      break;\n  } });\n}\n\nconst IonIcon = (/* unused pure expression or super */ null && (Icon));\nconst ion_icon_defineCustomElement = ion_icon_defineCustomElement$1;\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/dist/esm-es5/index.js\nvar esm_es5 = __webpack_require__(53774);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/dist/index.js\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/react/dist/index.esm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IonLifeCycleContext = /*@__PURE__*/ react.createContext({\n    onIonViewWillEnter: () => {\n        return;\n    },\n    ionViewWillEnter: () => {\n        return;\n    },\n    onIonViewDidEnter: () => {\n        return;\n    },\n    ionViewDidEnter: () => {\n        return;\n    },\n    onIonViewWillLeave: () => {\n        return;\n    },\n    ionViewWillLeave: () => {\n        return;\n    },\n    onIonViewDidLeave: () => {\n        return;\n    },\n    ionViewDidLeave: () => {\n        return;\n    },\n});\nconst DefaultIonLifeCycleContext = class {\n    constructor() {\n        this.ionViewWillEnterCallbacks = [];\n        this.ionViewDidEnterCallbacks = [];\n        this.ionViewWillLeaveCallbacks = [];\n        this.ionViewDidLeaveCallbacks = [];\n    }\n    onIonViewWillEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillEnterCallbacks.push(callback);\n        }\n    }\n    ionViewWillEnter() {\n        this.ionViewWillEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidEnterCallbacks.push(callback);\n        }\n    }\n    ionViewDidEnter() {\n        this.ionViewDidEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewWillLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewWillLeave() {\n        this.ionViewWillLeaveCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewDidLeave() {\n        this.ionViewDidLeaveCallbacks.forEach((cb) => cb());\n        this.componentCanBeDestroyed();\n    }\n    onComponentCanBeDestroyed(callback) {\n        this.componentCanBeDestroyedCallback = callback;\n    }\n    componentCanBeDestroyed() {\n        if (this.componentCanBeDestroyedCallback) {\n            this.componentCanBeDestroyedCallback();\n        }\n    }\n};\n\nconst withIonLifeCycle = (WrappedComponent) => {\n    return class IonLifeCycle extends React.Component {\n        constructor(props) {\n            super(props);\n            this.componentRef = React.createRef();\n        }\n        componentDidMount() {\n            const element = this.componentRef.current;\n            this.context.onIonViewWillEnter(() => {\n                if (element && element.ionViewWillEnter) {\n                    element.ionViewWillEnter();\n                }\n            });\n            this.context.onIonViewDidEnter(() => {\n                if (element && element.ionViewDidEnter) {\n                    element.ionViewDidEnter();\n                }\n            });\n            this.context.onIonViewWillLeave(() => {\n                if (element && element.ionViewWillLeave) {\n                    element.ionViewWillLeave();\n                }\n            });\n            this.context.onIonViewDidLeave(() => {\n                if (element && element.ionViewDidLeave) {\n                    element.ionViewDidLeave();\n                }\n            });\n        }\n        render() {\n            return (React.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n                this.context = context;\n                return React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));\n            }));\n        }\n    };\n};\n\nconst useIonViewWillEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillEnter(callback);\n    }, deps);\n};\nconst useIonViewDidEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidEnter(callback);\n    }, deps);\n};\nconst useIonViewWillLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillLeave(callback);\n    }, deps);\n};\nconst useIonViewDidLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidLeave(callback);\n    }, deps);\n};\n\nconst NavContext = /*@__PURE__*/ react.createContext({\n    getIonRedirect: () => undefined,\n    getIonRoute: () => undefined,\n    getPageManager: () => undefined,\n    getStackManager: () => undefined,\n    goBack: (route) => {\n        if (typeof window !== 'undefined') {\n            if (typeof route === 'string') {\n                window.location.pathname = route;\n            }\n            else {\n                window.history.back();\n            }\n        }\n    },\n    navigate: (path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    hasIonicRouter: () => false,\n    routeInfo: undefined,\n    setCurrentTab: () => undefined,\n    changeTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    resetTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n});\n\nconst dashToPascalCase = (str) => str\n    .toLowerCase()\n    .split('-')\n    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))\n    .join('');\nconst camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);\n\nconst attachProps = (node, newProps, oldProps = {}) => {\n    // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n    if (node instanceof Element) {\n        // add any classes in className to the class list\n        const className = getClassName(node.classList, newProps, oldProps);\n        if (className !== '') {\n            node.className = className;\n        }\n        Object.keys(newProps).forEach((name) => {\n            if (name === 'children' ||\n                name === 'style' ||\n                name === 'ref' ||\n                name === 'class' ||\n                name === 'className' ||\n                name === 'forwardedRef') {\n                return;\n            }\n            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                const eventName = name.substring(2);\n                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n                if (!isCoveredByReact(eventNameLc)) {\n                    syncEvent(node, eventNameLc, newProps[name]);\n                }\n            }\n            else {\n                node[name] = newProps[name];\n                const propType = typeof newProps[name];\n                if (propType === 'string') {\n                    node.setAttribute(camelToDashCase(name), newProps[name]);\n                }\n            }\n        });\n    }\n};\nconst getClassName = (classList, newProps, oldProps) => {\n    const newClassProp = newProps.className || newProps.class;\n    const oldClassProp = oldProps.className || oldProps.class;\n    // map the classes to Maps for performance\n    const currentClasses = arrayToMap(classList);\n    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n    const finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach((currentClass) => {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach((s) => finalClassNames.push(s));\n    return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nconst isCoveredByReact = (eventNameSuffix) => {\n    if (typeof document === 'undefined') {\n        return true;\n    }\n    else {\n        const eventName = 'on' + eventNameSuffix;\n        let isSupported = eventName in document;\n        if (!isSupported) {\n            const element = document.createElement('div');\n            element.setAttribute(eventName, 'return;');\n            isSupported = typeof element[eventName] === 'function';\n        }\n        return isSupported;\n    }\n};\nconst syncEvent = (node, eventName, newEventHandler) => {\n    const eventStore = node.__events || (node.__events = {});\n    const oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    // Bind new listener.\n    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n        if (newEventHandler) {\n            newEventHandler.call(this, e);\n        }\n    }));\n};\nconst arrayToMap = (arr) => {\n    const map = new Map();\n    arr.forEach((s) => map.set(s, s));\n    return map;\n};\n\nconst setRef = (ref, value) => {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref != null) {\n        // Cast as a MutableRef so we can assign current\n        ref.current = value;\n    }\n};\nconst mergeRefs = (...refs) => {\n    return (value) => {\n        refs.forEach(ref => {\n            setRef(ref, value);\n        });\n    };\n};\nconst createForwardRef$1 = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_defineCustomElement = (tagName, customElement) => {\n    if (customElement !== undefined &&\n        typeof customElements !== 'undefined' &&\n        !customElements.get(tagName)) {\n        customElements.define(tagName, customElement);\n    }\n};\n\nconst createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends react.Component {\n        constructor(props) {\n            super(props);\n            this.setComponentElRef = (element) => {\n                this.componentEl = element;\n            };\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            attachProps(this.componentEl, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            let propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else {\n                    acc[name] = cProps[name];\n                }\n                return acc;\n            }, {});\n            if (manipulatePropsFunction) {\n                propsToPass = manipulatePropsFunction(this.props, propsToPass);\n            }\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });\n            /**\n             * We use createElement here instead of\n             * React.createElement to work around a\n             * bug in Vite (https://github.com/vitejs/vite/issues/6104).\n             * React.createElement causes all elements to be rendered\n             * as <tagname> instead of the actual Web Component.\n             */\n            return (0,react.createElement)(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    // If context was passed to createReactComponent then conditionally add it to the Component Class\n    if (ReactComponentContext) {\n        ReactComponent.contextType = ReactComponentContext;\n    }\n    return createForwardRef$1(ReactComponent, displayName);\n};\n\n/* eslint-disable */\nconst IonAccordion = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion', undefined, undefined, defineCustomElement$1)));\nconst IonAccordionGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion-group', undefined, undefined, defineCustomElement$2)));\nconst IonAvatar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-avatar', undefined, undefined, defineCustomElement$3)));\nconst IonBackdrop = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-backdrop', undefined, undefined, defineCustomElement$4)));\nconst IonBadge = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-badge', undefined, undefined, defineCustomElement$5)));\nconst IonBreadcrumbs = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-breadcrumbs', undefined, undefined, defineCustomElement$6)));\nconst IonButtons = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-buttons', undefined, undefined, defineCustomElement$7)));\nconst IonCardContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-content', undefined, undefined, defineCustomElement$8)));\nconst IonCardHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-header', undefined, undefined, defineCustomElement$9)));\nconst IonCardSubtitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-subtitle', undefined, undefined, defineCustomElement$a)));\nconst IonCardTitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-title', undefined, undefined, defineCustomElement$b)));\nconst IonCheckbox = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-checkbox', undefined, undefined, defineCustomElement$c)));\nconst IonChip = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-chip', undefined, undefined, defineCustomElement$d)));\nconst IonCol = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-col', undefined, undefined, defineCustomElement$e)));\nconst IonContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-content', undefined, undefined, defineCustomElement$f)));\nconst IonDatetime = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-datetime', undefined, undefined, defineCustomElement$g)));\nconst IonFab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab', undefined, undefined, defineCustomElement$h)));\nconst IonFabList = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab-list', undefined, undefined, defineCustomElement$i)));\nconst IonFooter = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-footer', undefined, undefined, defineCustomElement$j)));\nconst IonGrid = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-grid', undefined, undefined, defineCustomElement$k)));\nconst IonHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-header', undefined, undefined, defineCustomElement$l)));\nconst IonImg = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-img', undefined, undefined, defineCustomElement$m)));\nconst IonInfiniteScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll', undefined, undefined, defineCustomElement$n)));\nconst IonInfiniteScrollContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll-content', undefined, undefined, defineCustomElement$o)));\nconst IonInput = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-input', undefined, undefined, defineCustomElement$p)));\nconst IonItemDivider = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-divider', undefined, undefined, defineCustomElement$q)));\nconst IonItemGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-group', undefined, undefined, defineCustomElement$r)));\nconst IonItemOptions = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-options', undefined, undefined, defineCustomElement$s)));\nconst IonItemSliding = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-sliding', undefined, undefined, defineCustomElement$t)));\nconst IonLabel = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-label', undefined, undefined, defineCustomElement$u)));\nconst IonList = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-list', undefined, undefined, defineCustomElement$v)));\nconst IonListHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-list-header', undefined, undefined, defineCustomElement$w)));\nconst IonMenu = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu', undefined, undefined, defineCustomElement$x)));\nconst IonMenuButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-button', undefined, undefined, defineCustomElement$y)));\nconst IonMenuToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-toggle', undefined, undefined, defineCustomElement$z)));\nconst IonNav = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav', undefined, undefined, defineCustomElement$A)));\nconst IonNavLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav-link', undefined, undefined, defineCustomElement$B)));\nconst IonNote = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-note', undefined, undefined, defineCustomElement$C)));\nconst IonProgressBar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-progress-bar', undefined, undefined, defineCustomElement$D)));\nconst IonRadio = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio', undefined, undefined, defineCustomElement$E)));\nconst IonRadioGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio-group', undefined, undefined, defineCustomElement$F)));\nconst IonRange = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-range', undefined, undefined, defineCustomElement$G)));\nconst IonRefresher = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher', undefined, undefined, defineCustomElement$H)));\nconst IonRefresherContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher-content', undefined, undefined, defineCustomElement$I)));\nconst IonReorder = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder', undefined, undefined, defineCustomElement$J)));\nconst IonReorderGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder-group', undefined, undefined, defineCustomElement$K)));\nconst IonRippleEffect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-ripple-effect', undefined, undefined, defineCustomElement$L)));\nconst IonRow = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-row', undefined, undefined, defineCustomElement$M)));\nconst IonSearchbar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-searchbar', undefined, undefined, defineCustomElement$N)));\nconst IonSegment = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment', undefined, undefined, defineCustomElement$O)));\nconst IonSegmentButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment-button', undefined, undefined, defineCustomElement$P)));\nconst IonSelect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select', undefined, undefined, defineCustomElement$Q)));\nconst IonSelectOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select-option', undefined, undefined, defineCustomElement$R)));\nconst IonSkeletonText = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-skeleton-text', undefined, undefined, defineCustomElement$S)));\nconst IonSlide = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slide', undefined, undefined, defineCustomElement$T)));\nconst IonSlides = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slides', undefined, undefined, defineCustomElement$U)));\nconst IonSpinner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-spinner', undefined, undefined, defineCustomElement$V)));\nconst IonSplitPane = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-split-pane', undefined, undefined, defineCustomElement$W)));\nconst IonTab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-tab', undefined, undefined, defineCustomElement$X)));\nconst IonText = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-text', undefined, undefined, defineCustomElement$Y)));\nconst IonTextarea = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-textarea', undefined, undefined, defineCustomElement$Z)));\nconst IonThumbnail = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-thumbnail', undefined, undefined, defineCustomElement$_)));\nconst IonTitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-title', undefined, undefined, defineCustomElement$$)));\nconst IonToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-toggle', undefined, undefined, defineCustomElement$10)));\nconst IonToolbar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-toolbar', undefined, undefined, defineCustomElement$11)));\nconst IonVirtualScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-virtual-scroll', undefined, undefined, defineCustomElement$12)));\n\nconst createForwardRef = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_isPlatform = (platform) => {\n    return isPlatform(window, platform);\n};\nconst index_esm_getPlatforms = () => {\n    return getPlatforms$1(window);\n};\nconst getConfig = () => {\n    if (typeof window !== 'undefined') {\n        const Ionic = window.Ionic;\n        if (Ionic && Ionic.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n};\n\nconst createRoutingComponent = (tagName, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends React.Component {\n        constructor(props) {\n            super(props);\n            this.handleClick = (e) => {\n                const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;\n                if (routerLink !== undefined) {\n                    e.preventDefault();\n                    this.context.navigate(routerLink, routerDirection, undefined, routerAnimation, routerOptions);\n                }\n            };\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = React.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            if (this.props.routerLink && !this.props.href) {\n                newProps.href = this.props.routerLink;\n            }\n            if (newProps.onClick) {\n                const oldClick = newProps.onClick;\n                newProps.onClick = (e) => {\n                    oldClick(e);\n                    if (!e.defaultPrevented) {\n                        this.handleClick(e);\n                    }\n                };\n            }\n            else {\n                newProps.onClick = this.handleClick;\n            }\n            return createElement(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        static get contextType() {\n            return NavContext;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonRouterLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-router-link', IonRouterLink$1)));\nconst IonButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-button', IonButton$1)));\nconst IonCard = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-card', IonCard$1)));\nconst IonFabButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-fab-button', IonFabButton$1)));\nconst IonItem = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-item', IonItem$1)));\nconst IonItemOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-item-option', IonItemOption$1)));\nconst IonBreadcrumb = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-breadcrumb', IonBreadcrumb$1)));\n\nconst createControllerComponent = (tagName, controller, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isUnmounted = false;\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        async componentDidMount() {\n            const { isOpen } = this.props;\n            if (isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            this.isUnmounted = true;\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        async componentDidUpdate(prevProps) {\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            this.overlay = await controller.create(Object.assign({}, cProps));\n            attachProps(this.overlay, {\n                [didDismissEventName]: this.handleDismiss,\n                [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),\n                [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),\n                [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e),\n            }, prevProps);\n            // Check isOpen again since the value could have changed during the async call to controller.create\n            // It's also possible for the component to have become unmounted.\n            if (this.props.isOpen === true && this.isUnmounted === false) {\n                setRef(this.props.forwardedRef, this.overlay);\n                await this.overlay.present();\n            }\n        }\n        render() {\n            return null;\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst IonAlert = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-alert', alertController, IonAlert$1)));\n\nconst IonLoading = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-loading', loadingController, IonLoading$1)));\n\nconst index_esm_toastController = {\n    create: (options) => toastController.create(options),\n    dismiss: (data, role, id) => toastController.dismiss(data, role, id),\n    getTop: () => toastController.getTop(),\n};\nconst IonToast = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-toast', index_esm_toastController, IonToast$1)));\n\nconst IonPicker = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-picker', pickerController, IonPicker$1)));\n\nconst createOverlayComponent = (tagName, controller, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isDismissing = false;\n            if (typeof document !== 'undefined') {\n                this.el = document.createElement('div');\n            }\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        componentDidMount() {\n            if (this.props.isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        shouldComponentUpdate(nextProps) {\n            // Check if the overlay component is about to dismiss\n            if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {\n                this.isDismissing = true;\n            }\n            return true;\n        }\n        async componentDidUpdate(prevProps) {\n            if (this.overlay) {\n                attachProps(this.overlay, this.props, prevProps);\n            }\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n                this.isDismissing = false;\n                /**\n                 * Now that the overlay is dismissed\n                 * we need to render again so that any\n                 * inner components will be unmounted\n                 */\n                this.forceUpdate();\n            }\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"children\", \"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });\n            this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));\n            setRef(this.props.forwardedRef, this.overlay);\n            attachProps(this.overlay, elementProps, prevProps);\n            await this.overlay.present();\n        }\n        render() {\n            /**\n             * Continue to render the component even when\n             * overlay is dismissing otherwise component\n             * will be hidden before animation is done.\n             */\n            return ReactDOM.createPortal(this.props.isOpen || this.isDismissing ? this.props.children : null, this.el);\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst index_esm_actionSheetController = {\n    create: (options) => actionSheetController.create(options),\n    dismiss: (data, role, id) => actionSheetController.dismiss(data, role, id),\n    getTop: () => actionSheetController.getTop(),\n};\nconst IonActionSheet = /*@__PURE__*/ (/* unused pure expression or super */ null && (createOverlayComponent('ion-action-sheet', index_esm_actionSheetController, defineCustomElement$13)));\n\nconst createInlineOverlayComponent = (tagName, defineCustomElement) => {\n    if (defineCustomElement) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends React.Component {\n        constructor(props) {\n            super(props);\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = React.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n            // Component is hidden by default\n            this.state = { isOpen: false };\n            // Create a local ref to the inner child element.\n            this.wrapperRef = React.createRef();\n        }\n        componentDidMount() {\n            var _a, _b;\n            this.componentDidUpdate(this.props);\n            /**\n             * Mount the inner component\n             * when overlay is about to open.\n             * Also manually call the onWillPresent\n             * handler if present as setState will\n             * cause the event handlers to be\n             * destroyed and re-created.\n             */\n            (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('willPresent', (evt) => {\n                this.setState({ isOpen: true });\n                this.props.onWillPresent && this.props.onWillPresent(evt);\n            });\n            /**\n             * Unmount the inner component.\n             * React will call Node.removeChild\n             * which expects the child to be\n             * a direct descendent of the parent\n             * but due to the presence of\n             * Web Component slots, this is not\n             * always the case. To work around this\n             * we move the inner component to the root\n             * of the Web Component so React can\n             * cleanup properly.\n             */\n            (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('didDismiss', (evt) => {\n                const wrapper = this.wrapperRef.current;\n                const el = this.ref.current;\n                /**\n                 * This component might be unmounted already, if the containing\n                 * element was removed while the popover was still open. (For\n                 * example, if an item contains an inline popover with a button\n                 * that removes the item.)\n                 */\n                if (wrapper && el) {\n                    el.append(wrapper);\n                    this.setState({ isOpen: false });\n                }\n                this.props.onDidDismiss && this.props.onDidDismiss(evt);\n            });\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            /**\n             * We only want the inner component\n             * to be mounted if the overlay is open,\n             * so conditionally render the component\n             * based on the isOpen state.\n             */\n            return createElement(tagName, newProps, (this.state.isOpen) ?\n                createElement('div', {\n                    id: 'ion-react-wrapper',\n                    ref: this.wrapperRef,\n                    style: {\n                        display: 'flex',\n                        flexDirection: 'column',\n                        height: '100%'\n                    }\n                }, children) :\n                null);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonModal = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-modal', defineCustomElement$14)));\n\nconst IonPopover = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-popover', defineCustomElement$15)));\n\nconst IonContext = react.createContext({\n    addOverlay: () => {\n        return;\n    },\n    removeOverlay: () => {\n        return;\n    },\n});\n\n/**\n * Manages overlays that are added via the useOverlay hook.\n * This is a standalone component so changes to its children don't cause other descendant\n * components to re-render when overlays are added. However, we need to communicate with the IonContext\n * that is set up in <IonApp />, so we register callbacks so when overlays are added to IonContext,\n * they ultimately added here.\n */\nconst IonOverlayManager = ({ onAddOverlay, onRemoveOverlay, }) => {\n    /**\n     * Because of the way we're passing around the addOverlay and removeOverlay\n     * callbacks, by the time they finally get called, they use a stale reference\n     * to the state that only has the initial values. So if two overlays are opened\n     * at the same time, both using useIonModal or similar (such as through nesting),\n     * the second will erase the first from the overlays list. This causes the content\n     * of the first overlay to unmount.\n     *\n     * We wrap the state in useRef to ensure the two callbacks always use the most\n     * up-to-date version.\n     *\n     * Further reading: https://stackoverflow.com/a/56554056\n     */\n    const [overlays, setOverlays] = useState({});\n    const overlaysRef = useRef({});\n    overlaysRef.current = overlays;\n    useEffect(() => {\n        /* Setup the callbacks that get called from <IonApp /> */\n        onAddOverlay(addOverlay);\n        onRemoveOverlay(removeOverlay);\n    }, []);\n    const addOverlay = (id, component, containerElement) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        newOverlays[id] = { component, containerElement };\n        setOverlays(newOverlays);\n    };\n    const removeOverlay = (id) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        delete newOverlays[id];\n        setOverlays(newOverlays);\n    };\n    const overlayKeys = Object.keys(overlays);\n    return (React.createElement(React.Fragment, null, overlayKeys.map((key) => {\n        const overlay = overlays[key];\n        return ReactDOM.createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);\n    })));\n};\n\nconst IonTabButtonInner = /*@__PURE__*/ createReactComponent('ion-tab-button', undefined, undefined, ion_tab_button_defineCustomElement);\nconst IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar', undefined, undefined, ion_tab_bar_defineCustomElement);\nconst IonBackButtonInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-back-button', undefined, undefined, defineCustomElement$18)));\nconst IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet', undefined, undefined, defineCustomElement);\nconst IonAppInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-app', undefined, undefined, defineCustomElement$1a)));\n// ionicons\nconst IonIconInner = /*@__PURE__*/ createReactComponent('ion-icon', undefined, undefined, ion_icon_defineCustomElement);\n\nconst IonApp = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        /*\n          Wire up methods to call into IonOverlayManager\n        */\n        this.ionContext = {\n            addOverlay: (id, overlay, containerElement) => {\n                if (this.addOverlayCallback) {\n                    this.addOverlayCallback(id, overlay, containerElement);\n                }\n            },\n            removeOverlay: (id) => {\n                if (this.removeOverlayCallback) {\n                    this.removeOverlayCallback(id);\n                }\n            },\n        };\n    }\n    render() {\n        return (React.createElement(IonContext.Provider, { value: this.ionContext },\n            React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),\n            React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {\n                    this.addOverlayCallback = callback;\n                }, onRemoveOverlay: (callback) => {\n                    this.removeOverlayCallback = callback;\n                } })));\n    }\n    static get displayName() {\n        return 'IonApp';\n    }\n})()));\n\nconst StackContext = react.createContext({\n    registerIonPage: () => undefined,\n    isInOutlet: () => false,\n});\n\nclass PageManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.ionPageElementRef = react.createRef();\n        // React refs must be stable (not created inline).\n        this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);\n    }\n    componentDidMount() {\n        if (this.ionPageElementRef.current) {\n            if (this.context.isInOutlet()) {\n                this.ionPageElementRef.current.classList.add('ion-page-invisible');\n            }\n            this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);\n            this.ionPageElementRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionPageElementRef.current) {\n            this.ionPageElementRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"routeInfo\", \"forwardedRef\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(\"div\", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonPageInternal extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const _a = this.props, { className, children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (react.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo, forwardedRef: forwardedRef }, props), children)) : (react.createElement(\"div\", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));\n    }\n    static get displayName() {\n        return 'IonPage';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonPage = createForwardRef(IonPageInternal, 'IonPage');\n\nconst IonTabsContext = react.createContext({\n    activeTab: undefined,\n    selectTab: () => false,\n});\n\nconst HTMLElementSSR = (typeof HTMLElement !== 'undefined'\n    ? HTMLElement\n    : class {\n    });\n\nclass OutletPageManager extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    componentDidMount() {\n        if (this.ionRouterOutlet) {\n            (0,esm_es5.componentOnReady)(this.ionRouterOutlet, () => {\n                this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);\n            });\n            this.ionRouterOutlet.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionRouterOutlet) {\n            this.ionRouterOutlet.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { StackManager, children, routeInfo } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"StackManager\", \"children\", \"routeInfo\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(StackManager, { routeInfo: routeInfo },\n                react.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => (this.ionRouterOutlet = val) }, props), children)));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonRouterOutletContainer extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const StackManager = this.context.getStackManager();\n        const _a = this.props, { children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (props.ionPage ? (react.createElement(OutletPageManager, Object.assign({ StackManager: StackManager, routeInfo: this.context.routeInfo }, props), children)) : (react.createElement(StackManager, { routeInfo: this.context.routeInfo },\n            react.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef: forwardedRef }), children)))) : (react.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');\n\nconst index_esm_IonTabButton = /*@__PURE__*/ (() => class extends react.Component {\n    constructor(props) {\n        super(props);\n        this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);\n    }\n    handleIonTabButtonClick() {\n        if (this.props.onClick) {\n            this.props.onClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    tab: this.props.tab,\n                    href: this.props.href,\n                    routeOptions: this.props.routerOptions,\n                },\n            }));\n        }\n    }\n    render() {\n        const _a = this.props, rest = (0,tslib_es6/* __rest */._T)(_a, [\"onClick\"]);\n        return (react.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest)));\n    }\n    static get displayName() {\n        return 'IonTabButton';\n    }\n})();\n\nclass IonTabBarUnwrapped extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.setActiveTabOnContext = (_tab) => { };\n        const tabs = {};\n        react.Children.forEach(props.children, (child) => {\n            var _a, _b, _c, _d;\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                tabs[child.props.tab] = {\n                    originalHref: child.props.href,\n                    currentHref: child.props.href,\n                    originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname)\n                        ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : undefined,\n                    currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname)\n                        ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : undefined,\n                };\n            }\n        });\n        this.state = {\n            tabs,\n        };\n        this.onTabButtonClick = this.onTabButtonClick.bind(this);\n        this.renderTabButton = this.renderTabButton.bind(this);\n        this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);\n        this.selectTab = this.selectTab.bind(this);\n    }\n    componentDidMount() {\n        const tabs = this.state.tabs;\n        const tabKeys = Object.keys(tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = tabs[key].originalHref;\n            return this.props.routeInfo.pathname.startsWith(href);\n        });\n        if (activeTab) {\n            this.setState({\n                activeTab,\n            });\n        }\n    }\n    componentDidUpdate() {\n        if (this.state.activeTab) {\n            this.setActiveTabOnContext(this.state.activeTab);\n        }\n    }\n    selectTab(tab) {\n        const tabUrl = this.state.tabs[tab];\n        if (tabUrl) {\n            this.onTabButtonClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    href: tabUrl.currentHref,\n                    tab,\n                    selected: tab === this.state.activeTab,\n                    routeOptions: undefined,\n                },\n            }));\n            return true;\n        }\n        return false;\n    }\n    static getDerivedStateFromProps(props, state) {\n        var _a, _b, _c;\n        const tabs = Object.assign({}, state.tabs);\n        const tabKeys = Object.keys(state.tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = state.tabs[key].originalHref;\n            return props.routeInfo.pathname.startsWith(href);\n        });\n        // Check to see if the tab button href has changed, and if so, update it in the tabs state\n        react.Children.forEach(props.children, (child) => {\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const tab = tabs[child.props.tab];\n                if (!tab || tab.originalHref !== child.props.href) {\n                    tabs[child.props.tab] = {\n                        originalHref: child.props.href,\n                        currentHref: child.props.href,\n                        originalRouteOptions: child.props.routeOptions,\n                        currentRouteOptions: child.props.routeOptions,\n                    };\n                }\n            }\n        });\n        const { activeTab: prevActiveTab } = state;\n        if (activeTab && prevActiveTab) {\n            const prevHref = state.tabs[prevActiveTab].currentHref;\n            const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;\n            if (activeTab !== prevActiveTab ||\n                prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ||\n                prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {\n                tabs[activeTab] = {\n                    originalHref: tabs[activeTab].originalHref,\n                    currentHref: props.routeInfo.pathname + (props.routeInfo.search || ''),\n                    originalRouteOptions: tabs[activeTab].originalRouteOptions,\n                    currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions,\n                };\n                if (props.routeInfo.routeAction === 'pop' && activeTab !== prevActiveTab) {\n                    // If navigating back and the tabs change, set the prev tab back to its original href\n                    tabs[prevActiveTab] = {\n                        originalHref: tabs[prevActiveTab].originalHref,\n                        currentHref: tabs[prevActiveTab].originalHref,\n                        originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,\n                        currentRouteOptions: tabs[prevActiveTab].currentRouteOptions,\n                    };\n                }\n            }\n        }\n        activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);\n        return {\n            activeTab,\n            tabs,\n        };\n    }\n    onTabButtonClick(e) {\n        const tappedTab = this.state.tabs[e.detail.tab];\n        const originalHref = tappedTab.originalHref;\n        const currentHref = e.detail.href;\n        const { activeTab: prevActiveTab } = this.state;\n        // this.props.onSetCurrentTab(e.detail.tab, this.props.routeInfo);\n        // Clicking the current tab will bring you back to the original href\n        if (prevActiveTab === e.detail.tab) {\n            if (originalHref !== currentHref) {\n                this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);\n            }\n        }\n        else {\n            if (this.props.onIonTabsWillChange) {\n                this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', { detail: { tab: e.detail.tab } }));\n            }\n            if (this.props.onIonTabsDidChange) {\n                this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', { detail: { tab: e.detail.tab } }));\n            }\n            this.setActiveTabOnContext(e.detail.tab);\n            this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);\n        }\n    }\n    renderTabButton(activeTab) {\n        return (child) => {\n            var _a, _b;\n            if (child != null &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const href = child.props.tab === activeTab\n                    ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;\n                const routeOptions = child.props.tab === activeTab\n                    ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;\n                return react.cloneElement(child, {\n                    href,\n                    routeOptions,\n                    onClick: this.onTabButtonClick,\n                });\n            }\n            return null;\n        };\n    }\n    render() {\n        const { activeTab } = this.state;\n        return (react.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), react.Children.map(this.props.children, this.renderTabButton(activeTab))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonTabBarContainer = react.memo((_a) => {\n    var { forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"forwardedRef\"]);\n    const context = (0,react.useContext)(NavContext);\n    return (react.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children));\n});\nconst index_esm_IonTabBar = createForwardRef(IonTabBarContainer, 'IonTabBar');\n\nclass IonTabsElement extends HTMLElementSSR {\n    constructor() {\n        super();\n    }\n}\nif (typeof window !== 'undefined' && window.customElements) {\n    const element = window.customElements.get('ion-tabs');\n    if (!element) {\n        window.customElements.define('ion-tabs', IonTabsElement);\n    }\n}\nconst hostStyles = {\n    display: 'flex',\n    position: 'absolute',\n    top: '0',\n    left: '0',\n    right: '0',\n    bottom: '0',\n    flexDirection: 'column',\n    width: '100%',\n    height: '100%',\n    contain: 'layout size style',\n};\nconst tabsInner = {\n    position: 'relative',\n    flex: 1,\n    contain: 'layout size style',\n};\nconst IonTabs = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        this.routerOutletRef = React.createRef();\n        this.tabBarRef = React.createRef();\n        this.ionTabContextState = {\n            activeTab: undefined,\n            selectTab: () => false,\n        };\n    }\n    componentDidMount() {\n        if (this.tabBarRef.current) {\n            // Grab initial value\n            this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;\n            // Override method\n            this.tabBarRef.current.setActiveTabOnContext = (tab) => {\n                this.ionTabContextState.activeTab = tab;\n            };\n            this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;\n        }\n    }\n    render() {\n        let outlet;\n        let tabBar;\n        const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = __rest(_a, [\"className\", \"onIonTabsDidChange\", \"onIonTabsWillChange\"]);\n        const children = typeof this.props.children === 'function'\n            ? this.props.children(this.ionTabContextState)\n            : this.props.children;\n        React.Children.forEach(children, (child) => {\n            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {\n                return;\n            }\n            if (child.type === index_esm_IonRouterOutlet || child.type.isRouterOutlet) {\n                outlet = React.cloneElement(child);\n            }\n            else if (child.type === Fragment && child.props.children[0].type === index_esm_IonRouterOutlet) {\n                outlet = child.props.children[0];\n            }\n            let childProps = {\n                ref: this.tabBarRef\n            };\n            /**\n             * Only pass these props\n             * down from IonTabs to IonTabBar\n             * if they are defined, otherwise\n             * if you have a handler set on\n             * IonTabBar it will be overridden.\n             */\n            if (onIonTabsDidChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });\n            }\n            if (onIonTabsWillChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });\n            }\n            if (child.type === index_esm_IonTabBar || child.type.isTabBar) {\n                tabBar = React.cloneElement(child, childProps);\n            }\n            else if (child.type === Fragment &&\n                (child.props.children[1].type === index_esm_IonTabBar || child.props.children[1].type.isTabBar)) {\n                tabBar = React.cloneElement(child.props.children[1], childProps);\n            }\n        });\n        if (!outlet) {\n            throw new Error('IonTabs must contain an IonRouterOutlet');\n        }\n        if (!tabBar) {\n            throw new Error('IonTabs needs a IonTabBar');\n        }\n        return (React.createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? (React.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo }, props),\n            React.createElement(\"ion-tabs\", { className: \"ion-tabs\", style: hostStyles },\n                tabBar.props.slot === 'top' ? tabBar : null,\n                React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n                tabBar.props.slot === 'bottom' ? tabBar : null))) : (React.createElement(\"div\", Object.assign({ className: className ? `${className}` : 'ion-tabs' }, props, { style: hostStyles }),\n            tabBar.props.slot === 'top' ? tabBar : null,\n            React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n            tabBar.props.slot === 'bottom' ? tabBar : null))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nconst IonBackButton = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.clickButton = (e) => {\n            const { defaultHref, routerAnimation } = this.props;\n            if (this.context.hasIonicRouter()) {\n                e.stopPropagation();\n                this.context.goBack(defaultHref, routerAnimation);\n            }\n            else if (defaultHref !== undefined) {\n                window.location.href = defaultHref;\n            }\n        };\n    }\n    render() {\n        return React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));\n    }\n    static get displayName() {\n        return 'IonBackButton';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nclass IonIconContainer extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        if (this.props.name) {\n            console.warn('In Ionic React, you import icons from \"ionicons/icons\" and set the icon you imported to the \"icon\" property. Setting the \"name\" property has no effect.');\n        }\n    }\n    render() {\n        var _a, _b;\n        const _c = this.props, { icon, ios, md } = _c, rest = (0,tslib_es6/* __rest */._T)(_c, [\"icon\", \"ios\", \"md\"]);\n        let iconToUse;\n        if (ios || md) {\n            if (index_esm_isPlatform('ios')) {\n                iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n            }\n            else {\n                iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n            }\n        }\n        else {\n            iconToUse = icon;\n        }\n        return (react.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonIcon = createForwardRef(IonIconContainer, 'IonIcon');\n\nclass IonRoute extends react.PureComponent {\n    render() {\n        const IonRouteInner = this.context.getIonRoute();\n        if (!this.context.hasIonicRouter() || !IonRoute) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRoute>');\n            return null;\n        }\n        return React.createElement(IonRouteInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nclass IonRedirect extends react.PureComponent {\n    render() {\n        const IonRedirectInner = this.context.getIonRedirect();\n        if (!this.context.hasIonicRouter() || !IonRedirect) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRedirect>');\n            return null;\n        }\n        return React.createElement(IonRedirectInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nconst IonRouterContext = react.createContext({\n    routeInfo: undefined,\n    push: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    back: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    canGoBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    nativeBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n});\n/**\n * A hook for more direct control over routing in an Ionic React application. Allows you to pass additional meta-data to the router before the call to the native router.\n */\nfunction useIonRouter() {\n    const context = useContext(IonRouterContext);\n    return {\n        back: context.back,\n        push: context.push,\n        goBack: context.back,\n        canGoBack: context.canGoBack,\n        routeInfo: context.routeInfo,\n    };\n}\n\nclass CreateAnimation extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.nodes = new Map();\n        this.animation = createAnimation(props.id);\n    }\n    setupAnimation(props) {\n        const animation = this.animation;\n        if (this.nodes.size > 0) {\n            animation.addElement(Array.from(this.nodes.values()));\n        }\n        checkConfig(animation, props);\n        checkPlayback(animation, props);\n    }\n    componentDidMount() {\n        const props = this.props;\n        this.setupAnimation(props);\n    }\n    componentDidUpdate(prevProps) {\n        const animation = this.animation;\n        const props = this.props;\n        checkConfig(animation, props, prevProps);\n        checkProgress(animation, props, prevProps);\n        checkPlayback(animation, props, prevProps);\n    }\n    render() {\n        const { children } = this.props;\n        return (React.createElement(React.Fragment, null, React.Children.map(children, (child, id) => React.cloneElement(child, { ref: (el) => this.nodes.set(id, el) }))));\n    }\n}\nconst checkConfig = (animation, currentProps = {}, prevProps = {}) => {\n    const reservedProps = [\n        'children',\n        'progressStart',\n        'progressStep',\n        'progressEnd',\n        'pause',\n        'stop',\n        'destroy',\n        'play',\n        'from',\n        'to',\n        'fromTo',\n        'onFinish',\n    ];\n    for (const key in currentProps) {\n        if (currentProps.hasOwnProperty(key) &&\n            !reservedProps.includes(key) &&\n            currentProps[key] !== prevProps[key]) {\n            animation[key](currentProps[key]);\n        }\n    }\n    const fromValues = currentProps.from;\n    if (fromValues && fromValues !== prevProps.from) {\n        const values = Array.isArray(fromValues) ? fromValues : [fromValues];\n        values.forEach((val) => animation.from(val.property, val.value));\n    }\n    const toValues = currentProps.to;\n    if (toValues && toValues !== prevProps.to) {\n        const values = Array.isArray(toValues) ? toValues : [toValues];\n        values.forEach((val) => animation.to(val.property, val.value));\n    }\n    const fromToValues = currentProps.fromTo;\n    if (fromToValues && fromToValues !== prevProps.fromTo) {\n        const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];\n        values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));\n    }\n    const onFinishValues = currentProps.onFinish;\n    if (onFinishValues && onFinishValues !== prevProps.onFinish) {\n        const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];\n        values.forEach((val) => animation.onFinish(val.callback, val.opts));\n    }\n};\nconst checkProgress = (animation, currentProps = {}, prevProps = {}) => {\n    var _a, _b, _c, _d, _e;\n    const { progressStart, progressStep, progressEnd } = currentProps;\n    if (progressStart &&\n        (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) ||\n            ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {\n        animation.progressStart(progressStart.forceLinearEasing, progressStart.step);\n    }\n    if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {\n        animation.progressStep(progressStep.step);\n    }\n    if (progressEnd &&\n        (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) ||\n            ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) ||\n            (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {\n        animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);\n    }\n};\nconst checkPlayback = (animation, currentProps = {}, prevProps = {}) => {\n    if (!prevProps.play && currentProps.play) {\n        animation.play();\n    }\n    if (!prevProps.pause && currentProps.pause) {\n        animation.pause();\n    }\n    if (!prevProps.stop && currentProps.stop) {\n        animation.stop();\n    }\n    if (!prevProps.destroy && currentProps.destroy) {\n        animation.destroy();\n    }\n};\n\nfunction useController(displayName, controller, defineCustomElement) {\n    const overlayRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    defineCustomElement();\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        const handleDismiss = (event) => {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n        };\n        overlayRef.current = await controller.create(Object.assign({}, rest));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n    }, [controller]);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonActionSheet component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonActionSheet() {\n    const controller = useController('IonActionSheet', actionSheetController$1, defineCustomElement$13);\n    const present = useCallback((buttonsOrOptions, header) => {\n        if (Array.isArray(buttonsOrOptions)) {\n            return controller.present({\n                buttons: buttonsOrOptions,\n                header,\n            });\n        }\n        else {\n            return controller.present(buttonsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonAlert component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonAlert() {\n    const controller = useController('IonAlert', alertController, defineCustomElement$1c);\n    const present = useCallback((messageOrOptions, buttons) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonToast component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonToast() {\n    const controller = useController('IonToast', toastController$1, defineCustomElement$1d);\n    const present = useCallback((messageOrOptions, duration) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\nconst ids = { main: 0 };\nconst generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return id.toString();\n};\n\nfunction useOverlay(displayName, controller, defineCustomElement, component, componentProps) {\n    const overlayRef = useRef();\n    const containerElRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    const [isOpen, setIsOpen] = useState(false);\n    const ionContext = useContext(IonContext);\n    const [overlayId] = useState(generateId('overlay'));\n    defineCustomElement();\n    useEffect(() => {\n        if (isOpen && component && containerElRef.current) {\n            if (React.isValidElement(component)) {\n                ionContext.addOverlay(overlayId, component, containerElRef.current);\n            }\n            else {\n                const element = createElement(component, componentProps);\n                ionContext.addOverlay(overlayId, element, containerElRef.current);\n            }\n        }\n    }, [component, containerElRef.current, isOpen, componentProps]);\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        if (typeof document !== 'undefined') {\n            containerElRef.current = document.createElement('div');\n        }\n        overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n        setIsOpen(true);\n        function handleDismiss(event) {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n            containerElRef.current = undefined;\n            setIsOpen(false);\n            ionContext.removeOverlay(overlayId);\n        }\n    }, []);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n        containerElRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonModal component\n * @param component The component that the modal will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonModal(component, componentProps) {\n    const controller = useOverlay('IonModal', modalController, defineCustomElement$14, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @param component The component that the popover will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPopover(component, componentProps) {\n    const controller = useOverlay('IonPopover', popoverController, defineCustomElement$15, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPicker() {\n    const controller = useController('IonPicker', pickerController, defineCustomElement$1e);\n    const present = useCallback((columnsOrOptions, buttons) => {\n        if (Array.isArray(columnsOrOptions)) {\n            return controller.present({\n                columns: columnsOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(columnsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonLoading component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonLoading() {\n    const controller = useController('IonLoading', loadingController, defineCustomElement$1f);\n    const present = useCallback((messageOrOptions = '', duration, spinner) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration,\n                spinner: spinner !== null && spinner !== void 0 ? spinner : 'lines',\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\nconst setupIonicReact = (config = {}) => {\n    /**\n     * By default Ionic Framework hides elements that\n     * are not hydrated, but in the CE build there is no\n     * hydration.\n     * TODO: Remove when all integrations have been\n     * migrated to CE build.\n     */\n    if (typeof document !== 'undefined') {\n        document.documentElement.classList.add('ion-ce');\n    }\n    initialize(Object.assign({}, config));\n};\n\nconst RouteManagerContext = /*@__PURE__*/ react.createContext({\n    addViewItem: () => undefined,\n    canGoBack: () => undefined,\n    clearOutlet: () => undefined,\n    createViewItem: () => undefined,\n    findViewItemByPathname: () => undefined,\n    findLeavingViewItemByRouteInfo: () => undefined,\n    findViewItemByRouteInfo: () => undefined,\n    getChildrenToRender: () => undefined,\n    goBack: () => undefined,\n    unMountViewItem: () => undefined,\n});\n\nclass ViewLifeCycleManager extends react.Component {\n    constructor(props) {\n        super(props);\n        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();\n        this._isMounted = false;\n        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {\n            if (!this.props.mount) {\n                if (this._isMounted) {\n                    this.setState({\n                        show: false,\n                    }, () => this.props.removeView());\n                }\n            }\n        });\n        this.state = {\n            show: true,\n        };\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        this._isMounted = false;\n    }\n    render() {\n        const { show } = this.state;\n        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));\n    }\n}\n\n// const RESTRICT_SIZE = 100;\nclass LocationHistory {\n    constructor() {\n        this.locationHistory = [];\n        this.tabHistory = {};\n    }\n    add(routeInfo) {\n        if (routeInfo.routeAction === 'push' || routeInfo.routeAction == null) {\n            this._add(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'pop') {\n            this._pop(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'replace') {\n            this._replace(routeInfo);\n        }\n        if (routeInfo.routeDirection === 'root') {\n            this._clear();\n            this._add(routeInfo);\n        }\n    }\n    clearTabStack(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            routeInfos.forEach((ri) => {\n                this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);\n            });\n            this.tabHistory[tab] = [];\n        }\n    }\n    update(routeInfo) {\n        const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            this.locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = this.tabHistory[routeInfo.tab || ''];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            this.tabHistory[routeInfo.tab] = [routeInfo];\n        }\n    }\n    _add(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {\n                routeInfos.pop();\n            }\n            routeInfos.push(routeInfo);\n        }\n        this.locationHistory.push(routeInfo);\n    }\n    _areRoutesEqual(route1, route2) {\n        if (!route1 || !route2) {\n            return false;\n        }\n        return route1.pathname === route2.pathname && route1.search === route2.search;\n    }\n    _pop(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // Pop the previous route\n            routeInfos.pop();\n            // Replace the current route with an updated version\n            routeInfos.pop();\n            routeInfos.push(routeInfo);\n        }\n        // Pop the previous route\n        this.locationHistory.pop();\n        // Replace the current route with an updated version\n        this.locationHistory.pop();\n        this.locationHistory.push(routeInfo);\n    }\n    _replace(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        routeInfos && routeInfos.pop();\n        this.locationHistory.pop();\n        this._add(routeInfo);\n    }\n    _clear() {\n        const keys = Object.keys(this.tabHistory);\n        keys.forEach((k) => (this.tabHistory[k] = []));\n        this.locationHistory = [];\n    }\n    _getRouteInfosByKey(key) {\n        let routeInfos;\n        if (key) {\n            routeInfos = this.tabHistory[key];\n            if (!routeInfos) {\n                routeInfos = this.tabHistory[key] = [];\n            }\n        }\n        return routeInfos;\n    }\n    getFirstRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[0];\n        }\n        return undefined;\n    }\n    getCurrentRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[routeInfos.length - 1];\n        }\n        return undefined;\n    }\n    findLastLocation(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            for (let i = routeInfos.length - 2; i >= 0; i--) {\n                const ri = routeInfos[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        for (let i = this.locationHistory.length - 2; i >= 0; i--) {\n            const ri = this.locationHistory[i];\n            if (ri) {\n                if (ri.pathname === routeInfo.pushedByRoute) {\n                    return ri;\n                }\n            }\n        }\n        return undefined;\n    }\n    previous() {\n        return (this.locationHistory[this.locationHistory.length - 2] ||\n            this.locationHistory[this.locationHistory.length - 1]);\n    }\n    current() {\n        return this.locationHistory[this.locationHistory.length - 1];\n    }\n    canGoBack() {\n        return this.locationHistory.length > 1;\n    }\n}\n\nclass NavManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this._isMounted = false;\n        this.ionRouterContextValue = {\n            push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {\n                this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);\n            },\n            back: (animationBuilder) => {\n                this.goBack(undefined, animationBuilder);\n            },\n            canGoBack: () => this.props.locationHistory.canGoBack(),\n            nativeBack: () => this.props.onNativeBack(),\n            routeInfo: this.props.routeInfo,\n        };\n        this.state = {\n            goBack: this.goBack.bind(this),\n            hasIonicRouter: () => true,\n            navigate: this.navigate.bind(this),\n            getIonRedirect: this.getIonRedirect.bind(this),\n            getIonRoute: this.getIonRoute.bind(this),\n            getStackManager: this.getStackManager.bind(this),\n            getPageManager: this.getPageManager.bind(this),\n            routeInfo: this.props.routeInfo,\n            setCurrentTab: this.props.onSetCurrentTab,\n            changeTab: this.props.onChangeTab,\n            resetTab: this.props.onResetTab,\n        };\n        if (typeof document !== 'undefined') {\n            this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);\n            document.addEventListener('ionBackButton', this.handleHardwareBackButton);\n        }\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener('ionBackButton', this.handleHardwareBackButton);\n            this._isMounted = false;\n        }\n    }\n    handleHardwareBackButton(e) {\n        e.detail.register(0, (processNextHandler) => {\n            if (this._isMounted) {\n                this.nativeGoBack();\n                processNextHandler();\n            }\n        });\n    }\n    goBack(route, animationBuilder) {\n        this.props.onNavigateBack(route, animationBuilder);\n    }\n    nativeGoBack() {\n        this.props.onNativeBack();\n    }\n    navigate(path, direction = 'forward', action = 'push', animationBuilder, options, tab) {\n        this.props.onNavigate(path, action, direction, animationBuilder, options, tab);\n    }\n    getPageManager() {\n        return PageManager;\n    }\n    getIonRedirect() {\n        return this.props.ionRedirect;\n    }\n    getIonRoute() {\n        return this.props.ionRoute;\n    }\n    getStackManager() {\n        return this.props.stackManager;\n    }\n    render() {\n        return (React.createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },\n            React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)));\n    }\n}\n\nclass ViewStacks {\n    constructor() {\n        this.viewStacks = {};\n        this.add = this.add.bind(this);\n        this.clear = this.clear.bind(this);\n        this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);\n        this.remove = this.remove.bind(this);\n    }\n    add(viewItem) {\n        const { outletId } = viewItem;\n        if (!this.viewStacks[outletId]) {\n            this.viewStacks[outletId] = [viewItem];\n        }\n        else {\n            this.viewStacks[outletId].push(viewItem);\n        }\n    }\n    clear(outletId) {\n        // Give some time for the leaving views to transition before removing\n        setTimeout(() => {\n            // console.log('Removing viewstack for outletID ' + outletId);\n            delete this.viewStacks[outletId];\n        }, 500);\n    }\n    getViewItemsForOutlet(outletId) {\n        return this.viewStacks[outletId] || [];\n    }\n    remove(viewItem) {\n        const { outletId } = viewItem;\n        const viewStack = this.viewStacks[outletId];\n        if (viewStack) {\n            const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);\n            if (viewItemToRemove) {\n                viewItemToRemove.mount = false;\n                this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);\n            }\n        }\n    }\n    getStackIds() {\n        return Object.keys(this.viewStacks);\n    }\n    getAllViewItems() {\n        const keys = this.getStackIds();\n        const viewItems = [];\n        keys.forEach((k) => {\n            viewItems.push(...this.viewStacks[k]);\n        });\n        return viewItems;\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsMkRBQTJELFdBQVcscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBZ0I7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUIsZUFBZSxjQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsd0JBQXdCO0FBQ3JHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFDQUFxQyxpQkFBaUIsaUNBQWlDLEdBQUc7QUFDckosNkRBQTZELHFDQUFxQyxpQ0FBaUMsaUNBQWlDLEdBQUc7QUFDdks7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUUrbUQ7QUFDL21EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbmljLWdsb2JhbC5qcz9mOGU3Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9vdmVybGF5cy5qcz9lMmY5Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9jdWJpYy1iZXppZXIuanM/YzUxMCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvZnJhbWV3b3JrLWRlbGVnYXRlLmpzP2MxMjEiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yb3V0ZXItb3V0bGV0LmpzP2JiYTkiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL3RoZW1lLmpzPzU0YmYiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10YWItYmFyLmpzP2ZjNmYiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL3JpcHBsZS1lZmZlY3QuanM/NjA1YiIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRhYi1idXR0b24uanM/OGM5MCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2EzMDAiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9pb25pY29ucy9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanM/ODQxOSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL2NvbXBvbmVudHMvdXRpbHMuanM/OTY4OCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL2NvbXBvbmVudHMvaW9uLWljb24uanM/OGEzYyIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvaW5kZXguanM/ZmU3MCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9yZWFjdC9kaXN0L2luZGV4LmVzbS5qcz83OGZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBDb250ZXh0LCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldE1vZGUsIGdldE1vZGUgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5cbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubSA9IG5ldyBNYXAoKTtcbiAgfVxuICByZXNldChjb25maWdPYmopIHtcbiAgICB0aGlzLm0gPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iaikpO1xuICB9XG4gIGdldChrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLm0uZ2V0KGtleSk7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGZhbGxiYWNrO1xuICB9XG4gIGdldEJvb2xlYW4oa2V5LCBmYWxsYmFjayA9IGZhbHNlKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5tLmdldChrZXkpO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWwgPT09ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuICEhdmFsO1xuICB9XG4gIGdldE51bWJlcihrZXksIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgdmFsID0gcGFyc2VGbG9hdCh0aGlzLm0uZ2V0KGtleSkpO1xuICAgIHJldHVybiBpc05hTih2YWwpID8gKGZhbGxiYWNrICE9PSB1bmRlZmluZWQgPyBmYWxsYmFjayA6IE5hTikgOiB2YWw7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm0uc2V0KGtleSwgdmFsdWUpO1xuICB9XG59XG5jb25zdCBjb25maWcgPSAvKkBfX1BVUkVfXyovIG5ldyBDb25maWcoKTtcbmNvbnN0IGNvbmZpZ0Zyb21TZXNzaW9uID0gKHdpbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbmZpZ1N0ciA9IHdpbi5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKElPTklDX1NFU1NJT05fS0VZKTtcbiAgICByZXR1cm4gY29uZmlnU3RyICE9PSBudWxsID8gSlNPTi5wYXJzZShjb25maWdTdHIpIDoge307XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5jb25zdCBzYXZlQ29uZmlnID0gKHdpbiwgYykgPT4ge1xuICB0cnkge1xuICAgIHdpbi5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKElPTklDX1NFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShjKSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm47XG4gIH1cbn07XG5jb25zdCBjb25maWdGcm9tVVJMID0gKHdpbikgPT4ge1xuICBjb25zdCBjb25maWdPYmogPSB7fTtcbiAgd2luLmxvY2F0aW9uLnNlYXJjaFxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zcGxpdCgnPScpKVxuICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2RlY29kZVVSSUNvbXBvbmVudChrZXkpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpXSlcbiAgICAuZmlsdGVyKChba2V5XSkgPT4gc3RhcnRzV2l0aChrZXksIElPTklDX1BSRUZJWCkpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LnNsaWNlKElPTklDX1BSRUZJWC5sZW5ndGgpLCB2YWx1ZV0pXG4gICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbmZpZ09ialtrZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gY29uZmlnT2JqO1xufTtcbmNvbnN0IHN0YXJ0c1dpdGggPSAoaW5wdXQsIHNlYXJjaCkgPT4ge1xuICByZXR1cm4gaW5wdXQuc3Vic3RyKDAsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59O1xuY29uc3QgSU9OSUNfUFJFRklYID0gJ2lvbmljOic7XG5jb25zdCBJT05JQ19TRVNTSU9OX0tFWSA9ICdpb25pYy1wZXJzaXN0LWNvbmZpZyc7XG5cbmNvbnN0IGdldFBsYXRmb3JtcyA9ICh3aW4pID0+IHNldHVwUGxhdGZvcm1zKHdpbik7XG5jb25zdCBpc1BsYXRmb3JtID0gKHdpbk9yUGxhdGZvcm0sIHBsYXRmb3JtKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luT3JQbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICBwbGF0Zm9ybSA9IHdpbk9yUGxhdGZvcm07XG4gICAgd2luT3JQbGF0Zm9ybSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZ2V0UGxhdGZvcm1zKHdpbk9yUGxhdGZvcm0pLmluY2x1ZGVzKHBsYXRmb3JtKTtcbn07XG5jb25zdCBzZXR1cFBsYXRmb3JtcyA9ICh3aW4gPSB3aW5kb3cpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHdpbi5Jb25pYyA9IHdpbi5Jb25pYyB8fCB7fTtcbiAgbGV0IHBsYXRmb3JtcyA9IHdpbi5Jb25pYy5wbGF0Zm9ybXM7XG4gIGlmIChwbGF0Zm9ybXMgPT0gbnVsbCkge1xuICAgIHBsYXRmb3JtcyA9IHdpbi5Jb25pYy5wbGF0Zm9ybXMgPSBkZXRlY3RQbGF0Zm9ybXMod2luKTtcbiAgICBwbGF0Zm9ybXMuZm9yRWFjaChwID0+IHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChgcGx0LSR7cH1gKSk7XG4gIH1cbiAgcmV0dXJuIHBsYXRmb3Jtcztcbn07XG5jb25zdCBkZXRlY3RQbGF0Zm9ybXMgPSAod2luKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVBsYXRmb3JtTWV0aG9kcyA9IGNvbmZpZy5nZXQoJ3BsYXRmb3JtJyk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhQTEFURk9STVNfTUFQKS5maWx0ZXIocCA9PiB7XG4gICAgY29uc3QgY3VzdG9tTWV0aG9kID0gY3VzdG9tUGxhdGZvcm1NZXRob2RzICYmIGN1c3RvbVBsYXRmb3JtTWV0aG9kc1twXTtcbiAgICByZXR1cm4gdHlwZW9mIGN1c3RvbU1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1ldGhvZCh3aW4pIDogUExBVEZPUk1TX01BUFtwXSh3aW4pO1xuICB9KTtcbn07XG5jb25zdCBpc01vYmlsZVdlYiA9ICh3aW4pID0+IGlzTW9iaWxlKHdpbikgJiYgIWlzSHlicmlkKHdpbik7XG5jb25zdCBpc0lwYWQgPSAod2luKSA9PiB7XG4gIC8vIGlPUyAxMiBhbmQgYmVsb3dcbiAgaWYgKHRlc3RVc2VyQWdlbnQod2luLCAvaVBhZC9pKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGlPUyAxMytcbiAgaWYgKHRlc3RVc2VyQWdlbnQod2luLCAvTWFjaW50b3NoL2kpICYmIGlzTW9iaWxlKHdpbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNJcGhvbmUgPSAod2luKSA9PiB0ZXN0VXNlckFnZW50KHdpbiwgL2lQaG9uZS9pKTtcbmNvbnN0IGlzSU9TID0gKHdpbikgPT4gdGVzdFVzZXJBZ2VudCh3aW4sIC9pUGhvbmV8aVBvZC9pKSB8fCBpc0lwYWQod2luKTtcbmNvbnN0IGlzQW5kcm9pZCA9ICh3aW4pID0+IHRlc3RVc2VyQWdlbnQod2luLCAvYW5kcm9pZHxzaW5rL2kpO1xuY29uc3QgaXNBbmRyb2lkVGFibGV0ID0gKHdpbikgPT4ge1xuICByZXR1cm4gaXNBbmRyb2lkKHdpbikgJiYgIXRlc3RVc2VyQWdlbnQod2luLCAvbW9iaWxlL2kpO1xufTtcbmNvbnN0IGlzUGhhYmxldCA9ICh3aW4pID0+IHtcbiAgY29uc3Qgd2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luLmlubmVySGVpZ2h0O1xuICBjb25zdCBzbWFsbGVzdCA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBsYXJnZXN0ID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiAoc21hbGxlc3QgPiAzOTAgJiYgc21hbGxlc3QgPCA1MjApICYmXG4gICAgKGxhcmdlc3QgPiA2MjAgJiYgbGFyZ2VzdCA8IDgwMCk7XG59O1xuY29uc3QgaXNUYWJsZXQgPSAod2luKSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbi5pbm5lckhlaWdodDtcbiAgY29uc3Qgc21hbGxlc3QgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgbGFyZ2VzdCA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICByZXR1cm4gKGlzSXBhZCh3aW4pIHx8XG4gICAgaXNBbmRyb2lkVGFibGV0KHdpbikgfHxcbiAgICAoKHNtYWxsZXN0ID4gNDYwICYmIHNtYWxsZXN0IDwgODIwKSAmJlxuICAgICAgKGxhcmdlc3QgPiA3ODAgJiYgbGFyZ2VzdCA8IDE0MDApKSk7XG59O1xuY29uc3QgaXNNb2JpbGUgPSAod2luKSA9PiBtYXRjaE1lZGlhKHdpbiwgJyhhbnktcG9pbnRlcjpjb2Fyc2UpJyk7XG5jb25zdCBpc0Rlc2t0b3AgPSAod2luKSA9PiAhaXNNb2JpbGUod2luKTtcbmNvbnN0IGlzSHlicmlkID0gKHdpbikgPT4gaXNDb3Jkb3ZhKHdpbikgfHwgaXNDYXBhY2l0b3JOYXRpdmUod2luKTtcbmNvbnN0IGlzQ29yZG92YSA9ICh3aW4pID0+ICEhKHdpblsnY29yZG92YSddIHx8IHdpblsncGhvbmVnYXAnXSB8fCB3aW5bJ1Bob25lR2FwJ10pO1xuY29uc3QgaXNDYXBhY2l0b3JOYXRpdmUgPSAod2luKSA9PiB7XG4gIGNvbnN0IGNhcGFjaXRvciA9IHdpblsnQ2FwYWNpdG9yJ107XG4gIHJldHVybiAhIShjYXBhY2l0b3IgJiYgY2FwYWNpdG9yLmlzTmF0aXZlKTtcbn07XG5jb25zdCBpc0VsZWN0cm9uID0gKHdpbikgPT4gdGVzdFVzZXJBZ2VudCh3aW4sIC9lbGVjdHJvbi9pKTtcbmNvbnN0IGlzUFdBID0gKHdpbikgPT4gISEoKHdpbi5tYXRjaE1lZGlhICYmIHdpbi5tYXRjaE1lZGlhKCcoZGlzcGxheS1tb2RlOiBzdGFuZGFsb25lKScpLm1hdGNoZXMpIHx8IHdpbi5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG5jb25zdCB0ZXN0VXNlckFnZW50ID0gKHdpbiwgZXhwcikgPT4gZXhwci50ZXN0KHdpbi5uYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IG1hdGNoTWVkaWEgPSAod2luLCBxdWVyeSkgPT4gd2luLm1hdGNoTWVkaWEgJiYgd2luLm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XG5jb25zdCBQTEFURk9STVNfTUFQID0ge1xuICAnaXBhZCc6IGlzSXBhZCxcbiAgJ2lwaG9uZSc6IGlzSXBob25lLFxuICAnaW9zJzogaXNJT1MsXG4gICdhbmRyb2lkJzogaXNBbmRyb2lkLFxuICAncGhhYmxldCc6IGlzUGhhYmxldCxcbiAgJ3RhYmxldCc6IGlzVGFibGV0LFxuICAnY29yZG92YSc6IGlzQ29yZG92YSxcbiAgJ2NhcGFjaXRvcic6IGlzQ2FwYWNpdG9yTmF0aXZlLFxuICAnZWxlY3Ryb24nOiBpc0VsZWN0cm9uLFxuICAncHdhJzogaXNQV0EsXG4gICdtb2JpbGUnOiBpc01vYmlsZSxcbiAgJ21vYmlsZXdlYic6IGlzTW9iaWxlV2ViLFxuICAnZGVza3RvcCc6IGlzRGVza3RvcCxcbiAgJ2h5YnJpZCc6IGlzSHlicmlkXG59O1xuXG5sZXQgZGVmYXVsdE1vZGU7XG5jb25zdCBnZXRJb25Nb2RlID0gKHJlZikgPT4ge1xuICByZXR1cm4gKHJlZiAmJiBnZXRNb2RlKHJlZikpIHx8IGRlZmF1bHRNb2RlO1xufTtcbmNvbnN0IGluaXRpYWxpemUgPSAodXNlckNvbmZpZyA9IHt9KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGNvbnN0IHdpbiA9IHdpbmRvdztcbiAgQ29udGV4dC5jb25maWcgPSBjb25maWc7XG4gIGNvbnN0IElvbmljID0gd2luLklvbmljID0gd2luLklvbmljIHx8IHt9O1xuICBjb25zdCBwbGF0Zm9ybUhlbHBlcnMgPSB7fTtcbiAgaWYgKHVzZXJDb25maWcuX2FlbCkge1xuICAgIHBsYXRmb3JtSGVscGVycy5hZWwgPSB1c2VyQ29uZmlnLl9hZWw7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcuX3JlbCkge1xuICAgIHBsYXRmb3JtSGVscGVycy5yZWwgPSB1c2VyQ29uZmlnLl9yZWw7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcuX2NlKSB7XG4gICAgcGxhdGZvcm1IZWxwZXJzLmNlID0gdXNlckNvbmZpZy5fY2U7XG4gIH1cbiAgc2V0UGxhdGZvcm1IZWxwZXJzKHBsYXRmb3JtSGVscGVycyk7XG4gIC8vIGNyZWF0ZSB0aGUgSW9uaWMuY29uZmlnIGZyb20gcmF3IGNvbmZpZyBvYmplY3QgKGlmIGl0IGV4aXN0cylcbiAgLy8gYW5kIGNvbnZlcnQgSW9uaWMuY29uZmlnIGludG8gYSBDb25maWdBcGkgdGhhdCBoYXMgYSBnZXQoKSBmblxuICBjb25zdCBjb25maWdPYmogPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ0Zyb21TZXNzaW9uKHdpbikpLCB7IHBlcnNpc3RDb25maWc6IGZhbHNlIH0pLCBJb25pYy5jb25maWcpLCBjb25maWdGcm9tVVJMKHdpbikpLCB1c2VyQ29uZmlnKTtcbiAgY29uZmlnLnJlc2V0KGNvbmZpZ09iaik7XG4gIGlmIChjb25maWcuZ2V0Qm9vbGVhbigncGVyc2lzdENvbmZpZycpKSB7XG4gICAgc2F2ZUNvbmZpZyh3aW4sIGNvbmZpZ09iaik7XG4gIH1cbiAgLy8gU2V0dXAgcGxhdGZvcm1zXG4gIHNldHVwUGxhdGZvcm1zKHdpbik7XG4gIC8vIGZpcnN0IHNlZSBpZiB0aGUgbW9kZSB3YXMgc2V0IGFzIGFuIGF0dHJpYnV0ZSBvbiA8aHRtbD5cbiAgLy8gd2hpY2ggY291bGQgaGF2ZSBiZWVuIHNldCBieSB0aGUgdXNlciwgb3IgYnkgcHJlLXJlbmRlcmluZ1xuICAvLyBvdGhlcndpc2UgZ2V0IHRoZSBtb2RlIHZpYSBjb25maWcgc2V0dGluZ3MsIGFuZCBmYWxsYmFjayB0byBtZFxuICBJb25pYy5jb25maWcgPSBjb25maWc7XG4gIElvbmljLm1vZGUgPSBkZWZhdWx0TW9kZSA9IGNvbmZpZy5nZXQoJ21vZGUnLCAoZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGUnKSkgfHwgKGlzUGxhdGZvcm0od2luLCAnaW9zJykgPyAnaW9zJyA6ICdtZCcpKTtcbiAgY29uZmlnLnNldCgnbW9kZScsIGRlZmF1bHRNb2RlKTtcbiAgZG9jLmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBkZWZhdWx0TW9kZSk7XG4gIGRvYy5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkZWZhdWx0TW9kZSk7XG4gIGlmIChjb25maWcuZ2V0Qm9vbGVhbignX3Rlc3RpbmcnKSkge1xuICAgIGNvbmZpZy5zZXQoJ2FuaW1hdGVkJywgZmFsc2UpO1xuICB9XG4gIGNvbnN0IGlzSW9uaWNFbGVtZW50ID0gKGVsbSkgPT4gZWxtLnRhZ05hbWUgJiYgZWxtLnRhZ05hbWUuc3RhcnRzV2l0aCgnSU9OLScpO1xuICBjb25zdCBpc0FsbG93ZWRJb25pY01vZGVWYWx1ZSA9IChlbG1Nb2RlKSA9PiBbJ2lvcycsICdtZCddLmluY2x1ZGVzKGVsbU1vZGUpO1xuICBzZXRNb2RlKChlbG0pID0+IHtcbiAgICB3aGlsZSAoZWxtKSB7XG4gICAgICBjb25zdCBlbG1Nb2RlID0gZWxtLm1vZGUgfHwgZWxtLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgaWYgKGVsbU1vZGUpIHtcbiAgICAgICAgaWYgKGlzQWxsb3dlZElvbmljTW9kZVZhbHVlKGVsbU1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsbU1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJb25pY0VsZW1lbnQoZWxtKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBpb25pYyBtb2RlOiBcIicgKyBlbG1Nb2RlICsgJ1wiLCBleHBlY3RlZDogXCJpb3NcIiBvciBcIm1kXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxtID0gZWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0TW9kZTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBpc1BsYXRmb3JtIGFzIGEsIGdldElvbk1vZGUgYXMgYiwgY29uZmlnIGFzIGMsIGdldFBsYXRmb3JtcyBhcyBnLCBpbml0aWFsaXplIGFzIGkgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUsIGMgYXMgY29uZmlnIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWSB9IGZyb20gJy4vaGFyZHdhcmUtYmFjay1idXR0b24uanMnO1xuaW1wb3J0IHsgYyBhcyBjb21wb25lbnRPblJlYWR5LCBmIGFzIGZvY3VzRWxlbWVudCwgYSBhcyBhZGRFdmVudExpc3RlbmVyLCBiIGFzIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGcgYXMgZ2V0RWxlbWVudFJvb3QgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5sZXQgbGFzdElkID0gMDtcbmNvbnN0IGFjdGl2ZUFuaW1hdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgY3JlYXRlQ29udHJvbGxlciA9ICh0YWdOYW1lKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVPdmVybGF5KHRhZ05hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZGlzbWlzcyhkYXRhLCByb2xlLCBpZCkge1xuICAgICAgcmV0dXJuIGRpc21pc3NPdmVybGF5KGRvY3VtZW50LCBkYXRhLCByb2xlLCB0YWdOYW1lLCBpZCk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRUb3AoKSB7XG4gICAgICByZXR1cm4gZ2V0T3ZlcmxheShkb2N1bWVudCwgdGFnTmFtZSk7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGFsZXJ0Q29udHJvbGxlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlcignaW9uLWFsZXJ0Jyk7XG5jb25zdCBhY3Rpb25TaGVldENvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1hY3Rpb24tc2hlZXQnKTtcbmNvbnN0IGxvYWRpbmdDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tbG9hZGluZycpO1xuY29uc3QgbW9kYWxDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tbW9kYWwnKTtcbmNvbnN0IHBpY2tlckNvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1waWNrZXInKTtcbmNvbnN0IHBvcG92ZXJDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tcG9wb3ZlcicpO1xuY29uc3QgdG9hc3RDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tdG9hc3QnKTtcbmNvbnN0IHByZXBhcmVPdmVybGF5ID0gKGVsKSA9PiB7XG4gIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSAqL1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbm5lY3RMaXN0ZW5lcnMoZG9jdW1lbnQpO1xuICB9XG4gIGNvbnN0IG92ZXJsYXlJbmRleCA9IGxhc3RJZCsrO1xuICBlbC5vdmVybGF5SW5kZXggPSBvdmVybGF5SW5kZXg7XG4gIGlmICghZWwuaGFzQXR0cmlidXRlKCdpZCcpKSB7XG4gICAgZWwuaWQgPSBgaW9uLW92ZXJsYXktJHtvdmVybGF5SW5kZXh9YDtcbiAgfVxufTtcbmNvbnN0IGNyZWF0ZU92ZXJsYXkgPSAodGFnTmFtZSwgb3B0cykgPT4ge1xuICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuY3VzdG9tRWxlbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5jdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCh0YWdOYW1lKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdvdmVybGF5LWhpZGRlbicpO1xuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0IHRoZSBwYXNzZWQgaW4gb3ZlcmxheSBvcHRpb25zIGludG8gcHJvcHNcbiAgICAgICAqIHRoYXQgZ2V0IHBhc3NlZCBkb3duIGludG8gdGhlIG5ldyBvdmVybGF5LlxuICAgICAgICovXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgaGFzQ29udHJvbGxlcjogdHJ1ZSB9KSk7XG4gICAgICAvLyBhcHBlbmQgdGhlIG92ZXJsYXkgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgYm9keVxuICAgICAgZ2V0QXBwUm9vdChkb2N1bWVudCkuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjb21wb25lbnRPblJlYWR5KGVsZW1lbnQsIHJlc29sdmUpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuY29uc3QgZm9jdXNhYmxlUXVlcnlTdHJpbmcgPSAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KFt0YWJpbmRleF49XCItXCJdKSwgdGV4dGFyZWE6bm90KFt0YWJpbmRleF49XCItXCJdKSwgYnV0dG9uOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIHNlbGVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCAuaW9uLWZvY3VzYWJsZTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pJztcbmNvbnN0IGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmcgPSAnaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3QnO1xuY29uc3QgZm9jdXNGaXJzdERlc2NlbmRhbnQgPSAocmVmLCBvdmVybGF5KSA9PiB7XG4gIGxldCBmaXJzdElucHV0ID0gcmVmLnF1ZXJ5U2VsZWN0b3IoZm9jdXNhYmxlUXVlcnlTdHJpbmcpO1xuICBjb25zdCBzaGFkb3dSb290ID0gZmlyc3RJbnB1dCAmJiBmaXJzdElucHV0LnNoYWRvd1Jvb3Q7XG4gIGlmIChzaGFkb3dSb290KSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGlubmVyIGZvY3VzYWJsZSBlbGVtZW50cywganVzdCBmb2N1cyB0aGUgaG9zdCBlbGVtZW50LlxuICAgIGZpcnN0SW5wdXQgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZykgfHwgZmlyc3RJbnB1dDtcbiAgfVxuICBpZiAoZmlyc3RJbnB1dCkge1xuICAgIGZvY3VzRWxlbWVudChmaXJzdElucHV0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBGb2N1cyBvdmVybGF5IGluc3RlYWQgb2YgbGV0dGluZyBmb2N1cyBlc2NhcGVcbiAgICBvdmVybGF5LmZvY3VzKCk7XG4gIH1cbn07XG5jb25zdCBpc092ZXJsYXlIaWRkZW4gPSAob3ZlcmxheSkgPT4gb3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ292ZXJsYXktaGlkZGVuJyk7XG5jb25zdCBmb2N1c0xhc3REZXNjZW5kYW50ID0gKHJlZiwgb3ZlcmxheSkgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKHJlZi5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZVF1ZXJ5U3RyaW5nKSk7XG4gIGxldCBsYXN0SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMCA/IGlucHV0c1tpbnB1dHMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICBjb25zdCBzaGFkb3dSb290ID0gbGFzdElucHV0ICYmIGxhc3RJbnB1dC5zaGFkb3dSb290O1xuICBpZiAoc2hhZG93Um9vdCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBpbm5lciBmb2N1c2FibGUgZWxlbWVudHMsIGp1c3QgZm9jdXMgdGhlIGhvc3QgZWxlbWVudC5cbiAgICBsYXN0SW5wdXQgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZykgfHwgbGFzdElucHV0O1xuICB9XG4gIGlmIChsYXN0SW5wdXQpIHtcbiAgICBsYXN0SW5wdXQuZm9jdXMoKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBGb2N1cyBvdmVybGF5IGluc3RlYWQgb2YgbGV0dGluZyBmb2N1cyBlc2NhcGVcbiAgICBvdmVybGF5LmZvY3VzKCk7XG4gIH1cbn07XG4vKipcbiAqIFRyYXBzIGtleWJvYXJkIGZvY3VzIGluc2lkZSBvZiBvdmVybGF5IGNvbXBvbmVudHMuXG4gKiBCYXNlZCBvbiBodHRwczovL3czYy5naXRodWIuaW8vYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvZGlhbG9nLW1vZGFsL2FsZXJ0ZGlhbG9nLmh0bWxcbiAqIFRoaXMgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiBBY3Rpb24gU2hlZXQsIEFsZXJ0LCBMb2FkaW5nLCBNb2RhbCxcbiAqIFBpY2tlciwgYW5kIFBvcG92ZXIuXG4gKiBTaG91bGQgTk9UIGluY2x1ZGU6IFRvYXN0XG4gKi9cbmNvbnN0IHRyYXBLZXlib2FyZEZvY3VzID0gKGV2LCBkb2MpID0+IHtcbiAgY29uc3QgbGFzdE92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYywgJ2lvbi1hbGVydCxpb24tYWN0aW9uLXNoZWV0LGlvbi1sb2FkaW5nLGlvbi1tb2RhbCxpb24tcGlja2VyLGlvbi1wb3BvdmVyJyk7XG4gIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiAgLyoqXG4gICAqIElmIG5vIGFjdGl2ZSBvdmVybGF5LCBpZ25vcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogSWYgdGhpcyBjb21wb25lbnQgdXNlcyB0aGUgc2hhZG93IGRvbSxcbiAgICogdGhpcyBnbG9iYWwgbGlzdGVuZXIgaXMgcG9pbnRsZXNzXG4gICAqIHNpbmNlIGl0IHdpbGwgbm90IGNhdGNoIHRoZSBmb2N1c1xuICAgKiB0cmFwcyBhcyB0aGV5IGFyZSBpbnNpZGUgdGhlIHNoYWRvdyByb290LlxuICAgKiBXZSBuZWVkIHRvIGFkZCBhIGxpc3RlbmVyIHRvIHRoZSBzaGFkb3cgcm9vdFxuICAgKiBpdHNlbGYgdG8gZW5zdXJlIHRoZSBmb2N1cyB0cmFwIHdvcmtzLlxuICAgKi9cbiAgaWYgKCFsYXN0T3ZlcmxheSB8fCAhdGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGUgaW9uLWRpc2FibGUtZm9jdXMtdHJhcCBjbGFzc1xuICAgKiBpcyBwcmVzZW50IG9uIGFuIG92ZXJsYXksIHRoZW4gdGhpcyBjb21wb25lbnRcbiAgICogaW5zdGFuY2UgaGFzIG9wdGVkIG91dCBvZiBmb2N1cyB0cmFwcGluZy5cbiAgICogQW4gZXhhbXBsZSBvZiB0aGlzIGlzIHdoZW4gdGhlIHNoZWV0IG1vZGFsXG4gICAqIGhhcyBhIGJhY2tkcm9wIHRoYXQgaXMgZGlzYWJsZWQuIFRoZSBjb250ZW50XG4gICAqIGJlaGluZCB0aGUgc2hlZXQgc2hvdWxkIGJlIGZvY3VzYWJsZSB1bnRpbFxuICAgKiB0aGUgYmFja2Ryb3AgaXMgZW5hYmxlZC5cbiAgICovXG4gIGlmIChsYXN0T3ZlcmxheS5jbGFzc0xpc3QuY29udGFpbnMoJ2lvbi1kaXNhYmxlLWZvY3VzLXRyYXAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0cmFwU2NvcGVkRm9jdXMgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgd2UgYXJlIGZvY3VzaW5nIHRoZSBvdmVybGF5LCBjbGVhclxuICAgICAqIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudCBzbyB0aGF0IGhpdHRpbmdcbiAgICAgKiB0YWIgYWN0aXZhdGVzIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAqIGluIHRoZSBvdmVybGF5IHdyYXBwZXIuXG4gICAgICovXG4gICAgaWYgKGxhc3RPdmVybGF5ID09PSB0YXJnZXQpIHtcbiAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICAgIC8qKlxuICAgICAgICogT3RoZXJ3aXNlLCB3ZSBtdXN0IGJlIGZvY3VzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAqIGluc2lkZSBvZiB0aGUgb3ZlcmxheS4gVGhlIHR3byBwb3NzaWJsZSBvcHRpb25zXG4gICAgICAgKiBoZXJlIGFyZSBhbiBpbnB1dC9idXR0b24vZXRjIG9yIHRoZSBpb24tZm9jdXMtdHJhcFxuICAgICAgICogZWxlbWVudC4gVGhlIGZvY3VzIHRyYXAgZWxlbWVudCBpcyB1c2VkIHRvIHByZXZlbnRcbiAgICAgICAqIHRoZSBrZXlib2FyZCBmb2N1cyBmcm9tIGxlYXZpbmcgdGhlIG92ZXJsYXkgd2hlblxuICAgICAgICogdXNpbmcgVGFiIG9yIHNjcmVlbiBhc3Npc3RhbnRzLlxuICAgICAgICovXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBXZSBkbyBub3Qgd2FudCB0byBmb2N1cyB0aGUgdHJhcHMsIHNvIGdldCB0aGUgb3ZlcmxheVxuICAgICAgICogd3JhcHBlciBlbGVtZW50IGFzIHRoZSB0cmFwcyBsaXZlIG91dHNpZGUgb2YgdGhlIHdyYXBwZXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG92ZXJsYXlSb290ID0gZ2V0RWxlbWVudFJvb3QobGFzdE92ZXJsYXkpO1xuICAgICAgaWYgKCFvdmVybGF5Um9vdC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJsYXlXcmFwcGVyID0gb3ZlcmxheVJvb3QucXVlcnlTZWxlY3RvcignLmlvbi1vdmVybGF5LXdyYXBwZXInKTtcbiAgICAgIGlmICghb3ZlcmxheVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGluc2lkZSB0aGUgd3JhcHBlciwgbGV0IHRoZSBicm93c2VyXG4gICAgICAgKiBmb2N1cyBhcyBub3JtYWwgYW5kIGtlZXAgYSBsb2cgb2YgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBpZiAob3ZlcmxheVdyYXBwZXIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICBsYXN0T3ZlcmxheS5sYXN0Rm9jdXMgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE90aGVyd2lzZSwgd2UgbXVzdCBoYXZlIGZvY3VzZWQgb25lIG9mIHRoZSBmb2N1cyB0cmFwcy5cbiAgICAgICAgICogV2UgbmVlZCB0byB3cmFwIHRoZSBmb2N1cyB0byBlaXRoZXIgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICogb3IgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmNlIHdlIGNhbGwgYGZvY3VzRmlyc3REZXNjZW5kYW50YCBhbmQgZm9jdXMgdGhlIGZpcnN0XG4gICAgICAgICAqIGRlc2NlbmRhbnQsIGFub3RoZXIgZm9jdXMgZXZlbnQgd2lsbCBmaXJlIHdoaWNoIHdpbGxcbiAgICAgICAgICogY2F1c2UgYGxhc3RPdmVybGF5Lmxhc3RGb2N1c2AgdG8gYmUgdXBkYXRlZCBiZWZvcmVcbiAgICAgICAgICogd2UgY2FuIHJ1biB0aGUgY29kZSBhZnRlciB0aGF0LiBXZSB3aWxsIGNhY2hlIHRoZSB2YWx1ZVxuICAgICAgICAgKiBoZXJlIHRvIGF2b2lkIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0T3ZlcmxheS5sYXN0Rm9jdXM7XG4gICAgICAgIC8vIEZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBvdmVybGF5IHdyYXBwZXJcbiAgICAgICAgZm9jdXNGaXJzdERlc2NlbmRhbnQob3ZlcmxheVdyYXBwZXIsIGxhc3RPdmVybGF5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjYWNoZWQgbGFzdCBmb2N1c2VkIGVsZW1lbnQgaXMgdGhlXG4gICAgICAgICAqIHNhbWUgYXMgdGhlIGFjdGl2ZSBlbGVtZW50LCB0aGVuIHdlIG5lZWRcbiAgICAgICAgICogdG8gd3JhcCBmb2N1cyB0byB0aGUgbGFzdCBkZXNjZW5kYW50LiBUaGlzIGhhcHBlbnNcbiAgICAgICAgICogd2hlbiB0aGUgZmlyc3QgZGVzY2VuZGFudCBpcyBmb2N1c2VkLCBhbmQgdGhlIHVzZXJcbiAgICAgICAgICogcHJlc3NlcyBTaGlmdCArIFRhYi4gVGhlIHByZXZpb3VzIGxpbmUgd2lsbCBmb2N1c1xuICAgICAgICAgKiB0aGUgc2FtZSBkZXNjZW5kYW50IGFnYWluICh0aGUgZmlyc3Qgb25lKSwgY2F1c2luZ1xuICAgICAgICAgKiBsYXN0IGZvY3VzIHRvIGVxdWFsIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChsYXN0Rm9jdXMgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgZm9jdXNMYXN0RGVzY2VuZGFudChvdmVybGF5V3JhcHBlciwgbGFzdE92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhcFNoYWRvd0ZvY3VzID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgaW5zaWRlIHRoZSB3cmFwcGVyLCBsZXQgdGhlIGJyb3dzZXJcbiAgICAgKiBmb2N1cyBhcyBub3JtYWwgYW5kIGtlZXAgYSBsb2cgb2YgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGlmIChsYXN0T3ZlcmxheS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBsYXN0T3ZlcmxheS5sYXN0Rm9jdXMgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBPdGhlcndpc2UsIHdlIGFyZSBhYm91dCB0byBoYXZlIGZvY3VzXG4gICAgICAgKiBnbyBvdXQgb2YgdGhlIG92ZXJsYXkuIFdlIG5lZWQgdG8gd3JhcFxuICAgICAgICogdGhlIGZvY3VzIHRvIGVpdGhlciB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICogb3IgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiBPbmNlIHdlIGNhbGwgYGZvY3VzRmlyc3REZXNjZW5kYW50YCBhbmQgZm9jdXMgdGhlIGZpcnN0XG4gICAgICAgKiBkZXNjZW5kYW50LCBhbm90aGVyIGZvY3VzIGV2ZW50IHdpbGwgZmlyZSB3aGljaCB3aWxsXG4gICAgICAgKiBjYXVzZSBgbGFzdE92ZXJsYXkubGFzdEZvY3VzYCB0byBiZSB1cGRhdGVkIGJlZm9yZVxuICAgICAgICogd2UgY2FuIHJ1biB0aGUgY29kZSBhZnRlciB0aGF0LiBXZSB3aWxsIGNhY2hlIHRoZSB2YWx1ZVxuICAgICAgICogaGVyZSB0byBhdm9pZCB0aGF0LlxuICAgICAgICovXG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0T3ZlcmxheS5sYXN0Rm9jdXM7XG4gICAgICAvLyBGb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgb3ZlcmxheSB3cmFwcGVyXG4gICAgICBmb2N1c0ZpcnN0RGVzY2VuZGFudChsYXN0T3ZlcmxheSwgbGFzdE92ZXJsYXkpO1xuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgY2FjaGVkIGxhc3QgZm9jdXNlZCBlbGVtZW50IGlzIHRoZVxuICAgICAgICogc2FtZSBhcyB0aGUgYWN0aXZlIGVsZW1lbnQsIHRoZW4gd2UgbmVlZFxuICAgICAgICogdG8gd3JhcCBmb2N1cyB0byB0aGUgbGFzdCBkZXNjZW5kYW50LiBUaGlzIGhhcHBlbnNcbiAgICAgICAqIHdoZW4gdGhlIGZpcnN0IGRlc2NlbmRhbnQgaXMgZm9jdXNlZCwgYW5kIHRoZSB1c2VyXG4gICAgICAgKiBwcmVzc2VzIFNoaWZ0ICsgVGFiLiBUaGUgcHJldmlvdXMgbGluZSB3aWxsIGZvY3VzXG4gICAgICAgKiB0aGUgc2FtZSBkZXNjZW5kYW50IGFnYWluICh0aGUgZmlyc3Qgb25lKSwgY2F1c2luZ1xuICAgICAgICogbGFzdCBmb2N1cyB0byBlcXVhbCB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0Rm9jdXMgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIGZvY3VzTGFzdERlc2NlbmRhbnQobGFzdE92ZXJsYXksIGxhc3RPdmVybGF5KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgfTtcbiAgaWYgKGxhc3RPdmVybGF5LnNoYWRvd1Jvb3QpIHtcbiAgICB0cmFwU2hhZG93Rm9jdXMoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0cmFwU2NvcGVkRm9jdXMoKTtcbiAgfVxufTtcbmNvbnN0IGNvbm5lY3RMaXN0ZW5lcnMgPSAoZG9jKSA9PiB7XG4gIGlmIChsYXN0SWQgPT09IDApIHtcbiAgICBsYXN0SWQgPSAxO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChldikgPT4ge1xuICAgICAgdHJhcEtleWJvYXJkRm9jdXMoZXYsIGRvYyk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgLy8gaGFuZGxlIGJhY2stYnV0dG9uIGNsaWNrXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2lvbkJhY2tCdXR0b24nLCBldiA9PiB7XG4gICAgICBjb25zdCBsYXN0T3ZlcmxheSA9IGdldE92ZXJsYXkoZG9jKTtcbiAgICAgIGlmIChsYXN0T3ZlcmxheSAmJiBsYXN0T3ZlcmxheS5iYWNrZHJvcERpc21pc3MpIHtcbiAgICAgICAgZXYuZGV0YWlsLnJlZ2lzdGVyKE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFksICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGFzdE92ZXJsYXkuZGlzbWlzcyh1bmRlZmluZWQsIEJBQ0tEUk9QKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIEVTQyB0byBjbG9zZSBvdmVybGF5XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZXYgPT4ge1xuICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgY29uc3QgbGFzdE92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYyk7XG4gICAgICAgIGlmIChsYXN0T3ZlcmxheSAmJiBsYXN0T3ZlcmxheS5iYWNrZHJvcERpc21pc3MpIHtcbiAgICAgICAgICBsYXN0T3ZlcmxheS5kaXNtaXNzKHVuZGVmaW5lZCwgQkFDS0RST1ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCBkaXNtaXNzT3ZlcmxheSA9IChkb2MsIGRhdGEsIHJvbGUsIG92ZXJsYXlUYWcsIGlkKSA9PiB7XG4gIGNvbnN0IG92ZXJsYXkgPSBnZXRPdmVybGF5KGRvYywgb3ZlcmxheVRhZywgaWQpO1xuICBpZiAoIW92ZXJsYXkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ292ZXJsYXkgZG9lcyBub3QgZXhpc3QnKTtcbiAgfVxuICByZXR1cm4gb3ZlcmxheS5kaXNtaXNzKGRhdGEsIHJvbGUpO1xufTtcbmNvbnN0IGdldE92ZXJsYXlzID0gKGRvYywgc2VsZWN0b3IpID0+IHtcbiAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICBzZWxlY3RvciA9ICdpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3Zlcixpb24tdG9hc3QnO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAuZmlsdGVyKGMgPT4gYy5vdmVybGF5SW5kZXggPiAwKTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gb3ZlcmxheSBlbGVtZW50XG4gKiBAcGFyYW0gZG9jIFRoZSBkb2N1bWVudCB0byBmaW5kIHRoZSBlbGVtZW50IHdpdGhpbi5cbiAqIEBwYXJhbSBvdmVybGF5VGFnIFRoZSBzZWxlY3RvciBmb3IgdGhlIG92ZXJsYXksIGRlZmF1bHRzIHRvIElvbmljIG92ZXJsYXkgY29tcG9uZW50cy5cbiAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBvdmVybGF5IGluc3RhbmNlLlxuICogQHJldHVybnMgVGhlIG92ZXJsYXkgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiBubyBvdmVybGF5IGVsZW1lbnQgaXMgZm91bmQuXG4gKi9cbmNvbnN0IGdldE92ZXJsYXkgPSAoZG9jLCBvdmVybGF5VGFnLCBpZCkgPT4ge1xuICBjb25zdCBvdmVybGF5cyA9IGdldE92ZXJsYXlzKGRvYywgb3ZlcmxheVRhZykuZmlsdGVyKG8gPT4gIWlzT3ZlcmxheUhpZGRlbihvKSk7XG4gIHJldHVybiAoaWQgPT09IHVuZGVmaW5lZClcbiAgICA/IG92ZXJsYXlzW292ZXJsYXlzLmxlbmd0aCAtIDFdXG4gICAgOiBvdmVybGF5cy5maW5kKG8gPT4gby5pZCA9PT0gaWQpO1xufTtcbi8qKlxuICogV2hlbiBhbiBvdmVybGF5IGlzIHByZXNlbnRlZCwgdGhlIG1haW5cbiAqIGZvY3VzIGlzIHRoZSBvdmVybGF5IG5vdCB0aGUgcGFnZSBjb250ZW50LlxuICogV2UgbmVlZCB0byByZW1vdmUgdGhlIHBhZ2UgY29udGVudCBmcm9tIHRoZVxuICogYWNjZXNzaWJpbGl0eSB0cmVlIG90aGVyd2lzZSB3aGVuXG4gKiB1c2VycyB1c2UgXCJyZWFkIHNjcmVlbiBmcm9tIHRvcFwiIGdlc3R1cmVzIHdpdGhcbiAqIFRhbGtCYWNrIGFuZCBWb2ljZU92ZXIsIHRoZSBzY3JlZW4gcmVhZGVyIHdpbGwgYmVnaW5cbiAqIHRvIHJlYWQgdGhlIGNvbnRlbnQgdW5kZXJuZWF0aCB0aGUgb3ZlcmxheS5cbiAqXG4gKiBXZSBuZWVkIGEgY29udGFpbmVyIHdoZXJlIGFsbCBwYWdlIGNvbXBvbmVudHNcbiAqIGV4aXN0IHRoYXQgaXMgc2VwYXJhdGUgZnJvbSB3aGVyZSB0aGUgb3ZlcmxheXNcbiAqIGFyZSBhZGRlZCBpbiB0aGUgRE9NLiBGb3IgbW9zdCBhcHBzLCB0aGlzIGVsZW1lbnRcbiAqIGlzIHRoZSB0b3AgbW9zdCBpb24tcm91dGVyLW91dGxldC4gSW4gdGhlIGV2ZW50XG4gKiB0aGF0IGRldnMgYXJlIG5vdCB1c2luZyBhIHJvdXRlcixcbiAqIHRoZXkgd2lsbCBuZWVkIHRvIGFkZCB0aGUgXCJpb24tdmlldy1jb250YWluZXItcm9vdFwiXG4gKiBpZCB0byB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGVpciB2aWV3cy5cbiAqXG4gKiBUT0RPOiBJZiBGcmFtZXdvcmsgc3VwcG9ydHMgaGF2aW5nIG11bHRpcGxlIHRvcFxuICogbGV2ZWwgcm91dGVyIG91dGxldHMgd2Ugd291bGQgbmVlZCB0byB1cGRhdGUgdGhpcy5cbiAqIEV4YW1wbGU6IE9uZSBvdXRsZXQgZm9yIHNpZGUgbWVudSBhbmQgb25lIG91dGxldFxuICogZm9yIG1haW4gY29udGVudC5cbiAqL1xuY29uc3Qgc2V0Um9vdEFyaWFIaWRkZW4gPSAoaGlkZGVuID0gZmFsc2UpID0+IHtcbiAgY29uc3Qgcm9vdCA9IGdldEFwcFJvb3QoZG9jdW1lbnQpO1xuICBjb25zdCB2aWV3Q29udGFpbmVyID0gcm9vdC5xdWVyeVNlbGVjdG9yKCdpb24tcm91dGVyLW91dGxldCwgaW9uLW5hdiwgI2lvbi12aWV3LWNvbnRhaW5lci1yb290Jyk7XG4gIGlmICghdmlld0NvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaGlkZGVuKSB7XG4gICAgdmlld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2aWV3Q29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgfVxufTtcbmNvbnN0IHByZXNlbnQgPSBhc3luYyAob3ZlcmxheSwgbmFtZSwgaW9zRW50ZXJBbmltYXRpb24sIG1kRW50ZXJBbmltYXRpb24sIG9wdHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKG92ZXJsYXkucHJlc2VudGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNldFJvb3RBcmlhSGlkZGVuKHRydWUpO1xuICBvdmVybGF5LnByZXNlbnRlZCA9IHRydWU7XG4gIG92ZXJsYXkud2lsbFByZXNlbnQuZW1pdCgpO1xuICAoX2EgPSBvdmVybGF5LndpbGxQcmVzZW50U2hvcnRoYW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdCgpO1xuICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZShvdmVybGF5KTtcbiAgLy8gZ2V0IHRoZSB1c2VyJ3MgYW5pbWF0aW9uIGZuIGlmIG9uZSB3YXMgcHJvdmlkZWRcbiAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IChvdmVybGF5LmVudGVyQW5pbWF0aW9uKVxuICAgID8gb3ZlcmxheS5lbnRlckFuaW1hdGlvblxuICAgIDogY29uZmlnLmdldChuYW1lLCBtb2RlID09PSAnaW9zJyA/IGlvc0VudGVyQW5pbWF0aW9uIDogbWRFbnRlckFuaW1hdGlvbik7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IGF3YWl0IG92ZXJsYXlBbmltYXRpb24ob3ZlcmxheSwgYW5pbWF0aW9uQnVpbGRlciwgb3ZlcmxheS5lbCwgb3B0cyk7XG4gIGlmIChjb21wbGV0ZWQpIHtcbiAgICBvdmVybGF5LmRpZFByZXNlbnQuZW1pdCgpO1xuICAgIChfYiA9IG92ZXJsYXkuZGlkUHJlc2VudFNob3J0aGFuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVtaXQoKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiBhbiBvdmVybGF5IHRoYXQgc3RlYWxzIGZvY3VzXG4gICAqIGlzIGRpc21pc3NlZCwgZm9jdXMgc2hvdWxkIGJlIHJldHVybmVkXG4gICAqIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWRcbiAgICogcHJpb3IgdG8gdGhlIG92ZXJsYXkgb3BlbmluZy4gVG9hc3RcbiAgICogZG9lcyBub3Qgc3RlYWwgZm9jdXMgYW5kIGlzIGV4Y2x1ZGVkXG4gICAqIGZyb20gcmV0dXJuaW5nIGZvY3VzIGFzIGEgcmVzdWx0LlxuICAgKi9cbiAgaWYgKG92ZXJsYXkuZWwudGFnTmFtZSAhPT0gJ0lPTi1UT0FTVCcpIHtcbiAgICBmb2N1c1ByZXZpb3VzRWxlbWVudE9uRGlzbWlzcyhvdmVybGF5LmVsKTtcbiAgfVxuICBpZiAob3ZlcmxheS5rZXlib2FyZENsb3NlKSB7XG4gICAgb3ZlcmxheS5lbC5mb2N1cygpO1xuICB9XG59O1xuLyoqXG4gKiBXaGVuIGFuIG92ZXJsYXkgY29tcG9uZW50IGlzIGRpc21pc3NlZCxcbiAqIGZvY3VzIHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgZWxlbWVudFxuICogdGhhdCBwcmVzZW50ZWQgdGhlIG92ZXJsYXkuIE90aGVyd2lzZVxuICogZm9jdXMgd2lsbCBiZSBzZXQgb24gdGhlIGJvZHkgd2hpY2hcbiAqIG1lYW5zIHRoYXQgcGVvcGxlIHVzaW5nIHNjcmVlbiByZWFkZXJzXG4gKiBvciB0YWJiaW5nIHdpbGwgbmVlZCB0byByZS1uYXZpZ2F0ZVxuICogdG8gd2hlcmUgdGhleSB3ZXJlIGJlZm9yZSB0aGV5XG4gKiBvcGVuZWQgdGhlIG92ZXJsYXkuXG4gKi9cbmNvbnN0IGZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzID0gYXN5bmMgKG92ZXJsYXlFbCkgPT4ge1xuICBsZXQgcHJldmlvdXNFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCFwcmV2aW91c0VsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2hhZG93Um9vdCA9IHByZXZpb3VzRWxlbWVudCAmJiBwcmV2aW91c0VsZW1lbnQuc2hhZG93Um9vdDtcbiAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaW5uZXIgZm9jdXNhYmxlIGVsZW1lbnRzLCBqdXN0IGZvY3VzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgcHJldmlvdXNFbGVtZW50ID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGlubmVyRm9jdXNhYmxlUXVlcnlTdHJpbmcpIHx8IHByZXZpb3VzRWxlbWVudDtcbiAgfVxuICBhd2FpdCBvdmVybGF5RWwub25EaWREaXNtaXNzKCk7XG4gIHByZXZpb3VzRWxlbWVudC5mb2N1cygpO1xufTtcbmNvbnN0IGRpc21pc3MgPSBhc3luYyAob3ZlcmxheSwgZGF0YSwgcm9sZSwgbmFtZSwgaW9zTGVhdmVBbmltYXRpb24sIG1kTGVhdmVBbmltYXRpb24sIG9wdHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKCFvdmVybGF5LnByZXNlbnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzZXRSb290QXJpYUhpZGRlbihmYWxzZSk7XG4gIG92ZXJsYXkucHJlc2VudGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgLy8gT3ZlcmxheSBjb250ZW50cyBzaG91bGQgbm90IGJlIGNsaWNrYWJsZSBkdXJpbmcgZGlzbWlzc1xuICAgIG92ZXJsYXkuZWwuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgICBvdmVybGF5LndpbGxEaXNtaXNzLmVtaXQoeyBkYXRhLCByb2xlIH0pO1xuICAgIChfYSA9IG92ZXJsYXkud2lsbERpc21pc3NTaG9ydGhhbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0KHsgZGF0YSwgcm9sZSB9KTtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZShvdmVybGF5KTtcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gKG92ZXJsYXkubGVhdmVBbmltYXRpb24pXG4gICAgICA/IG92ZXJsYXkubGVhdmVBbmltYXRpb25cbiAgICAgIDogY29uZmlnLmdldChuYW1lLCBtb2RlID09PSAnaW9zJyA/IGlvc0xlYXZlQW5pbWF0aW9uIDogbWRMZWF2ZUFuaW1hdGlvbik7XG4gICAgLy8gSWYgZGlzbWlzc2VkIHZpYSBnZXN0dXJlLCBubyBuZWVkIHRvIHBsYXkgbGVhdmluZyBhbmltYXRpb24gYWdhaW5cbiAgICBpZiAocm9sZSAhPT0gJ2dlc3R1cmUnKSB7XG4gICAgICBhd2FpdCBvdmVybGF5QW5pbWF0aW9uKG92ZXJsYXksIGFuaW1hdGlvbkJ1aWxkZXIsIG92ZXJsYXkuZWwsIG9wdHMpO1xuICAgIH1cbiAgICBvdmVybGF5LmRpZERpc21pc3MuZW1pdCh7IGRhdGEsIHJvbGUgfSk7XG4gICAgKF9iID0gb3ZlcmxheS5kaWREaXNtaXNzU2hvcnRoYW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdCh7IGRhdGEsIHJvbGUgfSk7XG4gICAgYWN0aXZlQW5pbWF0aW9ucy5kZWxldGUob3ZlcmxheSk7XG4gICAgLyoqXG4gICAgICogTWFrZSBvdmVybGF5IGhpZGRlbiBhZ2FpbiBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZC5cbiAgICAgKiBXZSBjYW4gc2FmZWx5IHJlbW92ZSBwb2ludGVyLWV2ZW50czogbm9uZSBhc1xuICAgICAqIG92ZXJsYXktaGlkZGVuIHdpbGwgc2V0IGRpc3BsYXk6IG5vbmUuXG4gICAgICovXG4gICAgb3ZlcmxheS5lbC5jbGFzc0xpc3QuYWRkKCdvdmVybGF5LWhpZGRlbicpO1xuICAgIG92ZXJsYXkuZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJyk7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxuICBvdmVybGF5LmVsLnJlbW92ZSgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBnZXRBcHBSb290ID0gKGRvYykgPT4ge1xuICByZXR1cm4gZG9jLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1hcHAnKSB8fCBkb2MuYm9keTtcbn07XG5jb25zdCBvdmVybGF5QW5pbWF0aW9uID0gYXN5bmMgKG92ZXJsYXksIGFuaW1hdGlvbkJ1aWxkZXIsIGJhc2VFbCwgb3B0cykgPT4ge1xuICAvLyBNYWtlIG92ZXJsYXkgdmlzaWJsZSBpbiBjYXNlIGl0J3MgaGlkZGVuXG4gIGJhc2VFbC5jbGFzc0xpc3QucmVtb3ZlKCdvdmVybGF5LWhpZGRlbicpO1xuICBjb25zdCBhbmlSb290ID0gb3ZlcmxheS5lbDtcbiAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0aW9uQnVpbGRlcihhbmlSb290LCBvcHRzKTtcbiAgaWYgKCFvdmVybGF5LmFuaW1hdGVkIHx8ICFjb25maWcuZ2V0Qm9vbGVhbignYW5pbWF0ZWQnLCB0cnVlKSkge1xuICAgIGFuaW1hdGlvbi5kdXJhdGlvbigwKTtcbiAgfVxuICBpZiAob3ZlcmxheS5rZXlib2FyZENsb3NlKSB7XG4gICAgYW5pbWF0aW9uLmJlZm9yZUFkZFdyaXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBiYXNlRWwub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5tYXRjaGVzKCdpbnB1dCxpb24taW5wdXQsIGlvbi10ZXh0YXJlYScpKSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUFuaSA9IGFjdGl2ZUFuaW1hdGlvbnMuZ2V0KG92ZXJsYXkpIHx8IFtdO1xuICBhY3RpdmVBbmltYXRpb25zLnNldChvdmVybGF5LCBbLi4uYWN0aXZlQW5pLCBhbmltYXRpb25dKTtcbiAgYXdhaXQgYW5pbWF0aW9uLnBsYXkoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgZXZlbnRNZXRob2QgPSAoZWxlbWVudCwgZXZlbnROYW1lKSA9PiB7XG4gIGxldCByZXNvbHZlO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gIG9uY2VFdmVudChlbGVtZW50LCBldmVudE5hbWUsIChldmVudCkgPT4ge1xuICAgIHJlc29sdmUoZXZlbnQuZGV0YWlsKTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbmNvbnN0IG9uY2VFdmVudCA9IChlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXYpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgY2FsbGJhY2soZXYpO1xuICB9O1xuICBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG59O1xuY29uc3QgaXNDYW5jZWwgPSAocm9sZSkgPT4ge1xuICByZXR1cm4gcm9sZSA9PT0gJ2NhbmNlbCcgfHwgcm9sZSA9PT0gQkFDS0RST1A7XG59O1xuY29uc3QgZGVmYXVsdEdhdGUgPSAoaCkgPT4gaCgpO1xuLyoqXG4gKiBDYWxscyBhIGRldmVsb3BlciBwcm92aWRlZCBtZXRob2Qgd2hpbGUgYXZvaWRpbmdcbiAqIEFuZ3VsYXIgWm9uZXMuIFNpbmNlIHRoZSBoYW5kbGVyIGlzIHByb3ZpZGVkIGJ5XG4gKiB0aGUgZGV2ZWxvcGVyLCB3ZSBzaG91bGQgdGhyb3cgYW55IGVycm9yc1xuICogcmVjZWl2ZWQgc28gdGhhdCBkZXZlbG9wZXItcHJvdmlkZWQgYnVnXG4gKiB0cmFja2luZyBzb2Z0d2FyZSBjYW4gbG9nIGl0LlxuICovXG5jb25zdCBzYWZlQ2FsbCA9IChoYW5kbGVyLCBhcmcpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgam1wID0gY29uZmlnLmdldCgnX3pvbmVHYXRlJywgZGVmYXVsdEdhdGUpO1xuICAgIHJldHVybiBqbXAoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoYXJnKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBCQUNLRFJPUCA9ICdiYWNrZHJvcCc7XG5cbmV4cG9ydCB7IEJBQ0tEUk9QIGFzIEIsIGFsZXJ0Q29udHJvbGxlciBhcyBhLCBhY3Rpb25TaGVldENvbnRyb2xsZXIgYXMgYiwgcG9wb3ZlckNvbnRyb2xsZXIgYXMgYywgcHJlc2VudCBhcyBkLCBwcmVwYXJlT3ZlcmxheSBhcyBlLCBkaXNtaXNzIGFzIGYsIGV2ZW50TWV0aG9kIGFzIGcsIGZvY3VzRmlyc3REZXNjZW5kYW50IGFzIGgsIGlzQ2FuY2VsIGFzIGksIGdldE92ZXJsYXkgYXMgaiwgYWN0aXZlQW5pbWF0aW9ucyBhcyBrLCBsb2FkaW5nQ29udHJvbGxlciBhcyBsLCBtb2RhbENvbnRyb2xsZXIgYXMgbSwgcGlja2VyQ29udHJvbGxlciBhcyBwLCBzYWZlQ2FsbCBhcyBzLCB0b2FzdENvbnRyb2xsZXIgYXMgdCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbi8qKlxuICogQmFzZWQgb246XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzQ4MDA5L3ktY29vcmRpbmF0ZS1mb3ItYS1naXZlbi14LWN1YmljLWJlemllclxuICogaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yNjg0Ni9pcy10aGVyZS1hbi1leHBsaWNpdC1mb3JtLWZvci1jdWJpYy1iJUMzJUE5emllci1jdXJ2ZXNcbiAqIFRPRE86IFJlZHVjZSByb3VuZGluZyBlcnJvclxuICovXG4vKipcbiAqIEVYUEVSSU1FTlRBTFxuICogR2l2ZW4gYSBjdWJpYy1iZXppZXIgY3VydmUsIGdldCB0aGUgeCB2YWx1ZSAodGltZSkgZ2l2ZW5cbiAqIHRoZSB5IHZhbHVlIChwcm9ncmVzc2lvbikuXG4gKiBFeDogY3ViaWMtYmV6aWVyKDAuMzIsIDAuNzIsIDAsIDEpO1xuICogUDA6ICgwLCAwKVxuICogUDE6ICgwLjMyLCAwLjcyKVxuICogUDI6ICgwLCAxKVxuICogUDM6ICgxLCAxKVxuICpcbiAqIElmIHlvdSBnaXZlIGEgY3ViaWMgYmV6aWVyIGN1cnZlIHRoYXQgbmV2ZXIgcmVhY2hlcyB0aGVcbiAqIHByb3ZpZGVkIHByb2dyZXNzaW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICovXG5jb25zdCBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbiA9IChwMCwgcDEsIHAyLCBwMywgcHJvZ3Jlc3Npb24pID0+IHtcbiAgcmV0dXJuIHNvbHZlQ3ViaWNCZXppZXIocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHByb2dyZXNzaW9uKS5tYXAodFZhbHVlID0+IHtcbiAgICByZXR1cm4gc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbihwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdFZhbHVlKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBTb2x2ZSBhIGN1YmljIGVxdWF0aW9uIGluIG9uZSBkaW1lbnNpb24gKHRpbWUpXG4gKi9cbmNvbnN0IHNvbHZlQ3ViaWNQYXJhbWV0cmljRXF1YXRpb24gPSAocDAsIHAxLCBwMiwgcDMsIHQpID0+IHtcbiAgY29uc3QgcGFydEEgPSAoMyAqIHAxKSAqIE1hdGgucG93KHQgLSAxLCAyKTtcbiAgY29uc3QgcGFydEIgPSAoLTMgKiBwMiAqIHQpICsgKDMgKiBwMikgKyAocDMgKiB0KTtcbiAgY29uc3QgcGFydEMgPSBwMCAqIE1hdGgucG93KHQgLSAxLCAzKTtcbiAgcmV0dXJuIHQgKiAocGFydEEgKyAodCAqIHBhcnRCKSkgLSBwYXJ0Qztcbn07XG4vKipcbiAqIEZpbmQgdGhlIGB0YCB2YWx1ZSBmb3IgYSBjdWJpYyBiZXppZXIgdXNpbmcgQ2FyZGFubydzIGZvcm11bGFcbiAqL1xuY29uc3Qgc29sdmVDdWJpY0JlemllciA9IChwMCwgcDEsIHAyLCBwMywgcmVmUG9pbnQpID0+IHtcbiAgcDAgLT0gcmVmUG9pbnQ7XG4gIHAxIC09IHJlZlBvaW50O1xuICBwMiAtPSByZWZQb2ludDtcbiAgcDMgLT0gcmVmUG9pbnQ7XG4gIGNvbnN0IHJvb3RzID0gc29sdmVDdWJpY0VxdWF0aW9uKHAzIC0gMyAqIHAyICsgMyAqIHAxIC0gcDAsIDMgKiBwMiAtIDYgKiBwMSArIDMgKiBwMCwgMyAqIHAxIC0gMyAqIHAwLCBwMCk7XG4gIHJldHVybiByb290cy5maWx0ZXIocm9vdCA9PiByb290ID49IDAgJiYgcm9vdCA8PSAxKTtcbn07XG5jb25zdCBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uID0gKGEsIGIsIGMpID0+IHtcbiAgY29uc3QgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpLFxuICAgICAgKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKVxuICAgIF07XG4gIH1cbn07XG5jb25zdCBzb2x2ZUN1YmljRXF1YXRpb24gPSAoYSwgYiwgYywgZCkgPT4ge1xuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uKGIsIGMsIGQpO1xuICB9XG4gIGIgLz0gYTtcbiAgYyAvPSBhO1xuICBkIC89IGE7XG4gIGNvbnN0IHAgPSAoMyAqIGMgLSBiICogYikgLyAzO1xuICBjb25zdCBxID0gKDIgKiBiICogYiAqIGIgLSA5ICogYiAqIGMgKyAyNyAqIGQpIC8gMjc7XG4gIGlmIChwID09PSAwKSB7XG4gICAgcmV0dXJuIFtNYXRoLnBvdygtcSwgMSAvIDMpXTtcbiAgfVxuICBlbHNlIGlmIChxID09PSAwKSB7XG4gICAgcmV0dXJuIFtNYXRoLnNxcnQoLXApLCAtTWF0aC5zcXJ0KC1wKV07XG4gIH1cbiAgY29uc3QgZGlzY3JpbWluYW50ID0gTWF0aC5wb3cocSAvIDIsIDIpICsgTWF0aC5wb3cocCAvIDMsIDMpO1xuICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgcmV0dXJuIFtNYXRoLnBvdyhxIC8gMiwgMSAvIDIpIC0gYiAvIDNdO1xuICB9XG4gIGVsc2UgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICByZXR1cm4gW01hdGgucG93KC0ocSAvIDIpICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCksIDEgLyAzKSAtIE1hdGgucG93KChxIC8gMikgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSwgMSAvIDMpIC0gYiAvIDNdO1xuICB9XG4gIGNvbnN0IHIgPSBNYXRoLnNxcnQoTWF0aC5wb3coLShwIC8gMyksIDMpKTtcbiAgY29uc3QgcGhpID0gTWF0aC5hY29zKC0ocSAvICgyICogTWF0aC5zcXJ0KE1hdGgucG93KC0ocCAvIDMpLCAzKSkpKSk7XG4gIGNvbnN0IHMgPSAyICogTWF0aC5wb3cociwgMSAvIDMpO1xuICByZXR1cm4gW1xuICAgIHMgKiBNYXRoLmNvcyhwaGkgLyAzKSAtIGIgLyAzLFxuICAgIHMgKiBNYXRoLmNvcygocGhpICsgMiAqIE1hdGguUEkpIC8gMykgLSBiIC8gMyxcbiAgICBzICogTWF0aC5jb3MoKHBoaSArIDQgKiBNYXRoLlBJKSAvIDMpIC0gYiAvIDNcbiAgXTtcbn07XG5cbmV4cG9ydCB7IGdldFRpbWVHaXZlblByb2dyZXNzaW9uIGFzIGcgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG5jb25zdCBhdHRhY2hDb21wb25lbnQgPSBhc3luYyAoZGVsZWdhdGUsIGNvbnRhaW5lciwgY29tcG9uZW50LCBjc3NDbGFzc2VzLCBjb21wb25lbnRQcm9wcywgaW5saW5lKSA9PiB7XG4gIGlmIChkZWxlZ2F0ZSkge1xuICAgIHJldHVybiBkZWxlZ2F0ZS5hdHRhY2hWaWV3VG9Eb20oY29udGFpbmVyLCBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzLCBjc3NDbGFzc2VzKTtcbiAgfVxuICBpZiAoIWlubGluZSAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSAnc3RyaW5nJyAmJiAhKGNvbXBvbmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZnJhbWV3b3JrIGRlbGVnYXRlIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBjb25zdCBlbCA9ICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJylcbiAgICA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50ICYmIGNvbnRhaW5lci5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50KVxuICAgIDogY29tcG9uZW50O1xuICBpZiAoY3NzQ2xhc3Nlcykge1xuICAgIGNzc0NsYXNzZXMuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICB9XG4gIGlmIChjb21wb25lbnRQcm9wcykge1xuICAgIE9iamVjdC5hc3NpZ24oZWwsIGNvbXBvbmVudFByb3BzKTtcbiAgfVxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNvbXBvbmVudE9uUmVhZHkoZWwsIHJlc29sdmUpKTtcbiAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGRldGFjaENvbXBvbmVudCA9IChkZWxlZ2F0ZSwgZWxlbWVudCkgPT4ge1xuICBpZiAoZWxlbWVudCkge1xuICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgcmV0dXJuIGRlbGVnYXRlLnJlbW92ZVZpZXdGcm9tRG9tKGNvbnRhaW5lciwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcbmNvbnN0IENvcmVEZWxlZ2F0ZSA9ICgpID0+IHtcbiAgbGV0IEJhc2VDb21wb25lbnQ7XG4gIGxldCBSZWZlcmVuY2U7XG4gIGNvbnN0IGF0dGFjaFZpZXdUb0RvbSA9IGFzeW5jIChwYXJlbnRFbGVtZW50LCB1c2VyQ29tcG9uZW50LCB1c2VyQ29tcG9uZW50UHJvcHMgPSB7fSwgY3NzQ2xhc3NlcyA9IFtdKSA9PiB7XG4gICAgQmFzZUNvbXBvbmVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogSWYgcGFzc2luZyBpbiBhIGNvbXBvbmVudCB2aWEgdGhlIGBjb21wb25lbnRgIHByb3BzXG4gICAgICogd2UgbmVlZCB0byBhcHBlbmQgaXQgaW5zaWRlIG9mIG91ciBvdmVybGF5IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBpZiAodXNlckNvbXBvbmVudCkge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiBwYXNzaW5nIGluIHRoZSB0YWcgbmFtZSwgY3JlYXRlXG4gICAgICAgKiB0aGUgZWxlbWVudCBvdGhlcndpc2UganVzdCBnZXQgYSByZWZlcmVuY2VcbiAgICAgICAqIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGVsID0gKHR5cGVvZiB1c2VyQ29tcG9uZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgPyBCYXNlQ29tcG9uZW50Lm93bmVyRG9jdW1lbnQgJiYgQmFzZUNvbXBvbmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodXNlckNvbXBvbmVudClcbiAgICAgICAgOiB1c2VyQ29tcG9uZW50O1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW55IGNzcyBjbGFzc2VzIHBhc3NlZCBpblxuICAgICAgICogdmlhIHRoZSBjc3NDbGFzc2VzIHByb3Agb24gdGhlIG92ZXJsYXkuXG4gICAgICAgKi9cbiAgICAgIGNzc0NsYXNzZXMuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW55IHByb3BzIHBhc3NlZCBpblxuICAgICAgICogdmlhIHRoZSBjb21wb25lbnRQcm9wcyBwcm9wIG9uIHRoZSBvdmVybGF5LlxuICAgICAgICovXG4gICAgICBPYmplY3QuYXNzaWduKGVsLCB1c2VyQ29tcG9uZW50UHJvcHMpO1xuICAgICAgLyoqXG4gICAgICAgKiBGaW5hbGx5LCBhcHBlbmQgdGhlIGNvbXBvbmVudFxuICAgICAgICogaW5zaWRlIG9mIHRoZSBvdmVybGF5IGNvbXBvbmVudC5cbiAgICAgICAqL1xuICAgICAgQmFzZUNvbXBvbmVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNvbXBvbmVudE9uUmVhZHkoZWwsIHJlc29sdmUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmFzZUNvbXBvbmVudC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjb21wb25lbnQsIHRoZW4gd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgcGFyZW50XG4gICAgICAvLyBlbGVtZW50IHRvIGFwcGx5IHRoZSBjc3MgY2xhc3NlcyB0by5cbiAgICAgIGNvbnN0IGVsID0gQmFzZUNvbXBvbmVudC5vd25lckRvY3VtZW50ICYmIEJhc2VDb21wb25lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNzc0NsYXNzZXMuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgLy8gTW92ZSBlYWNoIGNoaWxkIGZyb20gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRvIHRoZSBuZXcgcGFyZW50IGVsZW1lbnQuXG4gICAgICBlbC5hcHBlbmQoLi4uQmFzZUNvbXBvbmVudC5jaGlsZHJlbik7XG4gICAgICAvLyBBcHBlbmQgdGhlIG5ldyBwYXJlbnQgZWxlbWVudCB0byB0aGUgb3JpZ2luYWwgcGFyZW50IGVsZW1lbnQuXG4gICAgICBCYXNlQ29tcG9uZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb290IG9mIHRoZSBhcHAgYW5kXG4gICAgICogYWRkIHRoZSBvdmVybGF5IHRoZXJlLlxuICAgICAqL1xuICAgIGNvbnN0IGFwcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1hcHAnKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHBsYWNlaG9sZGVyIGNvbW1lbnQgc28gdGhhdFxuICAgICAqIHdlIGNhbiByZXR1cm4gdGhpcyBjb21wb25lbnQgdG8gd2hlcmVcbiAgICAgKiBpdCB3YXMgcHJldmlvdXNseS5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdpb25pYyB0ZWxlcG9ydCcpO1xuICAgIEJhc2VDb21wb25lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoUmVmZXJlbmNlLCBCYXNlQ29tcG9uZW50KTtcbiAgICBhcHAuYXBwZW5kQ2hpbGQoQmFzZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIEJhc2VDb21wb25lbnQ7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVZpZXdGcm9tRG9tID0gKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybiBjb21wb25lbnQgdG8gd2hlcmUgaXQgd2FzIHByZXZpb3VzbHkgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBpZiAoQmFzZUNvbXBvbmVudCAmJiBSZWZlcmVuY2UpIHtcbiAgICAgIFJlZmVyZW5jZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShCYXNlQ29tcG9uZW50LCBSZWZlcmVuY2UpO1xuICAgICAgUmVmZXJlbmNlLnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHJldHVybiB7IGF0dGFjaFZpZXdUb0RvbSwgcmVtb3ZlVmlld0Zyb21Eb20gfTtcbn07XG5cbmV4cG9ydCB7IENvcmVEZWxlZ2F0ZSBhcyBDLCBhdHRhY2hDb21wb25lbnQgYXMgYSwgZGV0YWNoQ29tcG9uZW50IGFzIGQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBjcmVhdGVFdmVudCwgaCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSwgYyBhcyBjb25maWcgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFRpbWVHaXZlblByb2dyZXNzaW9uIH0gZnJvbSAnLi9jdWJpYy1iZXppZXIuanMnO1xuaW1wb3J0IHsgYSBhcyBhdHRhY2hDb21wb25lbnQsIGQgYXMgZGV0YWNoQ29tcG9uZW50IH0gZnJvbSAnLi9mcmFtZXdvcmstZGVsZWdhdGUuanMnO1xuaW1wb3J0IHsgcyBhcyBzaGFsbG93RXF1YWxTdHJpbmdNYXAgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuaW1wb3J0IHsgdCBhcyB0cmFuc2l0aW9uIH0gZnJvbSAnLi9pbmRleDQuanMnO1xuXG5jb25zdCByb3V0ZU91dGxldENzcyA9IFwiOmhvc3R7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGFpbjpsYXlvdXQgc2l6ZSBzdHlsZTtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDowfVwiO1xuXG5jb25zdCBSb3V0ZXJPdXRsZXQgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uTmF2V2lsbExvYWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvbk5hdldpbGxMb2FkXCIsIDcpO1xuICAgIHRoaXMuaW9uTmF2V2lsbENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uTmF2V2lsbENoYW5nZVwiLCAzKTtcbiAgICB0aGlzLmlvbk5hdkRpZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uTmF2RGlkQ2hhbmdlXCIsIDMpO1xuICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlIGRldGVybWluZXMgd2hpY2ggcGxhdGZvcm0gc3R5bGVzIHRvIHVzZS5cbiAgICAgKi9cbiAgICB0aGlzLm1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHJvdXRlci1vdXRsZXQgc2hvdWxkIGFuaW1hdGUgdGhlIHRyYW5zaXRpb24gb2YgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgfVxuICBzd2lwZUhhbmRsZXJDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLmdlc3R1cmUpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZS5lbmFibGUodGhpcy5zd2lwZUhhbmRsZXIgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuc3dpcGVIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuc3dpcGVIYW5kbGVyLm9uU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2VzdHVyZSA9IChhd2FpdCBpbXBvcnQoJy4vc3dpcGUtYmFjay5qcycpKS5jcmVhdGVTd2lwZUJhY2tHZXN0dXJlKHRoaXMuZWwsICgpID0+ICF0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgJiYgISF0aGlzLnN3aXBlSGFuZGxlciAmJiB0aGlzLnN3aXBlSGFuZGxlci5jYW5TdGFydCgpLCAoKSA9PiBvblN0YXJ0KCksIHN0ZXAgPT4gdGhpcy5hbmkgJiYgdGhpcy5hbmkucHJvZ3Jlc3NTdGVwKHN0ZXApLCAoc2hvdWxkQ29tcGxldGUsIHN0ZXAsIGR1cikgPT4ge1xuICAgICAgaWYgKHRoaXMuYW5pKSB7XG4gICAgICAgIHRoaXMuYW5pLm9uRmluaXNoKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGhpcy5zd2lwZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3dpcGVIYW5kbGVyLm9uRW5kKHNob3VsZENvbXBsZXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHsgb25lVGltZUNhbGxiYWNrOiB0cnVlIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGZvciByb3VuZGluZyBlcnJvcnMgaW4gSlNcbiAgICAgICAgbGV0IG5ld1N0ZXBWYWx1ZSA9IChzaG91bGRDb21wbGV0ZSkgPyAtMC4wMDEgOiAwLjAwMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuaW1hdGlvbiB3aWxsIGJlIHJldmVyc2VkIGhlcmUsIHNvIG5lZWQgdG9cbiAgICAgICAgICogcmV2ZXJzZSB0aGUgZWFzaW5nIGN1cnZlIGFzIHdlbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQWRkaXRpb25hbGx5LCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSB0aW1lIHJlbGF0aXZlXG4gICAgICAgICAqIHRvIHRoZSBuZXcgZWFzaW5nIGN1cnZlLCBhcyBgc3RlcFZhbHVlYCBpcyBnb2luZyB0byBiZSBnaXZlblxuICAgICAgICAgKiBpbiB0ZXJtcyBvZiBhIGxpbmVhciBjdXJ2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgICB0aGlzLmFuaS5lYXNpbmcoJ2N1YmljLWJlemllcigxLCAwLCAwLjY4LCAwLjI4KScpO1xuICAgICAgICAgIG5ld1N0ZXBWYWx1ZSArPSBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihbMCwgMF0sIFsxLCAwXSwgWzAuNjgsIDAuMjhdLCBbMSwgMV0sIHN0ZXApWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld1N0ZXBWYWx1ZSArPSBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbihbMCwgMF0sIFswLjMyLCAwLjcyXSwgWzAsIDFdLCBbMSwgMV0sIHN0ZXApWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pLnByb2dyZXNzRW5kKHNob3VsZENvbXBsZXRlID8gMSA6IDAsIG5ld1N0ZXBWYWx1ZSwgZHVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN3aXBlSGFuZGxlckNoYW5nZWQoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLmlvbk5hdldpbGxMb2FkLmVtaXQoKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5nZXN0dXJlKSB7XG4gICAgICB0aGlzLmdlc3R1cmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5nZXN0dXJlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIGNvbW1pdChlbnRlcmluZ0VsLCBsZWF2aW5nRWwsIG9wdHMpIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmxvY2soKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjaGFuZ2VkID0gYXdhaXQgdGhpcy50cmFuc2l0aW9uKGVudGVyaW5nRWwsIGxlYXZpbmdFbCwgb3B0cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgICB1bmxvY2soKTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIHNldFJvdXRlSWQoaWQsIHBhcmFtcywgZGlyZWN0aW9uLCBhbmltYXRpb24pIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gYXdhaXQgdGhpcy5zZXRSb290KGlkLCBwYXJhbXMsIHtcbiAgICAgIGR1cmF0aW9uOiBkaXJlY3Rpb24gPT09ICdyb290JyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gJ2JhY2snID8gJ2JhY2snIDogJ2ZvcndhcmQnLFxuICAgICAgYW5pbWF0aW9uQnVpbGRlcjogYW5pbWF0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZWQsXG4gICAgICBlbGVtZW50OiB0aGlzLmFjdGl2ZUVsXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIGdldFJvdXRlSWQoKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5hY3RpdmVFbDtcbiAgICByZXR1cm4gYWN0aXZlID8ge1xuICAgICAgaWQ6IGFjdGl2ZS50YWdOYW1lLFxuICAgICAgZWxlbWVudDogYWN0aXZlLFxuICAgICAgcGFyYW1zOiB0aGlzLmFjdGl2ZVBhcmFtcyxcbiAgICB9IDogdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIHNldFJvb3QoY29tcG9uZW50LCBwYXJhbXMsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVDb21wb25lbnQgPT09IGNvbXBvbmVudCAmJiBzaGFsbG93RXF1YWxTdHJpbmdNYXAocGFyYW1zLCB0aGlzLmFjdGl2ZVBhcmFtcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXR0YWNoIGVudGVyaW5nIHZpZXcgdG8gRE9NXG4gICAgY29uc3QgbGVhdmluZ0VsID0gdGhpcy5hY3RpdmVFbDtcbiAgICBjb25zdCBlbnRlcmluZ0VsID0gYXdhaXQgYXR0YWNoQ29tcG9uZW50KHRoaXMuZGVsZWdhdGUsIHRoaXMuZWwsIGNvbXBvbmVudCwgWydpb24tcGFnZScsICdpb24tcGFnZS1pbnZpc2libGUnXSwgcGFyYW1zKTtcbiAgICB0aGlzLmFjdGl2ZUNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLmFjdGl2ZUVsID0gZW50ZXJpbmdFbDtcbiAgICB0aGlzLmFjdGl2ZVBhcmFtcyA9IHBhcmFtcztcbiAgICAvLyBjb21taXQgYW5pbWF0aW9uXG4gICAgYXdhaXQgdGhpcy5jb21taXQoZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzKTtcbiAgICBhd2FpdCBkZXRhY2hDb21wb25lbnQodGhpcy5kZWxlZ2F0ZSwgbGVhdmluZ0VsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyB0cmFuc2l0aW9uKGVudGVyaW5nRWwsIGxlYXZpbmdFbCwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKGxlYXZpbmdFbCA9PT0gZW50ZXJpbmdFbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbWl0IG5hdiB3aWxsIGNoYW5nZSBldmVudFxuICAgIHRoaXMuaW9uTmF2V2lsbENoYW5nZS5lbWl0KCk7XG4gICAgY29uc3QgeyBlbCwgbW9kZSB9ID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRlZCA9IHRoaXMuYW5pbWF0ZWQgJiYgY29uZmlnLmdldEJvb2xlYW4oJ2FuaW1hdGVkJywgdHJ1ZSk7XG4gICAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IG9wdHMuYW5pbWF0aW9uQnVpbGRlciB8fCB0aGlzLmFuaW1hdGlvbiB8fCBjb25maWcuZ2V0KCduYXZBbmltYXRpb24nKTtcbiAgICBhd2FpdCB0cmFuc2l0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IG1vZGUsXG4gICAgICBhbmltYXRlZCxcbiAgICAgIGVudGVyaW5nRWwsXG4gICAgICBsZWF2aW5nRWwsIGJhc2VFbDogZWwsIHByb2dyZXNzQ2FsbGJhY2s6IChvcHRzLnByb2dyZXNzQW5pbWF0aW9uXG4gICAgICAgID8gYW5pID0+IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBCZWNhdXNlIHRoaXMgcHJvZ3Jlc3MgY2FsbGJhY2sgaXMgY2FsbGVkIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICogaXQgaXMgcG9zc2libGUgZm9yIHRoZSBnZXN0dXJlIHRvIHN0YXJ0IGFuZCBlbmQgYmVmb3JlXG4gICAgICAgICAgICogdGhlIGFuaW1hdGlvbiBpcyBldmVyIHNldC4gSW4gdGhhdCBzY2VuYXJpbywgd2Ugc2hvdWxkXG4gICAgICAgICAgICogaW1tZWRpYXRlbHkgY2FsbCBwcm9ncmVzc0VuZCBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIHByb21pc2VcbiAgICAgICAgICAgKiByZXNvbHZlcyBhbmQgdGhlIGdlc3R1cmUgZG9lcyBub3QgZ2V0IGxvY2tlZCB1cC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoYW5pICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGFuaS5vbkZpbmlzaCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodGhpcy5zd2lwZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXBlSGFuZGxlci5vbkVuZChmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgb25lVGltZUNhbGxiYWNrOiB0cnVlIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQbGF5aW5nIGFuaW1hdGlvbiB0byBiZWdpbm5pbmdcbiAgICAgICAgICAgICAqIHdpdGggYSBkdXJhdGlvbiBvZiAwIHByZXZlbnRzXG4gICAgICAgICAgICAgKiBhbnkgZmxpY2tlcmluZyB3aGVuIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAqIGlzIGxhdGVyIGNsZWFuZWQgdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFuaS5wcm9ncmVzc0VuZCgwLCAwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuaSA9IGFuaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQpIH0sIG9wdHMpLCB7IGFuaW1hdGlvbkJ1aWxkZXIgfSkpO1xuICAgIC8vIGVtaXQgbmF2IGNoYW5nZWQgZXZlbnRcbiAgICB0aGlzLmlvbk5hdkRpZENoYW5nZS5lbWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgbG9jaygpIHtcbiAgICBjb25zdCBwID0gdGhpcy53YWl0UHJvbWlzZTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICB0aGlzLndhaXRQcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gICAgaWYgKHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXdhaXQgcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChcInNsb3RcIiwgbnVsbCkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInN3aXBlSGFuZGxlclwiOiBbXCJzd2lwZUhhbmRsZXJDaGFuZ2VkXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHJvdXRlT3V0bGV0Q3NzOyB9XG59LCBbMSwgXCJpb24tcm91dGVyLW91dGxldFwiLCB7XG4gICAgXCJtb2RlXCI6IFsxMDI1XSxcbiAgICBcImRlbGVnYXRlXCI6IFsxNl0sXG4gICAgXCJhbmltYXRlZFwiOiBbNF0sXG4gICAgXCJhbmltYXRpb25cIjogWzE2XSxcbiAgICBcInN3aXBlSGFuZGxlclwiOiBbMTZdLFxuICAgIFwiY29tbWl0XCI6IFs2NF0sXG4gICAgXCJzZXRSb3V0ZUlkXCI6IFs2NF0sXG4gICAgXCJnZXRSb3V0ZUlkXCI6IFs2NF1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tcm91dGVyLW91dGxldFwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLXJvdXRlci1vdXRsZXRcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBSb3V0ZXJPdXRsZXQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvblJvdXRlck91dGxldCA9IFJvdXRlck91dGxldDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvblJvdXRlck91dGxldCwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmNvbnN0IGhvc3RDb250ZXh0ID0gKHNlbGVjdG9yLCBlbCkgPT4ge1xuICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3RvcikgIT09IG51bGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgdGhlIG1vZGUgYW5kIGNvbG9yIGNsYXNzZXMgZm9yIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGNsYXNzZXMgcGFzc2VkIGluXG4gKi9cbmNvbnN0IGNyZWF0ZUNvbG9yQ2xhc3NlcyA9IChjb2xvciwgY3NzQ2xhc3NNYXApID0+IHtcbiAgcmV0dXJuICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGNvbG9yLmxlbmd0aCA+IDApID8gT2JqZWN0LmFzc2lnbih7ICdpb24tY29sb3InOiB0cnVlLCBbYGlvbi1jb2xvci0ke2NvbG9yfWBdOiB0cnVlIH0sIGNzc0NsYXNzTWFwKSA6IGNzc0NsYXNzTWFwO1xufTtcbmNvbnN0IGdldENsYXNzTGlzdCA9IChjbGFzc2VzKSA9PiB7XG4gIGlmIChjbGFzc2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmlzQXJyYXkoY2xhc3NlcykgPyBjbGFzc2VzIDogY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgIHJldHVybiBhcnJheVxuICAgICAgLmZpbHRlcihjID0+IGMgIT0gbnVsbClcbiAgICAgIC5tYXAoYyA9PiBjLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoYyA9PiBjICE9PSAnJyk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbmNvbnN0IGdldENsYXNzTWFwID0gKGNsYXNzZXMpID0+IHtcbiAgY29uc3QgbWFwID0ge307XG4gIGdldENsYXNzTGlzdChjbGFzc2VzKS5mb3JFYWNoKGMgPT4gbWFwW2NdID0gdHJ1ZSk7XG4gIHJldHVybiBtYXA7XG59O1xuY29uc3QgU0NIRU1FID0gL15bYS16XVthLXowLTkrXFwtLl0qOi87XG5jb25zdCBvcGVuVVJMID0gYXN5bmMgKHVybCwgZXYsIGRpcmVjdGlvbiwgYW5pbWF0aW9uKSA9PiB7XG4gIGlmICh1cmwgIT0gbnVsbCAmJiB1cmxbMF0gIT09ICcjJyAmJiAhU0NIRU1FLnRlc3QodXJsKSkge1xuICAgIGNvbnN0IHJvdXRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1yb3V0ZXInKTtcbiAgICBpZiAocm91dGVyKSB7XG4gICAgICBpZiAoZXYgIT0gbnVsbCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlci5wdXNoKHVybCwgZGlyZWN0aW9uLCBhbmltYXRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVDb2xvckNsYXNzZXMgYXMgYywgZ2V0Q2xhc3NNYXAgYXMgZywgaG9zdENvbnRleHQgYXMgaCwgb3BlblVSTCBhcyBvIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgY3JlYXRlRXZlbnQsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZUNvbG9yQ2xhc3NlcyB9IGZyb20gJy4vdGhlbWUuanMnO1xuXG5jb25zdCB0YWJCYXJJb3NDc3MgPSBcIjpob3N0e3BhZGRpbmctbGVmdDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOmF1dG87cGFkZGluZy1ib3R0b206dmFyKC0taW9uLXNhZmUtYXJlYS1ib3R0b20sIDApO2JvcmRlci10b3A6dmFyKC0tYm9yZGVyKTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNvbG9yKTt0ZXh0LWFsaWduOmNlbnRlcjtjb250YWluOnN0cmljdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7ei1pbmRleDoxMDstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudDtib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnR9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpfX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pey0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1zaGFkZSk7LS1jb2xvci1zZWxlY3RlZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpLDpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7Y29sb3I6cmdiYSh2YXIoLS1pb24tY29sb3ItY29udHJhc3QtcmdiKSwgMC43KX06aG9zdCguaW9uLWNvbG9yKSw6aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCksOmhvc3QoLnRhYi1iYXItdHJhbnNsdWNlbnQpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCl7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQpfTpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9Omhvc3QoW3Nsb3Q9dG9wXSl7cGFkZGluZy10b3A6dmFyKC0taW9uLXNhZmUtYXJlYS10b3AsIDApO3BhZGRpbmctYm90dG9tOjA7Ym9yZGVyLXRvcDowO2JvcmRlci1ib3R0b206dmFyKC0tYm9yZGVyKX06aG9zdCgudGFiLWJhci1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0ey0tYmFja2dyb3VuZDp2YXIoLS1pb24tdGFiLWJhci1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tY29sb3Itc3RlcC01MCwgI2Y3ZjdmNykpOy0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi10YWItYmFyLWJhY2tncm91bmQtZm9jdXNlZCwgI2UwZTBlMCk7LS1ib3JkZXI6MC41NXB4IHNvbGlkIHZhcigtLWlvbi10YWItYmFyLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCByZ2JhKDAsIDAsIDAsIDAuMikpKSk7LS1jb2xvcjp2YXIoLS1pb24tdGFiLWJhci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtNDAwLCAjOTk5OTk5KSk7LS1jb2xvci1zZWxlY3RlZDp2YXIoLS1pb24tdGFiLWJhci1jb2xvci1zZWxlY3RlZCwgdmFyKC0taW9uLWNvbG9yLXByaW1hcnksICMzODgwZmYpKTtoZWlnaHQ6NTBweH1Ac3VwcG9ydHMgKCgtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cigwKSkgb3IgKGJhY2tkcm9wLWZpbHRlcjogYmx1cigwKSkpezpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KXstLWJhY2tncm91bmQ6cmdiYSh2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpLCAwLjgpOy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDIxMCUpIGJsdXIoMjBweCk7YmFja2Ryb3AtZmlsdGVyOnNhdHVyYXRlKDIxMCUpIGJsdXIoMjBweCl9Omhvc3QoLmlvbi1jb2xvci50YWItYmFyLXRyYW5zbHVjZW50KXtiYWNrZ3JvdW5kOnJnYmEodmFyKC0taW9uLWNvbG9yLWJhc2UtcmdiKSwgMC44KX06aG9zdCgudGFiLWJhci10cmFuc2x1Y2VudCkgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uLmlvbi1mb2N1c2VkKXtiYWNrZ3JvdW5kOnJnYmEodmFyKC0taW9uLWJhY2tncm91bmQtY29sb3ItcmdiLCAyNTUsIDI1NSwgMjU1KSwgMC42KX19XCI7XG5cbmNvbnN0IHRhYkJhck1kQ3NzID0gXCI6aG9zdHtwYWRkaW5nLWxlZnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDphdXRvO3BhZGRpbmctYm90dG9tOnZhcigtLWlvbi1zYWZlLWFyZWEtYm90dG9tLCAwKTtib3JkZXItdG9wOnZhcigtLWJvcmRlcik7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcik7dGV4dC1hbGlnbjpjZW50ZXI7Y29udGFpbjpzdHJpY3Q7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3otaW5kZXg6MTA7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnQ7Ym94LXNpemluZzpjb250ZW50LWJveCAhaW1wb3J0YW50fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3R7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KX19Omhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tY29sb3Itc2hhZGUpOy0tY29sb3Itc2VsZWN0ZWQ6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoLnRhYi1zZWxlY3RlZCl7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0KX06aG9zdCguaW9uLWNvbG9yKSw6aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2NvbG9yOnJnYmEodmFyKC0taW9uLWNvbG9yLWNvbnRyYXN0LXJnYiksIDAuNyl9Omhvc3QoLmlvbi1jb2xvciksOmhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXtiYWNrZ3JvdW5kOnZhcigtLWlvbi1jb2xvci1iYXNlKX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24uaW9uLWZvY3VzZWQpLDpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24uaW9uLWZvY3VzZWQpe2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKX06aG9zdCgudGFiLWJhci10cmFuc2x1Y2VudCkgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fTpob3N0KFtzbG90PXRvcF0pe3BhZGRpbmctdG9wOnZhcigtLWlvbi1zYWZlLWFyZWEtdG9wLCAwKTtwYWRkaW5nLWJvdHRvbTowO2JvcmRlci10b3A6MDtib3JkZXItYm90dG9tOnZhcigtLWJvcmRlcil9Omhvc3QoLnRhYi1iYXItaGlkZGVuKXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudH06aG9zdHstLWJhY2tncm91bmQ6dmFyKC0taW9uLXRhYi1iYXItYmFja2dyb3VuZCwgdmFyKC0taW9uLWJhY2tncm91bmQtY29sb3IsICNmZmYpKTstLWJhY2tncm91bmQtZm9jdXNlZDp2YXIoLS1pb24tdGFiLWJhci1iYWNrZ3JvdW5kLWZvY3VzZWQsICNlMGUwZTApOy0tYm9yZGVyOjFweCBzb2xpZCB2YXIoLS1pb24tdGFiLWJhci1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1ib3JkZXItY29sb3IsIHZhcigtLWlvbi1jb2xvci1zdGVwLTE1MCwgcmdiYSgwLCAwLCAwLCAwLjA3KSkpKTstLWNvbG9yOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLCB2YXIoLS1pb24tY29sb3Itc3RlcC02MDAsICM2NjY2NjYpKTstLWNvbG9yLXNlbGVjdGVkOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLXNlbGVjdGVkLCB2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZikpO2hlaWdodDo1NnB4fVwiO1xuXG5jb25zdCBUYWJCYXIgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uVGFiQmFyQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uVGFiQmFyQ2hhbmdlZFwiLCA3KTtcbiAgICB0aGlzLmtleWJvYXJkVmlzaWJsZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHRhYiBiYXIgd2lsbCBiZSB0cmFuc2x1Y2VudC5cbiAgICAgKiBPbmx5IGFwcGxpZXMgd2hlbiB0aGUgbW9kZSBpcyBgXCJpb3NcImAgYW5kIHRoZSBkZXZpY2Ugc3VwcG9ydHNcbiAgICAgKiBbYGJhY2tkcm9wLWZpbHRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9iYWNrZHJvcC1maWx0ZXIjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zbHVjZW50ID0gZmFsc2U7XG4gIH1cbiAgc2VsZWN0ZWRUYWJDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVGFiICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW9uVGFiQmFyQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgdGFiOiB0aGlzLnNlbGVjdGVkVGFiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5zZWxlY3RlZFRhYkNoYW5nZWQoKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMua2V5Ym9hcmRXaWxsU2hvd0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVsLmdldEF0dHJpYnV0ZSgnc2xvdCcpICE9PSAndG9wJykge1xuICAgICAgICAgIHRoaXMua2V5Ym9hcmRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5rZXlib2FyZFZpc2libGUgPSBmYWxzZSwgNTApO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxTaG93JywgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5Ym9hcmRXaWxsSGlkZScsIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxTaG93JywgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5Ym9hcmRXaWxsSGlkZScsIHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIpO1xuICAgICAgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlciA9IHRoaXMua2V5Ym9hcmRXaWxsSGlkZUhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbG9yLCB0cmFuc2x1Y2VudCwga2V5Ym9hcmRWaXNpYmxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IHJvbGU6IFwidGFibGlzdFwiLCBcImFyaWEtaGlkZGVuXCI6IGtleWJvYXJkVmlzaWJsZSA/ICd0cnVlJyA6IG51bGwsIGNsYXNzOiBjcmVhdGVDb2xvckNsYXNzZXMoY29sb3IsIHtcbiAgICAgICAgW21vZGVdOiB0cnVlLFxuICAgICAgICAndGFiLWJhci10cmFuc2x1Y2VudCc6IHRyYW5zbHVjZW50LFxuICAgICAgICAndGFiLWJhci1oaWRkZW4nOiBrZXlib2FyZFZpc2libGUsXG4gICAgICB9KSB9LCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcInNlbGVjdGVkVGFiXCI6IFtcInNlbGVjdGVkVGFiQ2hhbmdlZFwiXVxuICB9OyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB7XG4gICAgaW9zOiB0YWJCYXJJb3NDc3MsXG4gICAgbWQ6IHRhYkJhck1kQ3NzXG4gIH07IH1cbn0sIFszMywgXCJpb24tdGFiLWJhclwiLCB7XG4gICAgXCJjb2xvclwiOiBbNTEzXSxcbiAgICBcInNlbGVjdGVkVGFiXCI6IFsxLCBcInNlbGVjdGVkLXRhYlwiXSxcbiAgICBcInRyYW5zbHVjZW50XCI6IFs0XSxcbiAgICBcImtleWJvYXJkVmlzaWJsZVwiOiBbMzJdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRhYi1iYXJcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi10YWItYmFyXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgVGFiQmFyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25UYWJCYXIgPSBUYWJCYXI7XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25UYWJCYXIsIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCByZWFkVGFzaywgd3JpdGVUYXNrLCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuXG5jb25zdCByaXBwbGVFZmZlY3RDc3MgPSBcIjpob3N0e2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRhaW46c3RyaWN0O3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QoLnVuYm91bmRlZCl7Y29udGFpbjpsYXlvdXQgc2l6ZSBzdHlsZX0ucmlwcGxlLWVmZmVjdHtib3JkZXItcmFkaXVzOjUwJTtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjtjb2xvcjppbmhlcml0O2NvbnRhaW46c3RyaWN0O29wYWNpdHk6MDstd2Via2l0LWFuaW1hdGlvbjoyMjVtcyByaXBwbGVBbmltYXRpb24gZm9yd2FyZHMsIDc1bXMgZmFkZUluQW5pbWF0aW9uIGZvcndhcmRzO2FuaW1hdGlvbjoyMjVtcyByaXBwbGVBbmltYXRpb24gZm9yd2FyZHMsIDc1bXMgZmFkZUluQW5pbWF0aW9uIGZvcndhcmRzO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSwgb3BhY2l0eTtwb2ludGVyLWV2ZW50czpub25lfS5mYWRlLW91dHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKTstd2Via2l0LWFuaW1hdGlvbjoxNTBtcyBmYWRlT3V0QW5pbWF0aW9uIGZvcndhcmRzO2FuaW1hdGlvbjoxNTBtcyBmYWRlT3V0QW5pbWF0aW9uIGZvcndhcmRzfUAtd2Via2l0LWtleWZyYW1lcyByaXBwbGVBbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKTt0cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpfX1Aa2V5ZnJhbWVzIHJpcHBsZUFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2Zvcm06c2NhbGUoMSl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpO3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSl9fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlSW5BbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MH10b3tvcGFjaXR5OjAuMTZ9fUBrZXlmcmFtZXMgZmFkZUluQW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtvcGFjaXR5OjB9dG97b3BhY2l0eTowLjE2fX1ALXdlYmtpdC1rZXlmcmFtZXMgZmFkZU91dEFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eTowLjE2fXRve29wYWNpdHk6MH19QGtleWZyYW1lcyBmYWRlT3V0QW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtvcGFjaXR5OjAuMTZ9dG97b3BhY2l0eTowfX1cIjtcblxuY29uc3QgUmlwcGxlRWZmZWN0ID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0eXBlIG9mIHJpcHBsZS1lZmZlY3Q6XG4gICAgICpcbiAgICAgKiAtIGBib3VuZGVkYDogdGhlIHJpcHBsZSBlZmZlY3QgZXhwYW5kcyBmcm9tIHRoZSB1c2VyJ3MgY2xpY2sgcG9zaXRpb25cbiAgICAgKiAtIGB1bmJvdW5kZWRgOiB0aGUgcmlwcGxlIGVmZmVjdCBleHBhbmRzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYnV0dG9uIGFuZCBvdmVyZmxvd3MgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIE5PVEU6IFN1cmZhY2VzIGZvciBib3VuZGVkIHJpcHBsZXMgc2hvdWxkIGhhdmUgdGhlIG92ZXJmbG93IHByb3BlcnR5IHNldCB0byBoaWRkZW4sXG4gICAgICogd2hpbGUgc3VyZmFjZXMgZm9yIHVuYm91bmRlZCByaXBwbGVzIHNob3VsZCBoYXZlIGl0IHNldCB0byB2aXNpYmxlLlxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9ICdib3VuZGVkJztcbiAgfVxuICAvKipcbiAgICogQWRkcyB0aGUgcmlwcGxlIGVmZmVjdCB0byB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygd2hlcmUgdGhlIHJpcHBsZSBzaG91bGQgc3RhcnQuXG4gICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHdoZXJlIHRoZSByaXBwbGUgc2hvdWxkIHN0YXJ0LlxuICAgKi9cbiAgYXN5bmMgYWRkUmlwcGxlKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZWFkVGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gdGhpcy51bmJvdW5kZWQgPyBtYXhEaW0gOiBoeXBvdGVudXNlICsgUEFERElORztcbiAgICAgICAgY29uc3QgaW5pdGlhbFNpemUgPSBNYXRoLmZsb29yKG1heERpbSAqIElOSVRJQUxfT1JJR0lOX1NDQUxFKTtcbiAgICAgICAgY29uc3QgZmluYWxTY2FsZSA9IG1heFJhZGl1cyAvIGluaXRpYWxTaXplO1xuICAgICAgICBsZXQgcG9zWCA9IHggLSByZWN0LmxlZnQ7XG4gICAgICAgIGxldCBwb3NZID0geSAtIHJlY3QudG9wO1xuICAgICAgICBpZiAodGhpcy51bmJvdW5kZWQpIHtcbiAgICAgICAgICBwb3NYID0gd2lkdGggKiAwLjU7XG4gICAgICAgICAgcG9zWSA9IGhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZVggPSBwb3NYIC0gaW5pdGlhbFNpemUgKiAwLjU7XG4gICAgICAgIGNvbnN0IHN0eWxlWSA9IHBvc1kgLSBpbml0aWFsU2l6ZSAqIDAuNTtcbiAgICAgICAgY29uc3QgbW92ZVggPSB3aWR0aCAqIDAuNSAtIHBvc1g7XG4gICAgICAgIGNvbnN0IG1vdmVZID0gaGVpZ2h0ICogMC41IC0gcG9zWTtcbiAgICAgICAgd3JpdGVUYXNrKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmlwcGxlLWVmZmVjdCcpO1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gZGl2LnN0eWxlO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IHN0eWxlWSArICdweCc7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IHN0eWxlWCArICdweCc7XG4gICAgICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSBpbml0aWFsU2l6ZSArICdweCc7XG4gICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoJy0tZmluYWwtc2NhbGUnLCBgJHtmaW5hbFNjYWxlfWApO1xuICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KCctLXRyYW5zbGF0ZS1lbmQnLCBgJHttb3ZlWH1weCwgJHttb3ZlWX1weGApO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZWwuc2hhZG93Um9vdCB8fCB0aGlzLmVsO1xuICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlbW92ZVJpcHBsZShkaXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMjI1ICsgMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICd1bmJvdW5kZWQnO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICd1bmJvdW5kZWQnOiB0aGlzLnVuYm91bmRlZFxuICAgICAgfSB9KSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gcmlwcGxlRWZmZWN0Q3NzOyB9XG59LCBbMSwgXCJpb24tcmlwcGxlLWVmZmVjdFwiLCB7XG4gICAgXCJ0eXBlXCI6IFsxXSxcbiAgICBcImFkZFJpcHBsZVwiOiBbNjRdXG4gIH1dKTtcbmNvbnN0IHJlbW92ZVJpcHBsZSA9IChyaXBwbGUpID0+IHtcbiAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtb3V0Jyk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHJpcHBsZS5yZW1vdmUoKTtcbiAgfSwgMjAwKTtcbn07XG5jb25zdCBQQURESU5HID0gMTA7XG5jb25zdCBJTklUSUFMX09SSUdJTl9TQ0FMRSA9IDAuNTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1yaXBwbGUtZWZmZWN0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tcmlwcGxlLWVmZmVjdFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFJpcHBsZUVmZmVjdCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuZXhwb3J0IHsgUmlwcGxlRWZmZWN0IGFzIFIsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYyBhcyBjb25maWcsIGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQyIH0gZnJvbSAnLi9yaXBwbGUtZWZmZWN0LmpzJztcblxuY29uc3QgdGFiQnV0dG9uSW9zQ3NzID0gXCI6aG9zdHstLXJpcHBsZS1jb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCk7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eToxOy1tcy1mbGV4OjE7ZmxleDoxOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MTAwJTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcil9LmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLXJhZGl1czppbmhlcml0O21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtwYWRkaW5nLWxlZnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1yaWdodDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy10b3A6dmFyKC0tcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLXBhZGRpbmctYm90dG9tKTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtc3R5bGU6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7dGV4dC1pbmRlbnQ6aW5oZXJpdDt0ZXh0LW92ZXJmbG93OmluaGVyaXQ7dGV4dC10cmFuc2Zvcm06aW5oZXJpdDt0ZXh0LWFsaWduOmluaGVyaXQ7d2hpdGUtc3BhY2U6aW5oZXJpdDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlcjowO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O3RleHQtZGVjb3JhdGlvbjpub25lO2N1cnNvcjpwb2ludGVyO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5idXR0b24tbmF0aXZle3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0uYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDpcXFwiXFxcIjtvcGFjaXR5OjB9LmJ1dHRvbi1pbm5lcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1mbG93OmluaGVyaXQ7ZmxleC1mbG93OmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWNvbG9yLWZvY3VzZWQpfTpob3N0KC5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpe2E6aG92ZXJ7Y29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpfX06aG9zdCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCl9Omhvc3QoLnRhYi1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0KC50YWItZGlzYWJsZWQpe3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowLjR9OjpzbG90dGVkKGlvbi1sYWJlbCksOjpzbG90dGVkKGlvbi1pY29uKXtkaXNwbGF5OmJsb2NrOy1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO21heC13aWR0aDoxMDAlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9OjpzbG90dGVkKGlvbi1sYWJlbCl7LW1zLWZsZXgtb3JkZXI6MDtvcmRlcjowfTo6c2xvdHRlZChpb24taWNvbil7LW1zLWZsZXgtb3JkZXI6LTE7b3JkZXI6LTE7aGVpZ2h0OjFlbX06aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXt3aGl0ZS1zcGFjZTpub3JtYWx9OjpzbG90dGVkKGlvbi1iYWRnZSl7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MX06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KXstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd306aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCl7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKXstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWljb24pe2Rpc3BsYXk6bm9uZX06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXtkaXNwbGF5Om5vbmV9aW9uLXJpcHBsZS1lZmZlY3R7Y29sb3I6dmFyKC0tcmlwcGxlLWNvbG9yKX06aG9zdHstLXBhZGRpbmctdG9wOjA7LS1wYWRkaW5nLWVuZDoycHg7LS1wYWRkaW5nLWJvdHRvbTowOy0tcGFkZGluZy1zdGFydDoycHg7bWF4LXdpZHRoOjI0MHB4O2ZvbnQtc2l6ZToxMHB4fTo6c2xvdHRlZChpb24tYmFkZ2Upe3BhZGRpbmctbGVmdDo2cHg7cGFkZGluZy1yaWdodDo2cHg7cGFkZGluZy10b3A6MXB4O3BhZGRpbmctYm90dG9tOjFweDtsZWZ0OmNhbGMoNTAlICsgNnB4KTt0b3A6NHB4O2hlaWdodDphdXRvO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6OnNsb3R0ZWQoaW9uLWJhZGdlKXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6NnB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjZweDstd2Via2l0LXBhZGRpbmctZW5kOjZweDtwYWRkaW5nLWlubGluZS1lbmQ6NnB4fX1bZGlyPXJ0bF0gOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyA2cHgpfTo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjMwcHh9OjpzbG90dGVkKGlvbi1pY29uOjpiZWZvcmUpe3ZlcnRpY2FsLWFsaWduOnRvcH06OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToxcHg7bWluLWhlaWdodDoxMXB4O2ZvbnQtd2VpZ2h0OjUwMH06aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuMX06aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjF9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24taWNvbiksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1pY29uKXttaW4td2lkdGg6MjRweDtoZWlnaHQ6MjZweDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjFweDtmb250LXNpemU6MjRweH06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDpjYWxjKDUwJSArIDEycHgpfTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWxheW91dC1pY29uLWJvdHRvbSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OmNhbGMoNTAlICsgMTJweCl9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MXB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjRweH06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDpjYWxjKDUwJSArIDM1cHgpO3RvcDoxMHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tc3RhcnQgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tZW5kIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyAzNXB4KX06aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6Y2FsYyg1MCUgKyAzMHB4KTt0b3A6MTBweH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24taGlkZSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWhhcy1sYWJlbC1vbmx5IDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyAzMHB4KX06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWhhcy1pY29uLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2Upe3RvcDoxMHB4fTpob3N0KC50YWItbGF5b3V0LWxhYmVsLWhpZGUpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowfVwiO1xuXG5jb25zdCB0YWJCdXR0b25NZENzcyA9IFwiOmhvc3R7LS1yaXBwbGUtY29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpOy0tYmFja2dyb3VuZC1mb2N1c2VkLW9wYWNpdHk6MTstbXMtZmxleDoxO2ZsZXg6MTstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7b3V0bGluZTpub25lO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tY29sb3IpfS5idXR0b24tbmF0aXZle2JvcmRlci1yYWRpdXM6aW5oZXJpdDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1sZWZ0OnZhcigtLXBhZGRpbmctc3RhcnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctdG9wOnZhcigtLXBhZGRpbmctdG9wKTtwYWRkaW5nLWJvdHRvbTp2YXIoLS1wYWRkaW5nLWJvdHRvbSk7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXN0eWxlOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtaW5kZW50OmluaGVyaXQ7dGV4dC1vdmVyZmxvdzppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7dGV4dC1hbGlnbjppbmhlcml0O3doaXRlLXNwYWNlOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1kaXJlY3Rpb246aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1wYWNrOmluaGVyaXQ7anVzdGlmeS1jb250ZW50OmluaGVyaXQ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDt0ZXh0LWRlY29yYXRpb246bm9uZTtjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtdXNlci1kcmFnOm5vbmV9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXsuYnV0dG9uLW5hdGl2ZXtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1pbmxpbmUtc3RhcnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7LXdlYmtpdC1wYWRkaW5nLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLXBhZGRpbmctZW5kKX19LmJ1dHRvbi1uYXRpdmU6OmFmdGVye2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowO3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7b3BhY2l0eTowfS5idXR0b24taW5uZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtZmxvdzppbmhlcml0O2ZsZXgtZmxvdzppbmhlcml0Oy1tcy1mbGV4LWFsaWduOmluaGVyaXQ7YWxpZ24taXRlbXM6aW5oZXJpdDstbXMtZmxleC1wYWNrOmluaGVyaXQ7anVzdGlmeS1jb250ZW50OmluaGVyaXQ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjF9Omhvc3QoLmlvbi1mb2N1c2VkKSAuYnV0dG9uLW5hdGl2ZXtjb2xvcjp2YXIoLS1jb2xvci1mb2N1c2VkKX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZlOjphZnRlcntiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtZm9jdXNlZCk7b3BhY2l0eTp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eSl9QG1lZGlhIChhbnktaG92ZXI6IGhvdmVyKXthOmhvdmVye2NvbG9yOnZhcigtLWNvbG9yLXNlbGVjdGVkKX19Omhvc3QoLnRhYi1zZWxlY3RlZCl7Y29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpfTpob3N0KC50YWItaGlkZGVuKXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudH06aG9zdCgudGFiLWRpc2FibGVkKXtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MC40fTo6c2xvdHRlZChpb24tbGFiZWwpLDo6c2xvdHRlZChpb24taWNvbil7ZGlzcGxheTpibG9jazstbXMtZmxleC1pdGVtLWFsaWduOmNlbnRlcjthbGlnbi1zZWxmOmNlbnRlcjttYXgtd2lkdGg6MTAwJTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fTo6c2xvdHRlZChpb24tbGFiZWwpey1tcy1mbGV4LW9yZGVyOjA7b3JkZXI6MH06OnNsb3R0ZWQoaW9uLWljb24pey1tcy1mbGV4LW9yZGVyOi0xO29yZGVyOi0xO2hlaWdodDoxZW19Omhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1sYWJlbCl7d2hpdGUtc3BhY2U6bm9ybWFsfTo6c2xvdHRlZChpb24tYmFkZ2Upey13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjF9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCl7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LWRpcmVjdGlvbjpyb3d9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpey1tcy1mbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSl7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1pY29uKXtkaXNwbGF5Om5vbmV9Omhvc3QoLnRhYi1sYXlvdXQtbGFiZWwtaGlkZSkgOjpzbG90dGVkKGlvbi1sYWJlbCl7ZGlzcGxheTpub25lfWlvbi1yaXBwbGUtZWZmZWN0e2NvbG9yOnZhcigtLXJpcHBsZS1jb2xvcil9Omhvc3R7LS1wYWRkaW5nLXRvcDowOy0tcGFkZGluZy1lbmQ6MTJweDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjEycHg7bWF4LXdpZHRoOjE2OHB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0Om5vcm1hbDtsZXR0ZXItc3BhY2luZzowLjAzZW19OjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDt0ZXh0LXRyYW5zZm9ybTpub25lfTo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjE2cHg7bWFyZ2luLWJvdHRvbToxNnB4Oy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgY2VudGVyO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcjtmb250LXNpemU6MjJweH1bZGlyPXJ0bF0gOjpzbG90dGVkKGlvbi1pY29uKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgOjpzbG90dGVkKGlvbi1pY29uKXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2FsYygxMDAlIC0gY2VudGVyKSBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpjYWxjKDEwMCUgLSBjZW50ZXIpIGNlbnRlcn06OnNsb3R0ZWQoaW9uLWJhZGdlKXtib3JkZXItcmFkaXVzOjhweDtwYWRkaW5nLWxlZnQ6MnB4O3BhZGRpbmctcmlnaHQ6MnB4O3BhZGRpbmctdG9wOjNweDtwYWRkaW5nLWJvdHRvbToycHg7bGVmdDpjYWxjKDUwJSArIDZweCk7dG9wOjhweDttaW4td2lkdGg6MTJweDtmb250LXNpemU6OHB4O2ZvbnQtd2VpZ2h0Om5vcm1hbH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24tYmFkZ2Upe3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDoycHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MnB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6MnB4O3BhZGRpbmctaW5saW5lLWVuZDoycHh9fVtkaXI9cnRsXSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDpjYWxjKDUwJSArIDZweCl9OjpzbG90dGVkKGlvbi1iYWRnZTplbXB0eSl7ZGlzcGxheTpibG9jazttaW4td2lkdGg6OHB4O2hlaWdodDo4cHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi10b3ApIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDo2cHg7bWFyZ2luLWJvdHRvbToycHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi10b3ApIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjZweH06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDo3MCU7dG9wOjhweH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20gOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDo3MCV9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206NnB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tdG9wOjZweDttYXJnaW4tYm90dG9tOjB9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6ODAlO3RvcDoxNnB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tc3RhcnQgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1lbmQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tZW5kIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6ODAlfTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXJpZ2h0OjZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24taWNvbil7bWFyZ2luLXJpZ2h0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLWVuZDo2cHg7bWFyZ2luLWlubGluZS1lbmQ6NnB4fX06aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDo2cHh9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDp1bnNldDstd2Via2l0LW1hcmdpbi1zdGFydDo2cHg7bWFyZ2luLWlubGluZS1zdGFydDo2cHh9fTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDo3MCU7dG9wOjE2cHh9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWxheW91dC1pY29uLWhpZGUgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1oYXMtbGFiZWwtb25seSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjcwJX06aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tbGFiZWwpLDpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9Omhvc3QoLnRhYi1sYXlvdXQtbGFiZWwtaGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1oYXMtaWNvbi1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXt0b3A6MTZweH06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWljb24pLDpob3N0KC50YWItaGFzLWljb24tb25seSkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO2ZvbnQtc2l6ZToyNHB4fVwiO1xuXG5jb25zdCBUYWJCdXR0b24gPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW9uVGFiQnV0dG9uQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImlvblRhYkJ1dHRvbkNsaWNrXCIsIDcpO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhlIHRhYiBidXR0b24uXG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RlZCB0YWIgY29tcG9uZW50XG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMub25LZXlVcCA9IChldikgPT4ge1xuICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICB0aGlzLnNlbGVjdFRhYihldik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uQ2xpY2sgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMuc2VsZWN0VGFiKGV2KTtcbiAgICB9O1xuICB9XG4gIG9uVGFiQmFyQ2hhbmdlZChldikge1xuICAgIGNvbnN0IGRpc3BhdGNoZWRGcm9tID0gZXYudGFyZ2V0O1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZWwucGFyZW50RWxlbWVudDtcbiAgICBpZiAoKGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhwYXJlbnQpKSB8fCAoZGlzcGF0Y2hlZEZyb20gJiYgZGlzcGF0Y2hlZEZyb20uY29udGFpbnModGhpcy5lbCkpKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy50YWIgPT09IGV2LmRldGFpbC50YWI7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGlmICh0aGlzLmxheW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxheW91dCA9IGNvbmZpZy5nZXQoJ3RhYkJ1dHRvbkxheW91dCcsICdpY29uLXRvcCcpO1xuICAgIH1cbiAgfVxuICBzZWxlY3RUYWIoZXYpIHtcbiAgICBpZiAodGhpcy50YWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuaW9uVGFiQnV0dG9uQ2xpY2suZW1pdCh7XG4gICAgICAgICAgdGFiOiB0aGlzLnRhYixcbiAgICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBnZXQgaGFzTGFiZWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdpb24tbGFiZWwnKTtcbiAgfVxuICBnZXQgaGFzSWNvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1pY29uJyk7XG4gIH1cbiAgZ2V0IHRhYkluZGV4KCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IGhhc1RhYkluZGV4ID0gdGhpcy5lbC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgaWYgKGhhc1RhYkluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBoYXNJY29uLCBoYXNMYWJlbCwgdGFiSW5kZXgsIGhyZWYsIHJlbCwgdGFyZ2V0LCBsYXlvdXQsIHNlbGVjdGVkLCB0YWIgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICBkb3dubG9hZDogdGhpcy5kb3dubG9hZCxcbiAgICAgIGhyZWYsXG4gICAgICByZWwsXG4gICAgICB0YXJnZXRcbiAgICB9O1xuICAgIHJldHVybiAoaChIb3N0LCB7IG9uQ2xpY2s6IHRoaXMub25DbGljaywgb25LZXl1cDogdGhpcy5vbktleVVwLCByb2xlOiBcInRhYlwiLCB0YWJpbmRleDogdGFiSW5kZXgsIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCA/ICd0cnVlJyA6IG51bGwsIGlkOiB0YWIgIT09IHVuZGVmaW5lZCA/IGB0YWItYnV0dG9uLSR7dGFifWAgOiBudWxsLCBjbGFzczoge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICd0YWItc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgJ3RhYi1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAndGFiLWhhcy1sYWJlbCc6IGhhc0xhYmVsLFxuICAgICAgICAndGFiLWhhcy1pY29uJzogaGFzSWNvbixcbiAgICAgICAgJ3RhYi1oYXMtbGFiZWwtb25seSc6IGhhc0xhYmVsICYmICFoYXNJY29uLFxuICAgICAgICAndGFiLWhhcy1pY29uLW9ubHknOiBoYXNJY29uICYmICFoYXNMYWJlbCxcbiAgICAgICAgW2B0YWItbGF5b3V0LSR7bGF5b3V0fWBdOiB0cnVlLFxuICAgICAgICAnaW9uLWFjdGl2YXRhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2lvbi1zZWxlY3RhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2lvbi1mb2N1c2FibGUnOiB0cnVlXG4gICAgICB9IH0sIGgoXCJhXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJzLCB7IHRhYkluZGV4OiAtMSwgY2xhc3M6IFwiYnV0dG9uLW5hdGl2ZVwiLCBwYXJ0OiBcIm5hdGl2ZVwiIH0pLCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImJ1dHRvbi1pbm5lclwiIH0sIGgoXCJzbG90XCIsIG51bGwpKSwgbW9kZSA9PT0gJ21kJyAmJiBoKFwiaW9uLXJpcHBsZS1lZmZlY3RcIiwgeyB0eXBlOiBcInVuYm91bmRlZFwiIH0pKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHtcbiAgICBpb3M6IHRhYkJ1dHRvbklvc0NzcyxcbiAgICBtZDogdGFiQnV0dG9uTWRDc3NcbiAgfTsgfVxufSwgWzMzLCBcImlvbi10YWItYnV0dG9uXCIsIHtcbiAgICBcImRpc2FibGVkXCI6IFs0XSxcbiAgICBcImRvd25sb2FkXCI6IFsxXSxcbiAgICBcImhyZWZcIjogWzFdLFxuICAgIFwicmVsXCI6IFsxXSxcbiAgICBcImxheW91dFwiOiBbMTAyNV0sXG4gICAgXCJzZWxlY3RlZFwiOiBbMTAyOF0sXG4gICAgXCJ0YWJcIjogWzFdLFxuICAgIFwidGFyZ2V0XCI6IFsxXVxuICB9LCBbWzgsIFwiaW9uVGFiQmFyQ2hhbmdlZFwiLCBcIm9uVGFiQmFyQ2hhbmdlZFwiXV1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXRhYi1idXR0b25cIiwgXCJpb24tcmlwcGxlLWVmZmVjdFwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLXRhYi1idXR0b25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUYWJCdXR0b24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlvbi1yaXBwbGUtZWZmZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDIoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25UYWJCdXR0b24gPSBUYWJCdXR0b247XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25UYWJCdXR0b24sIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsImNvbnN0IEJVSUxEID0ge1xuICAgIGFsbFJlbmRlckZuOiBmYWxzZSxcbiAgICBjbXBEaWRMb2FkOiB0cnVlLFxuICAgIGNtcERpZFVubG9hZDogZmFsc2UsXG4gICAgY21wRGlkVXBkYXRlOiB0cnVlLFxuICAgIGNtcERpZFJlbmRlcjogdHJ1ZSxcbiAgICBjbXBXaWxsTG9hZDogdHJ1ZSxcbiAgICBjbXBXaWxsVXBkYXRlOiB0cnVlLFxuICAgIGNtcFdpbGxSZW5kZXI6IHRydWUsXG4gICAgY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZWxlbWVudDogdHJ1ZSxcbiAgICBldmVudDogdHJ1ZSxcbiAgICBoYXNSZW5kZXJGbjogdHJ1ZSxcbiAgICBsaWZlY3ljbGU6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudDogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRCb2R5OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0OiB0cnVlLFxuICAgIG1lbWJlcjogdHJ1ZSxcbiAgICBtZXRob2Q6IHRydWUsXG4gICAgbW9kZTogdHJ1ZSxcbiAgICBvYnNlcnZlQXR0cmlidXRlOiB0cnVlLFxuICAgIHByb3A6IHRydWUsXG4gICAgcHJvcE11dGFibGU6IHRydWUsXG4gICAgcmVmbGVjdDogdHJ1ZSxcbiAgICBzY29wZWQ6IHRydWUsXG4gICAgc2hhZG93RG9tOiB0cnVlLFxuICAgIHNsb3Q6IHRydWUsXG4gICAgY3NzQW5ub3RhdGlvbnM6IHRydWUsXG4gICAgc3RhdGU6IHRydWUsXG4gICAgc3R5bGU6IHRydWUsXG4gICAgc3ZnOiB0cnVlLFxuICAgIHVwZGF0YWJsZTogdHJ1ZSxcbiAgICB2ZG9tQXR0cmlidXRlOiB0cnVlLFxuICAgIHZkb21YbGluazogdHJ1ZSxcbiAgICB2ZG9tQ2xhc3M6IHRydWUsXG4gICAgdmRvbUZ1bmN0aW9uYWw6IHRydWUsXG4gICAgdmRvbUtleTogdHJ1ZSxcbiAgICB2ZG9tTGlzdGVuZXI6IHRydWUsXG4gICAgdmRvbVJlZjogdHJ1ZSxcbiAgICB2ZG9tUHJvcE9yQXR0cjogdHJ1ZSxcbiAgICB2ZG9tUmVuZGVyOiB0cnVlLFxuICAgIHZkb21TdHlsZTogdHJ1ZSxcbiAgICB2ZG9tVGV4dDogdHJ1ZSxcbiAgICB3YXRjaENhbGxiYWNrOiB0cnVlLFxuICAgIHRhc2tRdWV1ZTogdHJ1ZSxcbiAgICBob3RNb2R1bGVSZXBsYWNlbWVudDogZmFsc2UsXG4gICAgaXNEZWJ1ZzogZmFsc2UsXG4gICAgaXNEZXY6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogZmFsc2UsXG4gICAgaHlkcmF0ZVNlcnZlclNpZGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVDbGllbnRTaWRlOiBmYWxzZSxcbiAgICBsaWZlY3ljbGVET01FdmVudHM6IGZhbHNlLFxuICAgIGxhenlMb2FkOiBmYWxzZSxcbiAgICBwcm9maWxlOiBmYWxzZSxcbiAgICBzbG90UmVsb2NhdGlvbjogdHJ1ZSxcbiAgICBhcHBlbmRDaGlsZFNsb3RGaXg6IGZhbHNlLFxuICAgIGNsb25lTm9kZUZpeDogZmFsc2UsXG4gICAgaHlkcmF0ZWRBdHRyaWJ1dGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQ2xhc3M6IHRydWUsXG4gICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgIHNjcmlwdERhdGFPcHRzOiBmYWxzZSxcbiAgICBzY29wZWRTbG90VGV4dENvbnRlbnRGaXg6IGZhbHNlLFxuICAgIHNoYWRvd0RvbVNoaW06IGZhbHNlLFxuICAgIHNsb3RDaGlsZE5vZGVzRml4OiBmYWxzZSxcbiAgICBpbnZpc2libGVQcmVoeWRyYXRpb246IHRydWUsXG4gICAgcHJvcEJvb2xlYW46IHRydWUsXG4gICAgcHJvcE51bWJlcjogdHJ1ZSxcbiAgICBwcm9wU3RyaW5nOiB0cnVlLFxuICAgIGNzc1ZhclNoaW06IGZhbHNlLFxuICAgIGNvbnN0cnVjdGFibGVDU1M6IHRydWUsXG4gICAgY21wU2hvdWxkVXBkYXRlOiB0cnVlLFxuICAgIGRldlRvb2xzOiBmYWxzZSxcbiAgICBkeW5hbWljSW1wb3J0U2hpbTogZmFsc2UsXG4gICAgc2hhZG93RGVsZWdhdGVzRm9jdXM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSxcbiAgICBhc3luY0xvYWRpbmc6IGZhbHNlLFxuICAgIGFzeW5jUXVldWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIGF0dGFjaFN0eWxlczogdHJ1ZSxcbn07XG5jb25zdCBFbnYgPSB7fTtcbmNvbnN0IE5BTUVTUEFDRSA9IC8qIGRlZmF1bHQgKi8gJ2FwcCc7XG5cbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9O1xuIiwibGV0IHNjb3BlSWQ7XG5sZXQgY29udGVudFJlZjtcbmxldCBob3N0VGFnTmFtZTtcbmxldCBjdXN0b21FcnJvcjtcbmxldCBpID0gMDtcbmxldCB1c2VOYXRpdmVTaGFkb3dEb20gPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RSZWxvY2F0ZSA9IGZhbHNlO1xubGV0IGlzU3ZnTW9kZSA9IGZhbHNlO1xubGV0IHJlbmRlcmluZ1JlZiA9IG51bGw7XG5sZXQgcXVldWVDb25nZXN0aW9uID0gMDtcbmxldCBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuMTIuMSB8IE1JVCBMaWNlbnNlZCB8IGh0dHBzOi8vc3RlbmNpbGpzLmNvbVxuICovXG5pbXBvcnQgeyBCVUlMRCwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuY29uc3QgQ1NTID0gQlVJTEQuY3NzVmFyU2hpbSA/IHdpbi5DU1MgOiBudWxsO1xuY29uc3QgZG9jID0gd2luLmRvY3VtZW50IHx8IHsgaGVhZDoge30gfTtcbmNvbnN0IEggPSAod2luLkhUTUxFbGVtZW50IHx8IGNsYXNzIHtcbn0pO1xuY29uc3QgcGx0ID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHJlc291cmNlc1VybCQ6ICcnLFxuICAgIGptcDogKGgpID0+IGgoKSxcbiAgICByYWY6IChoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCksXG4gICAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgcmVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgY2U6IChldmVudE5hbWUsIG9wdHMpID0+IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9wdHMpLFxufTtcbmNvbnN0IHNldFBsYXRmb3JtSGVscGVycyA9IChoZWxwZXJzKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIGhlbHBlcnMpO1xufTtcbmNvbnN0IHN1cHBvcnRzU2hhZG93ID0gQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBCVUlMRC5zaGFkb3dEb21cbiAgICA/IC8qQF9fUFVSRV9fKi8gKCgpID0+IChkb2MuaGVhZC5hdHRhY2hTaGFkb3cgKyAnJykuaW5kZXhPZignW25hdGl2ZScpID4gLTEpKClcbiAgICA6IHRydWU7XG5jb25zdCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICBsZXQgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zO1xufSkoKTtcbmNvbnN0IHByb21pc2VSZXNvbHZlID0gKHYpID0+IFByb21pc2UucmVzb2x2ZSh2KTtcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzID0gQlVJTEQuY29uc3RydWN0YWJsZUNTU1xuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmV3IENTU1N0eWxlU2hlZXQoKS5yZXBsYWNlID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKClcbiAgICA6IGZhbHNlO1xuY29uc3QgQ29udGV4dCA9IHt9O1xuY29uc3QgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoaW4gdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBpbml0aWFsaXplIG91ciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIG5vdyBzbyB0aGF0IHdlIGNhbiBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgbWF5XG4gICAgICAgIC8vIGhhdmUgZmlyZWQgZXZlbiBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIHJlYWR5XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IG1heSBoYXZlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICBpZiAoYXR0YWNoUGFyZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW1wb3J0YW50IHNvIHRoYXQgd2Uga25vdyB0aGUgaG9zdCBlbGVtZW50IGFjdHVhbGx5IGhhcyBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRvIG9ubHkgaGF2ZSB0aGUgb25lcyB0aGF0IEFSRSBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgQlVUIHRoZSBwYXJlbnQgZWxlbWVudCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGF0dGFjaGVkIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0aGF0IGFyZSBOT1QgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+ICEoZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldCA/IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA6IGVsbTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBob3N0TGlzdGVuZXJQcm94eShob3N0UmVmLCBtZXRob2QpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGhvc3RMaXN0ZW5lck9wdHMoZmxhZ3MpO1xuICAgICAgICAgICAgcGx0LmFlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpO1xuICAgICAgICAgICAgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCB8fCBbXSkucHVzaCgoKSA9PiBwbHQucmVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaG9zdExpc3RlbmVyUHJveHkgPSAoaG9zdFJlZiwgbWV0aG9kTmFtZSkgPT4gKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZSBpcyByZWFkeSwgbGV0J3MgY2FsbCBpdCdzIG1lbWJlciBtZXRob2QgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRsYXp5SW5zdGFuY2UkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCB8fCBbXSkucHVzaChbbWV0aG9kTmFtZSwgZXZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGhvc3RFbGVtZW50JFttZXRob2ROYW1lXShldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbn07XG5jb25zdCBnZXRIb3N0TGlzdGVuZXJUYXJnZXQgPSAoZWxtLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudCAmJiBmbGFncyAmIDQgLyogVGFyZ2V0RG9jdW1lbnQgKi8pXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdyAmJiBmbGFncyAmIDggLyogVGFyZ2V0V2luZG93ICovKVxuICAgICAgICByZXR1cm4gd2luO1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRCb2R5ICYmIGZsYWdzICYgMTYgLyogVGFyZ2V0Qm9keSAqLylcbiAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQgJiYgZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pXG4gICAgICAgIHJldHVybiBlbG0ucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWxtO1xufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaG9zdExpc3RlbmVyT3B0cyA9IChmbGFncykgPT4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnNcbiAgICA/ICh7XG4gICAgICAgIHBhc3NpdmU6IChmbGFncyAmIDEgLyogUGFzc2l2ZSAqLykgIT09IDAsXG4gICAgICAgIGNhcHR1cmU6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDAsXG4gICAgfSlcbiAgICA6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDA7XG5jb25zdCBDT05URU5UX1JFRl9JRCA9ICdyJztcbmNvbnN0IE9SR19MT0NBVElPTl9JRCA9ICdvJztcbmNvbnN0IFNMT1RfTk9ERV9JRCA9ICdzJztcbmNvbnN0IFRFWFRfTk9ERV9JRCA9ICd0JztcbmNvbnN0IEhZRFJBVEVfSUQgPSAncy1pZCc7XG5jb25zdCBIWURSQVRFRF9TVFlMRV9JRCA9ICdzdHktaWQnO1xuY29uc3QgSFlEUkFURV9DSElMRF9JRCA9ICdjLWlkJztcbmNvbnN0IEhZRFJBVEVEX0NTUyA9ICd7dmlzaWJpbGl0eTpoaWRkZW59Lmh5ZHJhdGVke3Zpc2liaWxpdHk6aW5oZXJpdH0nO1xuY29uc3QgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBjcmVhdGVUaW1lID0gKGZuTmFtZSwgdGFnTmFtZSA9ICcnKSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBjb25zdCBrZXkgPSBgc3Q6JHtmbk5hbWV9OiR7dGFnTmFtZX06JHtpKyt9YDtcbiAgICAgICAgLy8gU3RhcnRcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICAvLyBFbmRcbiAgICAgICAgcmV0dXJuICgpID0+IHBlcmZvcm1hbmNlLm1lYXN1cmUoYFtTdGVuY2lsXSAke2ZuTmFtZX0oKSA8JHt0YWdOYW1lfT5gLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdW5pcXVlVGltZSA9IChrZXksIG1lYXN1cmVUZXh0KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShrZXkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShtZWFzdXJlVGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlVGV4dCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBpZiAoIWhvc3RSZWYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmxhZ3MgPSBob3N0UmVmLiRmbGFncyQ7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyQ291bnQ6IGhvc3RSZWYuJHJlbmRlckNvdW50JCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkOiAhIShmbGFncyAmIDIgLyogaGFzUmVuZGVyZWQgKi8pLFxuICAgICAgICAgICAgaGFzQ29ubmVjdGVkOiAhIShmbGFncyAmIDEgLyogaGFzQ29ubmVjdGVkICovKSxcbiAgICAgICAgICAgIGlzV2FpdGluZ0ZvckNoaWxkcmVuOiAhIShmbGFncyAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pLFxuICAgICAgICAgICAgaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZTogISEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pLFxuICAgICAgICAgICAgaXNRdWV1ZWRGb3JVcGRhdGU6ICEhKGZsYWdzICYgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pLFxuICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaGFzTG9hZGVkQ29tcG9uZW50OiAhIShmbGFncyAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBpc1dhdGNoUmVhZHk6ICEhKGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLyksXG4gICAgICAgICAgICBpc0xpc3RlblJlYWR5OiAhIShmbGFncyAmIDI1NiAvKiBpc0xpc3RlblJlYWR5ICovKSxcbiAgICAgICAgICAgIG5lZWRzUmVyZW5kZXI6ICEhKGZsYWdzICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pLFxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVZhbHVlczogaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLFxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudDogaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkLFxuICAgICAgICBob3N0RWxlbWVudCxcbiAgICAgICAgbGF6eUluc3RhbmNlOiBob3N0UmVmLiRsYXp5SW5zdGFuY2UkLFxuICAgICAgICB2bm9kZTogaG9zdFJlZi4kdm5vZGUkLFxuICAgICAgICBtb2RlTmFtZTogaG9zdFJlZi4kbW9kZU5hbWUkLFxuICAgICAgICBvblJlYWR5UHJvbWlzZTogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLFxuICAgICAgICBvblJlYWR5UmVzb2x2ZTogaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkLFxuICAgICAgICBvbkluc3RhbmNlUHJvbWlzZTogaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkLFxuICAgICAgICBvbkluc3RhbmNlUmVzb2x2ZTogaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkLFxuICAgICAgICBvblJlbmRlclJlc29sdmU6IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQsXG4gICAgICAgIHF1ZXVlZExpc3RlbmVyczogaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCxcbiAgICAgICAgcm1MaXN0ZW5lcnM6IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCxcbiAgICAgICAgWydzLWlkJ106IGhvc3RFbGVtZW50WydzLWlkJ10sXG4gICAgICAgIFsncy1jciddOiBob3N0RWxlbWVudFsncy1jciddLFxuICAgICAgICBbJ3MtbHInXTogaG9zdEVsZW1lbnRbJ3MtbHInXSxcbiAgICAgICAgWydzLXAnXTogaG9zdEVsZW1lbnRbJ3MtcCddLFxuICAgICAgICBbJ3MtcmMnXTogaG9zdEVsZW1lbnRbJ3MtcmMnXSxcbiAgICAgICAgWydzLXNjJ106IGhvc3RFbGVtZW50WydzLXNjJ10sXG4gICAgfTtcbn07XG5jb25zdCBpbnN0YWxsRGV2VG9vbHMgPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmRldlRvb2xzKSB7XG4gICAgICAgIGNvbnN0IHN0ZW5jaWwgPSAod2luLnN0ZW5jaWwgPSB3aW4uc3RlbmNpbCB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5zcGVjdCA9IHN0ZW5jaWwuaW5zcGVjdDtcbiAgICAgICAgc3RlbmNpbC5pbnNwZWN0ID0gKHJlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIHR5cGVvZiBvcmlnaW5hbEluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW5hbEluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHJvb3RBcHBsaWVkU3R5bGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyU3R5bGUgPSAoc2NvcGVJZCwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICAgICAgc3R5bGUgPSAoc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKSk7XG4gICAgICAgIHN0eWxlLnJlcGxhY2UoY3NzVGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgfVxuICAgIHN0eWxlcy5zZXQoc2NvcGVJZCwgc3R5bGUpO1xufTtcbmNvbnN0IGFkZFN0eWxlID0gKHN0eWxlQ29udGFpbmVyTm9kZSwgY21wTWV0YSwgbW9kZSwgaG9zdEVsbSkgPT4ge1xuICAgIGxldCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmICghQlVJTEQuYXR0YWNoU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUlkO1xuICAgIH1cbiAgICAvLyBpZiBhbiBlbGVtZW50IGlzIE5PVCBjb25uZWN0ZWQgdGhlbiBnZXRSb290Tm9kZSgpIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyByb290IG5vZGVcbiAgICAvLyBzbyB0aGUgZmFsbGJhY2sgaXMgdG8gYWx3YXlzIHVzZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSByb290IG5vZGUgaW4gdGhvc2UgY2FzZXNcbiAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gPyBzdHlsZUNvbnRhaW5lck5vZGUgOiBkb2M7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUuaGVhZCB8fCBzdHlsZUNvbnRhaW5lck5vZGU7XG4gICAgICAgICAgICBsZXQgYXBwbGllZFN0eWxlcyA9IHJvb3RBcHBsaWVkU3R5bGVzLmdldChzdHlsZUNvbnRhaW5lck5vZGUpO1xuICAgICAgICAgICAgbGV0IHN0eWxlRWxtO1xuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcm9vdEFwcGxpZWRTdHlsZXMuc2V0KHN0eWxlQ29udGFpbmVyTm9kZSwgKGFwcGxpZWRTdHlsZXMgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmhvc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlRWxtID0gc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoYFske0hZRFJBVEVEX1NUWUxFX0lEfT1cIiR7c2NvcGVJZH1cIl1gKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGhhcHBlbmluZyBvbiBuYXRpdmUgc2hhZG93LWRvbSwgZG8gbm90IG5lZWRzIENTUyB2YXIgc2hpbVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtID0gcGx0LiRjc3NTaGltJC5jcmVhdGVIb3N0U3R5bGUoaG9zdEVsbSwgc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGVJZCA9IHN0eWxlRWxtWydzLXNjJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlSWQgPSBuZXdTY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgc3R5bGVJRCB0byB0aGUgYXBwbGllZFN0eWxlcyBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY3NzVmFyU2hpbSBtaWdodCBuZWVkIHRvIGFwcGx5IHNldmVyYWwgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzaGVldHMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lELCBzY29wZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlRWxtLCBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcignbGluaycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcy5hZGQoc2NvcGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELmNvbnN0cnVjdGFibGVDU1MgJiYgIXN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzID0gWy4uLnN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMsIHN0eWxlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVJZDtcbn07XG5jb25zdCBhdHRhY2hTdHlsZXMgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgY29uc3QgZW5kQXR0YWNoU3R5bGVzID0gY3JlYXRlVGltZSgnYXR0YWNoU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSBhZGRTdHlsZShCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgZWxtLnNoYWRvd1Jvb3QgPyBlbG0uc2hhZG93Um9vdCA6IGVsbS5nZXRSb290Tm9kZSgpLCBjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQsIGVsbSk7XG4gICAgaWYgKChCVUlMRC5zaGFkb3dEb20gfHwgQlVJTEQuc2NvcGVkKSAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucyAmJiBmbGFncyAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgICAgIGlmIChCVUlMRC5zY29wZWQgJiYgZmxhZ3MgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRBdHRhY2hTdHlsZXMoKTtcbn07XG5jb25zdCBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gJ3NjLScgKyAoQlVJTEQubW9kZSAmJiBtb2RlICYmIGNtcC4kZmxhZ3MkICYgMzIgLyogaGFzTW9kZSAqLyA/IGNtcC4kdGFnTmFtZSQgKyAnLScgKyBtb2RlIDogY21wLiR0YWdOYW1lJCk7XG5jb25zdCBjb252ZXJ0U2NvcGVkVG9TaGFkb3cgPSAoY3NzKSA9PiBjc3MucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csICckMXsnKTtcbi8vIFByaXZhdGVcbmNvbnN0IGNvbXB1dGVNb2RlID0gKGVsbSkgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGgpID0+IGgoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gaCgpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG4vLyBjb25zdCBzdGFjazogYW55W10gPSBbXTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgdk5vZGVDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmICgoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmICFpc0NvbXBsZXhUeXBlKGNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgY2hpbGQuJGZsYWdzJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHZub2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGNsYXNzIC8gY2xhc3NuYW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgdm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NEYXRhID0gdm5vZGVEYXRhLmNsYXNzTmFtZSB8fCB2bm9kZURhdGEuY2xhc3M7XG4gICAgICAgICAgICBpZiAoY2xhc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEYXRhLmNsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNsYXNzRGF0YSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xhc3NEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChrKSA9PiBjbGFzc0RhdGFba10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdk5vZGVDaGlsZHJlbi5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC4gTWFrZSBzdXJlOlxuLSBZb3UgYXJlIE5PVCB1c2luZyBob3N0RGF0YSgpIGFuZCA8SG9zdD4gaW4gdGhlIHNhbWUgY29tcG9uZW50LlxuLSA8SG9zdD4gaXMgdXNlZCBvbmNlLCBhbmQgaXQncyB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50IG9mIHRoZSByZW5kZXIoKSBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21GdW5jdGlvbmFsICYmIHR5cGVvZiBub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub2RlTmFtZSBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIHJldHVybiBub2RlTmFtZSh2bm9kZURhdGEgPT09IG51bGwgPyB7fSA6IHZub2RlRGF0YSwgdk5vZGVDaGlsZHJlbiwgdmRvbUZuVXRpbHMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGVOYW1lLCBudWxsKTtcbiAgICB2bm9kZS4kYXR0cnMkID0gdm5vZGVEYXRhO1xuICAgIGlmICh2Tm9kZUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdm5vZGUuJGNoaWxkcmVuJCA9IHZOb2RlQ2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0ga2V5O1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgdm5vZGUuJG5hbWUkID0gc2xvdE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBuZXdWTm9kZSA9ICh0YWcsIHRleHQpID0+IHtcbiAgICBjb25zdCB2bm9kZSA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJHRhZyQ6IHRhZyxcbiAgICAgICAgJHRleHQkOiB0ZXh0LFxuICAgICAgICAkZWxtJDogbnVsbCxcbiAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICB9O1xuICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgIHZub2RlLiRhdHRycyQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICB2bm9kZS4ka2V5JCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgSG9zdCA9IHt9O1xuY29uc3QgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbmNvbnN0IHZkb21GblV0aWxzID0ge1xuICAgIGZvckVhY2g6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLmZvckVhY2goY2IpLFxuICAgIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSksXG59O1xuY29uc3QgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gICAgdmF0dHJzOiBub2RlLiRhdHRycyQsXG4gICAgdmNoaWxkcmVuOiBub2RlLiRjaGlsZHJlbiQsXG4gICAgdmtleTogbm9kZS4ka2V5JCxcbiAgICB2bmFtZTogbm9kZS4kbmFtZSQsXG4gICAgdnRhZzogbm9kZS4kdGFnJCxcbiAgICB2dGV4dDogbm9kZS4kdGV4dCQsXG59KTtcbmNvbnN0IGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52dGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZub2RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmF0dHJzKTtcbiAgICAgICAgaWYgKG5vZGUudmtleSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLmtleSA9IG5vZGUudmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52bmFtZSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLm5hbWUgPSBub2RlLnZuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi4obm9kZS52Y2hpbGRyZW4gfHwgW10pKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICAgIHZub2RlLiRhdHRycyQgPSBub2RlLnZhdHRycztcbiAgICB2bm9kZS4kY2hpbGRyZW4kID0gbm9kZS52Y2hpbGRyZW47XG4gICAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gICAgdm5vZGUuJG5hbWUkID0gbm9kZS52bmFtZTtcbiAgICByZXR1cm4gdm5vZGU7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG9yZGVyaW5nIG9mIGF0dHJpYnV0ZXMgb24gYW4gaW5wdXQgZWxlbWVudFxuICogQHBhcmFtIGlucHV0RWxtIHRoZSBlbGVtZW50IHRvIHZhbGlkYXRlXG4gKi9cbmNvbnN0IHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzID0gKGlucHV0RWxtKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhpbnB1dEVsbSk7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wcy5pbmRleE9mKCd2YWx1ZScpO1xuICAgIGlmICh2YWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5kZXggPSBwcm9wcy5pbmRleE9mKCd0eXBlJyk7XG4gICAgY29uc3QgbWluSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHByb3BzLmluZGV4T2YoJ21heCcpO1xuICAgIGNvbnN0IHN0ZXBJbmRleCA9IHByb3BzLmluZGV4T2YoJ3N0ZXAnKTtcbiAgICBpZiAodmFsdWUgPCB0eXBlSW5kZXggfHwgdmFsdWUgPCBtaW5JbmRleCB8fCB2YWx1ZSA8IG1heEluZGV4IHx8IHZhbHVlIDwgc3RlcEluZGV4KSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCJ2YWx1ZVwiIHByb3Agb2YgPGlucHV0PiBzaG91bGQgYmUgc2V0IGFmdGVyIFwibWluXCIsIFwibWF4XCIsIFwidHlwZVwiIGFuZCBcInN0ZXBcImApO1xuICAgIH1cbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gc2V0QWNjZXNzb3IoKSBmdW5jdGlvbiBiYXNlZCBvbiBQcmVhY3QgYnlcbiAqIEphc29uIE1pbGxlciAoQGRldmVsb3BpdClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgY29tcGlsZXIgYW5kIHZkb21cbiAqL1xuY29uc3Qgc2V0QWNjZXNzb3IgPSAoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGlzU3ZnLCBmbGFncykgPT4ge1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IGlzUHJvcCA9IGlzTWVtYmVySW5FbGVtZW50KGVsbSwgbWVtYmVyTmFtZSk7XG4gICAgICAgIGxldCBsbiA9IG1lbWJlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcyAmJiBtZW1iZXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbG0uY2xhc3NMaXN0O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFuZXdDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFvbGRDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSBuZXdWYWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09ICdrZXknKVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUmVmICYmIG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUxpc3RlbmVyICYmXG4gICAgICAgICAgICAoQlVJTEQubGF6eUxvYWQgPyAhaXNQcm9wIDogIWVsbS5fX2xvb2t1cFNldHRlcl9fKG1lbWJlck5hbWUpKSAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVswXSA9PT0gJ28nICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IGlmIGl0IGV4aXN0cyBhbmQgaXQncyBub3QgYSBTVkdcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKChpc1Byb3AgfHwgKGlzQ29tcGxleCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkpICYmICFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgPyBuZXdWbm9kZS4kZWxtJC5ob3N0XG4gICAgICAgIDogbmV3Vm5vZGUuJGVsbSQ7XG4gICAgY29uc3Qgb2xkVm5vZGVBdHRycyA9IChvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkKSB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgbm8gbG9uZ2VyIHByZXNlbnQgb24gdGhlIHZub2RlIGJ5IHNldHRpbmcgdGhlbSB0byB1bmRlZmluZWRcbiAgICAgICAgZm9yIChtZW1iZXJOYW1lIGluIG9sZFZub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykpIHtcbiAgICAgICAgICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHVuZGVmaW5lZCwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgIGZvciAobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgbmV3Vm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICB9XG59O1xuY29uc3QgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID1cbiAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJClcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA/ICdzbG90LWZiJ1xuICAgICAgICAgICAgICAgIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUsIG5ld0NoKSA9PiB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBpZHhJbk9sZCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGVsbVRvTW92ZTtcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtaWdodCBoYXZlIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVLZXlUb09sZElkeFxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkU3RhcnRJZHg7IGkgPD0gb2xkRW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoW2ldICYmIG9sZENoW2ldLiRrZXkkICE9PSBudWxsICYmIG9sZENoW2ldLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsbVRvTW92ZS4kdGFnJCAhPT0gbmV3U3RhcnRWbm9kZS4kdGFnJCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIGlkeEluT2xkLCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgbmV3U3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxufTtcbmNvbnN0IGlzU2FtZVZub2RlID0gKHZub2RlMSwgdm5vZGUyKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAodm5vZGUxLiR0YWckID09PSB2bm9kZTIuJHRhZyQpIHtcbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlMS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRuYW1lJCA9PT0gdm5vZGUyLiRuYW1lJDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4ka2V5JCA9PT0gdm5vZGUyLiRrZXkkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgLy8gdGhpcyBub2RlIHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGRvbVxuICAgIC8vIGJlY2F1c2Ugb2Ygc29tZSBvdGhlciBjb21wb25lbnQncyBzbG90XG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYW4gaHRtbCBjb21tZW50IGluIHBsYWNlIG9mIHdoZXJlXG4gICAgLy8gaXQncyBvcmlnaW5hbCBsb2NhdGlvbiB3YXMgYWNjb3JkaW5nIHRvIGl0J3Mgb3JpZ2luYWwgdmRvbVxuICAgIHJldHVybiAobm9kZSAmJiBub2RlWydzLW9sJ10pIHx8IG5vZGU7XG59O1xuY29uc3QgcGFyZW50UmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiAobm9kZVsncy1vbCddID8gbm9kZVsncy1vbCddIDogbm9kZSkucGFyZW50Tm9kZTtcbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgbGV0IGRlZmF1bHRIb2xkZXI7XG4gICAgaWYgKCFCVUlMRC52ZG9tVGV4dCB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVuZGVyaW5nIGFuIHN2ZyBlbGVtZW50LCBvciBzdGlsbCByZW5kZXJpbmcgbm9kZXMgaW5zaWRlIG9mIG9uZVxuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhpcyB0byB0aGUgd2hlbiB0aGUgY29tcGlsZXIgc2VlcyB3ZSdyZSB1c2luZyBhbiBzdmcgc29tZXdoZXJlXG4gICAgICAgICAgICBpc1N2Z01vZGUgPSB0YWcgPT09ICdzdmcnID8gdHJ1ZSA6IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudCBub2RlXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90ICYmIHRhZyA9PT0gJ3Nsb3QnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgb2YgYW4gZWxlbWVudCBPUiBpdCdzIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBhbHJlYWR5IGtub3cgaXQncyBwb3NzaWJsZSBpdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIGVsZW1lbnQncyBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlJ3MgY2hpbGQgdm5vZGVzIGZvciBib3RoIHRoZSBvbGQgYW5kIG5ldyB2bm9kZXNcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2hpbGRyZW4sIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG9sZCBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgbmV3IGNoaWxkIHZub2RlcyB0byBhZGRcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSB3YXMgdGV4dCwgc28gYmUgc3VyZSB0byBjbGVhciBpdCBvdXRcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHZub2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiB0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAoZGVmYXVsdEhvbGRlciA9IGVsbVsncy1jciddKSkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIHNsb3R0ZWQgY29udGVudFxuICAgICAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSB0ZXh0IG9ubHkgdm5vZGVcbiAgICAgICAgLy8gYW5kIGFsc28gb25seSBpZiB0aGUgdGV4dCBpcyBkaWZmZXJlbnQgdGhhbiBiZWZvcmVcbiAgICAgICAgZWxtLmRhdGEgPSB0ZXh0O1xuICAgIH1cbn07XG5jb25zdCB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBpO1xuICAgIGxldCBpbGVuO1xuICAgIGxldCBqO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCBmYWxsYmFjayBub2RlXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzbG90IG5hbWUgZm9yIHRoaXMgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIHNob3cgYSBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgaWYgdGhlcmUgYXJlIG90aGVyIHNsb3RzIGluIHRoZSBsaWdodCBkb21cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNoaWxkTm9kZXNbal0ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddIHx8IHNsb3ROYW1lQXR0ciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2libGluZyBub2RlIGlzIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IE9SIGlzIGEgbmFtZWQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8gJiYgY2hpbGROb2Rlc1tqXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVsb2NhdGVOb2RlcyA9IFtdO1xuY29uc3QgcmVsb2NhdGVTbG90Q29udGVudCA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgcmVsb2NhdGVOb2RlRGF0YTtcbiAgICBsZXQgajtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgc29tZSBjaGFuZ2VzIHRvIHNsb3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgd2UgYWxzbyBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrcyBhcmUgY29ycmVjdGx5IGhpZGRlbiBvciBzaG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IG5vZGVbJ3Mtc24nXSB8fCBzbG90TmFtZUF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgd2UgbmV2ZXIgZm91bmQgYSBzbG90IGhvbWUgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0dXJucyBvdXQgd2UgZGlkLCBzbyBsZXQncyByZW1lbWJlciBpdCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3VyIGxpc3Qgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2xvdFJlZk5vZGUkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5tYXAoKHJlbG9jYXRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZSgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZmFyIHRoaXMgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgc2xvdCBob21lLCBub3Qgc2V0dGluZyBzbG90UmVmTm9kZSBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZXZlciBmaW5kIGEgaG9tZSBmb3IgdGhpcyBlbGVtZW50IHRoZW4gd2UnbGwgbmVlZCB0byBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNOb2RlTG9jYXRlZEluU2xvdCA9IChub2RlVG9SZWxvY2F0ZSwgc2xvdE5hbWVBdHRyKSA9PiB7XG4gICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gbnVsbCAmJiBzbG90TmFtZUF0dHIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKCdzbG90JykgPT09IHNsb3ROYW1lQXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5hbWVBdHRyID09PSAnJztcbn07XG5jb25zdCBjYWxsTm9kZVJlZnMgPSAodk5vZGUpID0+IHtcbiAgICBpZiAoQlVJTEQudmRvbVJlZikge1xuICAgICAgICB2Tm9kZS4kYXR0cnMkICYmIHZOb2RlLiRhdHRycyQucmVmICYmIHZOb2RlLiRhdHRycyQucmVmKG51bGwpO1xuICAgICAgICB2Tm9kZS4kY2hpbGRyZW4kICYmIHZOb2RlLiRjaGlsZHJlbiQubWFwKGNhbGxOb2RlUmVmcyk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlclZkb20gPSAoaG9zdFJlZiwgcmVuZGVyRm5SZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgaG9zdEVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3Qgb2xkVk5vZGUgPSBob3N0UmVmLiR2bm9kZSQgfHwgbmV3Vk5vZGUobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgcm9vdFZub2RlID0gaXNIb3N0KHJlbmRlckZuUmVzdWx0cykgPyByZW5kZXJGblJlc3VsdHMgOiBoKG51bGwsIG51bGwsIHJlbmRlckZuUmVzdWx0cyk7XG4gICAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gICAgLy8gPEhvc3Q+IHJ1bnRpbWUgY2hlY2tcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgQXJyYXkuaXNBcnJheShyZW5kZXJGblJlc3VsdHMpICYmIHJlbmRlckZuUmVzdWx0cy5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5tYXAoKFtwcm9wTmFtZSwgYXR0cmlidXRlXSkgPT4gKHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICByb290Vm5vZGUuJHRhZyQgPSBudWxsO1xuICAgIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogaXNIb3N0ICovO1xuICAgIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgICByb290Vm5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCA9IChCVUlMRC5zaGFkb3dEb20gPyBob3N0RWxtLnNoYWRvd1Jvb3QgfHwgaG9zdEVsbSA6IGhvc3RFbG0pO1xuICAgIGlmIChCVUlMRC5zY29wZWQgfHwgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIHNjb3BlSWQgPSBob3N0RWxtWydzLXNjJ107XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBjb250ZW50UmVmID0gaG9zdEVsbVsncy1jciddO1xuICAgICAgICB1c2VOYXRpdmVTaGFkb3dEb20gPSBzdXBwb3J0c1NoYWRvdyAmJiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSAhPT0gMDtcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBzeW5jaHJvbm91cyBwYXRjaFxuICAgIHBhdGNoKG9sZFZOb2RlLCByb290Vm5vZGUpO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAvLyB3aGlsZSB3ZSdyZSBtb3Zpbmcgbm9kZXMgYXJvdW5kIGV4aXN0aW5nIG5vZGVzLCB0ZW1wb3JhcmlseSBkaXNhYmxlXG4gICAgICAgIC8vIHRoZSBkaXNjb25uZWN0Q2FsbGJhY2sgZnJvbSB3b3JraW5nXG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIGlmIChjaGVja1Nsb3RSZWxvY2F0ZSkge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgbGV0IHJlbG9jYXRlRGF0YTtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZWxvY2F0ZTtcbiAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZVJlZjtcbiAgICAgICAgICAgIGxldCBpbnNlcnRCZWZvcmVOb2RlO1xuICAgICAgICAgICAgbGV0IHJlZk5vZGU7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlbG9jYXRlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWxvY2F0ZURhdGEgPSByZWxvY2F0ZU5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlID0gcmVsb2NhdGVEYXRhLiRub2RlVG9SZWxvY2F0ZSQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIHJlZmVyZW5jZSBub2RlIG1hcmtpbmcgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgZm9yIGxhdGVyIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsTG9jYXRpb25EZWJ1Z05vZGUobm9kZVRvUmVsb2NhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgobm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZSksIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGluc2VydCBpdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9yZ0xvY2F0aW9uTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSAmJiByZWZOb2RlWydzLXNuJ10gPT09IG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlWydzLW5yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbnNlcnRCZWZvcmVOb2RlICYmIHBhcmVudE5vZGVSZWYgIT09IG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5uZXh0U2libGluZyAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgY2hlY2tlZCB0aGF0IGl0J3Mgd29ydGggd2hpbGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoYXQgdGhlIG5vZGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBuZXh0IHNpYmxpbmcgb3IgcGFyZW50IHJlbG9jYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1obiddICYmIG5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYSBjb21wb25lbnQgaW4gdGhlIGluZGV4Lmh0bWwgdGhhdCBkb2Vzbid0IGhhdmUgaXQncyBob3N0bmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ10ucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0IGJhY2sgdG8gdGhlIGRvbSBidXQgaW4gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZVJlZi5pbnNlcnRCZWZvcmUobm9kZVRvUmVsb2NhdGUsIGluc2VydEJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lc24ndCBoYXZlIGEgc2xvdCBob21lIHRvIGdvIHRvLCBzbyBsZXQncyBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZSBtb3Zpbmcgbm9kZXMgYXJvdW5kXG4gICAgICAgIC8vIGFsbG93IHRoZSBkaXNjb25uZWN0IGNhbGxiYWNrIHRvIHdvcmsgYWdhaW5cbiAgICAgICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICByZWxvY2F0ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgfVxufTtcbi8vIHNsb3QgY29tbWVudCBkZWJ1ZyBub2RlcyBvbmx5IGNyZWF0ZWQgd2l0aCB0aGUgYC0tZGVidWdgIGZsYWdcbi8vIG90aGVyd2lzZSB0aGVzZSBub2RlcyBhcmUgdGV4dCBub2RlcyB3L291dCBjb250ZW50XG5jb25zdCBzbG90UmVmZXJlbmNlRGVidWdOb2RlID0gKHNsb3RWTm9kZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYDxzbG90JHtzbG90Vk5vZGUuJG5hbWUkID8gJyBuYW1lPVwiJyArIHNsb3RWTm9kZS4kbmFtZSQgKyAnXCInIDogJyd9PiAoaG9zdD0ke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9KWApO1xuY29uc3Qgb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZSA9IChub2RlVG9SZWxvY2F0ZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYG9yZy1sb2NhdGlvbiBmb3IgYCArXG4gICAgKG5vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZVxuICAgICAgICA/IGA8JHtub2RlVG9SZWxvY2F0ZS5sb2NhbE5hbWV9PiAoaG9zdD0ke25vZGVUb1JlbG9jYXRlWydzLWhuJ119KWBcbiAgICAgICAgOiBgWyR7bm9kZVRvUmVsb2NhdGUudGV4dENvbnRlbnR9XWApKTtcbmNvbnN0IGdldEVsZW1lbnQgPSAocmVmKSA9PiAoQlVJTEQubGF6eUxvYWQgPyBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA6IHJlZik7XG5jb25zdCBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gICAgY29uc3QgZWxtID0gZ2V0RWxlbWVudChyZWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtaXQ6IChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcIiR7bmFtZX1cIiBldmVudCB3YXMgZW1pdHRlZCwgYnV0IHRoZSBkaXNwYXRjaGVyIG5vZGUgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byB0aGUgZG9tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRFdmVudChlbG0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogISEoZmxhZ3MgJiAxIC8qIENhbmNlbGxhYmxlICovKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSAmIGRpc3BhdGNoIGEgY3VzdG9tIEV2ZW50IG9uIGEgcHJvdmlkZWQgdGFyZ2V0XG4gKiBAcGFyYW0gZWxtIHRoZSB0YXJnZXQgb2YgdGhlIEV2ZW50XG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBnaXZlIHRoZSBjdXN0b20gRXZlbnRcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGEgY3VzdG9tIEV2ZW50XG4gKiBAcmV0dXJucyB0aGUgY3VzdG9tIEV2ZW50XG4gKi9cbmNvbnN0IGVtaXRFdmVudCA9IChlbG0sIG5hbWUsIG9wdHMpID0+IHtcbiAgICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gICAgcmV0dXJuIGV2O1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10ucHVzaChuZXcgUHJvbWlzZSgocikgPT4gKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSkpO1xuICAgIH1cbn07XG5jb25zdCBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgaWYgKEJVSUxELnRhc2tRdWV1ZSAmJiBCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGhvc3RSZWYuJGZsYWdzJCAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiBCVUlMRC50YXNrUXVldWUgPyB3cml0ZVRhc2soZGlzcGF0Y2gpIDogZGlzcGF0Y2goKTtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kU2NoZWR1bGUgPSBjcmVhdGVUaW1lKCdzY2hlZHVsZVVwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsTG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFJlbmRlcicpO1xuICAgIGlmIChCVUlMRC5jbXBXaWxsUmVuZGVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjb25uZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgc2VydmVyU2lkZUNvbm5lY3RlZChlbG0pO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBvbmx5IGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICdjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICAgICAgLy8gb2ssIHNvIHR1cm5zIG91dCB0aGVyZSBhcmUgc29tZSBjaGlsZCBob3N0IGVsZW1lbnRzXG4gICAgICAgIC8vIHdhaXRpbmcgb24gdGhpcyBwYXJlbnQgZWxlbWVudCB0byBsb2FkXG4gICAgICAgIC8vIGxldCdzIGZpcmUgb2ZmIGFsbCB1cGRhdGUgY2FsbGJhY2tzIHdhaXRpbmdcbiAgICAgICAgcmMubWFwKChjYikgPT4gY2IoKSk7XG4gICAgICAgIGVsbVsncy1yYyddID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRSZW5kZXIoKTtcbiAgICBlbmRVcGRhdGUoKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUHJvbWlzZXMgPSBlbG1bJ3MtcCddO1xuICAgICAgICBjb25zdCBwb3N0VXBkYXRlID0gKCkgPT4gcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwb3N0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChjaGlsZHJlblByb21pc2VzKS50aGVuKHBvc3RVcGRhdGUpO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICAgICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIC8vIGluIG9yZGVyIGZvciBidW5kbGVycyB0byBjb3JyZWN0bHkgdHJlZXNoYWtlIHRoZSBCVUlMRCBvYmplY3RcbiAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSBCVUlMRCBpcyBub3QgZGVvcHRpbWl6ZWQgd2l0aGluIGEgdHJ5L2NhdGNoXG4gICAgLy8gaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI3RyZWVzaGFrZSB0cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgY29uc3QgYWxsUmVuZGVyRm4gPSBCVUlMRC5hbGxSZW5kZXJGbiA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBsYXp5TG9hZCA9IEJVSUxELmxhenlMb2FkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHRhc2tRdWV1ZSA9IEJVSUxELnRhc2tRdWV1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB1cGRhdGFibGUgPSBCVUlMRC51cGRhdGFibGUgPyB0cnVlIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyaW5nUmVmID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKHVwZGF0YWJsZSAmJiB0YXNrUXVldWUpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0YWJsZSB8fCBsYXp5TG9hZCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogaGFzUmVuZGVyZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmhhc1JlbmRlckZuIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tUmVuZGVyIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBjaGlsZCBub2RlcyB0byByZW5kZXIgaW50byB0aGlzIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjc3MgY2xhc3MvYXR0cnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSkudGhlbigodmFsdWUpID0+IHJlbmRlclZkb20oaG9zdFJlZiwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICAgIH1cbiAgICByZW5kZXJpbmdSZWYgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgaWYgKEJVSUxELmNtcERpZFJlbmRlcikge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQoZWxtKTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gZmlyZSBvZmYgdGhlIHVzZXIncyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIChpZiBvbmUgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgLy8gY29tcG9uZW50RGlkVXBkYXRlIHJ1bnMgQUZURVIgcmVuZGVyKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxtWydzLWhtci1sb2FkJ10gJiYgZWxtWydzLWhtci1sb2FkJ10oKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELm1ldGhvZCAmJiBCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+KDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIFwidHJ1ZVwiIHdoZW4gdGhlIGZvcmNlZCB1cGRhdGUgd2FzIHN1Y2Nlc3NmdWxseSBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwRGlkTG9hZCA9ICh3aG8pID0+IHtcbiAgICAvLyBvbiBhcHBsb2FkXG4gICAgLy8gd2UgaGF2ZSBmaW5pc2ggdGhlIGZpcnN0IGJpZyBpbml0aWFsIHJlbmRlclxuICAgIGlmIChCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICBhZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBuZXh0VGljaygoKSA9PiBlbWl0RXZlbnQod2luLCAnYXBwbG9hZCcsIHsgZGV0YWlsOiB7IG5hbWVzcGFjZTogTkFNRVNQQUNFIH0gfSkpO1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1lYXN1cmUpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7TkFNRVNQQUNFfSBpbml0aWFsIGxvYWQgKGJ5ICR7d2hvfSlgLCAnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxufTtcbmNvbnN0IHNhZmVDYWxsID0gKGluc3RhbmNlLCBtZXRob2QsIGFyZykgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2RdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCB0aGVuID0gKHByb21pc2UsIHRoZW5GbikgPT4ge1xuICAgIHJldHVybiBwcm9taXNlICYmIHByb21pc2UudGhlbiA/IHByb21pc2UudGhlbih0aGVuRm4pIDogdGhlbkZuKCk7XG59O1xuY29uc3QgZW1pdExpZmVjeWNsZUV2ZW50ID0gKGVsbSwgbGlmZWN5Y2xlTmFtZSkgPT4ge1xuICAgIGlmIChCVUlMRC5saWZlY3ljbGVET01FdmVudHMpIHtcbiAgICAgICAgZW1pdEV2ZW50KGVsbSwgJ3N0ZW5jaWxfJyArIGxpZmVjeWNsZU5hbWUsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogTkFNRVNQQUNFLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGFkZEh5ZHJhdGVkRmxhZyA9IChlbG0pID0+IEJVSUxELmh5ZHJhdGVkQ2xhc3NcbiAgICA/IGVsbS5jbGFzc0xpc3QuYWRkKCdoeWRyYXRlZCcpXG4gICAgOiBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZVxuICAgICAgICA/IGVsbS5zZXRBdHRyaWJ1dGUoJ2h5ZHJhdGVkJywgJycpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuY29uc3Qgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZEVsbS5jb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBlbmRIeWRyYXRlID0gY3JlYXRlVGltZSgnaHlkcmF0ZUNsaWVudCcsIHRhZ05hbWUpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBob3N0RWxtLnNoYWRvd1Jvb3Q7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3ROb2RlcyA9IEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290ID8gW10gOiBudWxsO1xuICAgIGNvbnN0IHZub2RlID0gKGhvc3RSZWYuJHZub2RlJCA9IG5ld1ZOb2RlKHRhZ05hbWUsIG51bGwpKTtcbiAgICBpZiAoIXBsdC4kb3JnTG9jTm9kZXMkKSB7XG4gICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZG9jLmJvZHksIChwbHQuJG9yZ0xvY05vZGVzJCA9IG5ldyBNYXAoKSkpO1xuICAgIH1cbiAgICBob3N0RWxtW0hZRFJBVEVfSURdID0gaG9zdElkO1xuICAgIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgIGNsaWVudEh5ZHJhdGUodm5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBob3N0RWxtLCBob3N0SWQpO1xuICAgIGNoaWxkUmVuZGVyTm9kZXMubWFwKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uSWQgPSBjLiRob3N0SWQkICsgJy4nICsgYy4kbm9kZUlkJDtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlID0gcGx0LiRvcmdMb2NOb2RlcyQuZ2V0KG9yZ0xvY2F0aW9uSWQpO1xuICAgICAgICBjb25zdCBub2RlID0gYy4kZWxtJDtcbiAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvcmdMb2NhdGlvbk5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbm9kZVsncy1obiddID0gdGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddWydzLW5yJ10gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShvcmdMb2NhdGlvbklkKTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2hhZG93Um9vdE5vZGVzLm1hcCgoc2hhZG93Um9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2hhZG93Um9vdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kSHlkcmF0ZSgpO1xufTtcbmNvbnN0IGNsaWVudEh5ZHJhdGUgPSAocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLCBob3N0SWQpID0+IHtcbiAgICBsZXQgY2hpbGROb2RlVHlwZTtcbiAgICBsZXQgY2hpbGRJZFNwbHQ7XG4gICAgbGV0IGNoaWxkVk5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGROb2RlVHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO1xuICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSkge1xuICAgICAgICAgICAgLy8gZ290IHRoZSBub2RlIGRhdGEgZnJvbSB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgICAgICBjaGlsZElkU3BsdCA9IGNoaWxkTm9kZVR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzBdID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICRub2RlSWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICAgICAkdGFnJDogbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAkYXR0cnMkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJG5hbWUkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldyBjaGlsZCB2bm9kZVxuICAgICAgICAgICAgICAgIC8vIHNvIGVuc3VyZSBpdHMgcGFyZW50IHZub2RlIGhhcyB0aGUgdmNoaWxkcmVuIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIG91ciBjaGlsZCB2bm9kZSB0byBhIHNwZWNpZmljIGluZGV4IG9mIHRoZSB2bm9kZSdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdyB0aGUgbmV3IHBhcmVudCB2bm9kZSBmb3IgYWxsIHRoZSBuZXh0IGNoaWxkIGNoZWNrc1xuICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZHJpbGwgZG93biwgZW5kIHRvIHN0YXJ0IHNvIHdlIGNhbiByZW1vdmUgbm9kZXNcbiAgICAgICAgZm9yIChpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5jaGlsZE5vZGVzW2ldLCBob3N0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgZHJpbGxpbmcgZG93biB0aHJvdWdoIHRoZSBzaGFkb3cgcm9vdCBub2Rlc1xuICAgICAgICAgICAgZm9yIChpID0gbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICAvLyBgJHtDT01NRU5UX1RZUEV9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzFdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMV0gPT09ICcwJykge1xuICAgICAgICAgICAgLy8gY29tbWVudCBub2RlIGZvciBlaXRoZXIgdGhlIGhvc3QgaWQgb3IgYSAwIGhvc3QgaWRcbiAgICAgICAgICAgIGNoaWxkTm9kZVR5cGUgPSBjaGlsZElkU3BsdFswXTtcbiAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzRdLFxuICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRhZyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBURVhUX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRleHQkID0gY2hpbGRWTm9kZS4kZWxtJC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZW5kZXJOb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRleHQgY29tbWVudCBzaW5jZSBpdCdzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlcyAmJiBjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRWTm9kZS4kaG9zdElkJCA9PT0gaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21tZW50IG5vZGUgaXMgc3BlY2lmY2FsbHkgZm9yIHRoaXMgaG9zdCBpZFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBTTE9UX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7U0xPVF9OT0RFX0lEfS4ke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGFnJCA9ICdzbG90JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSBjaGlsZFZOb2RlLiRuYW1lJCA9IGNoaWxkSWRTcGx0WzVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgc3VwcG9ydCBzaGFkb3dSb290IGFuZCB0aGlzIGlzIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhY3R1YWwgc2xvdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZUVsZW1lbnQoY2hpbGRWTm9kZS4kdGFnJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kbmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsb3QgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kLnNldEF0dHJpYnV0ZSgnbmFtZScsIGNoaWxkVk5vZGUuJG5hbWUkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbmV3IHNsb3QgZWxlbWVudCBiZWZvcmUgdGhlIHNsb3QgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZFZOb2RlLiRlbG0kLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2xvdCBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZE5vZGVUeXBlID09PSBDT05URU5UX1JFRl9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtDT05URU5UX1JFRl9JRH0uJHtob3N0SWR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudCByZWYgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsbVsncy1jciddID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3MtY24nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Vk5vZGUgJiYgcGFyZW50Vk5vZGUuJHRhZyQgPT09ICdzdHlsZScpIHtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShudWxsLCBub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgdm5vZGUuJGVsbSQgPSBub2RlO1xuICAgICAgICB2bm9kZS4kaW5kZXgkID0gJzAnO1xuICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW3Zub2RlXTtcbiAgICB9XG59O1xuY29uc3QgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZSA9IChub2RlLCBvcmdMb2NOb2RlcykgPT4ge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgb3JnTG9jTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IE9SR19MT0NBVElPTl9JRCkge1xuICAgICAgICAgICAgb3JnTG9jTm9kZXMuc2V0KGNoaWxkSWRTcGx0WzFdICsgJy4nICsgY2hpbGRJZFNwbHRbMl0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBrbm93IGlmIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBpc1xuICAgICAgICAgICAgLy8gdGhlIHJvb3QgbGlnaHQtZG9tIG9mIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgIG5vZGVbJ3MtZW4nXSA9IGNoaWxkSWRTcGx0WzNdO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlUHJvcGVydHlWYWx1ZSA9IChwcm9wVmFsdWUsIHByb3BUeXBlKSA9PiB7XG4gICAgLy8gZW5zdXJlIHRoaXMgdmFsdWUgaXMgb2YgdGhlIGNvcnJlY3QgcHJvcCB0eXBlXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgaWYgKEJVSUxELnByb3BCb29sZWFuICYmIHByb3BUeXBlICYgNCAvKiBCb29sZWFuICovKSB7XG4gICAgICAgICAgICAvLyBwZXIgdGhlIEhUTUwgc3BlYywgYW55IHN0cmluZyB2YWx1ZSBtZWFucyBpdCBpcyBhIGJvb2xlYW4gdHJ1ZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnV0IHdlJ2xsIGNoZWF0IGhlcmUgYW5kIHNheSB0aGF0IHRoZSBzdHJpbmcgXCJmYWxzZVwiIGlzIHRoZSBib29sZWFuIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiBwcm9wVmFsdWUgPT09ICcnIHx8ICEhcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wTnVtYmVyICYmIHByb3BUeXBlICYgMiAvKiBOdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBTdHJpbmcgKi8pIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBwYXNzZWQgYXMgYSBudW1iZXIgb3IgYm9vbGVhblxuICAgICAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgaXQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1bmRhbnQgcmV0dXJuIGhlcmUgZm9yIGJldHRlciBtaW5pZmljYXRpb25cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgLy8gbm90IHN1cmUgZXhhY3RseSB3aGF0IHR5cGUgd2Ugd2FudFxuICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hhbmdlIHRvIGEgZGlmZmVyZW50IHR5cGVcbiAgICByZXR1cm4gcHJvcFZhbHVlO1xufTtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGhvc3RFbGVtZW50JCA6IHJlZjtcbiAgICBjb25zdCBvbGRWYWwgPSBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICAgIGlmICgoIUJVSUxELmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pIHx8IG9sZFZhbCA9PT0gdW5kZWZpbmVkKSAmJiBuZXdWYWwgIT09IG9sZFZhbCkge1xuICAgICAgICAvLyBnYWR6b29rcyEgdGhlIHByb3BlcnR5J3MgdmFsdWUgaGFzIGNoYW5nZWQhIVxuICAgICAgICAvLyBzZXQgb3VyIG5ldyB2YWx1ZSFcbiAgICAgICAgaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLnNldChwcm9wTmFtZSwgbmV3VmFsKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMTAyNCAvKiBkZXZPblJlbmRlciAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgcmVuZGVyaW5nLiBUaGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIGluZmluaXRlLWxvb3BzIGFuZCBvdGhlciBidWdzLmAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDIwNDggLyogZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyBcImNvbXBvbmVudERpZExvYWQoKVwiLCB0aGlzIHRyaWdnZXJzIGV4dHJhIHJlLXJlbmRlcnMsIHRyeSB0byBzZXR1cCBvbiBcImNvbXBvbmVudFdpbGxMb2FkKClcImAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJVSUxELmxhenlMb2FkIHx8IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbWV0aG9kIG5hbWVzIG9mIHdhdGNoIGZ1bmN0aW9ucyB0byBjYWxsXG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hNZXRob2RzID0gY21wTWV0YS4kd2F0Y2hlcnMkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaW5zdGFuY2UgaXMgd2F0Y2hpbmcgZm9yIHdoZW4gdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTWV0aG9kcy5tYXAoKHdhdGNoTWV0aG9kTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIG9mZiBlYWNoIG9mIHRoZSB3YXRjaCBtZXRob2RzIHRoYXQgYXJlIHdhdGNoaW5nIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIG9sZFZhbCwgcHJvcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhpcyB2YWx1ZSBhY3R1YWxseSBjaGFuZ2VkLCBzbyB3ZSd2ZSBnb3Qgd29yayB0byBkbyFcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkLCBvdGhlcndpc2UganVzdCBjaGlsbCBvdXRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGF0IHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlLCBidXQgZG9uJ3Qgd29ycnkgYWJvdXQgcXVldWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwIG1pbGxpb25zIGN1eiB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgaXQgb25seSBydW5zIG9uY2VcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoQlVJTEQucHJvcCB8fCBCVUlMRC5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovIHx8XG4gICAgICAgICAgICAgICAgICAgICgoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIHByb3BcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBnZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGR1cmluZyBkZXYgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmLiRmbGFncyQgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgYSBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8pICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgbm90IG11dGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMTAyNCAvKiBNdXRhYmxlICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgQFByb3AoKSBcIiR7bWVtYmVyTmFtZX1cIiBvbiA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IGlzIGltbXV0YWJsZSBidXQgd2FzIG1vZGlmaWVkIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQuXFxuTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvcHJvcGVydGllcyNwcm9wLW11dGFiaWxpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmxhenlMb2FkICYmXG4gICAgICAgICAgICAgICAgQlVJTEQubWV0aG9kICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyRmxhZ3MgJiA2NCAvKiBNZXRob2QgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIG1ldGhvZFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYuJG9uSW5zdGFuY2VQcm9taXNlJC50aGVuKCgpID0+IHJlZi4kbGF6eUluc3RhbmNlJFttZW1iZXJOYW1lXSguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQlVJTEQub2JzZXJ2ZUF0dHJpYnV0ZSAmJiAoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluIGEgd2ViIGNvbXBvbmVudCBsaWZlY3ljbGUgdGhlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBydW5zIHByaW9yIHRvIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgY2FzZSB3aGVyZSBhbiBhdHRyaWJ1dGUgd2FzIHNldCBpbmxpbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBzZXRzIHRoZSBhdHRyaWJ1dGUgaW5saW5lIG9uIGEgY3VzdG9tIGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyBpdCBiZWZvcmUgaXQgaGFzIGJlZW4gdXBncmFkZWQgYXMgc2hvd24gYmVsb3c6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwhLS0gdGhpcyBjb21wb25lbnQgaGFzIF9ub3RfIGJlZW4gdXBncmFkZWQgeWV0IC0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8bXktY29tcG9uZW50IGlkPVwidGVzdFwiIHNvbWUtYXR0cmlidXRlPVwic29tZS12YWx1ZVwiPjwvbXktY29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIGdyYWIgbm9uLXVwZ3JhZGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAvLyB1cGdyYWRlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlIGlmIHdlIGRvIG5vdCB1bnNoYWRvdyBoZXJlIGFuZCB1c2UgdGhlIHZhbHVlIG9mIHRoZSBzaGFkb3dpbmcgcHJvcGVydHksIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyAgd2lsbCBiZSBjYWxsZWQgd2l0aCBgbmV3VmFsdWUgPSBcInNvbWUtdmFsdWVcImAgYW5kIHdpbGwgc2V0IHRoZSBzaGFkb3dlZCBwcm9wZXJ0eSAodGhpcy5zb21lQXR0cmlidXRlID0gXCJhbm90aGVyLXZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vICB0byB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IGlubGluZSBpLmUuIFwic29tZS12YWx1ZVwiIGZyb20gYWJvdmUgZXhhbXBsZS4gV2hlblxuICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGNvbm5lY3RlZENhbGxiYWNrIGF0dGVtcHRzIHRvIHVuc2hhZG93IGl0IHdpbGwgdXNlIFwic29tZS12YWx1ZVwiIGFzIHRoZSBpbml0aWFsIHZhbHVlIHJhdGhlciB0aGFuIFwiYW5vdGhlci12YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIHdhcyBOT1Qgc2V0IGlubGluZSBidXQgd2FzIG5vdCBzZXQgcHJvZ3JhbW1hdGljYWxseSBzaGFsbCBiZSBoYW5kbGVkL3Vuc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJ5IGNvbm5lY3RlZENhbGxiYWNrIGFzIHRoaXMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVE9ETyhTVEVOQ0lMLTE2KSB3ZSBzaG91bGQgdGhpbmsgYWJvdXQgd2hldGhlciBvciBub3Qgd2UgYWN0dWFsbHkgd2FudCB0byBiZSByZWZsZWN0aW5nIHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9wZXJ0aWVzIGhlcmUgZ2l2ZW4gdGhhdCB0aGlzIGdvZXMgYWdhaW5zdCBiZXN0IHByYWN0aWNlcyBvdXRsaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2F2b2lkLXJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcE5hbWUgZXhpc3RzIG9uIHRoZSBwcm90b3R5cGUgb2YgYENzdHJgLCB0aGlzIHVwZGF0ZSBtYXkgYmUgYSByZXN1bHQgb2YgU3RlbmNpbCB1c2luZyBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFQSXMgdG8gcmVmbGVjdCBwcm9wcyBhcyBhdHRyaWJ1dGVzLiBDYWxscyB0byBgc2V0QXR0cmlidXRlKHNvbWVFbGVtZW50LCBwcm9wTmFtZSlgIHdpbGwgcmVzdWx0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvcE5hbWVgIHRvIGJlIGNvbnZlcnRlZCB0byBhIGBET01TdHJpbmdgLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgd2Ugd2FudCBmb3Igb3RoZXIgcHJpbWl0aXZlIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBSZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5zdHlsZSkgJiZcbiAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChDc3RyLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBBd2FpdCBjcmVhdGVzIGEgbWljcm8tdGFzayBhdm9pZCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExvYWQgPSB1bmlxdWVUaW1lKGBzdDpsb2FkOiR7Y21wTWV0YS4kdGFnTmFtZSR9OiR7aG9zdFJlZi4kbW9kZU5hbWUkfWAsIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gKTtcbiAgICAgICAgICAgICAgICBDc3RyID0gYXdhaXQgQ3N0cjtcbiAgICAgICAgICAgICAgICBlbmRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKEJVSUxELmlzRGV2IHx8IEJVSUxELmlzRGVidWcpICYmICFDc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyICYmICFDc3RyLmlzUHJveGllZCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIG5ldmVyIHByb3hpZWQgdGhpcyBDb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBhZGQgdGhlIGdldHRlcnMvc2V0dGVycyB0byBpdHMgcHJvdG90eXBlIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHdlIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAyIC8qIHByb3h5U3RhdGUgKi8pO1xuICAgICAgICAgICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZSgnY3JlYXRlSW5zdGFuY2UnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAvLyBvaywgdGltZSB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCB0cmFjayBvZiB3aGVuIHdlIHN0YXJ0IGFuZCBzdG9wXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBnZXR0ZXJzL3NldHRlcnMgZG9uJ3QgaW5jb3JyZWN0bHkgc3RlcCBvbiBkYXRhXG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgbGF6eS1sb2FkZWQgY29tcG9uZW50IGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBwYXNzaW5nIHRoZSBob3N0UmVmIGlzIHZlcnkgaW1wb3J0YW50IGR1cmluZ1xuICAgICAgICAgICAgLy8gY29uc3RydWN0aW9uIGluIG9yZGVyIHRvIGRpcmVjdGx5IHdpcmUgdG9nZXRoZXIgdGhlXG4gICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgYW5kIHRoZSBsYXp5LWxvYWRlZCBpbnN0YW5jZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgQ3N0cihob3N0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzeW5jIGNvbnN0cnVjdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgQ3N0ciA9IGVsbS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBDdXN0b21FbGVtZW50UmVnaXN0cnkgdG8gbWFyayB0aGUgY29tcG9uZW50IGFzIHJlYWR5IGJlZm9yZSBzZXR0aW5nIGBpc1dhdGNoUmVhZHlgLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB3YXRjaGVycyBtYXkgZmlyZSBwcmVtYXR1cmVseSBpZiBgY3VzdG9tRWxlbWVudHMuZ2V0KClgL2BjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCgpYCByZXNvbHZlcyBfYmVmb3JlX1xuICAgICAgICAgICAgLy8gU3RlbmNpbCBoYXMgY29tcGxldGVkIGluc3RhbnRpYXRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKGNtcE1ldGEuJHRhZ05hbWUkKS50aGVuKCgpID0+IChob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbSAmJlxuICAgICAgICAgICAgICAgICAgICBCVUlMRC5zaGFkb3dEb21TaGltICYmXG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KCcuL3NoYWRvdy1jc3MuanMnKS50aGVuKChtKSA9PiBtLnNjb3BlQ3NzKHN0eWxlLCBzY29wZUlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICBlbmRSZWdpc3RlclN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgbGF6eSBpbnN0YW5jZVxuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBhbmNlc3RvckNvbXBvbmVudCAmJiBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgbG9hZCBhbmQgdGhpcyBjb21wb25lbnQgaXQgaGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBidXQgdGhlIGFuY2VzdG9yIGNvbXBvbmVudCBoYXMgTk9UIGZpcmVkIGl0cyB3aWxsIHVwZGF0ZSBsaWZlY3ljbGUgeWV0XG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3QgY29vbCBvdXIgamV0cyBhbmQgd2FpdCBmb3IgdGhlIGFuY2VzdG9yIHRvIGNvbnRpbnVlIGZpcnN0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBnZXQgZmlyZWQgb2ZmIHdoZW4gdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBmaW5hbGx5IGdldHMgYXJvdW5kIHRvIHJlbmRlcmluZyBpdHMgbGF6eSBzZWxmXG4gICAgICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddLnB1c2goc2NoZWR1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuY29uc3QgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcnVuIGlmIHdlIGhhdmUgbGlzdGVuZXJzIGJlaW5nIGF0dGFjaGVkIHRvIGEgcGFyZW50XG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IEJVSUxELm1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhLCBlbG0uZ2V0QXR0cmlidXRlKCdzLW1vZGUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlSWQgKyAnLWgnLCBzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZWxtLCBjbXBNZXRhLiR0YWdOYW1lJCwgaG9zdElkLCBob3N0UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIWhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xvdCBwb2x5ZmlsbCBpcyByZXF1aXJlZCB3ZSdsbCBuZWVkIHRvIHB1dCBzb21lIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gaGVyZSB0byBhY3QgYXMgb3JpZ2luYWwgY29udGVudCBhbmNob3JzIGFzIHdlIG1vdmUgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICgoQlVJTEQuc2xvdCB8fCBCVUlMRC5zaGFkb3dEb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRmbGFncyQgJiAoNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLyB8IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBhbmNlc3RvciBjb21wb25lbnQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgYXMgb25lIG9mIHRoZSBhY3RpdmVseSBsb2FkaW5nIGNoaWxkIGNvbXBvbmVudHMgZm9yIGl0cyBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGltYiB1cCB0aGUgYW5jZXN0b3JzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgZmluaXNoZWQgaXRzIGxpZmVjeWNsZSB1cGRhdGUgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICgoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoJ3MtaWQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCB0aGlzIGNvbXBvbmVudHMgZmlyc3QgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgY29tcG9uZW50J3MgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIChob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQgPSBhbmNlc3RvckNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMYXp5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQucHJvcCAmJiAhQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCkubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLyAmJiBlbG0uaGFzT3duUHJvcGVydHkobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaW5pdGlhbGl6ZU5leHRUaWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGVkQ2FsbGJhY2ssIHRhc2tRdWV1ZSwgaW5pdGlhbExvYWRcbiAgICAgICAgICAgICAgICAvLyBhbmd1bGFyIHNldHMgYXR0cmlidXRlIEFGVEVSIGNvbm5lY3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE4OTA5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk5NDBcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IHRoZSBmaXJzdCB0aW1lIHRoaXMgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gcmVhdHRhY2ggYW55IGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaG9zdFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSB3b3VsZCBoYXZlIGJlZW4gcmVtb3ZlZCB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmlyZSBvZmYgY29ubmVjdGVkQ2FsbGJhY2soKSBvbiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRDb25uZWN0ZWQoKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29udGVudFJlZmVyZW5jZSA9IChlbG0pID0+IHtcbiAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAvLyBhbmQgdGhpcyBob3N0IGVsZW1lbnQgd2FzIE5PVCBjcmVhdGVkIHdpdGggU1NSXG4gICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNvbnRlbnQgd2FzIGZpcnN0IHBsYWNlZCwgd2hpY2ggaXMgdXNlZnVsIGxhdGVyIG9uXG4gICAgY29uc3QgY29udGVudFJlZkVsbSA9IChlbG1bJ3MtY3InXSA9IGRvYy5jcmVhdGVDb21tZW50KEJVSUxELmlzRGVidWcgPyBgY29udGVudC1yZWYgKGhvc3Q9JHtlbG0ubG9jYWxOYW1lfSlgIDogJycpKTtcbiAgICBjb250ZW50UmVmRWxtWydzLWNuJ10gPSB0cnVlO1xuICAgIGVsbS5pbnNlcnRCZWZvcmUoY29udGVudFJlZkVsbSwgZWxtLmZpcnN0Q2hpbGQpO1xufTtcbmNvbnN0IGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHJtTGlzdGVuZXJzJC5tYXAoKHJtTGlzdGVuZXIpID0+IHJtTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIENTUyB2YXItc2hpbSB0cmFja2luZ1xuICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICBwbHQuJGNzc1NoaW0kLnJlbW92ZUhvc3QoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVW5sb2FkKSB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVubG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSAoQ3N0ciwgY29tcGFjdE1ldGEpID0+IHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY29tcGFjdE1ldGFbMV0sIHByb3h5Q3VzdG9tRWxlbWVudChDc3RyLCBjb21wYWN0TWV0YSkpO1xufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci4kd2F0Y2hlcnMkO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgICAgIF9fcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHRoaXMsIGNtcE1ldGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmNvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRhY2hTaGFkb3coKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIENzdHIuaXMgPSBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xuY29uc3QgZm9yY2VNb2RlVXBkYXRlID0gKGVsbSkgPT4ge1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBCVUlMRC5tb2RlICYmICFCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBjb25zdCBtb2RlID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCAhPT0gbW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NvcGVJZCA9IGVsbVsncy1zYyddO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsbS5jb25zdHJ1Y3Rvci5zdHlsZVttb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGZsYWdzICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBobXJTdGFydCA9IChlbG0sIGNtcE1ldGEsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAvLyByZXNldCBzdGF0ZSBmbGFncyB0byBvbmx5IGhhdmUgYmVlbiBjb25uZWN0ZWRcbiAgICBob3N0UmVmLiRmbGFncyQgPSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAvLyBUT0RPXG4gICAgLy8gZGV0YXRjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IHBhc3NpbmcgYW4gZXhhY3QgZXZlbnQgbmFtZSBpdCdsbFxuICAgIC8vIHJlbW92ZSBhbGwgb2YgdGhpcyBlbGVtZW50J3MgZXZlbnQsIHdoaWNoIGlzIGdvb2RcbiAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGlzIGNvbXBvbmVudCBmaW5pc2hlcyBobXJcbiAgICBlbG1bJ3MtaG1yLWxvYWQnXSA9ICgpID0+IHtcbiAgICAgICAgLy8gZmluaXNoZWQgaG1yIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgZGVsZXRlIGVsbVsncy1obXItbG9hZCddO1xuICAgIH07XG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuY29uc3QgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBjb25zdCBvcmdDbG9uZU5vZGUgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGU7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzU2hhZG93RG9tID0gQlVJTEQuc2hhZG93RG9tID8gc3JjTm9kZS5zaGFkb3dSb290ICYmIHN1cHBvcnRzU2hhZG93IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgICAgIGlmIChCVUlMRC5zbG90ICYmICFpc1NoYWRvd0RvbSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgc2xvdHRlZCwgbm9uU3RlbmNpbE5vZGU7XG4gICAgICAgICAgICBsZXQgc3RlbmNpbFByaXZhdGVzID0gW1xuICAgICAgICAgICAgICAgICdzLWlkJyxcbiAgICAgICAgICAgICAgICAncy1jcicsXG4gICAgICAgICAgICAgICAgJ3MtbHInLFxuICAgICAgICAgICAgICAgICdzLXJjJyxcbiAgICAgICAgICAgICAgICAncy1zYycsXG4gICAgICAgICAgICAgICAgJ3MtcCcsXG4gICAgICAgICAgICAgICAgJ3MtY24nLFxuICAgICAgICAgICAgICAgICdzLXNyJyxcbiAgICAgICAgICAgICAgICAncy1zbicsXG4gICAgICAgICAgICAgICAgJ3MtaG4nLFxuICAgICAgICAgICAgICAgICdzLW9sJyxcbiAgICAgICAgICAgICAgICAncy1ucicsXG4gICAgICAgICAgICAgICAgJ3Mtc2knLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgIG5vblN0ZW5jaWxOb2RlID0gc3RlbmNpbFByaXZhdGVzLmV2ZXJ5KChwcml2YXRlRmllbGQpID0+ICFzcmNOb2RlLmNoaWxkTm9kZXNbaV1bcHJpdmF0ZUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCAmJiBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uU3RlbmNpbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaFNsb3RBcHBlbmRDaGlsZCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IChuZXdDaGlsZFsncy1zbiddID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpKTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEFmdGVyID0gc2xvdENoaWxkTm9kZXNbc2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIGFwcGVuZEFmdGVyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9O1xufTtcbi8qKlxuICogUGF0Y2hlcyB0aGUgdGV4dCBjb250ZW50IG9mIGFuIHVubmFtZWQgc2xvdHRlZCBub2RlIGluc2lkZSBhIHNjb3BlZCBjb21wb25lbnRcbiAqIEBwYXJhbSBob3N0RWxlbWVudFByb3RvdHlwZSB0aGUgYEVsZW1lbnRgIHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBjbXBNZXRhIGNvbXBvbmVudCBydW50aW1lIG1ldGFkYXRhIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHBhdGNoZWQgb3Igbm90XG4gKi9cbmNvbnN0IHBhdGNoVGV4dENvbnRlbnQgPSAoaG9zdEVsZW1lbnRQcm90b3R5cGUsIGNtcE1ldGEpID0+IHtcbiAgICBpZiAoQlVJTEQuc2NvcGVkICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50Jyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0RWxlbWVudFByb3RvdHlwZSwgJ19fdGV4dENvbnRlbnQnLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgJ2RlZmF1bHQgc2xvdCcsIHdoaWNoIHdvdWxkIGJlIHRoZSBmaXJzdCBzbG90IGluIGEgc2hhZG93IHRyZWUgKGlmIHdlIHdlcmUgdXNpbmcgb25lKSwgd2hvc2UgbmFtZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsICcnKTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc2xvdCBub2RlIGlzIGZvdW5kLCB0aGUgdGV4dENvbnRlbnQgX21heV8gYmUgZm91bmQgaW4gdGhlIG5leHQgc2libGluZyAodGV4dCkgbm9kZSwgZGVwZW5kaW5nIG9uIGhvd1xuICAgICAgICAgICAgICAgIC8vIG5vZGVzIHdlcmUgcmVvcmRlcmVkIGR1cmluZyB0aGUgdmRvbSByZW5kZXIuIGZpcnN0IHRyeSB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tIHRoZSBzaWJsaW5nLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT09IG51bGwgfHwgc2xvdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIFRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBuZWVkIHRvIGJlIHBsYWNlZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLFxuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiBob3cgbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIHNldCB0aGUgdGV4dCBjb250ZW50IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZG4ndCBmaW5kIGEgc2xvdCwgYnV0IHRoYXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlcmUgaXNuJ3Qgb25lLiBpZiB0aGlzIGNoZWNrIHJhbiBiZWZvcmUgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkZWQsIHdlIGNvdWxkIGhhdmUgbWlzc2VkIGl0LiBjaGVjayBmb3IgYSBjb250ZW50IHJlZmVyZW5jZSBlbGVtZW50IG9uIHRoZSBzY29wZWQgY29tcG9uZW50IGFuZCBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSB0aGlzWydzLWNyJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmRWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXygnY2hpbGROb2RlcycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZEVsZW1lbnRDb3VudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGROb2RlcycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0ZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEhvc3RSZWYodGhpcykuJGZsYWdzJCAmIDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGEgc2VyaWVzIG9mIGNoaWxkIG5vZGVzIGZvciBhIHNsb3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqIEBwYXJhbSBjaGlsZE5vZGVzIHRoZSBub2RlcyB0byBzZWFyY2ggZm9yIGEgc2xvdCB3aXRoIGEgc3BlY2lmaWMgbmFtZS5cbiAqIEBwYXJhbSBzbG90TmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdCB0byBtYXRjaCBvbi5cbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBuYW1lLCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGdldEhvc3RTbG90Tm9kZSA9IChjaGlsZE5vZGVzLCBzbG90TmFtZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGZvciAoOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgY2hpbGROb2RlWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZSA9IGdldEhvc3RTbG90Tm9kZShjaGlsZE5vZGUuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbbl07XG4gICAgd2hpbGUgKChuID0gbi5uZXh0U2libGluZykgJiYgblsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xufTtcbmNvbnN0IGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxuICAgIGluc3RhbGxEZXZUb29scygpO1xuICAgIGNvbnN0IGVuZEJvb3RzdHJhcCA9IGNyZWF0ZVRpbWUoJ2Jvb3RzdHJhcExhenknKTtcbiAgICBjb25zdCBjbXBUYWdzID0gW107XG4gICAgY29uc3QgZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSB8fCBbXTtcbiAgICBjb25zdCBjdXN0b21FbGVtZW50cyA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgICBjb25zdCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgY29uc3QgbWV0YUNoYXJzZXQgPSAvKkBfX1BVUkVfXyovIGhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtjaGFyc2V0XScpO1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdHlsZSA9IC8qQF9fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICBjb25zdCBzdHlsZXMgPSAvKkBfX1BVUkVfXyovIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBbJHtIWURSQVRFRF9TVFlMRV9JRH1dYCk7XG4gICAgbGV0IGFwcExvYWRGYWxsYmFjaztcbiAgICBsZXQgaXNCb290c3RyYXBwaW5nID0gdHJ1ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIG9wdGlvbnMpO1xuICAgIHBsdC4kcmVzb3VyY2VzVXJsJCA9IG5ldyBVUkwob3B0aW9ucy5yZXNvdXJjZXNVcmwgfHwgJy4vJywgZG9jLmJhc2VVUkkpLmhyZWY7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luY1F1ZXVlKSB7XG4gICAgICAgICAgICBwbHQuJGZsYWdzJCB8PSA0IC8qIHF1ZXVlU3luYyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGFwcCBpcyBhbHJlYWR5IGh5ZHJhdGVkIHRoZXJlIGlzIG5vdCBwb2ludCB0byBkaXNhYmxlIHRoZVxuICAgICAgICAvLyBhc3luYyBxdWV1ZS4gVGhpcyB3aWxsIGltcHJvdmUgdGhlIGZpcnN0IGlucHV0IGRlbGF5XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiYgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIGZvciAoOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWdpc3RlclN0eWxlKHN0eWxlc1tpXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLCBjb252ZXJ0U2NvcGVkVG9TaGFkb3coc3R5bGVzW2ldLmlubmVySFRNTCksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgICAgICBsYXp5QnVuZGxlWzFdLm1hcCgoY29tcGFjdE1ldGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICAgICAgICAgJHRhZ05hbWUkOiBjb21wYWN0TWV0YVsxXSxcbiAgICAgICAgICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAgICAgICAgICRsaXN0ZW5lcnMkOiBjb21wYWN0TWV0YVszXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgIXN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKVxuICAgICAgICAgICAgICAgIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgICAgICBjb25zdCBIb3N0RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGlzIHVzaW5nIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSByZWFkLW9ubHkgcHJvcGVydHkgXCJzaGFkb3dSb290XCIgdG8gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIHRoZSBzaGFkb3cgcm9vdCBidWlsZCBjb25kaXRpb25hbHMgdG8gbWluaW1pemUgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBzaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoJ3NoYWRvd1Jvb3QnIGluIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaGFkb3dSb290ID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdENoaWxkTm9kZXNGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChhcHBMb2FkRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayB3aWxsIGJlIHByb2Nlc3NlZCBvbmNlIGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnRPblJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQuY2xvbmVOb2RlRml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hDbG9uZU5vZGUoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFNsb3RBcHBlbmRDaGlsZChIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlWydzLWhtciddID0gZnVuY3Rpb24gKGhtclZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUZXh0Q29udGVudChIb3N0RWxlbWVudC5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21wTWV0YS4kbGF6eUJ1bmRsZUlkJCA9IGxhenlCdW5kbGVbMF07XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgcHJveHlDb21wb25lbnQoSG9zdEVsZW1lbnQsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELmludmlzaWJsZVByZWh5ZHJhdGlvbiAmJiAoQlVJTEQuaHlkcmF0ZWRDbGFzcyB8fCBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLmlubmVySFRNTCA9IGNtcFRhZ3MgKyBIWURSQVRFRF9DU1M7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJywgJycpO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZSh2aXNpYmlsaXR5U3R5bGUsIG1ldGFDaGFyc2V0ID8gbWV0YUNoYXJzZXQubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGRlZmVycmVkIGNvbm5lY3RlZENhbGxiYWNrcyBub3cgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICBpc0Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLm1hcCgoaG9zdCkgPT4gaG9zdC5jb25uZWN0ZWRDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9maWxlKSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwLCAndGltZW91dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGFwcExvYWQgZXZlbnRcbiAgICBlbmRCb290c3RyYXAoKTtcbn07XG5jb25zdCBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFzc2V0VXJsID0gbmV3IFVSTChwYXRoLCBwbHQuJHJlc291cmNlc1VybCQpO1xuICAgIHJldHVybiBhc3NldFVybC5vcmlnaW4gIT09IHdpbi5sb2NhdGlvbi5vcmlnaW4gPyBhc3NldFVybC5ocmVmIDogYXNzZXRVcmwucGF0aG5hbWU7XG59O1xuY29uc3Qgc2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IChwbHQuJHJlc291cmNlc1VybCQgPSBwYXRoKTtcbmNvbnN0IGdldENvbm5lY3QgPSAoX3JlZiwgdGFnTmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBlbG0gPSBkb2MucXVlcnlTZWxlY3Rvcih0YWdOYW1lKTtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICAgIGVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsbS5jb21wb25lbnRPblJlYWR5ID09PSAnZnVuY3Rpb24nID8gZWxtLmNvbXBvbmVudE9uUmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChlbCkgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2goKG9yZ0xvY2F0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZVJlZi5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlbGVzcyB3aGl0ZXNwYWNlIG5vZGUgYXQgdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBub2RlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlSWQgPSBgJHtPUkdfTE9DQVRJT05fSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5cIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTSEFET1cgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICdjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5jXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0NPUEVEIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5ub2RlVmFsdWUgPSBvcmdMb2NhdGlvbk5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGVbJ3MtbnInXSAhPSBudWxsKSB7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChob3N0UmVmICE9IG51bGwgJiYgIWRvY0RhdGEuc3RhdGljQ29tcG9uZW50cy5oYXMoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkczogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluc2VydFZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gICAgaWYgKHZub2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgICAgIGhvc3RFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfSUQsIGhvc3RJZCk7XG4gICAgICAgIGlmIChob3N0RWxtWydzLWNyJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEVsbVsncy1jciddLm5vZGVWYWx1ZSA9IGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoJ2MtaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaG9zdEVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbJ3Mtc3InXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgYCR7Y29tbWVudFsncy1ob3N0LWlkJ119LiR7Y29tbWVudFsncy1ub2RlLWlkJ119LjAuJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zID0gKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZEVsbSA9IHZub2RlQ2hpbGQuJGVsbSQ7XG4gICAgaWYgKGNoaWxkRWxtID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgICBjb25zdCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gO1xuICAgIGNoaWxkRWxtWydzLWhvc3QtaWQnXSA9IGhvc3RJZDtcbiAgICBjaGlsZEVsbVsncy1ub2RlLWlkJ10gPSBub2RlSWQ7XG4gICAgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChjaGlsZEVsbVsncy1zciddKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkRWxtWydzLXNuJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlQ2hpbGQuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIHZub2RlQ2hpbGQuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlLCBjbXBEYXRhLCBob3N0SWQsIGNoaWxkRGVwdGgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHNldFBsYXRmb3JtT3B0aW9ucyA9IChvcHRzKSA9PiBPYmplY3QuYXNzaWduKHBsdCwgb3B0cyk7XG5jb25zdCBGcmFnbWVudCA9IChfLCBjaGlsZHJlbikgPT4gY2hpbGRyZW47XG5jb25zdCBob3N0UmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlKSwgaG9zdFJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkID0gcikpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkID0gcikpO1xuICAgICAgICBlbG1bJ3MtcCddID0gW107XG4gICAgICAgIGVsbVsncy1yYyddID0gW107XG4gICAgfVxuICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICByZXR1cm4gaG9zdFJlZnMuc2V0KGVsbSwgaG9zdFJlZik7XG59O1xuY29uc3QgaXNNZW1iZXJJbkVsZW1lbnQgPSAoZWxtLCBtZW1iZXJOYW1lKSA9PiBtZW1iZXJOYW1lIGluIGVsbTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKGN1c3RvbUVycm9yIHx8IGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcbmNvbnN0IFNURU5DSUxfREVWX01PREUgPSBCVUlMRC5pc1Rlc3RpbmdcbiAgICA/IFsnU1RFTkNJTDonXSAvLyBFMkUgdGVzdGluZ1xuICAgIDogW1xuICAgICAgICAnJWNzdGVuY2lsJyxcbiAgICAgICAgJ2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweCcsXG4gICAgXTtcbmNvbnN0IGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldldhcm4gPSAoLi4ubSkgPT4gY29uc29sZS53YXJuKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldkluZm8gPSAoLi4ubSkgPT4gY29uc29sZS5pbmZvKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3Qgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IChjdXN0b21FcnJvciA9IGhhbmRsZXIpO1xuY29uc3QgY21wTW9kdWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3QgbG9hZE1vZHVsZSA9IChjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyBsb2FkTW9kdWxlSW1wb3J0XG4gICAgY29uc3QgZXhwb3J0TmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBidW5kbGVJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUcnlpbmcgdG8gbGF6aWx5IGxvYWQgY29tcG9uZW50IDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gd2l0aCBzdHlsZSBtb2RlIFwiJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDogZmFsc2U7XG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICAgICAgaWYgKCFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0ZWRNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfSwgY29uc29sZUVycm9yKTtcbn07XG5jb25zdCBzdHlsZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBtb2RlUmVzb2x1dGlvbkNoYWluID0gW107XG5jb25zdCBxdWV1ZURvbVJlYWRzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXNMb3cgPSBbXTtcbmNvbnN0IHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICAgIHF1ZXVlLnB1c2goY2IpO1xuICAgIGlmICghcXVldWVQZW5kaW5nKSB7XG4gICAgICAgIHF1ZXVlUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaV0ocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbn07XG5jb25zdCBjb25zdW1lVGltZW91dCA9IChxdWV1ZSwgdGltZW91dCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdHMgPSAwO1xuICAgIHdoaWxlIChpIDwgcXVldWUubGVuZ3RoICYmICh0cyA9IHBlcmZvcm1hbmNlLm5vdygpKSA8IHRpbWVvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2krK10odHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcXVldWVDb25nZXN0aW9uKys7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBmb3JjZSBhIGJ1bmNoIG9mIG1lZGl1bSBjYWxsYmFja3MgdG8gcnVuLCBidXQgc3RpbGwgaGF2ZVxuICAgIC8vIGEgdGhyb3R0bGUgb24gaG93IG1hbnkgY2FuIHJ1biBpbiBhIGNlcnRhaW4gdGltZVxuICAgIC8vIERPTSBSRUFEUyEhIVxuICAgIGNvbnN1bWUocXVldWVEb21SZWFkcyk7XG4gICAgLy8gRE9NIFdSSVRFUyEhIVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAocGx0LiRmbGFncyQgJiA2IC8qIHF1ZXVlTWFzayAqLykgPT09IDIgLyogYXBwTG9hZGVkICovXG4gICAgICAgICAgICA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTQgKiBNYXRoLmNlaWwocXVldWVDb25nZXN0aW9uICogKDEuMCAvIDEwLjApKVxuICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXMsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlc0xvdywgdGltZW91dCk7XG4gICAgICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlQ29uZ2VzdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN1bWUocXVldWVEb21Xcml0ZXMpO1xuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5leHRUaWNrID0gLypAX19QVVJFX18qLyAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG5jb25zdCByZWFkVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbmNvbnN0IHdyaXRlVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuZXhwb3J0IHsgQnVpbGQsIENTUywgQ29udGV4dCwgRnJhZ21lbnQsIEgsIEggYXMgSFRNTEVsZW1lbnQsIEhvc3QsIFNURU5DSUxfREVWX01PREUsIGFkZEhvc3RFdmVudExpc3RlbmVycywgYm9vdHN0cmFwTGF6eSwgY21wTW9kdWxlcywgY29ubmVjdGVkQ2FsbGJhY2ssIGNvbnNvbGVEZXZFcnJvciwgY29uc29sZURldkluZm8sIGNvbnNvbGVEZXZXYXJuLCBjb25zb2xlRXJyb3IsIGNyZWF0ZUV2ZW50LCBkZWZpbmVDdXN0b21FbGVtZW50LCBkaXNjb25uZWN0ZWRDYWxsYmFjaywgZG9jLCBmb3JjZU1vZGVVcGRhdGUsIGZvcmNlVXBkYXRlLCBnZXRBc3NldFBhdGgsIGdldENvbm5lY3QsIGdldENvbnRleHQsIGdldEVsZW1lbnQsIGdldEhvc3RSZWYsIGdldE1vZGUsIGdldFJlbmRlcmluZ1JlZiwgZ2V0VmFsdWUsIGgsIGluc2VydFZkb21Bbm5vdGF0aW9ucywgaXNNZW1iZXJJbkVsZW1lbnQsIGxvYWRNb2R1bGUsIG1vZGVSZXNvbHV0aW9uQ2hhaW4sIG5leHRUaWNrLCBwYXJzZVByb3BlcnR5VmFsdWUsIHBsdCwgcG9zdFVwZGF0ZUNvbXBvbmVudCwgcHJvbWlzZVJlc29sdmUsIHByb3h5Q29tcG9uZW50LCBwcm94eUN1c3RvbUVsZW1lbnQsIHJlYWRUYXNrLCByZWdpc3Rlckhvc3QsIHJlZ2lzdGVySW5zdGFuY2UsIHJlbmRlclZkb20sIHNldEFzc2V0UGF0aCwgc2V0RXJyb3JIYW5kbGVyLCBzZXRNb2RlLCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldFBsYXRmb3JtT3B0aW9ucywgc2V0VmFsdWUsIHN0eWxlcywgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMsIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zLCBzdXBwb3J0c1NoYWRvdywgd2luLCB3cml0ZVRhc2sgfTtcbiIsImltcG9ydCB7IGdldEFzc2V0UGF0aCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcblxubGV0IENBQ0hFRF9NQVA7XG5jb25zdCBnZXRJY29uTWFwID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICghQ0FDSEVEX01BUCkge1xuICAgICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgICAgd2luLklvbmljb25zID0gd2luLklvbmljb25zIHx8IHt9O1xuICAgICAgQ0FDSEVEX01BUCA9IHdpbi5Jb25pY29ucy5tYXAgPSB3aW4uSW9uaWNvbnMubWFwIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIENBQ0hFRF9NQVA7XG4gIH1cbn07XG5jb25zdCBhZGRJY29ucyA9IChpY29ucykgPT4ge1xuICBjb25zdCBtYXAgPSBnZXRJY29uTWFwKCk7XG4gIE9iamVjdC5rZXlzKGljb25zKS5mb3JFYWNoKG5hbWUgPT4gbWFwLnNldChuYW1lLCBpY29uc1tuYW1lXSkpO1xufTtcbmNvbnN0IGdldFVybCA9IChpKSA9PiB7XG4gIGxldCB1cmwgPSBnZXRTcmMoaS5zcmMpO1xuICBpZiAodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICB1cmwgPSBnZXROYW1lKGkubmFtZSwgaS5pY29uLCBpLm1vZGUsIGkuaW9zLCBpLm1kKTtcbiAgaWYgKHVybCkge1xuICAgIHJldHVybiBnZXROYW1lZFVybCh1cmwpO1xuICB9XG4gIGlmIChpLmljb24pIHtcbiAgICB1cmwgPSBnZXRTcmMoaS5pY29uKTtcbiAgICBpZiAodXJsKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICB1cmwgPSBnZXRTcmMoaS5pY29uW2kubW9kZV0pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldE5hbWVkVXJsID0gKGljb25OYW1lKSA9PiB7XG4gIGNvbnN0IHVybCA9IGdldEljb25NYXAoKS5nZXQoaWNvbk5hbWUpO1xuICBpZiAodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICByZXR1cm4gZ2V0QXNzZXRQYXRoKGBzdmcvJHtpY29uTmFtZX0uc3ZnYCk7XG59O1xuY29uc3QgZ2V0TmFtZSA9IChpY29uTmFtZSwgaWNvbiwgbW9kZSwgaW9zLCBtZCkgPT4ge1xuICAvLyBkZWZhdWx0IHRvIFwibWRcIiBpZiBzb21laG93IHRoZSBtb2RlIHdhc24ndCBzZXRcbiAgbW9kZSA9IChtb2RlICYmIHRvTG93ZXIobW9kZSkpID09PSAnaW9zJyA/ICdpb3MnIDogJ21kJztcbiAgLy8gaWYgYW4gaWNvbiB3YXMgcGFzc2VkIGluIHVzaW5nIHRoZSBpb3Mgb3IgbWQgYXR0cmlidXRlc1xuICAvLyBzZXQgdGhlIGljb25OYW1lIHRvIHdoYXRldmVyIHdhcyBwYXNzZWQgaW5cbiAgaWYgKGlvcyAmJiBtb2RlID09PSAnaW9zJykge1xuICAgIGljb25OYW1lID0gdG9Mb3dlcihpb3MpO1xuICB9XG4gIGVsc2UgaWYgKG1kICYmIG1vZGUgPT09ICdtZCcpIHtcbiAgICBpY29uTmFtZSA9IHRvTG93ZXIobWQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICghaWNvbk5hbWUgJiYgaWNvbiAmJiAhaXNTcmMoaWNvbikpIHtcbiAgICAgIGljb25OYW1lID0gaWNvbjtcbiAgICB9XG4gICAgaWYgKGlzU3RyKGljb25OYW1lKSkge1xuICAgICAgaWNvbk5hbWUgPSB0b0xvd2VyKGljb25OYW1lKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1N0cihpY29uTmFtZSkgfHwgaWNvbk5hbWUudHJpbSgpID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIG9ubHkgYWxsb3cgYWxwaGEgY2hhcmFjdGVycyBhbmQgZGFzaFxuICBjb25zdCBpbnZhbGlkQ2hhcnMgPSBpY29uTmFtZS5yZXBsYWNlKC9bYS16XXwtfFxcZC9naSwgJycpO1xuICBpZiAoaW52YWxpZENoYXJzICE9PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpY29uTmFtZTtcbn07XG5jb25zdCBnZXRTcmMgPSAoc3JjKSA9PiB7XG4gIGlmIChpc1N0cihzcmMpKSB7XG4gICAgc3JjID0gc3JjLnRyaW0oKTtcbiAgICBpZiAoaXNTcmMoc3JjKSkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgaXNTcmMgPSAoc3RyKSA9PiBzdHIubGVuZ3RoID4gMCAmJiAvKFxcL3xcXC4pLy50ZXN0KHN0cik7XG5jb25zdCBpc1N0ciA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuY29uc3QgdG9Mb3dlciA9ICh2YWwpID0+IHZhbC50b0xvd2VyQ2FzZSgpO1xuLyoqXG4gKiBFbGVtZW50cyBpbnNpZGUgb2Ygd2ViIGNvbXBvbmVudHMgc29tZXRpbWVzIG5lZWQgdG8gaW5oZXJpdCBnbG9iYWwgYXR0cmlidXRlc1xuICogc2V0IG9uIHRoZSBob3N0LiBGb3IgZXhhbXBsZSwgdGhlIGlubmVyIGlucHV0IGluIGBpb24taW5wdXRgIHNob3VsZCBpbmhlcml0XG4gKiB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgdGhhdCBkZXZlbG9wZXJzIHNldCBkaXJlY3RseSBvbiBgaW9uLWlucHV0YC4gVGhpc1xuICogaGVscGVyIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgaW4gY29tcG9uZW50V2lsbExvYWQgYW5kIGFzc2lnbmVkIHRvIGEgdmFyaWFibGVcbiAqIHRoYXQgaXMgbGF0ZXIgdXNlZCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSByZWFjdGl2ZSBhcyBjaGFuZ2luZyBhdHRyaWJ1dGVzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAqIGRvZXMgbm90IHRyaWdnZXIgYSByZS1yZW5kZXIuXG4gKi9cbmNvbnN0IGluaGVyaXRBdHRyaWJ1dGVzID0gKGVsLCBhdHRyaWJ1dGVzID0gW10pID0+IHtcbiAgY29uc3QgYXR0cmlidXRlT2JqZWN0ID0ge307XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVPYmplY3RbYXR0cl0gPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZU9iamVjdDtcbn07XG5cbmV4cG9ydCB7IGFkZEljb25zIGFzIGEsIGluaGVyaXRBdHRyaWJ1dGVzIGFzIGIsIGdldE5hbWUgYXMgYywgZ2V0VXJsIGFzIGcsIGlzU3RyIGFzIGkgfTtcbiIsImltcG9ydCB7IEhUTUxFbGVtZW50LCBCdWlsZCwgaCwgSG9zdCwgcHJveHlDdXN0b21FbGVtZW50IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgaSBhcyBpc1N0ciwgYiBhcyBpbmhlcml0QXR0cmlidXRlcywgZyBhcyBnZXRVcmwsIGMgYXMgZ2V0TmFtZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCB2YWxpZGF0ZUNvbnRlbnQgPSAoc3ZnQ29udGVudCkgPT4ge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IHN2Z0NvbnRlbnQ7XG4gIC8vIHNldHVwIHRoaXMgd2F5IHRvIGVuc3VyZSBpdCB3b3JrcyBvbiBvdXIgYnVkZHkgSUVcbiAgZm9yIChsZXQgaSA9IGRpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGRpdi5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzdmcnKSB7XG4gICAgICBkaXYucmVtb3ZlQ2hpbGQoZGl2LmNoaWxkTm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuICAvLyBtdXN0IG9ubHkgaGF2ZSAxIHJvb3QgZWxlbWVudFxuICBjb25zdCBzdmdFbG0gPSBkaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIGlmIChzdmdFbG0gJiYgc3ZnRWxtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgY29uc3Qgc3ZnQ2xhc3MgPSBzdmdFbG0uZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgIHN2Z0VsbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKHN2Z0NsYXNzICsgJyBzLWlvbi1pY29uJykudHJpbSgpKTtcbiAgICAvLyByb290IGVsZW1lbnQgbXVzdCBiZSBhbiBzdmdcbiAgICAvLyBsZXRzIGRvdWJsZSBjaGVjayB3ZSd2ZSBnb3QgdmFsaWQgZWxlbWVudHNcbiAgICAvLyBkbyBub3QgYWxsb3cgc2NyaXB0c1xuICAgIGlmIChpc1ZhbGlkKHN2Z0VsbSkpIHtcbiAgICAgIHJldHVybiBkaXYuaW5uZXJIVE1MO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59O1xuY29uc3QgaXNWYWxpZCA9IChlbG0pID0+IHtcbiAgaWYgKGVsbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGlmIChlbG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbG0uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsID0gZWxtLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgICBpZiAoaXNTdHIodmFsKSAmJiB2YWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvbicpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbG0uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc1ZhbGlkKGVsbS5jaGlsZE5vZGVzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaW9uaWNvbkNvbnRlbnQgPSBuZXcgTWFwKCk7XG5jb25zdCByZXF1ZXN0cyA9IG5ldyBNYXAoKTtcbmNvbnN0IGdldFN2Z0NvbnRlbnQgPSAodXJsLCBzYW5pdGl6ZSkgPT4ge1xuICAvLyBzZWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVxdWVzdCBmb3IgdGhpcyB1cmxcbiAgbGV0IHJlcSA9IHJlcXVlc3RzLmdldCh1cmwpO1xuICBpZiAoIXJlcSkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIHJlcXVlc3RcbiAgICAgIHJlcSA9IGZldGNoKHVybCkudGhlbigocnNwKSA9PiB7XG4gICAgICAgIGlmIChyc3Aub2spIHtcbiAgICAgICAgICByZXR1cm4gcnNwLnRleHQoKS50aGVuKChzdmdDb250ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3ZnQ29udGVudCAmJiBzYW5pdGl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3ZnQ29udGVudCA9IHZhbGlkYXRlQ29udGVudChzdmdDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlvbmljb25Db250ZW50LnNldCh1cmwsIHN2Z0NvbnRlbnQgfHwgJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlvbmljb25Db250ZW50LnNldCh1cmwsICcnKTtcbiAgICAgIH0pO1xuICAgICAgLy8gY2FjaGUgZm9yIHRoZSBzYW1lIHJlcXVlc3RzXG4gICAgICByZXF1ZXN0cy5zZXQodXJsLCByZXEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHNldCB0byBlbXB0eSBmb3Igc3NyIHNjZW5hcmlvcyBhbmQgcmVzb2x2ZSBwcm9taXNlXG4gICAgICBpb25pY29uQ29udGVudC5zZXQodXJsLCAnJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXE7XG59O1xuXG5jb25zdCBpY29uQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxZW07aGVpZ2h0OjFlbTtjb250YWluOnN0cmljdDtmaWxsOmN1cnJlbnRDb2xvcjstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudDtib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnR9Omhvc3QgLmlvbmljb257c3Ryb2tlOmN1cnJlbnRDb2xvcn0uaW9uaWNvbi1maWxsLW5vbmV7ZmlsbDpub25lfS5pb25pY29uLXN0cm9rZS13aWR0aHtzdHJva2Utd2lkdGg6MzJweDtzdHJva2Utd2lkdGg6dmFyKC0taW9uaWNvbi1zdHJva2Utd2lkdGgsIDMycHgpfS5pY29uLWlubmVyLC5pb25pY29uLHN2Z3tkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO3dpZHRoOjEwMCV9Omhvc3QoLmZsaXAtcnRsKSAuaWNvbi1pbm5lcnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVgoLTEpO3RyYW5zZm9ybTpzY2FsZVgoLTEpfTpob3N0KC5pY29uLXNtYWxsKXtmb250LXNpemU6MThweCAhaW1wb3J0YW50fTpob3N0KC5pY29uLWxhcmdlKXtmb250LXNpemU6MzJweCAhaW1wb3J0YW50fTpob3N0KC5pb24tY29sb3Ipe2NvbG9yOnZhcigtLWlvbi1jb2xvci1iYXNlKSAhaW1wb3J0YW50fTpob3N0KC5pb24tY29sb3ItcHJpbWFyeSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZil9Omhvc3QoLmlvbi1jb2xvci1zZWNvbmRhcnkpey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLXNlY29uZGFyeSwgIzBjZDFlOCl9Omhvc3QoLmlvbi1jb2xvci10ZXJ0aWFyeSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItdGVydGlhcnksICNmNGE5NDIpfTpob3N0KC5pb24tY29sb3Itc3VjY2Vzcyl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3Itc3VjY2VzcywgIzEwZGM2MCl9Omhvc3QoLmlvbi1jb2xvci13YXJuaW5nKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci13YXJuaW5nLCAjZmZjZTAwKX06aG9zdCguaW9uLWNvbG9yLWRhbmdlcil7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItZGFuZ2VyLCAjZjE0MTQxKX06aG9zdCguaW9uLWNvbG9yLWxpZ2h0KXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1saWdodCwgI2Y0ZjVmOCl9Omhvc3QoLmlvbi1jb2xvci1tZWRpdW0pey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLW1lZGl1bSwgIzk4OWFhMil9Omhvc3QoLmlvbi1jb2xvci1kYXJrKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1kYXJrLCAjMjIyNDI4KX1cIjtcblxubGV0IEljb24gPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaWNvbk5hbWUgPSBudWxsO1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGUgZGV0ZXJtaW5lcyB3aGljaCBwbGF0Zm9ybSBzdHlsZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IGdldElvbk1vZGUoKTtcbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkLCBpb24taWNvbiB3aWxsIGJlIGxvYWRlZCBsYXppbHkgd2hlbiBpdCdzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIERlZmF1bHQsIGBmYWxzZWAuXG4gICAgICovXG4gICAgdGhpcy5sYXp5ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgU1ZHIGNvbnRlbnQgdGhhdCBpcyBIVFRQIGZldGNoZWQgd2lsbCBub3QgYmUgY2hlY2tlZFxuICAgICAqIGlmIHRoZSByZXNwb25zZSBTVkcgY29udGVudCBoYXMgYW55IGA8c2NyaXB0PmAgZWxlbWVudHMsIG9yIGFueSBhdHRyaWJ1dGVzXG4gICAgICogdGhhdCBzdGFydCB3aXRoIGBvbmAsIHN1Y2ggYXMgYG9uY2xpY2tgLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLnNhbml0aXplID0gdHJ1ZTtcbiAgICB0aGlzLmhhc0FyaWFIaWRkZW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGVsIH0gPSB0aGlzO1xuICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgPT09ICd0cnVlJztcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW5oZXJpdGVkQXR0cmlidXRlcyA9IGluaGVyaXRBdHRyaWJ1dGVzKHRoaXMuZWwsIFsnYXJpYS1sYWJlbCddKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAvLyBwdXJwb3NlbHkgZG8gbm90IHJldHVybiB0aGUgcHJvbWlzZSBoZXJlIGJlY2F1c2UgbG9hZGluZ1xuICAgIC8vIHRoZSBzdmcgZmlsZSBzaG91bGQgbm90IGhvbGQgdXAgbG9hZGluZyB0aGUgYXBwXG4gICAgLy8gb25seSBsb2FkIHRoZSBzdmcgaWYgaXQncyB2aXNpYmxlXG4gICAgdGhpcy53YWl0VW50aWxWaXNpYmxlKHRoaXMuZWwsICc1MHB4JywgKCkgPT4ge1xuICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5sb2FkSWNvbigpO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmlvKSB7XG4gICAgICB0aGlzLmlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuaW8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHdhaXRVbnRpbFZpc2libGUoZWwsIHJvb3RNYXJnaW4sIGNiKSB7XG4gICAgaWYgKEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLmxhenkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBjb25zdCBpbyA9ICh0aGlzLmlvID0gbmV3IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlcigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YVswXS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIGlvLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLmlvID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHsgcm9vdE1hcmdpbiB9KSk7XG4gICAgICBpby5vYnNlcnZlKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgLy8gc28ganVzdCBmYWxsYmFjayB0byBhbHdheXMgc2hvdyBpdFxuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbiAgbG9hZEljb24oKSB7XG4gICAgaWYgKEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgY29uc3QgdXJsID0gZ2V0VXJsKHRoaXMpO1xuICAgICAgaWYgKHVybCkge1xuICAgICAgICBpZiAoaW9uaWNvbkNvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAvLyBzeW5jIGlmIGl0J3MgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICB0aGlzLnN2Z0NvbnRlbnQgPSBpb25pY29uQ29udGVudC5nZXQodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhc3luYyBpZiBpdCBoYXNuJ3QgYmVlbiBsb2FkZWRcbiAgICAgICAgICBnZXRTdmdDb250ZW50KHVybCwgdGhpcy5zYW5pdGl6ZSkudGhlbigoKSA9PiAodGhpcy5zdmdDb250ZW50ID0gaW9uaWNvbkNvbnRlbnQuZ2V0KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuaWNvbk5hbWUgPSBnZXROYW1lKHRoaXMubmFtZSwgdGhpcy5pY29uLCB0aGlzLm1vZGUsIHRoaXMuaW9zLCB0aGlzLm1kKTtcbiAgICAvKipcbiAgICAgKiBDb21lIHVwIHdpdGggYSBkZWZhdWx0IGxhYmVsXG4gICAgICogaW4gY2FzZSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgdGhlaXIgb3duLlxuICAgICAqL1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hcmlhTGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9cXC0vZywgJyAnKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaWNvbk5hbWUsIGFyaWFMYWJlbCwgaW5oZXJpdGVkQXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlIHx8ICdtZCc7XG4gICAgY29uc3QgZmxpcFJ0bCA9IHRoaXMuZmxpcFJ0bCB8fFxuICAgICAgKGljb25OYW1lICYmXG4gICAgICAgIChpY29uTmFtZS5pbmRleE9mKCdhcnJvdycpID4gLTEgfHwgaWNvbk5hbWUuaW5kZXhPZignY2hldnJvbicpID4gLTEpICYmXG4gICAgICAgIHRoaXMuZmxpcFJ0bCAhPT0gZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIE9ubHkgc2V0IHRoZSBhcmlhLWxhYmVsIGlmIGEpIHdlIGhhdmUgZ2VuZXJhdGVkXG4gICAgICogb25lIGZvciB0aGUgaWNvbiBhbmQgaWYgYXJpYS1oaWRkZW4gaXMgbm90IHNldCB0byBcInRydWVcIi5cbiAgICAgKiBJZiBkZXZlbG9wZXIgd2FudHMgdG8gc2V0IHRoZWlyIG93biBhcmlhLWxhYmVsLCB0aGVuXG4gICAgICogaW5oZXJpdGVkQXR0cmlidXRlcyBkb3duIGJlbG93IHdpbGwgb3ZlcnJpZGUgd2hhdGV2ZXJcbiAgICAgKiBkZWZhdWx0IGxhYmVsIHdlIGhhdmUgc2V0LlxuICAgICAqL1xuICAgIHJldHVybiAoaChIb3N0LCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhc0FyaWFIaWRkZW4oKSA/IGFyaWFMYWJlbCA6IG51bGwsIHJvbGU6IFwiaW1nXCIsIGNsYXNzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBbbW9kZV06IHRydWUgfSwgY3JlYXRlQ29sb3JDbGFzc2VzKHRoaXMuY29sb3IpKSwgeyBbYGljb24tJHt0aGlzLnNpemV9YF06ICEhdGhpcy5zaXplLCAnZmxpcC1ydGwnOiAhIWZsaXBSdGwgJiYgdGhpcy5lbC5vd25lckRvY3VtZW50LmRpciA9PT0gJ3J0bCcgfSkgfSwgaW5oZXJpdGVkQXR0cmlidXRlcyksIEJ1aWxkLmlzQnJvd3NlciAmJiB0aGlzLnN2Z0NvbnRlbnQgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBcImljb24taW5uZXJcIiwgaW5uZXJIVE1MOiB0aGlzLnN2Z0NvbnRlbnQgfSkpIDogKGgoXCJkaXZcIiwgeyBjbGFzczogXCJpY29uLWlubmVyXCIgfSkpKSk7XG4gIH1cbiAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1wic3ZnXCJdOyB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcIm5hbWVcIjogW1wibG9hZEljb25cIl0sXG4gICAgXCJzcmNcIjogW1wibG9hZEljb25cIl0sXG4gICAgXCJpY29uXCI6IFtcImxvYWRJY29uXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIGljb25Dc3M7IH1cbn07XG5jb25zdCBnZXRJb25Nb2RlID0gKCkgPT4gKEJ1aWxkLmlzQnJvd3NlciAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGUnKSkgfHwgJ21kJztcbmNvbnN0IGNyZWF0ZUNvbG9yQ2xhc3NlcyA9IChjb2xvcikgPT4ge1xuICByZXR1cm4gY29sb3JcbiAgICA/IHtcbiAgICAgICdpb24tY29sb3InOiB0cnVlLFxuICAgICAgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSxcbiAgICB9XG4gICAgOiBudWxsO1xufTtcbkljb24gPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChJY29uLCBbMSwgXCJpb24taWNvblwiLCB7XG4gICAgXCJtb2RlXCI6IFsxMDI1XSxcbiAgICBcImNvbG9yXCI6IFsxXSxcbiAgICBcImlvc1wiOiBbMV0sXG4gICAgXCJtZFwiOiBbMV0sXG4gICAgXCJmbGlwUnRsXCI6IFs0LCBcImZsaXAtcnRsXCJdLFxuICAgIFwibmFtZVwiOiBbNTEzXSxcbiAgICBcInNyY1wiOiBbMV0sXG4gICAgXCJpY29uXCI6IFs4XSxcbiAgICBcInNpemVcIjogWzFdLFxuICAgIFwibGF6eVwiOiBbNF0sXG4gICAgXCJzYW5pdGl6ZVwiOiBbNF0sXG4gICAgXCJzdmdDb250ZW50XCI6IFszMl0sXG4gICAgXCJpc1Zpc2libGVcIjogWzMyXSxcbiAgICBcImFyaWFMYWJlbFwiOiBbMzJdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1pY29uXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgSWNvbik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uSWNvbiA9IEljb247XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gZGVmaW5lQ3VzdG9tRWxlbWVudCQxO1xuXG5leHBvcnQgeyBJb25JY29uLCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCJleHBvcnQgKiBmcm9tICcuL2VzbS1lczUvaW5kZXguanMnOyIsImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCwgY3JlYXRlRWxlbWVudCwgdXNlU3RhdGUsIEZyYWdtZW50LCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzUGxhdGZvcm0gYXMgaXNQbGF0Zm9ybSQxLCBnZXRQbGF0Zm9ybXMgYXMgZ2V0UGxhdGZvcm1zJDEsIGFsZXJ0Q29udHJvbGxlciwgbG9hZGluZ0NvbnRyb2xsZXIsIHRvYXN0Q29udHJvbGxlciBhcyB0b2FzdENvbnRyb2xsZXIkMSwgcGlja2VyQ29udHJvbGxlciwgYWN0aW9uU2hlZXRDb250cm9sbGVyIGFzIGFjdGlvblNoZWV0Q29udHJvbGxlciQxLCBjcmVhdGVBbmltYXRpb24sIG1vZGFsQ29udHJvbGxlciwgcG9wb3ZlckNvbnRyb2xsZXIsIGluaXRpYWxpemUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzJztcbmV4cG9ydCB7IElvbmljU2FmZVN0cmluZywgSW9uaWNTbGlkZXMsIElvbmljU3dpcGVyLCBjcmVhdGVBbmltYXRpb24sIGNyZWF0ZUdlc3R1cmUsIGdldFRpbWVHaXZlblByb2dyZXNzaW9uLCBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uLCBtZFRyYW5zaXRpb25BbmltYXRpb24gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzJztcbmltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hY2NvcmRpb24uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hY2NvcmRpb24tZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDMgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1hdmF0YXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1iYWNrZHJvcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkNSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJhZGdlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ2IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYnJlYWRjcnVtYnMuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1idXR0b25zLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ5IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC1oZWFkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jYXJkLXN1YnRpdGxlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRiIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC10aXRsZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkYyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNoZWNrYm94LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRkIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2hpcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkZSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNvbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkZiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1kYXRldGltZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkaCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWZhYi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkaSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWZhYi1saXN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRqIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZm9vdGVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRrIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZ3JpZC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWhlYWRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWltZy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWluZmluaXRlLXNjcm9sbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkbyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWluZmluaXRlLXNjcm9sbC1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRwIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taW5wdXQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLWRpdmlkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLWdyb3VwLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRzIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS1vcHRpb25zLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR0IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS1zbGlkaW5nLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR1IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbGFiZWwuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1saXN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR3IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbGlzdC1oZWFkZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tZW51LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCR5IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbWVudS1idXR0b24uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHogfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tZW51LXRvZ2dsZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkQSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW5hdi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkQiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW5hdi1saW5rLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRDIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbm90ZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkRCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXByb2dyZXNzLWJhci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkRSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJhZGlvLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRGIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmFkaW8tZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yYW5nZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlZnJlc2hlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlZnJlc2hlci1jb250ZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRKIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmVvcmRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkSyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJlb3JkZXItZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEwgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yaXBwbGUtZWZmZWN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRNIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcm93LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCROIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VhcmNoYmFyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRPIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VnbWVudC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkUCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNlZ21lbnQtYnV0dG9uLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRRIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VsZWN0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRSIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VsZWN0LW9wdGlvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkUyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNrZWxldG9uLXRleHQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zbGlkZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkVSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNsaWRlcy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkViB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNwaW5uZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zcGxpdC1wYW5lLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRYIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRZIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGV4dC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkWiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRleHRhcmVhLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRfIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGh1bWJuYWlsLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQkIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGl0bGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEwIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdG9nZ2xlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRvb2xiYXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEyIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdmlydHVhbC1zY3JvbGwuanMnO1xuaW1wb3J0IHsgSW9uQnJlYWRjcnVtYiBhcyBJb25CcmVhZGNydW1iJDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1icmVhZGNydW1iLmpzJztcbmltcG9ydCB7IElvbkJ1dHRvbiBhcyBJb25CdXR0b24kMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBJb25DYXJkIGFzIElvbkNhcmQkMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNhcmQuanMnO1xuaW1wb3J0IHsgSW9uRmFiQnV0dG9uIGFzIElvbkZhYkJ1dHRvbiQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZmFiLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBJb25JdGVtT3B0aW9uIGFzIElvbkl0ZW1PcHRpb24kMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWl0ZW0tb3B0aW9uLmpzJztcbmltcG9ydCB7IElvbkl0ZW0gYXMgSW9uSXRlbSQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS5qcyc7XG5pbXBvcnQgeyBJb25Sb3V0ZXJMaW5rIGFzIElvblJvdXRlckxpbmskMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJvdXRlci1saW5rLmpzJztcbmltcG9ydCB7IElvbkFsZXJ0IGFzIElvbkFsZXJ0JDEsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFsZXJ0LmpzJztcbmltcG9ydCB7IElvbkxvYWRpbmcgYXMgSW9uTG9hZGluZyQxLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMWYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1sb2FkaW5nLmpzJztcbmltcG9ydCB7IElvblRvYXN0IGFzIElvblRvYXN0JDEsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRvYXN0LmpzJztcbmltcG9ydCB7IElvblBpY2tlciBhcyBJb25QaWNrZXIkMSwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDFlIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcGlja2VyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFjdGlvbi1zaGVldC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tb2RhbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1wb3BvdmVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFwcC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1iYWNrLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTkgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yb3V0ZXItb3V0bGV0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRhYi1iYXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDE2IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMWIgfSBmcm9tICdpb25pY29ucy9jb21wb25lbnRzL2lvbi1pY29uLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudE9uUmVhZHkgfSBmcm9tICdAaW9uaWMvY29yZSc7XG5cbmNvbnN0IElvbkxpZmVDeWNsZUNvbnRleHQgPSAvKkBfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIG9uSW9uVmlld1dpbGxFbnRlcjogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBpb25WaWV3V2lsbEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIG9uSW9uVmlld0RpZEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGlvblZpZXdEaWRFbnRlcjogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBvbklvblZpZXdXaWxsTGVhdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgaW9uVmlld1dpbGxMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBvbklvblZpZXdEaWRMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBpb25WaWV3RGlkTGVhdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG59KTtcbmNvbnN0IERlZmF1bHRJb25MaWZlQ3ljbGVDb250ZXh0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzID0gW107XG4gICAgfVxuICAgIG9uSW9uVmlld1dpbGxFbnRlcihjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3V2lsbEVudGVyQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3NbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld1dpbGxFbnRlcigpIHtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbEVudGVyQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9XG4gICAgb25Jb25WaWV3RGlkRW50ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld0RpZEVudGVyKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfVxuICAgIG9uSW9uVmlld1dpbGxMZWF2ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3NbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld1dpbGxMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5pb25WaWV3V2lsbExlYXZlQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9XG4gICAgb25Jb25WaWV3RGlkTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzLmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gY2FsbGJhY2suaWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRMZWF2ZUNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld0RpZExlYXZlKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdEaWRMZWF2ZUNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWQoKTtcbiAgICB9XG4gICAgb25Db21wb25lbnRDYW5CZURlc3Ryb3llZChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENhbkJlRGVzdHJveWVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgY29tcG9uZW50Q2FuQmVEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudENhbkJlRGVzdHJveWVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3Qgd2l0aElvbkxpZmVDeWNsZSA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzIElvbkxpZmVDeWNsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY29tcG9uZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3V2lsbEVudGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlvblZpZXdXaWxsRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3V2lsbEVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3RGlkRW50ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld0RpZEVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW9uVmlld0RpZEVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3V2lsbExlYXZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlvblZpZXdXaWxsTGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3V2lsbExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQub25Jb25WaWV3RGlkTGVhdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld0RpZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW9uVmlld0RpZExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvbkxpZmVDeWNsZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmNvbXBvbmVudFJlZiB9LCB0aGlzLnByb3BzKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgdXNlSW9uVmlld1dpbGxFbnRlciA9IChjYWxsYmFjaywgZGVwcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uTGlmZUN5Y2xlQ29udGV4dCk7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYoKTtcbiAgICBpZC5jdXJyZW50ID0gaWQuY3VycmVudCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5pZCA9IGlkLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQub25Jb25WaWV3V2lsbEVudGVyKGNhbGxiYWNrKTtcbiAgICB9LCBkZXBzKTtcbn07XG5jb25zdCB1c2VJb25WaWV3RGlkRW50ZXIgPSAoY2FsbGJhY2ssIGRlcHMgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KElvbkxpZmVDeWNsZUNvbnRleHQpO1xuICAgIGNvbnN0IGlkID0gdXNlUmVmKCk7XG4gICAgaWQuY3VycmVudCA9IGlkLmN1cnJlbnQgfHwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2suaWQgPSBpZC5jdXJyZW50O1xuICAgICAgICBjb250ZXh0Lm9uSW9uVmlld0RpZEVudGVyKGNhbGxiYWNrKTtcbiAgICB9LCBkZXBzKTtcbn07XG5jb25zdCB1c2VJb25WaWV3V2lsbExlYXZlID0gKGNhbGxiYWNrLCBkZXBzID0gW10pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJb25MaWZlQ3ljbGVDb250ZXh0KTtcbiAgICBjb25zdCBpZCA9IHVzZVJlZigpO1xuICAgIGlkLmN1cnJlbnQgPSBpZC5jdXJyZW50IHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmlkID0gaWQuY3VycmVudDtcbiAgICAgICAgY29udGV4dC5vbklvblZpZXdXaWxsTGVhdmUoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcbmNvbnN0IHVzZUlvblZpZXdEaWRMZWF2ZSA9IChjYWxsYmFjaywgZGVwcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uTGlmZUN5Y2xlQ29udGV4dCk7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYoKTtcbiAgICBpZC5jdXJyZW50ID0gaWQuY3VycmVudCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5pZCA9IGlkLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQub25Jb25WaWV3RGlkTGVhdmUoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcblxuY29uc3QgTmF2Q29udGV4dCA9IC8qQF9fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgZ2V0SW9uUmVkaXJlY3Q6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnZXRJb25Sb3V0ZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldFBhZ2VNYW5hZ2VyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ2V0U3RhY2tNYW5hZ2VyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ29CYWNrOiAocm91dGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvdXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9IHJvdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBuYXZpZ2F0ZTogKHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoYXNJb25pY1JvdXRlcjogKCkgPT4gZmFsc2UsXG4gICAgcm91dGVJbmZvOiB1bmRlZmluZWQsXG4gICAgc2V0Q3VycmVudFRhYjogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNoYW5nZVRhYjogKF90YWIsIHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNldFRhYjogKF90YWIsIHBhdGgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5jb25zdCBkYXNoVG9QYXNjYWxDYXNlID0gKHN0cikgPT4gc3RyXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAuc3BsaXQoJy0nKVxuICAgIC5tYXAoKHNlZ21lbnQpID0+IHNlZ21lbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWdtZW50LnNsaWNlKDEpKVxuICAgIC5qb2luKCcnKTtcbmNvbnN0IGNhbWVsVG9EYXNoQ2FzZSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIChtKSA9PiBgLSR7bVswXS50b0xvd2VyQ2FzZSgpfWApO1xuXG5jb25zdCBhdHRhY2hQcm9wcyA9IChub2RlLCBuZXdQcm9wcywgb2xkUHJvcHMgPSB7fSkgPT4ge1xuICAgIC8vIHNvbWUgdGVzdCBmcmFtZXdvcmtzIGRvbid0IHJlbmRlciBET00gZWxlbWVudHMsIHNvIHdlIHRlc3QgaGVyZSB0byBtYWtlIHN1cmUgd2UgYXJlIGRlYWxpbmcgd2l0aCBET00gZmlyc3RcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYWRkIGFueSBjbGFzc2VzIGluIGNsYXNzTmFtZSB0byB0aGUgY2xhc3MgbGlzdFxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUobm9kZS5jbGFzc0xpc3QsIG5ld1Byb3BzLCBvbGRQcm9wcyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUgIT09ICcnKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhuZXdQcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjaGlsZHJlbicgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ3JlZicgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2NsYXNzTmFtZScgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnZm9yd2FyZGVkUmVmJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbmFtZVsyXSA9PT0gbmFtZVsyXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbmFtZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lTGMgPSBldmVudE5hbWVbMF0udG9Mb3dlckNhc2UoKSArIGV2ZW50TmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZUxjKSkge1xuICAgICAgICAgICAgICAgICAgICBzeW5jRXZlbnQobm9kZSwgZXZlbnROYW1lTGMsIG5ld1Byb3BzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlW25hbWVdID0gbmV3UHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFR5cGUgPSB0eXBlb2YgbmV3UHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjYW1lbFRvRGFzaENhc2UobmFtZSksIG5ld1Byb3BzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRDbGFzc05hbWUgPSAoY2xhc3NMaXN0LCBuZXdQcm9wcywgb2xkUHJvcHMpID0+IHtcbiAgICBjb25zdCBuZXdDbGFzc1Byb3AgPSBuZXdQcm9wcy5jbGFzc05hbWUgfHwgbmV3UHJvcHMuY2xhc3M7XG4gICAgY29uc3Qgb2xkQ2xhc3NQcm9wID0gb2xkUHJvcHMuY2xhc3NOYW1lIHx8IG9sZFByb3BzLmNsYXNzO1xuICAgIC8vIG1hcCB0aGUgY2xhc3NlcyB0byBNYXBzIGZvciBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IGN1cnJlbnRDbGFzc2VzID0gYXJyYXlUb01hcChjbGFzc0xpc3QpO1xuICAgIGNvbnN0IGluY29taW5nUHJvcENsYXNzZXMgPSBhcnJheVRvTWFwKG5ld0NsYXNzUHJvcCA/IG5ld0NsYXNzUHJvcC5zcGxpdCgnICcpIDogW10pO1xuICAgIGNvbnN0IG9sZFByb3BDbGFzc2VzID0gYXJyYXlUb01hcChvbGRDbGFzc1Byb3AgPyBvbGRDbGFzc1Byb3Auc3BsaXQoJyAnKSA6IFtdKTtcbiAgICBjb25zdCBmaW5hbENsYXNzTmFtZXMgPSBbXTtcbiAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBvZiB0aGUgY3VycmVudCBjbGFzc2VzIG9uIHRoZSBjb21wb25lbnRcbiAgICAvLyB0byBzZWUgaWYgaXQgc2hvdWxkIGJlIGEgcGFydCBvZiB0aGUgY2xhc3NOYW1lcyBhZGRlZFxuICAgIGN1cnJlbnRDbGFzc2VzLmZvckVhY2goKGN1cnJlbnRDbGFzcykgPT4ge1xuICAgICAgICBpZiAoaW5jb21pbmdQcm9wQ2xhc3Nlcy5oYXMoY3VycmVudENsYXNzKSkge1xuICAgICAgICAgICAgLy8gYWRkIGl0IGFzIGl0cyBhbHJlYWR5IGluY2x1ZGVkIGluIGNsYXNzbmFtZXMgY29taW5nIGluIGZyb20gbmV3UHJvcHNcbiAgICAgICAgICAgIGZpbmFsQ2xhc3NOYW1lcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgICAgICBpbmNvbWluZ1Byb3BDbGFzc2VzLmRlbGV0ZShjdXJyZW50Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvbGRQcm9wQ2xhc3Nlcy5oYXMoY3VycmVudENsYXNzKSkge1xuICAgICAgICAgICAgLy8gYWRkIGl0IGFzIGl0IGhhcyBOT1QgYmVlbiByZW1vdmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGZpbmFsQ2xhc3NOYW1lcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbmNvbWluZ1Byb3BDbGFzc2VzLmZvckVhY2goKHMpID0+IGZpbmFsQ2xhc3NOYW1lcy5wdXNoKHMpKTtcbiAgICByZXR1cm4gZmluYWxDbGFzc05hbWVzLmpvaW4oJyAnKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmNvbnN0IGlzQ292ZXJlZEJ5UmVhY3QgPSAoZXZlbnROYW1lU3VmZml4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICAgICAgICBsZXQgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxufTtcbmNvbnN0IHN5bmNFdmVudCA9IChub2RlLCBldmVudE5hbWUsIG5ld0V2ZW50SGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IGV2ZW50U3RvcmUgPSBub2RlLl9fZXZlbnRzIHx8IChub2RlLl9fZXZlbnRzID0ge30pO1xuICAgIGNvbnN0IG9sZEV2ZW50SGFuZGxlciA9IGV2ZW50U3RvcmVbZXZlbnROYW1lXTtcbiAgICAvLyBSZW1vdmUgb2xkIGxpc3RlbmVyIHNvIHRoZXkgZG9uJ3QgZG91YmxlIHVwLlxuICAgIGlmIChvbGRFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgb2xkRXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gQmluZCBuZXcgbGlzdGVuZXIuXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGV2ZW50U3RvcmVbZXZlbnROYW1lXSA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICBpZiAobmV3RXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBuZXdFdmVudEhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbn07XG5jb25zdCBhcnJheVRvTWFwID0gKGFycikgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBhcnIuZm9yRWFjaCgocykgPT4gbWFwLnNldChzLCBzKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmNvbnN0IHNldFJlZiA9IChyZWYsIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2FzdCBhcyBhIE11dGFibGVSZWYgc28gd2UgY2FuIGFzc2lnbiBjdXJyZW50XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxufTtcbmNvbnN0IG1lcmdlUmVmcyA9ICguLi5yZWZzKSA9PiB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgICAgIHNldFJlZihyZWYsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5jb25zdCBjcmVhdGVGb3J3YXJkUmVmJDEgPSAoUmVhY3RDb21wb25lbnQsIGRpc3BsYXlOYW1lKSA9PiB7XG4gICAgY29uc3QgZm9yd2FyZFJlZiA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gICAgfTtcbiAgICBmb3J3YXJkUmVmLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgcmV0dXJuIFJlYWN0LmZvcndhcmRSZWYoZm9yd2FyZFJlZik7XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9ICh0YWdOYW1lLCBjdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGN1c3RvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgY3VzdG9tRWxlbWVudHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIGN1c3RvbUVsZW1lbnQpO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJlYWN0Q29tcG9uZW50ID0gKHRhZ05hbWUsIFJlYWN0Q29tcG9uZW50Q29udGV4dCwgbWFuaXB1bGF0ZVByb3BzRnVuY3Rpb24sIGRlZmluZUN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBpZiAoZGVmaW5lQ3VzdG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXNoVG9QYXNjYWxDYXNlKHRhZ05hbWUpO1xuICAgIGNvbnN0IFJlYWN0Q29tcG9uZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRDb21wb25lbnRFbFJlZiA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRFbCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgYXR0YWNoUHJvcHModGhpcy5jb21wb25lbnRFbCwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2hpbGRyZW4sIGZvcndhcmRlZFJlZiwgc3R5bGUsIGNsYXNzTmFtZSwgcmVmIH0gPSBfYSwgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImZvcndhcmRlZFJlZlwiLCBcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVmXCJdKTtcbiAgICAgICAgICAgIGxldCBwcm9wc1RvUGFzcyA9IE9iamVjdC5rZXlzKGNQcm9wcykucmVkdWNlKChhY2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdvbicpID09PSAwICYmIG5hbWVbMl0gPT09IG5hbWVbMl0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgaWYgKG1hbmlwdWxhdGVQcm9wc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1Bhc3MgPSBtYW5pcHVsYXRlUHJvcHNGdW5jdGlvbih0aGlzLnByb3BzLCBwcm9wc1RvUGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUb1Bhc3MpLCB7IHJlZjogbWVyZ2VSZWZzKGZvcndhcmRlZFJlZiwgdGhpcy5zZXRDb21wb25lbnRFbFJlZiksIHN0eWxlIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSB1c2UgY3JlYXRlRWxlbWVudCBoZXJlIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAqIFJlYWN0LmNyZWF0ZUVsZW1lbnQgdG8gd29yayBhcm91bmQgYVxuICAgICAgICAgICAgICogYnVnIGluIFZpdGUgKGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvNjEwNCkuXG4gICAgICAgICAgICAgKiBSZWFjdC5jcmVhdGVFbGVtZW50IGNhdXNlcyBhbGwgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAqIGFzIDx0YWduYW1lPiBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgV2ViIENvbXBvbmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgbmV3UHJvcHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjb250ZXh0IHdhcyBwYXNzZWQgdG8gY3JlYXRlUmVhY3RDb21wb25lbnQgdGhlbiBjb25kaXRpb25hbGx5IGFkZCBpdCB0byB0aGUgQ29tcG9uZW50IENsYXNzXG4gICAgaWYgKFJlYWN0Q29tcG9uZW50Q29udGV4dCkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5jb250ZXh0VHlwZSA9IFJlYWN0Q29tcG9uZW50Q29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZvcndhcmRSZWYkMShSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IElvbkFjY29yZGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1hY2NvcmRpb24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxKTtcbmNvbnN0IElvbkFjY29yZGlvbkdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWFjY29yZGlvbi1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDIpO1xuY29uc3QgSW9uQXZhdGFyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWF2YXRhcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDMpO1xuY29uc3QgSW9uQmFja2Ryb3AgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYmFja2Ryb3AnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ0KTtcbmNvbnN0IElvbkJhZGdlID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJhZGdlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkNSk7XG5jb25zdCBJb25CcmVhZGNydW1icyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1icmVhZGNydW1icycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDYpO1xuY29uc3QgSW9uQnV0dG9ucyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1idXR0b25zJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkNyk7XG5jb25zdCBJb25DYXJkQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLWNvbnRlbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4KTtcbmNvbnN0IElvbkNhcmRIZWFkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2FyZC1oZWFkZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ5KTtcbmNvbnN0IElvbkNhcmRTdWJ0aXRsZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLXN1YnRpdGxlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkYSk7XG5jb25zdCBJb25DYXJkVGl0bGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2FyZC10aXRsZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGIpO1xuY29uc3QgSW9uQ2hlY2tib3ggPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2hlY2tib3gnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRjKTtcbmNvbnN0IElvbkNoaXAgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY2hpcCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGQpO1xuY29uc3QgSW9uQ29sID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWNvbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGUpO1xuY29uc3QgSW9uQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jb250ZW50JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkZik7XG5jb25zdCBJb25EYXRldGltZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1kYXRldGltZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGcpO1xuY29uc3QgSW9uRmFiID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWZhYicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGgpO1xuY29uc3QgSW9uRmFiTGlzdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1mYWItbGlzdCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGkpO1xuY29uc3QgSW9uRm9vdGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWZvb3RlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGopO1xuY29uc3QgSW9uR3JpZCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1ncmlkJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkayk7XG5jb25zdCBJb25IZWFkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taGVhZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkbCk7XG5jb25zdCBJb25JbWcgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taW1nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkbSk7XG5jb25zdCBJb25JbmZpbml0ZVNjcm9sbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbmZpbml0ZS1zY3JvbGwnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRuKTtcbmNvbnN0IElvbkluZmluaXRlU2Nyb2xsQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbmZpbml0ZS1zY3JvbGwtY29udGVudCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JG8pO1xuY29uc3QgSW9uSW5wdXQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taW5wdXQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRwKTtcbmNvbnN0IElvbkl0ZW1EaXZpZGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tZGl2aWRlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHEpO1xuY29uc3QgSW9uSXRlbUdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tZ3JvdXAnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRyKTtcbmNvbnN0IElvbkl0ZW1PcHRpb25zID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWl0ZW0tb3B0aW9ucycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHMpO1xuY29uc3QgSW9uSXRlbVNsaWRpbmcgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taXRlbS1zbGlkaW5nJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdCk7XG5jb25zdCBJb25MYWJlbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1sYWJlbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHUpO1xuY29uc3QgSW9uTGlzdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1saXN0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdik7XG5jb25zdCBJb25MaXN0SGVhZGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWxpc3QtaGVhZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdyk7XG5jb25zdCBJb25NZW51ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLW1lbnUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR4KTtcbmNvbnN0IElvbk1lbnVCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbWVudS1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR5KTtcbmNvbnN0IElvbk1lbnVUb2dnbGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbWVudS10b2dnbGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR6KTtcbmNvbnN0IElvbk5hdiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1uYXYnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRBKTtcbmNvbnN0IElvbk5hdkxpbmsgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbmF2LWxpbmsnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRCKTtcbmNvbnN0IElvbk5vdGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbm90ZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEMpO1xuY29uc3QgSW9uUHJvZ3Jlc3NCYXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcHJvZ3Jlc3MtYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkRCk7XG5jb25zdCBJb25SYWRpbyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yYWRpbycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEUpO1xuY29uc3QgSW9uUmFkaW9Hcm91cCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yYWRpby1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEYpO1xuY29uc3QgSW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmFuZ2UnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRHKTtcbmNvbnN0IElvblJlZnJlc2hlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yZWZyZXNoZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRIKTtcbmNvbnN0IElvblJlZnJlc2hlckNvbnRlbnQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmVmcmVzaGVyLWNvbnRlbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRJKTtcbmNvbnN0IElvblJlb3JkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmVvcmRlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEopO1xuY29uc3QgSW9uUmVvcmRlckdyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJlb3JkZXItZ3JvdXAnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRLKTtcbmNvbnN0IElvblJpcHBsZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yaXBwbGUtZWZmZWN0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTCk7XG5jb25zdCBJb25Sb3cgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcm93JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTSk7XG5jb25zdCBJb25TZWFyY2hiYXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2VhcmNoYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkTik7XG5jb25zdCBJb25TZWdtZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNlZ21lbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRPKTtcbmNvbnN0IElvblNlZ21lbnRCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2VnbWVudC1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRQKTtcbmNvbnN0IElvblNlbGVjdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWxlY3QnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRRKTtcbmNvbnN0IElvblNlbGVjdE9wdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWxlY3Qtb3B0aW9uJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkUik7XG5jb25zdCBJb25Ta2VsZXRvblRleHQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2tlbGV0b24tdGV4dCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFMpO1xuY29uc3QgSW9uU2xpZGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2xpZGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRUKTtcbmNvbnN0IElvblNsaWRlcyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zbGlkZXMnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRVKTtcbmNvbnN0IElvblNwaW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc3Bpbm5lcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFYpO1xuY29uc3QgSW9uU3BsaXRQYW5lID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNwbGl0LXBhbmUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRXKTtcbmNvbnN0IElvblRhYiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10YWInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRYKTtcbmNvbnN0IElvblRleHQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGV4dCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFkpO1xuY29uc3QgSW9uVGV4dGFyZWEgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGV4dGFyZWEnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRaKTtcbmNvbnN0IElvblRodW1ibmFpbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10aHVtYm5haWwnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRfKTtcbmNvbnN0IElvblRpdGxlID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRpdGxlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkJCk7XG5jb25zdCBJb25Ub2dnbGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdG9nZ2xlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTApO1xuY29uc3QgSW9uVG9vbGJhciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10b29sYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTEpO1xuY29uc3QgSW9uVmlydHVhbFNjcm9sbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi12aXJ0dWFsLXNjcm9sbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDEyKTtcblxuY29uc3QgY3JlYXRlRm9yd2FyZFJlZiA9IChSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpID0+IHtcbiAgICBjb25zdCBmb3J3YXJkUmVmID0gKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9O1xuICAgIGZvcndhcmRSZWYuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZihmb3J3YXJkUmVmKTtcbn07XG5jb25zdCBpc1BsYXRmb3JtID0gKHBsYXRmb3JtKSA9PiB7XG4gICAgcmV0dXJuIGlzUGxhdGZvcm0kMSh3aW5kb3csIHBsYXRmb3JtKTtcbn07XG5jb25zdCBnZXRQbGF0Zm9ybXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFBsYXRmb3JtcyQxKHdpbmRvdyk7XG59O1xuY29uc3QgZ2V0Q29uZmlnID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBJb25pYyA9IHdpbmRvdy5Jb25pYztcbiAgICAgICAgaWYgKElvbmljICYmIElvbmljLmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIElvbmljLmNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGNyZWF0ZVJvdXRpbmdDb21wb25lbnQgPSAodGFnTmFtZSwgY3VzdG9tRWxlbWVudCkgPT4ge1xuICAgIGRlZmluZUN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY3VzdG9tRWxlbWVudCk7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXNoVG9QYXNjYWxDYXNlKHRhZ05hbWUpO1xuICAgIGNvbnN0IFJlYWN0Q29tcG9uZW50ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByb3V0ZXJMaW5rLCByb3V0ZXJEaXJlY3Rpb24sIHJvdXRlck9wdGlvbnMsIHJvdXRlckFuaW1hdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBpZiAocm91dGVyTGluayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lm5hdmlnYXRlKHJvdXRlckxpbmssIHJvdXRlckRpcmVjdGlvbiwgdW5kZWZpbmVkLCByb3V0ZXJBbmltYXRpb24sIHJvdXRlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdG8gYXR0YWNoIHByb3BzIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgLy8gUmVhY3QgcmVmcyBtdXN0IGJlIHN0YWJsZSAobm90IGNyZWF0ZWQgaW5saW5lKS5cbiAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyA9IG1lcmdlUmVmcyh0aGlzLnJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUodGhpcy5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyhub2RlLCB0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmLCBzdHlsZSwgY2xhc3NOYW1lLCByZWYgfSA9IF9hLCBjUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJyZWZcIl0pO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1Bhc3MgPSBPYmplY3Qua2V5cyhjUHJvcHMpLnJlZHVjZSgoYWNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignb24nKSA9PT0gMCAmJiBuYW1lWzJdID09PSBuYW1lWzJdLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ292ZXJlZEJ5UmVhY3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIGNQcm9wc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2NhbWVsVG9EYXNoQ2FzZShuYW1lKV0gPSBjUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUb1Bhc3MpLCB7IHJlZjogdGhpcy5zdGFibGVNZXJnZWRSZWZzLCBzdHlsZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnJvdXRlckxpbmsgJiYgIXRoaXMucHJvcHMuaHJlZikge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLmhyZWYgPSB0aGlzLnByb3BzLnJvdXRlckxpbms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3UHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZENsaWNrID0gbmV3UHJvcHMub25DbGljaztcbiAgICAgICAgICAgICAgICBuZXdQcm9wcy5vbkNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUNsaWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgbmV3UHJvcHMsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZUZvcndhcmRSZWYoUmVhY3RDb21wb25lbnQsIGRpc3BsYXlOYW1lKTtcbn07XG5cbmNvbnN0IElvblJvdXRlckxpbmsgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1yb3V0ZXItbGluaycsIElvblJvdXRlckxpbmskMSk7XG5jb25zdCBJb25CdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1idXR0b24nLCBJb25CdXR0b24kMSk7XG5jb25zdCBJb25DYXJkID0gLypAX19QVVJFX18qLyBjcmVhdGVSb3V0aW5nQ29tcG9uZW50KCdpb24tY2FyZCcsIElvbkNhcmQkMSk7XG5jb25zdCBJb25GYWJCdXR0b24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1mYWItYnV0dG9uJywgSW9uRmFiQnV0dG9uJDEpO1xuY29uc3QgSW9uSXRlbSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWl0ZW0nLCBJb25JdGVtJDEpO1xuY29uc3QgSW9uSXRlbU9wdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWl0ZW0tb3B0aW9uJywgSW9uSXRlbU9wdGlvbiQxKTtcbmNvbnN0IElvbkJyZWFkY3J1bWIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1icmVhZGNydW1iJywgSW9uQnJlYWRjcnVtYiQxKTtcblxuY29uc3QgY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCA9ICh0YWdOYW1lLCBjb250cm9sbGVyLCBjdXN0b21FbGVtZW50KSA9PiB7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBjdXN0b21FbGVtZW50KTtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgZGlkRGlzbWlzc0V2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9RGlkRGlzbWlzc2A7XG4gICAgY29uc3QgZGlkUHJlc2VudEV2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9RGlkUHJlc2VudGA7XG4gICAgY29uc3Qgd2lsbERpc21pc3NFdmVudE5hbWUgPSBgb24ke2Rpc3BsYXlOYW1lfVdpbGxEaXNtaXNzYDtcbiAgICBjb25zdCB3aWxsUHJlc2VudEV2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9V2lsbFByZXNlbnRgO1xuICAgIGNsYXNzIE92ZXJsYXkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNtaXNzID0gdGhpcy5oYW5kbGVEaXNtaXNzLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNPcGVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJldlByb3BzLmlzT3BlbiAhPT0gdGhpcy5wcm9wcy5pc09wZW4gJiYgdGhpcy5wcm9wcy5pc09wZW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlbnQocHJldlByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkgJiYgcHJldlByb3BzLmlzT3BlbiAhPT0gdGhpcy5wcm9wcy5pc09wZW4gJiYgdGhpcy5wcm9wcy5pc09wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHByZXNlbnQocHJldlByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIGNQcm9wcyA9IF9fcmVzdChfYSwgW1wiaXNPcGVuXCIsIFwib25EaWREaXNtaXNzXCIsIFwib25EaWRQcmVzZW50XCIsIFwib25XaWxsRGlzbWlzc1wiLCBcIm9uV2lsbFByZXNlbnRcIl0pO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5ID0gYXdhaXQgY29udHJvbGxlci5jcmVhdGUoT2JqZWN0LmFzc2lnbih7fSwgY1Byb3BzKSk7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyh0aGlzLm92ZXJsYXksIHtcbiAgICAgICAgICAgICAgICBbZGlkRGlzbWlzc0V2ZW50TmFtZV06IHRoaXMuaGFuZGxlRGlzbWlzcyxcbiAgICAgICAgICAgICAgICBbZGlkUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiB0aGlzLnByb3BzLm9uRGlkUHJlc2VudCAmJiB0aGlzLnByb3BzLm9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgICAgICBbd2lsbERpc21pc3NFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzICYmIHRoaXMucHJvcHMub25XaWxsRGlzbWlzcyhlKSxcbiAgICAgICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50ICYmIHRoaXMucHJvcHMub25XaWxsUHJlc2VudChlKSxcbiAgICAgICAgICAgIH0sIHByZXZQcm9wcyk7XG4gICAgICAgICAgICAvLyBDaGVjayBpc09wZW4gYWdhaW4gc2luY2UgdGhlIHZhbHVlIGNvdWxkIGhhdmUgY2hhbmdlZCBkdXJpbmcgdGhlIGFzeW5jIGNhbGwgdG8gY29udHJvbGxlci5jcmVhdGVcbiAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBwb3NzaWJsZSBmb3IgdGhlIGNvbXBvbmVudCB0byBoYXZlIGJlY29tZSB1bm1vdW50ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5pc09wZW4gPT09IHRydWUgJiYgdGhpcy5pc1VubW91bnRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIHRoaXMub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vdmVybGF5LnByZXNlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IHJlZiB9KSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBJb25BbGVydCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLWFsZXJ0JywgYWxlcnRDb250cm9sbGVyLCBJb25BbGVydCQxKTtcblxuY29uc3QgSW9uTG9hZGluZyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLWxvYWRpbmcnLCBsb2FkaW5nQ29udHJvbGxlciwgSW9uTG9hZGluZyQxKTtcblxuY29uc3QgdG9hc3RDb250cm9sbGVyID0ge1xuICAgIGNyZWF0ZTogKG9wdGlvbnMpID0+IHRvYXN0Q29udHJvbGxlciQxLmNyZWF0ZShvcHRpb25zKSxcbiAgICBkaXNtaXNzOiAoZGF0YSwgcm9sZSwgaWQpID0+IHRvYXN0Q29udHJvbGxlciQxLmRpc21pc3MoZGF0YSwgcm9sZSwgaWQpLFxuICAgIGdldFRvcDogKCkgPT4gdG9hc3RDb250cm9sbGVyJDEuZ2V0VG9wKCksXG59O1xuY29uc3QgSW9uVG9hc3QgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXJDb21wb25lbnQoJ2lvbi10b2FzdCcsIHRvYXN0Q29udHJvbGxlciwgSW9uVG9hc3QkMSk7XG5cbmNvbnN0IElvblBpY2tlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLXBpY2tlcicsIHBpY2tlckNvbnRyb2xsZXIsIElvblBpY2tlciQxKTtcblxuY29uc3QgY3JlYXRlT3ZlcmxheUNvbXBvbmVudCA9ICh0YWdOYW1lLCBjb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGRlZmluZUN1c3RvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZGFzaFRvUGFzY2FsQ2FzZSh0YWdOYW1lKTtcbiAgICBjb25zdCBkaWREaXNtaXNzRXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWREaXNtaXNzYDtcbiAgICBjb25zdCBkaWRQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWRQcmVzZW50YDtcbiAgICBjb25zdCB3aWxsRGlzbWlzc0V2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9V2lsbERpc21pc3NgO1xuICAgIGNvbnN0IHdpbGxQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1XaWxsUHJlc2VudGA7XG4gICAgY2xhc3MgT3ZlcmxheSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmlzRGlzbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc21pc3MgPSB0aGlzLmhhbmRsZURpc21pc3MuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdmVybGF5LmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBvdmVybGF5IGNvbXBvbmVudCBpcyBhYm91dCB0byBkaXNtaXNzXG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5ICYmIG5leHRQcm9wcy5pc09wZW4gIT09IHRoaXMucHJvcHMuaXNPcGVuICYmIG5leHRQcm9wcy5pc09wZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc21pc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaFByb3BzKHRoaXMub3ZlcmxheSwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudChwcmV2UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxheSAmJiBwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkuZGlzbWlzcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXNtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTm93IHRoYXQgdGhlIG92ZXJsYXkgaXMgZGlzbWlzc2VkXG4gICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byByZW5kZXIgYWdhaW4gc28gdGhhdCBhbnlcbiAgICAgICAgICAgICAgICAgKiBpbm5lciBjb21wb25lbnRzIHdpbGwgYmUgdW5tb3VudGVkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHByZXNlbnQocHJldlByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIGNQcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJpc09wZW5cIiwgXCJvbkRpZERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxEaXNtaXNzXCIsIFwib25XaWxsUHJlc2VudFwiXSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNQcm9wcyksIHsgcmVmOiB0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgW2RpZERpc21pc3NFdmVudE5hbWVdOiB0aGlzLmhhbmRsZURpc21pc3MsIFtkaWRQcmVzZW50RXZlbnROYW1lXTogKGUpID0+IHRoaXMucHJvcHMub25EaWRQcmVzZW50ICYmIHRoaXMucHJvcHMub25EaWRQcmVzZW50KGUpLCBbd2lsbERpc21pc3NFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzICYmIHRoaXMucHJvcHMub25XaWxsRGlzbWlzcyhlKSwgW3dpbGxQcmVzZW50RXZlbnROYW1lXTogKGUpID0+IHRoaXMucHJvcHMub25XaWxsUHJlc2VudCAmJiB0aGlzLnByb3BzLm9uV2lsbFByZXNlbnQoZSkgfSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnRQcm9wcyksIHsgY29tcG9uZW50OiB0aGlzLmVsLCBjb21wb25lbnRQcm9wczoge30gfSkpO1xuICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZm9yd2FyZGVkUmVmLCB0aGlzLm92ZXJsYXkpO1xuICAgICAgICAgICAgYXR0YWNoUHJvcHModGhpcy5vdmVybGF5LCBlbGVtZW50UHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkucHJlc2VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udGludWUgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQgZXZlbiB3aGVuXG4gICAgICAgICAgICAgKiBvdmVybGF5IGlzIGRpc21pc3Npbmcgb3RoZXJ3aXNlIGNvbXBvbmVudFxuICAgICAgICAgICAgICogd2lsbCBiZSBoaWRkZW4gYmVmb3JlIGFuaW1hdGlvbiBpcyBkb25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKHRoaXMucHJvcHMuaXNPcGVuIHx8IHRoaXMuaXNEaXNtaXNzaW5nID8gdGhpcy5wcm9wcy5jaGlsZHJlbiA6IG51bGwsIHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXksIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGFjdGlvblNoZWV0Q29udHJvbGxlciA9IHtcbiAgICBjcmVhdGU6IChvcHRpb25zKSA9PiBhY3Rpb25TaGVldENvbnRyb2xsZXIkMS5jcmVhdGUob3B0aW9ucyksXG4gICAgZGlzbWlzczogKGRhdGEsIHJvbGUsIGlkKSA9PiBhY3Rpb25TaGVldENvbnRyb2xsZXIkMS5kaXNtaXNzKGRhdGEsIHJvbGUsIGlkKSxcbiAgICBnZXRUb3A6ICgpID0+IGFjdGlvblNoZWV0Q29udHJvbGxlciQxLmdldFRvcCgpLFxufTtcbmNvbnN0IElvbkFjdGlvblNoZWV0ID0gLypAX19QVVJFX18qLyBjcmVhdGVPdmVybGF5Q29tcG9uZW50KCdpb24tYWN0aW9uLXNoZWV0JywgYWN0aW9uU2hlZXRDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDEzKTtcblxuY29uc3QgY3JlYXRlSW5saW5lT3ZlcmxheUNvbXBvbmVudCA9ICh0YWdOYW1lLCBkZWZpbmVDdXN0b21FbGVtZW50KSA9PiB7XG4gICAgaWYgKGRlZmluZUN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdG8gYXR0YWNoIHByb3BzIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAgICAgLy8gUmVhY3QgcmVmcyBtdXN0IGJlIHN0YWJsZSAobm90IGNyZWF0ZWQgaW5saW5lKS5cbiAgICAgICAgICAgIHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyA9IG1lcmdlUmVmcyh0aGlzLnJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgICAgICAgICAgLy8gQ29tcG9uZW50IGlzIGhpZGRlbiBieSBkZWZhdWx0XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0geyBpc09wZW46IGZhbHNlIH07XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCByZWYgdG8gdGhlIGlubmVyIGNoaWxkIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLndyYXBwZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTW91bnQgdGhlIGlubmVyIGNvbXBvbmVudFxuICAgICAgICAgICAgICogd2hlbiBvdmVybGF5IGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICAgICAgICAgKiBBbHNvIG1hbnVhbGx5IGNhbGwgdGhlIG9uV2lsbFByZXNlbnRcbiAgICAgICAgICAgICAqIGhhbmRsZXIgaWYgcHJlc2VudCBhcyBzZXRTdGF0ZSB3aWxsXG4gICAgICAgICAgICAgKiBjYXVzZSB0aGUgZXZlbnQgaGFuZGxlcnMgdG8gYmVcbiAgICAgICAgICAgICAqIGRlc3Ryb3llZCBhbmQgcmUtY3JlYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKF9hID0gdGhpcy5yZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ3dpbGxQcmVzZW50JywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50ICYmIHRoaXMucHJvcHMub25XaWxsUHJlc2VudChldnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVubW91bnQgdGhlIGlubmVyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAqIFJlYWN0IHdpbGwgY2FsbCBOb2RlLnJlbW92ZUNoaWxkXG4gICAgICAgICAgICAgKiB3aGljaCBleHBlY3RzIHRoZSBjaGlsZCB0byBiZVxuICAgICAgICAgICAgICogYSBkaXJlY3QgZGVzY2VuZGVudCBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgKiBidXQgZHVlIHRvIHRoZSBwcmVzZW5jZSBvZlxuICAgICAgICAgICAgICogV2ViIENvbXBvbmVudCBzbG90cywgdGhpcyBpcyBub3RcbiAgICAgICAgICAgICAqIGFsd2F5cyB0aGUgY2FzZS4gVG8gd29yayBhcm91bmQgdGhpc1xuICAgICAgICAgICAgICogd2UgbW92ZSB0aGUgaW5uZXIgY29tcG9uZW50IHRvIHRoZSByb290XG4gICAgICAgICAgICAgKiBvZiB0aGUgV2ViIENvbXBvbmVudCBzbyBSZWFjdCBjYW5cbiAgICAgICAgICAgICAqIGNsZWFudXAgcHJvcGVybHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIChfYiA9IHRoaXMucmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdkaWREaXNtaXNzJywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLndyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBjb21wb25lbnQgbWlnaHQgYmUgdW5tb3VudGVkIGFscmVhZHksIGlmIHRoZSBjb250YWluaW5nXG4gICAgICAgICAgICAgICAgICogZWxlbWVudCB3YXMgcmVtb3ZlZCB3aGlsZSB0aGUgcG9wb3ZlciB3YXMgc3RpbGwgb3Blbi4gKEZvclxuICAgICAgICAgICAgICAgICAqIGV4YW1wbGUsIGlmIGFuIGl0ZW0gY29udGFpbnMgYW4gaW5saW5lIHBvcG92ZXIgd2l0aCBhIGJ1dHRvblxuICAgICAgICAgICAgICAgICAqIHRoYXQgcmVtb3ZlcyB0aGUgaXRlbS4pXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRpZERpc21pc3MgJiYgdGhpcy5wcm9wcy5vbkRpZERpc21pc3MoZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZi5jdXJyZW50O1xuICAgICAgICAgICAgYXR0YWNoUHJvcHMobm9kZSwgdGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2hpbGRyZW4sIGZvcndhcmRlZFJlZiwgc3R5bGUsIGNsYXNzTmFtZSwgcmVmIH0gPSBfYSwgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImZvcndhcmRlZFJlZlwiLCBcInN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVmXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9QYXNzID0gT2JqZWN0LmtleXMoY1Byb3BzKS5yZWR1Y2UoKGFjYywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbmFtZVsyXSA9PT0gbmFtZVsyXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvdmVyZWRCeVJlYWN0KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChbJ3N0cmluZycsICdib29sZWFuJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiBjUHJvcHNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1tjYW1lbFRvRGFzaENhc2UobmFtZSldID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzVG9QYXNzKSwgeyByZWY6IHRoaXMuc3RhYmxlTWVyZ2VkUmVmcywgc3R5bGUgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIG9ubHkgd2FudCB0aGUgaW5uZXIgY29tcG9uZW50XG4gICAgICAgICAgICAgKiB0byBiZSBtb3VudGVkIGlmIHRoZSBvdmVybGF5IGlzIG9wZW4sXG4gICAgICAgICAgICAgKiBzbyBjb25kaXRpb25hbGx5IHJlbmRlciB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAgKiBiYXNlZCBvbiB0aGUgaXNPcGVuIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBuZXdQcm9wcywgKHRoaXMuc3RhdGUuaXNPcGVuKSA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lvbi1yZWFjdC13cmFwcGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0aGlzLndyYXBwZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbikgOlxuICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVGb3J3YXJkUmVmKFJlYWN0Q29tcG9uZW50LCBkaXNwbGF5TmFtZSk7XG59O1xuXG5jb25zdCBJb25Nb2RhbCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlSW5saW5lT3ZlcmxheUNvbXBvbmVudCgnaW9uLW1vZGFsJywgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNCk7XG5cbmNvbnN0IElvblBvcG92ZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUlubGluZU92ZXJsYXlDb21wb25lbnQoJ2lvbi1wb3BvdmVyJywgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNSk7XG5cbmNvbnN0IElvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhZGRPdmVybGF5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIHJlbW92ZU92ZXJsYXk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG59KTtcblxuLyoqXG4gKiBNYW5hZ2VzIG92ZXJsYXlzIHRoYXQgYXJlIGFkZGVkIHZpYSB0aGUgdXNlT3ZlcmxheSBob29rLlxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgY29tcG9uZW50IHNvIGNoYW5nZXMgdG8gaXRzIGNoaWxkcmVuIGRvbid0IGNhdXNlIG90aGVyIGRlc2NlbmRhbnRcbiAqIGNvbXBvbmVudHMgdG8gcmUtcmVuZGVyIHdoZW4gb3ZlcmxheXMgYXJlIGFkZGVkLiBIb3dldmVyLCB3ZSBuZWVkIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIElvbkNvbnRleHRcbiAqIHRoYXQgaXMgc2V0IHVwIGluIDxJb25BcHAgLz4sIHNvIHdlIHJlZ2lzdGVyIGNhbGxiYWNrcyBzbyB3aGVuIG92ZXJsYXlzIGFyZSBhZGRlZCB0byBJb25Db250ZXh0LFxuICogdGhleSB1bHRpbWF0ZWx5IGFkZGVkIGhlcmUuXG4gKi9cbmNvbnN0IElvbk92ZXJsYXlNYW5hZ2VyID0gKHsgb25BZGRPdmVybGF5LCBvblJlbW92ZU92ZXJsYXksIH0pID0+IHtcbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSB3YXkgd2UncmUgcGFzc2luZyBhcm91bmQgdGhlIGFkZE92ZXJsYXkgYW5kIHJlbW92ZU92ZXJsYXlcbiAgICAgKiBjYWxsYmFja3MsIGJ5IHRoZSB0aW1lIHRoZXkgZmluYWxseSBnZXQgY2FsbGVkLCB0aGV5IHVzZSBhIHN0YWxlIHJlZmVyZW5jZVxuICAgICAqIHRvIHRoZSBzdGF0ZSB0aGF0IG9ubHkgaGFzIHRoZSBpbml0aWFsIHZhbHVlcy4gU28gaWYgdHdvIG92ZXJsYXlzIGFyZSBvcGVuZWRcbiAgICAgKiBhdCB0aGUgc2FtZSB0aW1lLCBib3RoIHVzaW5nIHVzZUlvbk1vZGFsIG9yIHNpbWlsYXIgKHN1Y2ggYXMgdGhyb3VnaCBuZXN0aW5nKSxcbiAgICAgKiB0aGUgc2Vjb25kIHdpbGwgZXJhc2UgdGhlIGZpcnN0IGZyb20gdGhlIG92ZXJsYXlzIGxpc3QuIFRoaXMgY2F1c2VzIHRoZSBjb250ZW50XG4gICAgICogb2YgdGhlIGZpcnN0IG92ZXJsYXkgdG8gdW5tb3VudC5cbiAgICAgKlxuICAgICAqIFdlIHdyYXAgdGhlIHN0YXRlIGluIHVzZVJlZiB0byBlbnN1cmUgdGhlIHR3byBjYWxsYmFja3MgYWx3YXlzIHVzZSB0aGUgbW9zdFxuICAgICAqIHVwLXRvLWRhdGUgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEZ1cnRoZXIgcmVhZGluZzogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU2NTU0MDU2XG4gICAgICovXG4gICAgY29uc3QgW292ZXJsYXlzLCBzZXRPdmVybGF5c10gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3Qgb3ZlcmxheXNSZWYgPSB1c2VSZWYoe30pO1xuICAgIG92ZXJsYXlzUmVmLmN1cnJlbnQgPSBvdmVybGF5cztcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvKiBTZXR1cCB0aGUgY2FsbGJhY2tzIHRoYXQgZ2V0IGNhbGxlZCBmcm9tIDxJb25BcHAgLz4gKi9cbiAgICAgICAgb25BZGRPdmVybGF5KGFkZE92ZXJsYXkpO1xuICAgICAgICBvblJlbW92ZU92ZXJsYXkocmVtb3ZlT3ZlcmxheSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFkZE92ZXJsYXkgPSAoaWQsIGNvbXBvbmVudCwgY29udGFpbmVyRWxlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdPdmVybGF5cyA9IE9iamVjdC5hc3NpZ24oe30sIG92ZXJsYXlzUmVmLmN1cnJlbnQpO1xuICAgICAgICBuZXdPdmVybGF5c1tpZF0gPSB7IGNvbXBvbmVudCwgY29udGFpbmVyRWxlbWVudCB9O1xuICAgICAgICBzZXRPdmVybGF5cyhuZXdPdmVybGF5cyk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVPdmVybGF5ID0gKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld092ZXJsYXlzID0gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcmxheXNSZWYuY3VycmVudCk7XG4gICAgICAgIGRlbGV0ZSBuZXdPdmVybGF5c1tpZF07XG4gICAgICAgIHNldE92ZXJsYXlzKG5ld092ZXJsYXlzKTtcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJsYXlLZXlzID0gT2JqZWN0LmtleXMob3ZlcmxheXMpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgb3ZlcmxheUtleXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IG92ZXJsYXlzW2tleV07XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwob3ZlcmxheS5jb21wb25lbnQsIG92ZXJsYXkuY29udGFpbmVyRWxlbWVudCwgYG92ZXJsYXktJHtrZXl9YCk7XG4gICAgfSkpKTtcbn07XG5cbmNvbnN0IElvblRhYkJ1dHRvbklubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRhYi1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNik7XG5jb25zdCBJb25UYWJCYXJJbm5lciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10YWItYmFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTcpO1xuY29uc3QgSW9uQmFja0J1dHRvbklubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJhY2stYnV0dG9uJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTgpO1xuY29uc3QgSW9uUm91dGVyT3V0bGV0SW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcm91dGVyLW91dGxldCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDE5KTtcbmNvbnN0IElvbkFwcElubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWFwcCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDFhKTtcbi8vIGlvbmljb25zXG5jb25zdCBJb25JY29uSW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taWNvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDFiKTtcblxuY29uc3QgSW9uQXBwID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgLypcbiAgICAgICAgICBXaXJlIHVwIG1ldGhvZHMgdG8gY2FsbCBpbnRvIElvbk92ZXJsYXlNYW5hZ2VyXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW9uQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGFkZE92ZXJsYXk6IChpZCwgb3ZlcmxheSwgY29udGFpbmVyRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFkZE92ZXJsYXlDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE92ZXJsYXlDYWxsYmFjayhpZCwgb3ZlcmxheSwgY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZU92ZXJsYXk6IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZU92ZXJsYXlDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXlDYWxsYmFjayhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5pb25Db250ZXh0IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvbkFwcElubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSwgdGhpcy5wcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvbk92ZXJsYXlNYW5hZ2VyLCB7IG9uQWRkT3ZlcmxheTogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxheUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgfSwgb25SZW1vdmVPdmVybGF5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9IH0pKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uQXBwJztcbiAgICB9XG59KSgpO1xuXG5jb25zdCBTdGFja0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICByZWdpc3RlcklvblBhZ2U6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBpc0luT3V0bGV0OiAoKSA9PiBmYWxzZSxcbn0pO1xuXG5jbGFzcyBQYWdlTWFuYWdlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICAvLyBSZWFjdCByZWZzIG11c3QgYmUgc3RhYmxlIChub3QgY3JlYXRlZCBpbmxpbmUpLlxuICAgICAgICB0aGlzLnN0YWJsZU1lcmdlZFJlZnMgPSBtZXJnZVJlZnModGhpcy5pb25QYWdlRWxlbWVudFJlZiwgdGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pc0luT3V0bGV0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQuY2xhc3NMaXN0LmFkZCgnaW9uLXBhZ2UtaW52aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJb25QYWdlKHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5yb3V0ZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsRW50ZXInLCB0aGlzLmlvblZpZXdXaWxsRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRFbnRlcicsIHRoaXMuaW9uVmlld0RpZEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkTGVhdmUnLCB0aGlzLmlvblZpZXdEaWRMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbEVudGVyJywgdGhpcy5pb25WaWV3V2lsbEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkRW50ZXInLCB0aGlzLmlvblZpZXdEaWRFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxMZWF2ZScsIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZExlYXZlJywgdGhpcy5pb25WaWV3RGlkTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlvblZpZXdXaWxsRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxFbnRlcigpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZEVudGVyKCk7XG4gICAgfVxuICAgIGlvblZpZXdXaWxsTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxMZWF2ZSgpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZExlYXZlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNsYXNzTmFtZSwgY2hpbGRyZW4sIHJvdXRlSW5mbywgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwicm91dGVJbmZvXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvbkxpZmVDeWNsZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0gaW9uLXBhZ2VgIDogYGlvbi1wYWdlYCwgcmVmOiB0aGlzLnN0YWJsZU1lcmdlZFJlZnMgfSwgcHJvcHMpLCBjaGlsZHJlbikpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTdGFja0NvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25QYWdlSW50ZXJuYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZU1hbmFnZXIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX1gIDogJycsIHJvdXRlSW5mbzogdGhpcy5jb250ZXh0LnJvdXRlSW5mbywgZm9yd2FyZGVkUmVmOiBmb3J3YXJkZWRSZWYgfSwgcHJvcHMpLCBjaGlsZHJlbikpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYGlvbi1wYWdlICR7Y2xhc3NOYW1lfWAgOiAnaW9uLXBhZ2UnLCByZWY6IGZvcndhcmRlZFJlZiB9LCBwcm9wcyksIGNoaWxkcmVuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uUGFnZSc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cbmNvbnN0IElvblBhZ2UgPSBjcmVhdGVGb3J3YXJkUmVmKElvblBhZ2VJbnRlcm5hbCwgJ0lvblBhZ2UnKTtcblxuY29uc3QgSW9uVGFic0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhY3RpdmVUYWI6IHVuZGVmaW5lZCxcbiAgICBzZWxlY3RUYWI6ICgpID0+IGZhbHNlLFxufSk7XG5cbmNvbnN0IEhUTUxFbGVtZW50U1NSID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IEhUTUxFbGVtZW50XG4gICAgOiBjbGFzcyB7XG4gICAgfSk7XG5cbmNsYXNzIE91dGxldFBhZ2VNYW5hZ2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5pb25Sb3V0ZXJPdXRsZXQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkodGhpcy5pb25Sb3V0ZXJPdXRsZXQsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJb25QYWdlKHRoaXMuaW9uUm91dGVyT3V0bGV0LCB0aGlzLnByb3BzLnJvdXRlSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsRW50ZXInLCB0aGlzLmlvblZpZXdXaWxsRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZEVudGVyJywgdGhpcy5pb25WaWV3RGlkRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxMZWF2ZScsIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkTGVhdmUnLCB0aGlzLmlvblZpZXdEaWRMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlvblJvdXRlck91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxFbnRlcicsIHRoaXMuaW9uVmlld1dpbGxFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkRW50ZXInLCB0aGlzLmlvblZpZXdEaWRFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRMZWF2ZScsIHRoaXMuaW9uVmlld0RpZExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3V2lsbEVudGVySGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdXaWxsRW50ZXIoKTtcbiAgICB9XG4gICAgaW9uVmlld0RpZEVudGVySGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdEaWRFbnRlcigpO1xuICAgIH1cbiAgICBpb25WaWV3V2lsbExlYXZlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdXaWxsTGVhdmUoKTtcbiAgICB9XG4gICAgaW9uVmlld0RpZExlYXZlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0LmlvblZpZXdEaWRMZWF2ZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBTdGFja01hbmFnZXIsIGNoaWxkcmVuLCByb3V0ZUluZm8gfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiU3RhY2tNYW5hZ2VyXCIsIFwiY2hpbGRyZW5cIiwgXCJyb3V0ZUluZm9cIl0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uTGlmZUN5Y2xlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhY2tNYW5hZ2VyLCB7IHJvdXRlSW5mbzogcm91dGVJbmZvIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJb25Sb3V0ZXJPdXRsZXRJbm5lciwgT2JqZWN0LmFzc2lnbih7IHNldFJlZjogKHZhbCkgPT4gKHRoaXMuaW9uUm91dGVyT3V0bGV0ID0gdmFsKSB9LCBwcm9wcyksIGNoaWxkcmVuKSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTdGFja0NvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25Sb3V0ZXJPdXRsZXRDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBTdGFja01hbmFnZXIgPSB0aGlzLmNvbnRleHQuZ2V0U3RhY2tNYW5hZ2VyKCk7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCJdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpID8gKHByb3BzLmlvblBhZ2UgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsZXRQYWdlTWFuYWdlciwgT2JqZWN0LmFzc2lnbih7IFN0YWNrTWFuYWdlcjogU3RhY2tNYW5hZ2VyLCByb3V0ZUluZm86IHRoaXMuY29udGV4dC5yb3V0ZUluZm8gfSwgcHJvcHMpLCBjaGlsZHJlbikpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhY2tNYW5hZ2VyLCB7IHJvdXRlSW5mbzogdGhpcy5jb250ZXh0LnJvdXRlSW5mbyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJb25Sb3V0ZXJPdXRsZXRJbm5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiBmb3J3YXJkZWRSZWYgfSksIGNoaWxkcmVuKSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlck91dGxldElubmVyLCBPYmplY3QuYXNzaWduKHsgcmVmOiBmb3J3YXJkZWRSZWYgfSwgdGhpcy5wcm9wcyksIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuY29uc3QgSW9uUm91dGVyT3V0bGV0ID0gY3JlYXRlRm9yd2FyZFJlZihJb25Sb3V0ZXJPdXRsZXRDb250YWluZXIsICdJb25Sb3V0ZXJPdXRsZXQnKTtcblxuY29uc3QgSW9uVGFiQnV0dG9uID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVJb25UYWJCdXR0b25DbGljayA9IHRoaXMuaGFuZGxlSW9uVGFiQnV0dG9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlSW9uVGFiQnV0dG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DbGljayhuZXcgQ3VzdG9tRXZlbnQoJ2lvblRhYkJ1dHRvbkNsaWNrJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICB0YWI6IHRoaXMucHJvcHMudGFiLFxuICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLnByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlT3B0aW9uczogdGhpcy5wcm9wcy5yb3V0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm9uQ2xpY2tcIl0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uVGFiQnV0dG9uSW5uZXIsIE9iamVjdC5hc3NpZ24oeyBvbklvblRhYkJ1dHRvbkNsaWNrOiB0aGlzLmhhbmRsZUlvblRhYkJ1dHRvbkNsaWNrIH0sIHJlc3QpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnSW9uVGFiQnV0dG9uJztcbiAgICB9XG59KSgpO1xuXG5jbGFzcyBJb25UYWJCYXJVbndyYXBwZWQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gKF90YWIpID0+IHsgfTtcbiAgICAgICAgY29uc3QgdGFicyA9IHt9O1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkLnR5cGUgPT09IElvblRhYkJ1dHRvbiB8fCBjaGlsZC50eXBlLmlzVGFiQnV0dG9uKSkge1xuICAgICAgICAgICAgICAgIHRhYnNbY2hpbGQucHJvcHMudGFiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiBjaGlsZC5wcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogY2hpbGQucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSb3V0ZU9wdGlvbnM6IGNoaWxkLnByb3BzLmhyZWYgPT09ICgoX2EgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9iID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm91dGVPcHRpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5ocmVmID09PSAoKF9jID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGF0aG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChfZCA9IHByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJvdXRlT3B0aW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRhYnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25UYWJCdXR0b25DbGljayA9IHRoaXMub25UYWJCdXR0b25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlclRhYkJ1dHRvbiA9IHRoaXMucmVuZGVyVGFiQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gdGhpcy5zZXRBY3RpdmVUYWJPbkNvbnRleHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWxlY3RUYWIgPSB0aGlzLnNlbGVjdFRhYi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMuc3RhdGUudGFicztcbiAgICAgICAgY29uc3QgdGFiS2V5cyA9IE9iamVjdC5rZXlzKHRhYnMpO1xuICAgICAgICBjb25zdCBhY3RpdmVUYWIgPSB0YWJLZXlzLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHRhYnNba2V5XS5vcmlnaW5hbEhyZWY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5yb3V0ZUluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aChocmVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRhYixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYk9uQ29udGV4dCh0aGlzLnN0YXRlLmFjdGl2ZVRhYik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0VGFiKHRhYikge1xuICAgICAgICBjb25zdCB0YWJVcmwgPSB0aGlzLnN0YXRlLnRhYnNbdGFiXTtcbiAgICAgICAgaWYgKHRhYlVybCkge1xuICAgICAgICAgICAgdGhpcy5vblRhYkJ1dHRvbkNsaWNrKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiQnV0dG9uQ2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHRhYlVybC5jdXJyZW50SHJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFiLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogdGFiID09PSB0aGlzLnN0YXRlLmFjdGl2ZVRhYixcbiAgICAgICAgICAgICAgICAgICAgcm91dGVPcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRhYnMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS50YWJzKTtcbiAgICAgICAgY29uc3QgdGFiS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlLnRhYnMpO1xuICAgICAgICBjb25zdCBhY3RpdmVUYWIgPSB0YWJLZXlzLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHJlZiA9IHN0YXRlLnRhYnNba2V5XS5vcmlnaW5hbEhyZWY7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMucm91dGVJbmZvLnBhdGhuYW1lLnN0YXJ0c1dpdGgoaHJlZik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHRhYiBidXR0b24gaHJlZiBoYXMgY2hhbmdlZCwgYW5kIGlmIHNvLCB1cGRhdGUgaXQgaW4gdGhlIHRhYnMgc3RhdGVcbiAgICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgICAgICAgIChjaGlsZC50eXBlID09PSBJb25UYWJCdXR0b24gfHwgY2hpbGQudHlwZS5pc1RhYkJ1dHRvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWIgPSB0YWJzW2NoaWxkLnByb3BzLnRhYl07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWIgfHwgdGFiLm9yaWdpbmFsSHJlZiAhPT0gY2hpbGQucHJvcHMuaHJlZikge1xuICAgICAgICAgICAgICAgICAgICB0YWJzW2NoaWxkLnByb3BzLnRhYl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhyZWY6IGNoaWxkLnByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogY2hpbGQucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUm91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiBjaGlsZC5wcm9wcy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBhY3RpdmVUYWI6IHByZXZBY3RpdmVUYWIgfSA9IHN0YXRlO1xuICAgICAgICBpZiAoYWN0aXZlVGFiICYmIHByZXZBY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZIcmVmID0gc3RhdGUudGFic1twcmV2QWN0aXZlVGFiXS5jdXJyZW50SHJlZjtcbiAgICAgICAgICAgIGNvbnN0IHByZXZSb3V0ZU9wdGlvbnMgPSBzdGF0ZS50YWJzW3ByZXZBY3RpdmVUYWJdLmN1cnJlbnRSb3V0ZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFiICE9PSBwcmV2QWN0aXZlVGFiIHx8XG4gICAgICAgICAgICAgICAgcHJldkhyZWYgIT09ICgoX2EgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBwcmV2Um91dGVPcHRpb25zICE9PSAoKF9iID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm91dGVPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRhYnNbYWN0aXZlVGFiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiB0YWJzW2FjdGl2ZVRhYl0ub3JpZ2luYWxIcmVmLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SHJlZjogcHJvcHMucm91dGVJbmZvLnBhdGhuYW1lICsgKHByb3BzLnJvdXRlSW5mby5zZWFyY2ggfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJvdXRlT3B0aW9uczogdGFic1thY3RpdmVUYWJdLm9yaWdpbmFsUm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiAoX2MgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMucm91dGVJbmZvLnJvdXRlQWN0aW9uID09PSAncG9wJyAmJiBhY3RpdmVUYWIgIT09IHByZXZBY3RpdmVUYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmF2aWdhdGluZyBiYWNrIGFuZCB0aGUgdGFicyBjaGFuZ2UsIHNldCB0aGUgcHJldiB0YWIgYmFjayB0byBpdHMgb3JpZ2luYWwgaHJlZlxuICAgICAgICAgICAgICAgICAgICB0YWJzW3ByZXZBY3RpdmVUYWJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIcmVmOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIcmVmOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUm91dGVPcHRpb25zOiB0YWJzW3ByZXZBY3RpdmVUYWJdLm9yaWdpbmFsUm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlT3B0aW9uczogdGFic1twcmV2QWN0aXZlVGFiXS5jdXJyZW50Um91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVUYWIgJiYgcHJvcHMub25TZXRDdXJyZW50VGFiKGFjdGl2ZVRhYiwgcHJvcHMucm91dGVJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZVRhYixcbiAgICAgICAgICAgIHRhYnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uVGFiQnV0dG9uQ2xpY2soZSkge1xuICAgICAgICBjb25zdCB0YXBwZWRUYWIgPSB0aGlzLnN0YXRlLnRhYnNbZS5kZXRhaWwudGFiXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxIcmVmID0gdGFwcGVkVGFiLm9yaWdpbmFsSHJlZjtcbiAgICAgICAgY29uc3QgY3VycmVudEhyZWYgPSBlLmRldGFpbC5ocmVmO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZVRhYjogcHJldkFjdGl2ZVRhYiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgLy8gdGhpcy5wcm9wcy5vblNldEN1cnJlbnRUYWIoZS5kZXRhaWwudGFiLCB0aGlzLnByb3BzLnJvdXRlSW5mbyk7XG4gICAgICAgIC8vIENsaWNraW5nIHRoZSBjdXJyZW50IHRhYiB3aWxsIGJyaW5nIHlvdSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBocmVmXG4gICAgICAgIGlmIChwcmV2QWN0aXZlVGFiID09PSBlLmRldGFpbC50YWIpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEhyZWYgIT09IGN1cnJlbnRIcmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc2V0VGFiKGUuZGV0YWlsLnRhYiwgb3JpZ2luYWxIcmVmLCB0YXBwZWRUYWIub3JpZ2luYWxSb3V0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Jb25UYWJzV2lsbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Jb25UYWJzV2lsbENoYW5nZShuZXcgQ3VzdG9tRXZlbnQoJ2lvblRhYldpbGxDaGFuZ2UnLCB7IGRldGFpbDogeyB0YWI6IGUuZGV0YWlsLnRhYiB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW9uVGFic0RpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Jb25UYWJzRGlkQ2hhbmdlKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiRGlkQ2hhbmdlJywgeyBkZXRhaWw6IHsgdGFiOiBlLmRldGFpbC50YWIgfSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYk9uQ29udGV4dChlLmRldGFpbC50YWIpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNoYW5nZVRhYihlLmRldGFpbC50YWIsIGN1cnJlbnRIcmVmLCBlLmRldGFpbC5yb3V0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclRhYkJ1dHRvbihhY3RpdmVUYWIpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoY2hpbGQudHlwZSA9PT0gSW9uVGFiQnV0dG9uIHx8IGNoaWxkLnR5cGUuaXNUYWJCdXR0b24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNoaWxkLnByb3BzLnRhYiA9PT0gYWN0aXZlVGFiXG4gICAgICAgICAgICAgICAgICAgID8gKF9hID0gdGhpcy5wcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRobmFtZSA6IHRoaXMuc3RhdGUudGFic1tjaGlsZC5wcm9wcy50YWJdLmN1cnJlbnRIcmVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlT3B0aW9ucyA9IGNoaWxkLnByb3BzLnRhYiA9PT0gYWN0aXZlVGFiXG4gICAgICAgICAgICAgICAgICAgID8gKF9iID0gdGhpcy5wcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yb3V0ZU9wdGlvbnMgOiB0aGlzLnN0YXRlLnRhYnNbY2hpbGQucHJvcHMudGFiXS5jdXJyZW50Um91dGVPcHRpb25zO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcm91dGVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLm9uVGFiQnV0dG9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGFjdGl2ZVRhYiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvblRhYkJhcklubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHNlbGVjdGVkVGFiOiBhY3RpdmVUYWIgfSksIFJlYWN0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLnJlbmRlclRhYkJ1dHRvbihhY3RpdmVUYWIpKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59XG5jb25zdCBJb25UYWJCYXJDb250YWluZXIgPSBSZWFjdC5tZW1vKChfYSkgPT4ge1xuICAgIHZhciB7IGZvcndhcmRlZFJlZiB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5hdkNvbnRleHQpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25UYWJCYXJVbndyYXBwZWQsIE9iamVjdC5hc3NpZ24oeyByZWY6IGZvcndhcmRlZFJlZiB9LCBwcm9wcywgeyByb3V0ZUluZm86IHByb3BzLnJvdXRlSW5mbyB8fCBjb250ZXh0LnJvdXRlSW5mbyB8fCB7IHBhdGhuYW1lOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgfSwgb25TZXRDdXJyZW50VGFiOiBjb250ZXh0LnNldEN1cnJlbnRUYWIgfSksIHByb3BzLmNoaWxkcmVuKSk7XG59KTtcbmNvbnN0IElvblRhYkJhciA9IGNyZWF0ZUZvcndhcmRSZWYoSW9uVGFiQmFyQ29udGFpbmVyLCAnSW9uVGFiQmFyJyk7XG5cbmNsYXNzIElvblRhYnNFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnRTU1Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3VzdG9tRWxlbWVudHMpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldCgnaW9uLXRhYnMnKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnaW9uLXRhYnMnLCBJb25UYWJzRWxlbWVudCk7XG4gICAgfVxufVxuY29uc3QgaG9zdFN0eWxlcyA9IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnMCcsXG4gICAgbGVmdDogJzAnLFxuICAgIHJpZ2h0OiAnMCcsXG4gICAgYm90dG9tOiAnMCcsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBjb250YWluOiAnbGF5b3V0IHNpemUgc3R5bGUnLFxufTtcbmNvbnN0IHRhYnNJbm5lciA9IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBmbGV4OiAxLFxuICAgIGNvbnRhaW46ICdsYXlvdXQgc2l6ZSBzdHlsZScsXG59O1xuY29uc3QgSW9uVGFicyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMucm91dGVyT3V0bGV0UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMudGFiQmFyUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlID0ge1xuICAgICAgICAgICAgYWN0aXZlVGFiOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3RUYWI6ICgpID0+IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFiQmFyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIEdyYWIgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5pb25UYWJDb250ZXh0U3RhdGUuYWN0aXZlVGFiID0gdGhpcy50YWJCYXJSZWYuY3VycmVudC5zdGF0ZS5hY3RpdmVUYWI7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSBtZXRob2RcbiAgICAgICAgICAgIHRoaXMudGFiQmFyUmVmLmN1cnJlbnQuc2V0QWN0aXZlVGFiT25Db250ZXh0ID0gKHRhYikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlLmFjdGl2ZVRhYiA9IHRhYjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlvblRhYkNvbnRleHRTdGF0ZS5zZWxlY3RUYWIgPSB0aGlzLnRhYkJhclJlZi5jdXJyZW50LnNlbGVjdFRhYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCBvdXRsZXQ7XG4gICAgICAgIGxldCB0YWJCYXI7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjbGFzc05hbWUsIG9uSW9uVGFic0RpZENoYW5nZSwgb25Jb25UYWJzV2lsbENoYW5nZSB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJvbklvblRhYnNEaWRDaGFuZ2VcIiwgXCJvbklvblRhYnNXaWxsQ2hhbmdlXCJdKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlb2YgdGhpcy5wcm9wcy5jaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlKVxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgIWNoaWxkLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gSW9uUm91dGVyT3V0bGV0IHx8IGNoaWxkLnR5cGUuaXNSb3V0ZXJPdXRsZXQpIHtcbiAgICAgICAgICAgICAgICBvdXRsZXQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiYgY2hpbGQucHJvcHMuY2hpbGRyZW5bMF0udHlwZSA9PT0gSW9uUm91dGVyT3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgb3V0bGV0ID0gY2hpbGQucHJvcHMuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGRQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMudGFiQmFyUmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPbmx5IHBhc3MgdGhlc2UgcHJvcHNcbiAgICAgICAgICAgICAqIGRvd24gZnJvbSBJb25UYWJzIHRvIElvblRhYkJhclxuICAgICAgICAgICAgICogaWYgdGhleSBhcmUgZGVmaW5lZCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgKiBpZiB5b3UgaGF2ZSBhIGhhbmRsZXIgc2V0IG9uXG4gICAgICAgICAgICAgKiBJb25UYWJCYXIgaXQgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob25Jb25UYWJzRGlkQ2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGlsZFByb3BzKSwgeyBvbklvblRhYnNEaWRDaGFuZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Jb25UYWJzV2lsbENoYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hpbGRQcm9wcyksIHsgb25Jb25UYWJzV2lsbENoYW5nZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBJb25UYWJCYXIgfHwgY2hpbGQudHlwZS5pc1RhYkJhcikge1xuICAgICAgICAgICAgICAgIHRhYkJhciA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxuICAgICAgICAgICAgICAgIChjaGlsZC5wcm9wcy5jaGlsZHJlblsxXS50eXBlID09PSBJb25UYWJCYXIgfHwgY2hpbGQucHJvcHMuY2hpbGRyZW5bMV0udHlwZS5pc1RhYkJhcikpIHtcbiAgICAgICAgICAgICAgICB0YWJCYXIgPSBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQucHJvcHMuY2hpbGRyZW5bMV0sIGNoaWxkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvdXRsZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW9uVGFicyBtdXN0IGNvbnRhaW4gYW4gSW9uUm91dGVyT3V0bGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YWJCYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW9uVGFicyBuZWVkcyBhIElvblRhYkJhcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25UYWJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5pb25UYWJDb250ZXh0U3RhdGUgfSwgdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlTWFuYWdlciwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfWAgOiAnJywgcm91dGVJbmZvOiB0aGlzLmNvbnRleHQucm91dGVJbmZvIH0sIHByb3BzKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpb24tdGFic1wiLCB7IGNsYXNzTmFtZTogXCJpb24tdGFic1wiLCBzdHlsZTogaG9zdFN0eWxlcyB9LFxuICAgICAgICAgICAgICAgIHRhYkJhci5wcm9wcy5zbG90ID09PSAndG9wJyA/IHRhYkJhciA6IG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB0YWJzSW5uZXIsIGNsYXNzTmFtZTogXCJ0YWJzLWlubmVyXCIgfSwgb3V0bGV0KSxcbiAgICAgICAgICAgICAgICB0YWJCYXIucHJvcHMuc2xvdCA9PT0gJ2JvdHRvbScgPyB0YWJCYXIgOiBudWxsKSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfWAgOiAnaW9uLXRhYnMnIH0sIHByb3BzLCB7IHN0eWxlOiBob3N0U3R5bGVzIH0pLFxuICAgICAgICAgICAgdGFiQmFyLnByb3BzLnNsb3QgPT09ICd0b3AnID8gdGFiQmFyIDogbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogdGFic0lubmVyLCBjbGFzc05hbWU6IFwidGFicy1pbm5lclwiIH0sIG91dGxldCksXG4gICAgICAgICAgICB0YWJCYXIucHJvcHMuc2xvdCA9PT0gJ2JvdHRvbScgPyB0YWJCYXIgOiBudWxsKSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufSkoKTtcblxuY29uc3QgSW9uQmFja0J1dHRvbiA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jbGlja0J1dHRvbiA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRlZmF1bHRIcmVmLCByb3V0ZXJBbmltYXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nb0JhY2soZGVmYXVsdEhyZWYsIHJvdXRlckFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWZhdWx0SHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZWZhdWx0SHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJb25CYWNrQnV0dG9uSW5uZXIsIE9iamVjdC5hc3NpZ24oeyBvbkNsaWNrOiB0aGlzLmNsaWNrQnV0dG9uIH0sIHRoaXMucHJvcHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdJb25CYWNrQnV0dG9uJztcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufSkoKTtcblxuY2xhc3MgSW9uSWNvbkNvbnRhaW5lciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbiBJb25pYyBSZWFjdCwgeW91IGltcG9ydCBpY29ucyBmcm9tIFwiaW9uaWNvbnMvaWNvbnNcIiBhbmQgc2V0IHRoZSBpY29uIHlvdSBpbXBvcnRlZCB0byB0aGUgXCJpY29uXCIgcHJvcGVydHkuIFNldHRpbmcgdGhlIFwibmFtZVwiIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBfYyA9IHRoaXMucHJvcHMsIHsgaWNvbiwgaW9zLCBtZCB9ID0gX2MsIHJlc3QgPSBfX3Jlc3QoX2MsIFtcImljb25cIiwgXCJpb3NcIiwgXCJtZFwiXSk7XG4gICAgICAgIGxldCBpY29uVG9Vc2U7XG4gICAgICAgIGlmIChpb3MgfHwgbWQpIHtcbiAgICAgICAgICAgIGlmIChpc1BsYXRmb3JtKCdpb3MnKSkge1xuICAgICAgICAgICAgICAgIGljb25Ub1VzZSA9IChfYSA9IGlvcyAhPT0gbnVsbCAmJiBpb3MgIT09IHZvaWQgMCA/IGlvcyA6IG1kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWNvblRvVXNlID0gKF9iID0gbWQgIT09IG51bGwgJiYgbWQgIT09IHZvaWQgMCA/IG1kIDogaW9zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWNvblRvVXNlID0gaWNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uSWNvbklubmVyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgaWNvbjogaWNvblRvVXNlIH0sIHJlc3QpLCB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cbmNvbnN0IElvbkljb24gPSBjcmVhdGVGb3J3YXJkUmVmKElvbkljb25Db250YWluZXIsICdJb25JY29uJyk7XG5cbmNsYXNzIElvblJvdXRlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBJb25Sb3V0ZUlubmVyID0gdGhpcy5jb250ZXh0LmdldElvblJvdXRlKCk7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgfHwgIUlvblJvdXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgZWl0aGVyIGRvIG5vdCBoYXZlIGFuIElvbmljIFJvdXRlciBwYWNrYWdlLCBvciB5b3VyIHJvdXRlciBkb2VzIG5vdCBzdXBwb3J0IHVzaW5nIDxJb25Sb3V0ZT4nKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlSW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuXG5jbGFzcyBJb25SZWRpcmVjdCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgSW9uUmVkaXJlY3RJbm5lciA9IHRoaXMuY29udGV4dC5nZXRJb25SZWRpcmVjdCgpO1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5oYXNJb25pY1JvdXRlcigpIHx8ICFJb25SZWRpcmVjdCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IGVpdGhlciBkbyBub3QgaGF2ZSBhbiBJb25pYyBSb3V0ZXIgcGFja2FnZSwgb3IgeW91ciByb3V0ZXIgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyA8SW9uUmVkaXJlY3Q+Jyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJb25SZWRpcmVjdElubmVyLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cblxuY29uc3QgSW9uUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIHJvdXRlSW5mbzogdW5kZWZpbmVkLFxuICAgIHB1c2g6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJb25pYyBSb3V0ZXIgaXMgcmVxdWlyZWQgZm9yIElvblJvdXRlckNvbnRleHQnKTtcbiAgICB9LFxuICAgIGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJb25pYyBSb3V0ZXIgaXMgcmVxdWlyZWQgZm9yIElvblJvdXRlckNvbnRleHQnKTtcbiAgICB9LFxuICAgIGNhbkdvQmFjazogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG4gICAgbmF0aXZlQmFjazogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG59KTtcbi8qKlxuICogQSBob29rIGZvciBtb3JlIGRpcmVjdCBjb250cm9sIG92ZXIgcm91dGluZyBpbiBhbiBJb25pYyBSZWFjdCBhcHBsaWNhdGlvbi4gQWxsb3dzIHlvdSB0byBwYXNzIGFkZGl0aW9uYWwgbWV0YS1kYXRhIHRvIHRoZSByb3V0ZXIgYmVmb3JlIHRoZSBjYWxsIHRvIHRoZSBuYXRpdmUgcm91dGVyLlxuICovXG5mdW5jdGlvbiB1c2VJb25Sb3V0ZXIoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uUm91dGVyQ29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogY29udGV4dC5iYWNrLFxuICAgICAgICBwdXNoOiBjb250ZXh0LnB1c2gsXG4gICAgICAgIGdvQmFjazogY29udGV4dC5iYWNrLFxuICAgICAgICBjYW5Hb0JhY2s6IGNvbnRleHQuY2FuR29CYWNrLFxuICAgICAgICByb3V0ZUluZm86IGNvbnRleHQucm91dGVJbmZvLFxuICAgIH07XG59XG5cbmNsYXNzIENyZWF0ZUFuaW1hdGlvbiBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBjcmVhdGVBbmltYXRpb24ocHJvcHMuaWQpO1xuICAgIH1cbiAgICBzZXR1cEFuaW1hdGlvbihwcm9wcykge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKHRoaXMubm9kZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5hZGRFbGVtZW50KEFycmF5LmZyb20odGhpcy5ub2Rlcy52YWx1ZXMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29uZmlnKGFuaW1hdGlvbiwgcHJvcHMpO1xuICAgICAgICBjaGVja1BsYXliYWNrKGFuaW1hdGlvbiwgcHJvcHMpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnNldHVwQW5pbWF0aW9uKHByb3BzKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBjaGVja0NvbmZpZyhhbmltYXRpb24sIHByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICBjaGVja1Byb2dyZXNzKGFuaW1hdGlvbiwgcHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgIGNoZWNrUGxheWJhY2soYW5pbWF0aW9uLCBwcm9wcywgcHJldlByb3BzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpZCkgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7IHJlZjogKGVsKSA9PiB0aGlzLm5vZGVzLnNldChpZCwgZWwpIH0pKSkpO1xuICAgIH1cbn1cbmNvbnN0IGNoZWNrQ29uZmlnID0gKGFuaW1hdGlvbiwgY3VycmVudFByb3BzID0ge30sIHByZXZQcm9wcyA9IHt9KSA9PiB7XG4gICAgY29uc3QgcmVzZXJ2ZWRQcm9wcyA9IFtcbiAgICAgICAgJ2NoaWxkcmVuJyxcbiAgICAgICAgJ3Byb2dyZXNzU3RhcnQnLFxuICAgICAgICAncHJvZ3Jlc3NTdGVwJyxcbiAgICAgICAgJ3Byb2dyZXNzRW5kJyxcbiAgICAgICAgJ3BhdXNlJyxcbiAgICAgICAgJ3N0b3AnLFxuICAgICAgICAnZGVzdHJveScsXG4gICAgICAgICdwbGF5JyxcbiAgICAgICAgJ2Zyb20nLFxuICAgICAgICAndG8nLFxuICAgICAgICAnZnJvbVRvJyxcbiAgICAgICAgJ29uRmluaXNoJyxcbiAgICBdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnRQcm9wcykge1xuICAgICAgICBpZiAoY3VycmVudFByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAgICFyZXNlcnZlZFByb3BzLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSkge1xuICAgICAgICAgICAgYW5pbWF0aW9uW2tleV0oY3VycmVudFByb3BzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBjdXJyZW50UHJvcHMuZnJvbTtcbiAgICBpZiAoZnJvbVZhbHVlcyAmJiBmcm9tVmFsdWVzICE9PSBwcmV2UHJvcHMuZnJvbSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGZyb21WYWx1ZXMpID8gZnJvbVZhbHVlcyA6IFtmcm9tVmFsdWVzXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbCkgPT4gYW5pbWF0aW9uLmZyb20odmFsLnByb3BlcnR5LCB2YWwudmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3QgdG9WYWx1ZXMgPSBjdXJyZW50UHJvcHMudG87XG4gICAgaWYgKHRvVmFsdWVzICYmIHRvVmFsdWVzICE9PSBwcmV2UHJvcHMudG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh0b1ZhbHVlcykgPyB0b1ZhbHVlcyA6IFt0b1ZhbHVlc107XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IGFuaW1hdGlvbi50byh2YWwucHJvcGVydHksIHZhbC52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9WYWx1ZXMgPSBjdXJyZW50UHJvcHMuZnJvbVRvO1xuICAgIGlmIChmcm9tVG9WYWx1ZXMgJiYgZnJvbVRvVmFsdWVzICE9PSBwcmV2UHJvcHMuZnJvbVRvKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoZnJvbVRvVmFsdWVzKSA/IGZyb21Ub1ZhbHVlcyA6IFtmcm9tVG9WYWx1ZXNdO1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiBhbmltYXRpb24uZnJvbVRvKHZhbC5wcm9wZXJ0eSwgdmFsLmZyb21WYWx1ZSwgdmFsLnRvVmFsdWUpKTtcbiAgICB9XG4gICAgY29uc3Qgb25GaW5pc2hWYWx1ZXMgPSBjdXJyZW50UHJvcHMub25GaW5pc2g7XG4gICAgaWYgKG9uRmluaXNoVmFsdWVzICYmIG9uRmluaXNoVmFsdWVzICE9PSBwcmV2UHJvcHMub25GaW5pc2gpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShvbkZpbmlzaFZhbHVlcykgPyBvbkZpbmlzaFZhbHVlcyA6IFtvbkZpbmlzaFZhbHVlc107XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IGFuaW1hdGlvbi5vbkZpbmlzaCh2YWwuY2FsbGJhY2ssIHZhbC5vcHRzKSk7XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrUHJvZ3Jlc3MgPSAoYW5pbWF0aW9uLCBjdXJyZW50UHJvcHMgPSB7fSwgcHJldlByb3BzID0ge30pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgcHJvZ3Jlc3NTdGFydCwgcHJvZ3Jlc3NTdGVwLCBwcm9ncmVzc0VuZCB9ID0gY3VycmVudFByb3BzO1xuICAgIGlmIChwcm9ncmVzc1N0YXJ0ICYmXG4gICAgICAgICgoKF9hID0gcHJldlByb3BzLnByb2dyZXNzU3RhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUxpbmVhckVhc2luZykgIT09IChwcm9ncmVzc1N0YXJ0ID09PSBudWxsIHx8IHByb2dyZXNzU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzU3RhcnQuZm9yY2VMaW5lYXJFYXNpbmcpIHx8XG4gICAgICAgICAgICAoKF9iID0gcHJldlByb3BzLnByb2dyZXNzU3RhcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGVwKSAhPT0gKHByb2dyZXNzU3RhcnQgPT09IG51bGwgfHwgcHJvZ3Jlc3NTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdGFydC5zdGVwKSkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RhcnQocHJvZ3Jlc3NTdGFydC5mb3JjZUxpbmVhckVhc2luZywgcHJvZ3Jlc3NTdGFydC5zdGVwKTtcbiAgICB9XG4gICAgaWYgKHByb2dyZXNzU3RlcCAmJiAoKF9jID0gcHJldlByb3BzLnByb2dyZXNzU3RlcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0ZXApICE9PSAocHJvZ3Jlc3NTdGVwID09PSBudWxsIHx8IHByb2dyZXNzU3RlcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdGVwLnN0ZXApKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc1N0ZXAocHJvZ3Jlc3NTdGVwLnN0ZXApO1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NFbmQgJiZcbiAgICAgICAgKCgoX2QgPSBwcmV2UHJvcHMucHJvZ3Jlc3NFbmQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wbGF5VG8pICE9PSAocHJvZ3Jlc3NFbmQgPT09IG51bGwgfHwgcHJvZ3Jlc3NFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzRW5kLnBsYXlUbykgfHxcbiAgICAgICAgICAgICgoX2UgPSBwcmV2UHJvcHMucHJvZ3Jlc3NFbmQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zdGVwKSAhPT0gKHByb2dyZXNzRW5kID09PSBudWxsIHx8IHByb2dyZXNzRW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9ncmVzc0VuZC5zdGVwKSB8fFxuICAgICAgICAgICAgKHByZXZQcm9wcyA9PT0gbnVsbCB8fCBwcmV2UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZQcm9wcy5kdXIpICE9PSAocHJvZ3Jlc3NFbmQgPT09IG51bGwgfHwgcHJvZ3Jlc3NFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzRW5kLmR1cikpKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc0VuZChwcm9ncmVzc0VuZC5wbGF5VG8sIHByb2dyZXNzRW5kLnN0ZXAsIHByb2dyZXNzRW5kLmR1cik7XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrUGxheWJhY2sgPSAoYW5pbWF0aW9uLCBjdXJyZW50UHJvcHMgPSB7fSwgcHJldlByb3BzID0ge30pID0+IHtcbiAgICBpZiAoIXByZXZQcm9wcy5wbGF5ICYmIGN1cnJlbnRQcm9wcy5wbGF5KSB7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzLnBhdXNlICYmIGN1cnJlbnRQcm9wcy5wYXVzZSkge1xuICAgICAgICBhbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMuc3RvcCAmJiBjdXJyZW50UHJvcHMuc3RvcCkge1xuICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcy5kZXN0cm95ICYmIGN1cnJlbnRQcm9wcy5kZXN0cm95KSB7XG4gICAgICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihkaXNwbGF5TmFtZSwgY29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBkaWREaXNtaXNzRXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfURpZERpc21pc3NgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCBkaWRQcmVzZW50RXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfURpZFByZXNlbnRgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCB3aWxsRGlzbWlzc0V2ZW50TmFtZSA9IHVzZU1lbW8oKCkgPT4gYG9uJHtkaXNwbGF5TmFtZX1XaWxsRGlzbWlzc2AsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IHdpbGxQcmVzZW50RXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfVdpbGxQcmVzZW50YCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjayhhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAob3ZlcmxheVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvbkRpZERpc21pc3MsIG9uV2lsbERpc21pc3MsIG9uRGlkUHJlc2VudCwgb25XaWxsUHJlc2VudCB9ID0gb3B0aW9ucywgcmVzdCA9IF9fcmVzdChvcHRpb25zLCBbXCJvbkRpZERpc21pc3NcIiwgXCJvbldpbGxEaXNtaXNzXCIsIFwib25EaWRQcmVzZW50XCIsIFwib25XaWxsUHJlc2VudFwiXSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURpc21pc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChvbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICBvbkRpZERpc21pc3MoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKHt9LCByZXN0KSk7XG4gICAgICAgIGF0dGFjaFByb3BzKG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgW2RpZERpc21pc3NFdmVudE5hbWVdOiBoYW5kbGVEaXNtaXNzLFxuICAgICAgICAgICAgW2RpZFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25EaWRQcmVzZW50ICYmIG9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiBvbldpbGxEaXNtaXNzICYmIG9uV2lsbERpc21pc3MoZSksXG4gICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25XaWxsUHJlc2VudCAmJiBvbldpbGxQcmVzZW50KGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnByZXNlbnQoKTtcbiAgICB9LCBbY29udHJvbGxlcl0pO1xuICAgIGNvbnN0IGRpc21pc3MgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCAmJiAoYXdhaXQgb3ZlcmxheVJlZi5jdXJyZW50LmRpc21pc3MoKSk7XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlc2VudCxcbiAgICAgICAgZGlzbWlzcyxcbiAgICB9O1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkFjdGlvblNoZWV0IGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbkFjdGlvblNoZWV0KCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25BY3Rpb25TaGVldCcsIGFjdGlvblNoZWV0Q29udHJvbGxlciQxLCBkZWZpbmVDdXN0b21FbGVtZW50JDEzKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKGJ1dHRvbnNPck9wdGlvbnMsIGhlYWRlcikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidXR0b25zT3JPcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9uc09yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoYnV0dG9uc09yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkFsZXJ0IGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbkFsZXJ0KCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25BbGVydCcsIGFsZXJ0Q29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYyk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChtZXNzYWdlT3JPcHRpb25zLCBidXR0b25zKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZU9yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VPck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9ucyAhPT0gbnVsbCAmJiBidXR0b25zICE9PSB2b2lkIDAgPyBidXR0b25zIDogW3sgdGV4dDogJ09rJyB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudChtZXNzYWdlT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyLnByZXNlbnRdKTtcbiAgICByZXR1cm4gW3ByZXNlbnQsIGNvbnRyb2xsZXIuZGlzbWlzc107XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uVG9hc3QgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uVG9hc3QoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHVzZUNvbnRyb2xsZXIoJ0lvblRvYXN0JywgdG9hc3RDb250cm9sbGVyJDEsIGRlZmluZUN1c3RvbUVsZW1lbnQkMWQpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygobWVzc2FnZU9yT3B0aW9ucywgZHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHByZXNlbnQsXG4gICAgICAgIGNvbnRyb2xsZXIuZGlzbWlzc1xuICAgIF07XG59XG5cbmNvbnN0IGlkcyA9IHsgbWFpbjogMCB9O1xuY29uc3QgZ2VuZXJhdGVJZCA9ICh0eXBlID0gJ21haW4nKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGlkID0gKChfYSA9IGlkc1t0eXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgKyAxO1xuICAgIGlkc1t0eXBlXSA9IGlkO1xuICAgIHJldHVybiBpZC50b1N0cmluZygpO1xufTtcblxuZnVuY3Rpb24gdXNlT3ZlcmxheShkaXNwbGF5TmFtZSwgY29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgY29tcG9uZW50LCBjb21wb25lbnRQcm9wcykge1xuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBjb250YWluZXJFbFJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IGRpZERpc21pc3NFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkRGlzbWlzc2AsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IGRpZFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkUHJlc2VudGAsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IHdpbGxEaXNtaXNzRXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfVdpbGxEaXNtaXNzYCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgY29uc3Qgd2lsbFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9V2lsbFByZXNlbnRgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGlvbkNvbnRleHQgPSB1c2VDb250ZXh0KElvbkNvbnRleHQpO1xuICAgIGNvbnN0IFtvdmVybGF5SWRdID0gdXNlU3RhdGUoZ2VuZXJhdGVJZCgnb3ZlcmxheScpKTtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiAmJiBjb21wb25lbnQgJiYgY29udGFpbmVyRWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBpb25Db250ZXh0LmFkZE92ZXJsYXkob3ZlcmxheUlkLCBjb21wb25lbnQsIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBjb21wb25lbnRQcm9wcyk7XG4gICAgICAgICAgICAgICAgaW9uQ29udGV4dC5hZGRPdmVybGF5KG92ZXJsYXlJZCwgZWxlbWVudCwgY29udGFpbmVyRWxSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY29tcG9uZW50LCBjb250YWluZXJFbFJlZi5jdXJyZW50LCBpc09wZW4sIGNvbXBvbmVudFByb3BzXSk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChvdmVybGF5UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uRGlkRGlzbWlzcywgb25XaWxsRGlzbWlzcywgb25EaWRQcmVzZW50LCBvbldpbGxQcmVzZW50IH0gPSBvcHRpb25zLCByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcIm9uRGlkRGlzbWlzc1wiLCBcIm9uV2lsbERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxQcmVzZW50XCJdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgfVxuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IGNvbXBvbmVudDogY29udGFpbmVyRWxSZWYuY3VycmVudCB9KSk7XG4gICAgICAgIGF0dGFjaFByb3BzKG92ZXJsYXlSZWYuY3VycmVudCwge1xuICAgICAgICAgICAgW2RpZERpc21pc3NFdmVudE5hbWVdOiBoYW5kbGVEaXNtaXNzLFxuICAgICAgICAgICAgW2RpZFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25EaWRQcmVzZW50ICYmIG9uRGlkUHJlc2VudChlKSxcbiAgICAgICAgICAgIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiBvbldpbGxEaXNtaXNzICYmIG9uV2lsbERpc21pc3MoZSksXG4gICAgICAgICAgICBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gb25XaWxsUHJlc2VudCAmJiBvbldpbGxQcmVzZW50KGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50LnByZXNlbnQoKTtcbiAgICAgICAgc2V0SXNPcGVuKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEaXNtaXNzKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAob25EaWREaXNtaXNzKSB7XG4gICAgICAgICAgICAgICAgb25EaWREaXNtaXNzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBzZXRJc09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgaW9uQ29udGV4dC5yZW1vdmVPdmVybGF5KG92ZXJsYXlJZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ICYmIChhd2FpdCBvdmVybGF5UmVmLmN1cnJlbnQuZGlzbWlzcygpKTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250YWluZXJFbFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVzZW50LFxuICAgICAgICBkaXNtaXNzLFxuICAgIH07XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uTW9kYWwgY29tcG9uZW50XG4gKiBAcGFyYW0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdGhhdCB0aGUgbW9kYWwgd2lsbCBzaG93LiBDYW4gYmUgYSBSZWFjdCBDb21wb25lbnQsIGEgZnVuY3Rpb25hbCBjb21wb25lbnQsIG9yIGEgSlNYIEVsZW1lbnRcbiAqIEBwYXJhbSBjb21wb25lbnRQcm9wcyBUaGUgcHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LCBpZiByZXF1aXJlZFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvbk1vZGFsKGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlT3ZlcmxheSgnSW9uTW9kYWwnLCBtb2RhbENvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTQsIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucHJlc2VudChvcHRpb25zKTtcbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvblBpY2tlciBjb21wb25lbnRcbiAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0aGF0IHRoZSBwb3BvdmVyIHdpbGwgc2hvdy4gQ2FuIGJlIGEgUmVhY3QgQ29tcG9uZW50LCBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LCBvciBhIEpTWCBFbGVtZW50XG4gKiBAcGFyYW0gY29tcG9uZW50UHJvcHMgVGhlIHByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCwgaWYgcmVxdWlyZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHByZXNlbnQgYW5kIGRpc21pc3MgbWV0aG9kcyBpbiBhbiBhcnJheVxuICovXG5mdW5jdGlvbiB1c2VJb25Qb3BvdmVyKGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlT3ZlcmxheSgnSW9uUG9wb3ZlcicsIHBvcG92ZXJDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDE1LCBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnByZXNlbnQob3B0aW9ucyk7XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHByZXNlbnQsXG4gICAgICAgIGNvbnRyb2xsZXIuZGlzbWlzc1xuICAgIF07XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uUGlja2VyIGNvbXBvbmVudFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvblBpY2tlcigpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlQ29udHJvbGxlcignSW9uUGlja2VyJywgcGlja2VyQ29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZSk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChjb2x1bW5zT3JPcHRpb25zLCBidXR0b25zKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtbnNPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zT3JPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IGJ1dHRvbnMgIT09IG51bGwgJiYgYnV0dG9ucyAhPT0gdm9pZCAwID8gYnV0dG9ucyA6IFt7IHRleHQ6ICdPaycgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoY29sdW1uc09yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG4vKipcbiAqIEEgaG9vayBmb3IgcHJlc2VudGluZy9kaXNtaXNzaW5nIGFuIElvbkxvYWRpbmcgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uTG9hZGluZygpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlQ29udHJvbGxlcignSW9uTG9hZGluZycsIGxvYWRpbmdDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDFmKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2VPck9wdGlvbnMgPSAnJywgZHVyYXRpb24sIHNwaW5uZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGlubmVyOiBzcGlubmVyICE9PSBudWxsICYmIHNwaW5uZXIgIT09IHZvaWQgMCA/IHNwaW5uZXIgOiAnbGluZXMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbcHJlc2VudCwgY29udHJvbGxlci5kaXNtaXNzXTtcbn1cblxuY29uc3Qgc2V0dXBJb25pY1JlYWN0ID0gKGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBJb25pYyBGcmFtZXdvcmsgaGlkZXMgZWxlbWVudHMgdGhhdFxuICAgICAqIGFyZSBub3QgaHlkcmF0ZWQsIGJ1dCBpbiB0aGUgQ0UgYnVpbGQgdGhlcmUgaXMgbm9cbiAgICAgKiBoeWRyYXRpb24uXG4gICAgICogVE9ETzogUmVtb3ZlIHdoZW4gYWxsIGludGVncmF0aW9ucyBoYXZlIGJlZW5cbiAgICAgKiBtaWdyYXRlZCB0byBDRSBidWlsZC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW9uLWNlJyk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSk7XG59O1xuXG5jb25zdCBSb3V0ZU1hbmFnZXJDb250ZXh0ID0gLypAX19QVVJFX18qLyBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBhZGRWaWV3SXRlbTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNhbkdvQmFjazogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGNsZWFyT3V0bGV0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY3JlYXRlVmlld0l0ZW06ICgpID0+IHVuZGVmaW5lZCxcbiAgICBmaW5kVmlld0l0ZW1CeVBhdGhuYW1lOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZmluZExlYXZpbmdWaWV3SXRlbUJ5Um91dGVJbmZvOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZmluZFZpZXdJdGVtQnlSb3V0ZUluZm86ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnZXRDaGlsZHJlblRvUmVuZGVyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ29CYWNrOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgdW5Nb3VudFZpZXdJdGVtOiAoKSA9PiB1bmRlZmluZWQsXG59KTtcblxuY2xhc3MgVmlld0xpZmVDeWNsZU1hbmFnZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0ID0gbmV3IERlZmF1bHRJb25MaWZlQ3ljbGVDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQub25Db21wb25lbnRDYW5CZURlc3Ryb3llZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMubW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sICgpID0+IHRoaXMucHJvcHMucmVtb3ZlVmlldygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHNob3cgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25MaWZlQ3ljbGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQgfSwgc2hvdyAmJiB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuXG4vLyBjb25zdCBSRVNUUklDVF9TSVpFID0gMTAwO1xuY2xhc3MgTG9jYXRpb25IaXN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy50YWJIaXN0b3J5ID0ge307XG4gICAgfVxuICAgIGFkZChyb3V0ZUluZm8pIHtcbiAgICAgICAgaWYgKHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PT0gJ3B1c2gnIHx8IHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8ucm91dGVBY3Rpb24gPT09ICdwb3AnKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3Aocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8ucm91dGVBY3Rpb24gPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZShyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZUluZm8ucm91dGVEaXJlY3Rpb24gPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZChyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyVGFiU3RhY2sodGFiKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkodGFiKTtcbiAgICAgICAgaWYgKHJvdXRlSW5mb3MpIHtcbiAgICAgICAgICAgIHJvdXRlSW5mb3MuZm9yRWFjaCgocmkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeSA9IHRoaXMubG9jYXRpb25IaXN0b3J5LmZpbHRlcigoeCkgPT4geC5pZCAhPT0gcmkuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhYkhpc3RvcnlbdGFiXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShyb3V0ZUluZm8pIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb25JbmRleCA9IHRoaXMubG9jYXRpb25IaXN0b3J5LmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gcm91dGVJbmZvLmlkKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3Rvcnkuc3BsaWNlKGxvY2F0aW9uSW5kZXgsIDEsIHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFiQXJyYXkgPSB0aGlzLnRhYkhpc3Rvcnlbcm91dGVJbmZvLnRhYiB8fCAnJ107XG4gICAgICAgIGlmICh0YWJBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0YWJBcnJheS5maW5kSW5kZXgoKHgpID0+IHguaWQgPT09IHJvdXRlSW5mby5pZCk7XG4gICAgICAgICAgICBpZiAodGFiSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRhYkFycmF5LnNwbGljZSh0YWJJbmRleCwgMSwgcm91dGVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhYkFycmF5LnB1c2gocm91dGVJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZUluZm8udGFiKSB7XG4gICAgICAgICAgICB0aGlzLnRhYkhpc3Rvcnlbcm91dGVJbmZvLnRhYl0gPSBbcm91dGVJbmZvXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxhdGVzdCByb3V0ZUluZm8gaXMgdGhlIHNhbWUgKGdvaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGFicyksIHJlcGxhY2UgaXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9hcmVSb3V0ZXNFcXVhbChyb3V0ZUluZm9zW3JvdXRlSW5mb3MubGVuZ3RoIC0gMV0sIHJvdXRlSW5mbykpIHtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm9zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91dGVJbmZvcy5wdXNoKHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkucHVzaChyb3V0ZUluZm8pO1xuICAgIH1cbiAgICBfYXJlUm91dGVzRXF1YWwocm91dGUxLCByb3V0ZTIpIHtcbiAgICAgICAgaWYgKCFyb3V0ZTEgfHwgIXJvdXRlMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZTEucGF0aG5hbWUgPT09IHJvdXRlMi5wYXRobmFtZSAmJiByb3V0ZTEuc2VhcmNoID09PSByb3V0ZTIuc2VhcmNoO1xuICAgIH1cbiAgICBfcG9wKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyByb3V0ZVxuICAgICAgICAgICAgcm91dGVJbmZvcy5wb3AoKTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgcm91dGUgd2l0aCBhbiB1cGRhdGVkIHZlcnNpb25cbiAgICAgICAgICAgIHJvdXRlSW5mb3MucG9wKCk7XG4gICAgICAgICAgICByb3V0ZUluZm9zLnB1c2gocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHJvdXRlXG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjdXJyZW50IHJvdXRlIHdpdGggYW4gdXBkYXRlZCB2ZXJzaW9uXG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeS5wdXNoKHJvdXRlSW5mbyk7XG4gICAgfVxuICAgIF9yZXBsYWNlKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICByb3V0ZUluZm9zICYmIHJvdXRlSW5mb3MucG9wKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnBvcCgpO1xuICAgICAgICB0aGlzLl9hZGQocm91dGVJbmZvKTtcbiAgICB9XG4gICAgX2NsZWFyKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy50YWJIaXN0b3J5KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiAodGhpcy50YWJIaXN0b3J5W2tdID0gW10pKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkgPSBbXTtcbiAgICB9XG4gICAgX2dldFJvdXRlSW5mb3NCeUtleShrZXkpIHtcbiAgICAgICAgbGV0IHJvdXRlSW5mb3M7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHJvdXRlSW5mb3MgPSB0aGlzLnRhYkhpc3Rvcnlba2V5XTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvcykge1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mb3MgPSB0aGlzLnRhYkhpc3Rvcnlba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZUluZm9zO1xuICAgIH1cbiAgICBnZXRGaXJzdFJvdXRlSW5mb0ZvclRhYih0YWIpIHtcbiAgICAgICAgY29uc3Qgcm91dGVJbmZvcyA9IHRoaXMuX2dldFJvdXRlSW5mb3NCeUtleSh0YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mb3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFJvdXRlSW5mb0ZvclRhYih0YWIpIHtcbiAgICAgICAgY29uc3Qgcm91dGVJbmZvcyA9IHRoaXMuX2dldFJvdXRlSW5mb3NCeUtleSh0YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mb3Nbcm91dGVJbmZvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kTGFzdExvY2F0aW9uKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHJvdXRlSW5mby50YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHJvdXRlSW5mb3MubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByaSA9IHJvdXRlSW5mb3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaS5wYXRobmFtZSA9PT0gcm91dGVJbmZvLnB1c2hlZEJ5Um91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJpID0gdGhpcy5sb2NhdGlvbkhpc3RvcnlbaV07XG4gICAgICAgICAgICBpZiAocmkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmkucGF0aG5hbWUgPT09IHJvdXRlSW5mby5wdXNoZWRCeVJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcHJldmlvdXMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2NhdGlvbkhpc3RvcnlbdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMl0gfHxcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5W3RoaXMubG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gICAgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25IaXN0b3J5W3RoaXMubG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjYW5Hb0JhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uSGlzdG9yeS5sZW5ndGggPiAxO1xuICAgIH1cbn1cblxuY2xhc3MgTmF2TWFuYWdlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW9uUm91dGVyQ29udGV4dFZhbHVlID0ge1xuICAgICAgICAgICAgcHVzaDogKHBhdGhuYW1lLCByb3V0ZXJEaXJlY3Rpb24sIHJvdXRlQWN0aW9uLCByb3V0ZXJPcHRpb25zLCBhbmltYXRpb25CdWlsZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShwYXRobmFtZSwgcm91dGVyRGlyZWN0aW9uLCByb3V0ZUFjdGlvbiwgYW5pbWF0aW9uQnVpbGRlciwgcm91dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFjazogKGFuaW1hdGlvbkJ1aWxkZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdvQmFjayh1bmRlZmluZWQsIGFuaW1hdGlvbkJ1aWxkZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbkdvQmFjazogKCkgPT4gdGhpcy5wcm9wcy5sb2NhdGlvbkhpc3RvcnkuY2FuR29CYWNrKCksXG4gICAgICAgICAgICBuYXRpdmVCYWNrOiAoKSA9PiB0aGlzLnByb3BzLm9uTmF0aXZlQmFjaygpLFxuICAgICAgICAgICAgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGdvQmFjazogdGhpcy5nb0JhY2suYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGhhc0lvbmljUm91dGVyOiAoKSA9PiB0cnVlLFxuICAgICAgICAgICAgbmF2aWdhdGU6IHRoaXMubmF2aWdhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldElvblJlZGlyZWN0OiB0aGlzLmdldElvblJlZGlyZWN0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRJb25Sb3V0ZTogdGhpcy5nZXRJb25Sb3V0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0U3RhY2tNYW5hZ2VyOiB0aGlzLmdldFN0YWNrTWFuYWdlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0UGFnZU1hbmFnZXI6IHRoaXMuZ2V0UGFnZU1hbmFnZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJvdXRlSW5mbzogdGhpcy5wcm9wcy5yb3V0ZUluZm8sXG4gICAgICAgICAgICBzZXRDdXJyZW50VGFiOiB0aGlzLnByb3BzLm9uU2V0Q3VycmVudFRhYixcbiAgICAgICAgICAgIGNoYW5nZVRhYjogdGhpcy5wcm9wcy5vbkNoYW5nZVRhYixcbiAgICAgICAgICAgIHJlc2V0VGFiOiB0aGlzLnByb3BzLm9uUmVzZXRUYWIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbiA9IHRoaXMuaGFuZGxlSGFyZHdhcmVCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdpb25CYWNrQnV0dG9uJywgdGhpcy5oYW5kbGVIYXJkd2FyZUJhY2tCdXR0b24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvbkJhY2tCdXR0b24nLCB0aGlzLmhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbik7XG4gICAgICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVIYXJkd2FyZUJhY2tCdXR0b24oZSkge1xuICAgICAgICBlLmRldGFpbC5yZWdpc3RlcigwLCAocHJvY2Vzc05leHRIYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVHb0JhY2soKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dEhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdvQmFjayhyb3V0ZSwgYW5pbWF0aW9uQnVpbGRlcikge1xuICAgICAgICB0aGlzLnByb3BzLm9uTmF2aWdhdGVCYWNrKHJvdXRlLCBhbmltYXRpb25CdWlsZGVyKTtcbiAgICB9XG4gICAgbmF0aXZlR29CYWNrKCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTmF0aXZlQmFjaygpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZShwYXRoLCBkaXJlY3Rpb24gPSAnZm9yd2FyZCcsIGFjdGlvbiA9ICdwdXNoJywgYW5pbWF0aW9uQnVpbGRlciwgb3B0aW9ucywgdGFiKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25OYXZpZ2F0ZShwYXRoLCBhY3Rpb24sIGRpcmVjdGlvbiwgYW5pbWF0aW9uQnVpbGRlciwgb3B0aW9ucywgdGFiKTtcbiAgICB9XG4gICAgZ2V0UGFnZU1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiBQYWdlTWFuYWdlcjtcbiAgICB9XG4gICAgZ2V0SW9uUmVkaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmlvblJlZGlyZWN0O1xuICAgIH1cbiAgICBnZXRJb25Sb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW9uUm91dGU7XG4gICAgfVxuICAgIGdldFN0YWNrTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3RhY2tNYW5hZ2VyO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChOYXZDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB7IHJvdXRlSW5mbzogdGhpcy5wcm9wcy5yb3V0ZUluZm8gfSkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmlvblJvdXRlckNvbnRleHRWYWx1ZSksIHsgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyB9KSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVmlld1N0YWNrcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlld1N0YWNrcyA9IHt9O1xuICAgICAgICB0aGlzLmFkZCA9IHRoaXMuYWRkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXIgPSB0aGlzLmNsZWFyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Vmlld0l0ZW1zRm9yT3V0bGV0ID0gdGhpcy5nZXRWaWV3SXRlbXNGb3JPdXRsZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBhZGQodmlld0l0ZW0pIHtcbiAgICAgICAgY29uc3QgeyBvdXRsZXRJZCB9ID0gdmlld0l0ZW07XG4gICAgICAgIGlmICghdGhpcy52aWV3U3RhY2tzW291dGxldElkXSkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhY2tzW291dGxldElkXSA9IFt2aWV3SXRlbV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdLnB1c2godmlld0l0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKG91dGxldElkKSB7XG4gICAgICAgIC8vIEdpdmUgc29tZSB0aW1lIGZvciB0aGUgbGVhdmluZyB2aWV3cyB0byB0cmFuc2l0aW9uIGJlZm9yZSByZW1vdmluZ1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZW1vdmluZyB2aWV3c3RhY2sgZm9yIG91dGxldElEICcgKyBvdXRsZXRJZCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy52aWV3U3RhY2tzW291dGxldElkXTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgZ2V0Vmlld0l0ZW1zRm9yT3V0bGV0KG91dGxldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdIHx8IFtdO1xuICAgIH1cbiAgICByZW1vdmUodmlld0l0ZW0pIHtcbiAgICAgICAgY29uc3QgeyBvdXRsZXRJZCB9ID0gdmlld0l0ZW07XG4gICAgICAgIGNvbnN0IHZpZXdTdGFjayA9IHRoaXMudmlld1N0YWNrc1tvdXRsZXRJZF07XG4gICAgICAgIGlmICh2aWV3U3RhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdJdGVtVG9SZW1vdmUgPSB2aWV3U3RhY2suZmluZCgoeCkgPT4geC5pZCA9PT0gdmlld0l0ZW0uaWQpO1xuICAgICAgICAgICAgaWYgKHZpZXdJdGVtVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICB2aWV3SXRlbVRvUmVtb3ZlLm1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhY2tzW291dGxldElkXSA9IHZpZXdTdGFjay5maWx0ZXIoKHgpID0+IHguaWQgIT09IHZpZXdJdGVtVG9SZW1vdmUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN0YWNrSWRzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy52aWV3U3RhY2tzKTtcbiAgICB9XG4gICAgZ2V0QWxsVmlld0l0ZW1zKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5nZXRTdGFja0lkcygpO1xuICAgICAgICBjb25zdCB2aWV3SXRlbXMgPSBbXTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB2aWV3SXRlbXMucHVzaCguLi50aGlzLnZpZXdTdGFja3Nba10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpZXdJdGVtcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IENyZWF0ZUFuaW1hdGlvbiwgRGVmYXVsdElvbkxpZmVDeWNsZUNvbnRleHQsIElvbkFjY29yZGlvbiwgSW9uQWNjb3JkaW9uR3JvdXAsIElvbkFjdGlvblNoZWV0LCBJb25BbGVydCwgSW9uQXBwLCBJb25BdmF0YXIsIElvbkJhY2tCdXR0b24sIElvbkJhY2tkcm9wLCBJb25CYWRnZSwgSW9uQnJlYWRjcnVtYiwgSW9uQnJlYWRjcnVtYnMsIElvbkJ1dHRvbiwgSW9uQnV0dG9ucywgSW9uQ2FyZCwgSW9uQ2FyZENvbnRlbnQsIElvbkNhcmRIZWFkZXIsIElvbkNhcmRTdWJ0aXRsZSwgSW9uQ2FyZFRpdGxlLCBJb25DaGVja2JveCwgSW9uQ2hpcCwgSW9uQ29sLCBJb25Db250ZW50LCBJb25EYXRldGltZSwgSW9uRmFiLCBJb25GYWJCdXR0b24sIElvbkZhYkxpc3QsIElvbkZvb3RlciwgSW9uR3JpZCwgSW9uSGVhZGVyLCBJb25JY29uLCBJb25JbWcsIElvbkluZmluaXRlU2Nyb2xsLCBJb25JbmZpbml0ZVNjcm9sbENvbnRlbnQsIElvbklucHV0LCBJb25JdGVtLCBJb25JdGVtRGl2aWRlciwgSW9uSXRlbUdyb3VwLCBJb25JdGVtT3B0aW9uLCBJb25JdGVtT3B0aW9ucywgSW9uSXRlbVNsaWRpbmcsIElvbkxhYmVsLCBJb25MaWZlQ3ljbGVDb250ZXh0LCBJb25MaXN0LCBJb25MaXN0SGVhZGVyLCBJb25Mb2FkaW5nLCBJb25NZW51LCBJb25NZW51QnV0dG9uLCBJb25NZW51VG9nZ2xlLCBJb25Nb2RhbCwgSW9uTmF2LCBJb25OYXZMaW5rLCBJb25Ob3RlLCBJb25QYWdlLCBJb25QaWNrZXIsIElvblBvcG92ZXIsIElvblByb2dyZXNzQmFyLCBJb25SYWRpbywgSW9uUmFkaW9Hcm91cCwgSW9uUmFuZ2UsIElvblJlZGlyZWN0LCBJb25SZWZyZXNoZXIsIElvblJlZnJlc2hlckNvbnRlbnQsIElvblJlb3JkZXIsIElvblJlb3JkZXJHcm91cCwgSW9uUmlwcGxlRWZmZWN0LCBJb25Sb3V0ZSwgSW9uUm91dGVyQ29udGV4dCwgSW9uUm91dGVyTGluaywgSW9uUm91dGVyT3V0bGV0LCBJb25Sb3csIElvblNlYXJjaGJhciwgSW9uU2VnbWVudCwgSW9uU2VnbWVudEJ1dHRvbiwgSW9uU2VsZWN0LCBJb25TZWxlY3RPcHRpb24sIElvblNrZWxldG9uVGV4dCwgSW9uU2xpZGUsIElvblNsaWRlcywgSW9uU3Bpbm5lciwgSW9uU3BsaXRQYW5lLCBJb25UYWIsIElvblRhYkJhciwgSW9uVGFiQnV0dG9uLCBJb25UYWJzLCBJb25UYWJzQ29udGV4dCwgSW9uVGV4dCwgSW9uVGV4dGFyZWEsIElvblRodW1ibmFpbCwgSW9uVGl0bGUsIElvblRvYXN0LCBJb25Ub2dnbGUsIElvblRvb2xiYXIsIElvblZpcnR1YWxTY3JvbGwsIExvY2F0aW9uSGlzdG9yeSwgTmF2Q29udGV4dCwgTmF2TWFuYWdlciwgUm91dGVNYW5hZ2VyQ29udGV4dCwgU3RhY2tDb250ZXh0LCBWaWV3TGlmZUN5Y2xlTWFuYWdlciwgVmlld1N0YWNrcywgZ2VuZXJhdGVJZCwgZ2V0Q29uZmlnLCBnZXRQbGF0Zm9ybXMsIGlzUGxhdGZvcm0sIHNldHVwSW9uaWNSZWFjdCwgdXNlSW9uQWN0aW9uU2hlZXQsIHVzZUlvbkFsZXJ0LCB1c2VJb25Mb2FkaW5nLCB1c2VJb25Nb2RhbCwgdXNlSW9uUGlja2VyLCB1c2VJb25Qb3BvdmVyLCB1c2VJb25Sb3V0ZXIsIHVzZUlvblRvYXN0LCB1c2VJb25WaWV3RGlkRW50ZXIsIHVzZUlvblZpZXdEaWRMZWF2ZSwgdXNlSW9uVmlld1dpbGxFbnRlciwgdXNlSW9uVmlld1dpbGxMZWF2ZSwgd2l0aElvbkxpZmVDeWNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75087\n")},18463:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86010);\n/* harmony import */ var _Paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79895);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14670);\n\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    overflow: \'hidden\'\n  }\n};\nvar Card = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Card(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$raised = props.raised,\n      raised = _props$raised === void 0 ? false : _props$raised,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["classes", "className", "raised"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Paper__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(classes.root, className),\n    elevation: raised ? 8 : 1,\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCard\'\n})(Card));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0NjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUNnQztBQUMzRDtBQUNJO0FBQ1g7QUFDSztBQUNpQjtBQUN2QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1R0FBd0I7O0FBRXRDLHNCQUFzQixnREFBbUIsQ0FBQyx1REFBSyxFQUFFLHVGQUFRO0FBQ3pELGVBQWUseURBQUk7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsTUFBcUMsR0FBRyxDQTBCdkMsQ0FBQztBQUNGLGlFQUFlLHVFQUFVO0FBQ3pCO0FBQ0EsQ0FBQyxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQ2FyZC9DYXJkLmpzP2RmNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IFBhcGVyIGZyb20gJy4uL1BhcGVyJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gIH1cbn07XG52YXIgQ2FyZCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhcmQocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkcmFpc2VkID0gcHJvcHMucmFpc2VkLFxuICAgICAgcmFpc2VkID0gX3Byb3BzJHJhaXNlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcmFpc2VkLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJyYWlzZWRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYXBlciwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksXG4gICAgZWxldmF0aW9uOiByYWlzZWQgPyA4IDogMSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBDYXJkLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjYXJkIHdpbGwgdXNlIHJhaXNlZCBzdHlsaW5nLlxuICAgKi9cbiAgcmFpc2VkOiBQcm9wVHlwZXMuYm9vbFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlDYXJkJ1xufSkoQ2FyZCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18463\n')},51907:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14670);\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: \'flex\',\n    alignItems: \'center\',\n    padding: 8\n  },\n\n  /* Styles applied to the root element if `disableSpacing={false}`. */\n  spacing: {\n    \'& > :not(:first-child)\': {\n      marginLeft: 8\n    }\n  }\n};\nvar CardActions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardActions(props, ref) {\n  var _props$disableSpacing = props.disableSpacing,\n      disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,\n      classes = props.classes,\n      className = props.className,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["disableSpacing", "classes", "className"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className, !disableSpacing && classes.spacing),\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardActions\'\n})(CardActions));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE5MDcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBEO0FBQ2dDO0FBQzNEO0FBQ0k7QUFDWDtBQUNzQjtBQUN2QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVHQUF3Qjs7QUFFdEMsc0JBQXNCLGdEQUFtQixRQUFRLHVGQUFRO0FBQ3pELGVBQWUseURBQUk7QUFDbkI7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELE1BQXFDLEdBQUcsQ0EwQnZDLENBQUM7QUFDRixpRUFBZSx1RUFBVTtBQUN6QjtBQUNBLENBQUMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRBY3Rpb25zL0NhcmRBY3Rpb25zLmpzP2EzODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgcGFkZGluZzogOFxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVTcGFjaW5nPXtmYWxzZX1gLiAqL1xuICBzcGFjaW5nOiB7XG4gICAgJyYgPiA6bm90KDpmaXJzdC1jaGlsZCknOiB7XG4gICAgICBtYXJnaW5MZWZ0OiA4XG4gICAgfVxuICB9XG59O1xudmFyIENhcmRBY3Rpb25zID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FyZEFjdGlvbnMocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGRpc2FibGVTcGFjaW5nID0gcHJvcHMuZGlzYWJsZVNwYWNpbmcsXG4gICAgICBkaXNhYmxlU3BhY2luZyA9IF9wcm9wcyRkaXNhYmxlU3BhY2luZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVNwYWNpbmcsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJkaXNhYmxlU3BhY2luZ1wiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCAhZGlzYWJsZVNwYWNpbmcgJiYgY2xhc3Nlcy5zcGFjaW5nKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBDYXJkQWN0aW9ucy5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYWN0aW9ucyBkbyBub3QgaGF2ZSBhZGRpdGlvbmFsIG1hcmdpbi5cbiAgICovXG4gIGRpc2FibGVTcGFjaW5nOiBQcm9wVHlwZXMuYm9vbFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlDYXJkQWN0aW9ucydcbn0pKENhcmRBY3Rpb25zKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51907\n')},79912:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14670);\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 16,\n    \'&:last-child\': {\n      paddingBottom: 24\n    }\n  }\n};\nvar CardContent = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardContent(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? \'div\' : _props$component,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["classes", "className", "component"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className),\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardContent\'\n})(CardContent));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk5MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBEO0FBQ2dDO0FBQzNEO0FBQ0k7QUFDWDtBQUNzQjtBQUN2QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1R0FBd0I7O0FBRXRDLHNCQUFzQixnREFBbUIsWUFBWSx1RkFBUTtBQUM3RCxlQUFlLHlEQUFJO0FBQ25CO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxNQUFxQyxHQUFHLENBNkJ2QyxDQUFDO0FBQ0YsaUVBQWUsdUVBQVU7QUFDekI7QUFDQSxDQUFDLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9DYXJkQ29udGVudC9DYXJkQ29udGVudC5qcz9hMWFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgcGFkZGluZzogMTYsXG4gICAgJyY6bGFzdC1jaGlsZCc6IHtcbiAgICAgIHBhZGRpbmdCb3R0b206IDI0XG4gICAgfVxuICB9XG59O1xudmFyIENhcmRDb250ZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FyZENvbnRlbnQocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRDb250ZW50LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlDYXJkQ29udGVudCdcbn0pKENhcmRDb250ZW50KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///79912\n')},951:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14670);\n\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: \'block\',\n    backgroundSize: \'cover\',\n    backgroundRepeat: \'no-repeat\',\n    backgroundPosition: \'center\'\n  },\n\n  /* Styles applied to the root element if `component="video, audio, picture, iframe, or img"`. */\n  media: {\n    width: \'100%\'\n  },\n\n  /* Styles applied to the root element if `component="picture or img"`. */\n  img: {\n    // ⚠️ object-fit is not supported by IE 11.\n    objectFit: \'cover\'\n  }\n};\nvar MEDIA_COMPONENTS = [\'video\', \'audio\', \'picture\', \'iframe\', \'img\'];\nvar CardMedia = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardMedia(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? \'div\' : _props$component,\n      image = props.image,\n      src = props.src,\n      style = props.style,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["children", "classes", "className", "component", "image", "src", "style"]);\n\n  var isMediaComponent = MEDIA_COMPONENTS.indexOf(Component) !== -1;\n  var composedStyle = !isMediaComponent && image ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    backgroundImage: "url(\\"".concat(image, "\\")")\n  }, style) : style;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className, isMediaComponent && classes.media, "picture img".indexOf(Component) !== -1 && classes.img),\n    ref: ref,\n    style: composedStyle,\n    src: isMediaComponent ? image || src : undefined\n  }, other), children);\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardMedia\'\n})(CardMedia));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNnQztBQUMzRDtBQUNJO0FBQ1g7QUFDc0I7QUFDTTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUdBQXdCOztBQUV0QztBQUNBLG1EQUFtRCx1RkFBUTtBQUMzRDtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLFlBQVksdUZBQVE7QUFDN0QsZUFBZSx5REFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELE1BQXFDLEdBQUcsQ0FzRHZDLENBQUM7QUFDRixpRUFBZSx1RUFBVTtBQUN6QjtBQUNBLENBQUMsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRNZWRpYS9DYXJkTWVkaWEuanM/MjFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgYmFja2dyb3VuZFNpemU6ICdjb3ZlcicsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCcsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbXBvbmVudD1cInZpZGVvLCBhdWRpbywgcGljdHVyZSwgaWZyYW1lLCBvciBpbWdcImAuICovXG4gIG1lZGlhOiB7XG4gICAgd2lkdGg6ICcxMDAlJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbXBvbmVudD1cInBpY3R1cmUgb3IgaW1nXCJgLiAqL1xuICBpbWc6IHtcbiAgICAvLyDimqDvuI8gb2JqZWN0LWZpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExLlxuICAgIG9iamVjdEZpdDogJ2NvdmVyJ1xuICB9XG59O1xudmFyIE1FRElBX0NPTVBPTkVOVFMgPSBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3BpY3R1cmUnLCAnaWZyYW1lJywgJ2ltZyddO1xudmFyIENhcmRNZWRpYSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhcmRNZWRpYShwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgaW1hZ2UgPSBwcm9wcy5pbWFnZSxcbiAgICAgIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiaW1hZ2VcIiwgXCJzcmNcIiwgXCJzdHlsZVwiXSk7XG5cbiAgdmFyIGlzTWVkaWFDb21wb25lbnQgPSBNRURJQV9DT01QT05FTlRTLmluZGV4T2YoQ29tcG9uZW50KSAhPT0gLTE7XG4gIHZhciBjb21wb3NlZFN0eWxlID0gIWlzTWVkaWFDb21wb25lbnQgJiYgaW1hZ2UgPyBfZXh0ZW5kcyh7XG4gICAgYmFja2dyb3VuZEltYWdlOiBcInVybChcXFwiXCIuY29uY2F0KGltYWdlLCBcIlxcXCIpXCIpXG4gIH0sIHN0eWxlKSA6IHN0eWxlO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBpc01lZGlhQ29tcG9uZW50ICYmIGNsYXNzZXMubWVkaWEsIFwicGljdHVyZSBpbWdcIi5pbmRleE9mKENvbXBvbmVudCkgIT09IC0xICYmIGNsYXNzZXMuaW1nKSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogY29tcG9zZWRTdHlsZSxcbiAgICBzcmM6IGlzTWVkaWFDb21wb25lbnQgPyBpbWFnZSB8fCBzcmMgOiB1bmRlZmluZWRcbiAgfSwgb3RoZXIpLCBjaGlsZHJlbik7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRNZWRpYS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5ub2RlLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmNoaWxkcmVuICYmICFwcm9wcy5pbWFnZSAmJiAhcHJvcHMuc3JjICYmICFwcm9wcy5jb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hdGVyaWFsLVVJOiBFaXRoZXIgYGNoaWxkcmVuYCwgYGltYWdlYCwgYHNyY2Agb3IgYGNvbXBvbmVudGAgcHJvcCBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSW1hZ2UgdG8gYmUgZGlzcGxheWVkIGFzIGEgYmFja2dyb3VuZCBpbWFnZS5cbiAgICogRWl0aGVyIGBpbWFnZWAgb3IgYHNyY2AgcHJvcCBtdXN0IGJlIHNwZWNpZmllZC5cbiAgICogTm90ZSB0aGF0IGNhbGxlciBtdXN0IHNwZWNpZnkgaGVpZ2h0IG90aGVyd2lzZSB0aGUgaW1hZ2Ugd2lsbCBub3QgYmUgdmlzaWJsZS5cbiAgICovXG4gIGltYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgYGltYWdlYCBwcm9wZXJ0eS5cbiAgICogQXZhaWxhYmxlIG9ubHkgd2l0aCBtZWRpYSBjb21wb25lbnRzLlxuICAgKiBNZWRpYSBjb21wb25lbnRzOiBgdmlkZW9gLCBgYXVkaW9gLCBgcGljdHVyZWAsIGBpZnJhbWVgLCBgaW1nYC5cbiAgICovXG4gIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2FyZE1lZGlhJ1xufSkoQ2FyZE1lZGlhKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///951\n')},59460:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n\nvar _interopRequireDefault = __webpack_require__(95318);\n\nvar _interopRequireWildcard = __webpack_require__(20862);\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports.Z = void 0;\n\nvar React = _interopRequireWildcard(__webpack_require__(67294));\n\nvar _createSvgIcon = _interopRequireDefault(__webpack_require__(2108));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement("path", {\n  d: "M17.5 4.5c-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .65.73.45.75.45C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.41.21.75-.19.75-.45V6c-1.49-1.12-3.63-1.5-5.5-1.5zm3.5 14c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5v11.5z"\n}), \'ImportContacts\');\n\nexports.Z = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk0NjAuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLEtBQThDOztBQUVuRiw4QkFBOEIsbUJBQU8sQ0FBQyxLQUErQzs7QUFFckYsNkJBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxDQUFDO0FBQ0YsU0FBZTs7QUFFZixvQ0FBb0MsbUJBQU8sQ0FBQyxLQUFPOztBQUVuRCw0Q0FBNEMsbUJBQU8sQ0FBQyxJQUF1Qjs7QUFFM0U7QUFDQTtBQUNBLENBQUM7O0FBRUQsU0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2ljb25zL0ltcG9ydENvbnRhY3RzLmpzPzcwMzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX2NyZWF0ZVN2Z0ljb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2NyZWF0ZVN2Z0ljb25cIikpO1xuXG52YXIgX2RlZmF1bHQgPSAoMCwgX2NyZWF0ZVN2Z0ljb24uZGVmYXVsdCkoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTE3LjUgNC41Yy0xLjk1IDAtNC4wNS40LTUuNSAxLjUtMS40NS0xLjEtMy41NS0xLjUtNS41LTEuNVMyLjQ1IDQuOSAxIDZ2MTQuNjVjMCAuNjUuNzMuNDUuNzUuNDVDMy4xIDIwLjQ1IDUuMDUgMjAgNi41IDIwYzEuOTUgMCA0LjA1LjQgNS41IDEuNSAxLjM1LS44NSAzLjgtMS41IDUuNS0xLjUgMS42NSAwIDMuMzUuMyA0Ljc1IDEuMDUuNDEuMjEuNzUtLjE5Ljc1LS40NVY2Yy0xLjQ5LTEuMTItMy42My0xLjUtNS41LTEuNXptMy41IDE0Yy0xLjEtLjM1LTIuMy0uNS0zLjUtLjUtMS43IDAtNC4xNS42NS01LjUgMS41VjhjMS4zNS0uODUgMy44LTEuNSA1LjUtMS41IDEuMiAwIDIuNC4xNSAzLjUuNXYxMS41elwiXG59KSwgJ0ltcG9ydENvbnRhY3RzJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59460\n')},76990:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n\nvar _interopRequireDefault = __webpack_require__(95318);\n\nvar _interopRequireWildcard = __webpack_require__(20862);\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports.Z = void 0;\n\nvar React = _interopRequireWildcard(__webpack_require__(67294));\n\nvar _createSvgIcon = _interopRequireDefault(__webpack_require__(2108));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement("path", {\n  d: "M7.58 4.08L6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z"\n}), \'NotificationsActive\');\n\nexports.Z = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY5OTAuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLEtBQThDOztBQUVuRiw4QkFBOEIsbUJBQU8sQ0FBQyxLQUErQzs7QUFFckYsNkJBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxDQUFDO0FBQ0YsU0FBZTs7QUFFZixvQ0FBb0MsbUJBQU8sQ0FBQyxLQUFPOztBQUVuRCw0Q0FBNEMsbUJBQU8sQ0FBQyxJQUF1Qjs7QUFFM0U7QUFDQTtBQUNBLENBQUM7O0FBRUQsU0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2ljb25zL05vdGlmaWNhdGlvbnNBY3RpdmUuanM/ZGRiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfY3JlYXRlU3ZnSWNvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvY3JlYXRlU3ZnSWNvblwiKSk7XG5cbnZhciBfZGVmYXVsdCA9ICgwLCBfY3JlYXRlU3ZnSWNvbi5kZWZhdWx0KSggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNNy41OCA0LjA4TDYuMTUgMi42NUMzLjc1IDQuNDggMi4xNyA3LjMgMi4wMyAxMC41aDJjLjE1LTIuNjUgMS41MS00Ljk3IDMuNTUtNi40MnptMTIuMzkgNi40MmgyYy0uMTUtMy4yLTEuNzMtNi4wMi00LjEyLTcuODVsLTEuNDIgMS40M2MyLjAyIDEuNDUgMy4zOSAzLjc3IDMuNTQgNi40MnpNMTggMTFjMC0zLjA3LTEuNjQtNS42NC00LjUtNi4zMlY0YzAtLjgzLS42Ny0xLjUtMS41LTEuNXMtMS41LjY3LTEuNSAxLjV2LjY4QzcuNjMgNS4zNiA2IDcuOTIgNiAxMXY1bC0yIDJ2MWgxNnYtMWwtMi0ydi01em0tNiAxMWMuMTQgMCAuMjctLjAxLjQtLjA0LjY1LS4xNCAxLjE4LS41OCAxLjQ0LTEuMTguMS0uMjQuMTUtLjUuMTUtLjc4aC00Yy4wMSAxLjEuOSAyIDIuMDEgMnpcIlxufSksICdOb3RpZmljYXRpb25zQWN0aXZlJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76990\n')},77210:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z5\": () => (/* binding */ Build),\n  \"mv\": () => (/* binding */ H),\n  \"AA\": () => (/* binding */ Host),\n  \"yM\": () => (/* binding */ createEvent),\n  \"iJ\": () => (/* binding */ getMode),\n  \"h\": () => (/* binding */ h),\n  \"GH\": () => (/* binding */ proxyCustomElement),\n  \"wj\": () => (/* binding */ readTask),\n  \"Iu\": () => (/* binding */ writeTask)\n});\n\n// UNUSED EXPORTS: BUILD, CSS, Context, Env, Fragment, H, NAMESPACE, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getRenderingRef, getValue, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructibleStylesheets, supportsListenerOptions, supportsShadow, win\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.14.2 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (app_data_BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (app_data_BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n    const didValueChange = newVal !== oldVal && !areBothNaN;\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 576).then(__webpack_require__.bind(__webpack_require__, 20576)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(41993)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQTBCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQixtQ0FBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWU7QUFDOUI7QUFDd0U7QUFDNHZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhL2luZGV4LmpzP2JhOTUiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcz8zMTA1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJVSUxEID0ge1xuICAgIGFsbFJlbmRlckZuOiBmYWxzZSxcbiAgICBjbXBEaWRMb2FkOiB0cnVlLFxuICAgIGNtcERpZFVubG9hZDogZmFsc2UsXG4gICAgY21wRGlkVXBkYXRlOiB0cnVlLFxuICAgIGNtcERpZFJlbmRlcjogdHJ1ZSxcbiAgICBjbXBXaWxsTG9hZDogdHJ1ZSxcbiAgICBjbXBXaWxsVXBkYXRlOiB0cnVlLFxuICAgIGNtcFdpbGxSZW5kZXI6IHRydWUsXG4gICAgY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2s6IHRydWUsXG4gICAgZWxlbWVudDogdHJ1ZSxcbiAgICBldmVudDogdHJ1ZSxcbiAgICBoYXNSZW5kZXJGbjogdHJ1ZSxcbiAgICBsaWZlY3ljbGU6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyOiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudDogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXRCb2R5OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0OiB0cnVlLFxuICAgIG1lbWJlcjogdHJ1ZSxcbiAgICBtZXRob2Q6IHRydWUsXG4gICAgbW9kZTogdHJ1ZSxcbiAgICBvYnNlcnZlQXR0cmlidXRlOiB0cnVlLFxuICAgIHByb3A6IHRydWUsXG4gICAgcHJvcE11dGFibGU6IHRydWUsXG4gICAgcmVmbGVjdDogdHJ1ZSxcbiAgICBzY29wZWQ6IHRydWUsXG4gICAgc2hhZG93RG9tOiB0cnVlLFxuICAgIHNsb3Q6IHRydWUsXG4gICAgY3NzQW5ub3RhdGlvbnM6IHRydWUsXG4gICAgc3RhdGU6IHRydWUsXG4gICAgc3R5bGU6IHRydWUsXG4gICAgc3ZnOiB0cnVlLFxuICAgIHVwZGF0YWJsZTogdHJ1ZSxcbiAgICB2ZG9tQXR0cmlidXRlOiB0cnVlLFxuICAgIHZkb21YbGluazogdHJ1ZSxcbiAgICB2ZG9tQ2xhc3M6IHRydWUsXG4gICAgdmRvbUZ1bmN0aW9uYWw6IHRydWUsXG4gICAgdmRvbUtleTogdHJ1ZSxcbiAgICB2ZG9tTGlzdGVuZXI6IHRydWUsXG4gICAgdmRvbVJlZjogdHJ1ZSxcbiAgICB2ZG9tUHJvcE9yQXR0cjogdHJ1ZSxcbiAgICB2ZG9tUmVuZGVyOiB0cnVlLFxuICAgIHZkb21TdHlsZTogdHJ1ZSxcbiAgICB2ZG9tVGV4dDogdHJ1ZSxcbiAgICB3YXRjaENhbGxiYWNrOiB0cnVlLFxuICAgIHRhc2tRdWV1ZTogdHJ1ZSxcbiAgICBob3RNb2R1bGVSZXBsYWNlbWVudDogZmFsc2UsXG4gICAgaXNEZWJ1ZzogZmFsc2UsXG4gICAgaXNEZXY6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogZmFsc2UsXG4gICAgaHlkcmF0ZVNlcnZlclNpZGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVDbGllbnRTaWRlOiBmYWxzZSxcbiAgICBsaWZlY3ljbGVET01FdmVudHM6IGZhbHNlLFxuICAgIGxhenlMb2FkOiBmYWxzZSxcbiAgICBwcm9maWxlOiBmYWxzZSxcbiAgICBzbG90UmVsb2NhdGlvbjogdHJ1ZSxcbiAgICBhcHBlbmRDaGlsZFNsb3RGaXg6IGZhbHNlLFxuICAgIGNsb25lTm9kZUZpeDogZmFsc2UsXG4gICAgaHlkcmF0ZWRBdHRyaWJ1dGU6IGZhbHNlLFxuICAgIGh5ZHJhdGVkQ2xhc3M6IHRydWUsXG4gICAgc2FmYXJpMTA6IGZhbHNlLFxuICAgIHNjcmlwdERhdGFPcHRzOiBmYWxzZSxcbiAgICBzY29wZWRTbG90VGV4dENvbnRlbnRGaXg6IGZhbHNlLFxuICAgIHNoYWRvd0RvbVNoaW06IGZhbHNlLFxuICAgIHNsb3RDaGlsZE5vZGVzRml4OiBmYWxzZSxcbiAgICBpbnZpc2libGVQcmVoeWRyYXRpb246IHRydWUsXG4gICAgcHJvcEJvb2xlYW46IHRydWUsXG4gICAgcHJvcE51bWJlcjogdHJ1ZSxcbiAgICBwcm9wU3RyaW5nOiB0cnVlLFxuICAgIGNzc1ZhclNoaW06IGZhbHNlLFxuICAgIGNvbnN0cnVjdGFibGVDU1M6IHRydWUsXG4gICAgY21wU2hvdWxkVXBkYXRlOiB0cnVlLFxuICAgIGRldlRvb2xzOiBmYWxzZSxcbiAgICBkeW5hbWljSW1wb3J0U2hpbTogZmFsc2UsXG4gICAgc2hhZG93RGVsZWdhdGVzRm9jdXM6IHRydWUsXG4gICAgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSxcbiAgICBhc3luY0xvYWRpbmc6IGZhbHNlLFxuICAgIGFzeW5jUXVldWU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLFxuICAgIGF0dGFjaFN0eWxlczogdHJ1ZSxcbn07XG5jb25zdCBFbnYgPSB7fTtcbmNvbnN0IE5BTUVTUEFDRSA9IC8qIGRlZmF1bHQgKi8gJ2FwcCc7XG5cbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9O1xuIiwibGV0IHNjb3BlSWQ7XG5sZXQgY29udGVudFJlZjtcbmxldCBob3N0VGFnTmFtZTtcbmxldCBjdXN0b21FcnJvcjtcbmxldCBpID0gMDtcbmxldCB1c2VOYXRpdmVTaGFkb3dEb20gPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSBmYWxzZTtcbmxldCBjaGVja1Nsb3RSZWxvY2F0ZSA9IGZhbHNlO1xubGV0IGlzU3ZnTW9kZSA9IGZhbHNlO1xubGV0IHJlbmRlcmluZ1JlZiA9IG51bGw7XG5sZXQgcXVldWVDb25nZXN0aW9uID0gMDtcbmxldCBxdWV1ZVBlbmRpbmcgPSBmYWxzZTtcbi8qXG4gU3RlbmNpbCBDbGllbnQgUGxhdGZvcm0gdjIuMTQuMiB8IE1JVCBMaWNlbnNlZCB8IGh0dHBzOi8vc3RlbmNpbGpzLmNvbVxuICovXG5pbXBvcnQgeyBCVUlMRCwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuY29uc3QgQ1NTID0gQlVJTEQuY3NzVmFyU2hpbSA/IHdpbi5DU1MgOiBudWxsO1xuY29uc3QgZG9jID0gd2luLmRvY3VtZW50IHx8IHsgaGVhZDoge30gfTtcbmNvbnN0IEggPSAod2luLkhUTUxFbGVtZW50IHx8IGNsYXNzIHtcbn0pO1xuY29uc3QgcGx0ID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHJlc291cmNlc1VybCQ6ICcnLFxuICAgIGptcDogKGgpID0+IGgoKSxcbiAgICByYWY6IChoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCksXG4gICAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgcmVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gICAgY2U6IChldmVudE5hbWUsIG9wdHMpID0+IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIG9wdHMpLFxufTtcbmNvbnN0IHNldFBsYXRmb3JtSGVscGVycyA9IChoZWxwZXJzKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIGhlbHBlcnMpO1xufTtcbmNvbnN0IHN1cHBvcnRzU2hhZG93ID0gQlVJTEQuc2hhZG93RG9tU2hpbSAmJiBCVUlMRC5zaGFkb3dEb21cbiAgICA/IC8qQF9fUFVSRV9fKi8gKCgpID0+IChkb2MuaGVhZC5hdHRhY2hTaGFkb3cgKyAnJykuaW5kZXhPZignW25hdGl2ZScpID4gLTEpKClcbiAgICA6IHRydWU7XG5jb25zdCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICBsZXQgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zO1xufSkoKTtcbmNvbnN0IHByb21pc2VSZXNvbHZlID0gKHYpID0+IFByb21pc2UucmVzb2x2ZSh2KTtcbmNvbnN0IHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzID0gQlVJTEQuY29uc3RydWN0YWJsZUNTU1xuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmV3IENTU1N0eWxlU2hlZXQoKS5yZXBsYWNlID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pKClcbiAgICA6IGZhbHNlO1xuY29uc3QgQ29udGV4dCA9IHt9O1xuY29uc3QgYWRkSG9zdEV2ZW50TGlzdGVuZXJzID0gKGVsbSwgaG9zdFJlZiwgbGlzdGVuZXJzLCBhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpID0+IHtcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyICYmIGxpc3RlbmVycykge1xuICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoaW4gdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBpbml0aWFsaXplIG91ciBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAvLyB3ZSBkbyB0aGlzIG5vdyBzbyB0aGF0IHdlIGNhbiBsaXN0ZW4gdG8gZXZlbnRzIHRoYXQgbWF5XG4gICAgICAgIC8vIGhhdmUgZmlyZWQgZXZlbiBiZWZvcmUgdGhlIGluc3RhbmNlIGlzIHJlYWR5XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IG1heSBoYXZlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICBpZiAoYXR0YWNoUGFyZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgaW1wb3J0YW50IHNvIHRoYXQgd2Uga25vdyB0aGUgaG9zdCBlbGVtZW50IGFjdHVhbGx5IGhhcyBhIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRvIG9ubHkgaGF2ZSB0aGUgb25lcyB0aGF0IEFSRSBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWluZyByYW4gZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgQlVUIHRoZSBwYXJlbnQgZWxlbWVudCBsaXN0ZW5lcnMgc2hvdWxkIGJlIGF0dGFjaGVkIGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGhlIGxpc3RlbmVycyB0aGF0IGFyZSBOT1QgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKFtmbGFnc10pID0+ICEoZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldCA/IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA6IGVsbTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBob3N0TGlzdGVuZXJQcm94eShob3N0UmVmLCBtZXRob2QpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IGhvc3RMaXN0ZW5lck9wdHMoZmxhZ3MpO1xuICAgICAgICAgICAgcGx0LmFlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpO1xuICAgICAgICAgICAgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCB8fCBbXSkucHVzaCgoKSA9PiBwbHQucmVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaG9zdExpc3RlbmVyUHJveHkgPSAoaG9zdFJlZiwgbWV0aG9kTmFtZSkgPT4gKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZSBpcyByZWFkeSwgbGV0J3MgY2FsbCBpdCdzIG1lbWJlciBtZXRob2QgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRsYXp5SW5zdGFuY2UkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCB8fCBbXSkucHVzaChbbWV0aG9kTmFtZSwgZXZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGhvc3RFbGVtZW50JFttZXRob2ROYW1lXShldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbn07XG5jb25zdCBnZXRIb3N0TGlzdGVuZXJUYXJnZXQgPSAoZWxtLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudCAmJiBmbGFncyAmIDQgLyogVGFyZ2V0RG9jdW1lbnQgKi8pXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdyAmJiBmbGFncyAmIDggLyogVGFyZ2V0V2luZG93ICovKVxuICAgICAgICByZXR1cm4gd2luO1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRCb2R5ICYmIGZsYWdzICYgMTYgLyogVGFyZ2V0Qm9keSAqLylcbiAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQgJiYgZmxhZ3MgJiAzMiAvKiBUYXJnZXRQYXJlbnQgKi8pXG4gICAgICAgIHJldHVybiBlbG0ucGFyZW50RWxlbWVudDtcbiAgICByZXR1cm4gZWxtO1xufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgaG9zdExpc3RlbmVyT3B0cyA9IChmbGFncykgPT4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnNcbiAgICA/ICh7XG4gICAgICAgIHBhc3NpdmU6IChmbGFncyAmIDEgLyogUGFzc2l2ZSAqLykgIT09IDAsXG4gICAgICAgIGNhcHR1cmU6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDAsXG4gICAgfSlcbiAgICA6IChmbGFncyAmIDIgLyogQ2FwdHVyZSAqLykgIT09IDA7XG5jb25zdCBDT05URU5UX1JFRl9JRCA9ICdyJztcbmNvbnN0IE9SR19MT0NBVElPTl9JRCA9ICdvJztcbmNvbnN0IFNMT1RfTk9ERV9JRCA9ICdzJztcbmNvbnN0IFRFWFRfTk9ERV9JRCA9ICd0JztcbmNvbnN0IEhZRFJBVEVfSUQgPSAncy1pZCc7XG5jb25zdCBIWURSQVRFRF9TVFlMRV9JRCA9ICdzdHktaWQnO1xuY29uc3QgSFlEUkFURV9DSElMRF9JRCA9ICdjLWlkJztcbmNvbnN0IEhZRFJBVEVEX0NTUyA9ICd7dmlzaWJpbGl0eTpoaWRkZW59Lmh5ZHJhdGVke3Zpc2liaWxpdHk6aW5oZXJpdH0nO1xuY29uc3QgWExJTktfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBjcmVhdGVUaW1lID0gKGZuTmFtZSwgdGFnTmFtZSA9ICcnKSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBjb25zdCBrZXkgPSBgc3Q6JHtmbk5hbWV9OiR7dGFnTmFtZX06JHtpKyt9YDtcbiAgICAgICAgLy8gU3RhcnRcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICAvLyBFbmRcbiAgICAgICAgcmV0dXJuICgpID0+IHBlcmZvcm1hbmNlLm1lYXN1cmUoYFtTdGVuY2lsXSAke2ZuTmFtZX0oKSA8JHt0YWdOYW1lfT5gLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdW5pcXVlVGltZSA9IChrZXksIG1lYXN1cmVUZXh0KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShrZXkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShtZWFzdXJlVGV4dCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlVGV4dCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBpZiAoIWhvc3RSZWYpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmxhZ3MgPSBob3N0UmVmLiRmbGFncyQ7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyQ291bnQ6IGhvc3RSZWYuJHJlbmRlckNvdW50JCxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkOiAhIShmbGFncyAmIDIgLyogaGFzUmVuZGVyZWQgKi8pLFxuICAgICAgICAgICAgaGFzQ29ubmVjdGVkOiAhIShmbGFncyAmIDEgLyogaGFzQ29ubmVjdGVkICovKSxcbiAgICAgICAgICAgIGlzV2FpdGluZ0ZvckNoaWxkcmVuOiAhIShmbGFncyAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pLFxuICAgICAgICAgICAgaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZTogISEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pLFxuICAgICAgICAgICAgaXNRdWV1ZWRGb3JVcGRhdGU6ICEhKGZsYWdzICYgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pLFxuICAgICAgICAgICAgaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pLFxuICAgICAgICAgICAgaGFzTG9hZGVkQ29tcG9uZW50OiAhIShmbGFncyAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBpc1dhdGNoUmVhZHk6ICEhKGZsYWdzICYgMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLyksXG4gICAgICAgICAgICBpc0xpc3RlblJlYWR5OiAhIShmbGFncyAmIDI1NiAvKiBpc0xpc3RlblJlYWR5ICovKSxcbiAgICAgICAgICAgIG5lZWRzUmVyZW5kZXI6ICEhKGZsYWdzICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pLFxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVZhbHVlczogaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLFxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudDogaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkLFxuICAgICAgICBob3N0RWxlbWVudCxcbiAgICAgICAgbGF6eUluc3RhbmNlOiBob3N0UmVmLiRsYXp5SW5zdGFuY2UkLFxuICAgICAgICB2bm9kZTogaG9zdFJlZi4kdm5vZGUkLFxuICAgICAgICBtb2RlTmFtZTogaG9zdFJlZi4kbW9kZU5hbWUkLFxuICAgICAgICBvblJlYWR5UHJvbWlzZTogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLFxuICAgICAgICBvblJlYWR5UmVzb2x2ZTogaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkLFxuICAgICAgICBvbkluc3RhbmNlUHJvbWlzZTogaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkLFxuICAgICAgICBvbkluc3RhbmNlUmVzb2x2ZTogaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkLFxuICAgICAgICBvblJlbmRlclJlc29sdmU6IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQsXG4gICAgICAgIHF1ZXVlZExpc3RlbmVyczogaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCxcbiAgICAgICAgcm1MaXN0ZW5lcnM6IGhvc3RSZWYuJHJtTGlzdGVuZXJzJCxcbiAgICAgICAgWydzLWlkJ106IGhvc3RFbGVtZW50WydzLWlkJ10sXG4gICAgICAgIFsncy1jciddOiBob3N0RWxlbWVudFsncy1jciddLFxuICAgICAgICBbJ3MtbHInXTogaG9zdEVsZW1lbnRbJ3MtbHInXSxcbiAgICAgICAgWydzLXAnXTogaG9zdEVsZW1lbnRbJ3MtcCddLFxuICAgICAgICBbJ3MtcmMnXTogaG9zdEVsZW1lbnRbJ3MtcmMnXSxcbiAgICAgICAgWydzLXNjJ106IGhvc3RFbGVtZW50WydzLXNjJ10sXG4gICAgfTtcbn07XG5jb25zdCBpbnN0YWxsRGV2VG9vbHMgPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmRldlRvb2xzKSB7XG4gICAgICAgIGNvbnN0IHN0ZW5jaWwgPSAod2luLnN0ZW5jaWwgPSB3aW4uc3RlbmNpbCB8fCB7fSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5zcGVjdCA9IHN0ZW5jaWwuaW5zcGVjdDtcbiAgICAgICAgc3RlbmNpbC5pbnNwZWN0ID0gKHJlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIHR5cGVvZiBvcmlnaW5hbEluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW5hbEluc3BlY3QocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IHJvb3RBcHBsaWVkU3R5bGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyU3R5bGUgPSAoc2NvcGVJZCwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKHN1cHBvcnRzQ29uc3RydWN0aWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICAgICAgc3R5bGUgPSAoc3R5bGUgfHwgbmV3IENTU1N0eWxlU2hlZXQoKSk7XG4gICAgICAgIHN0eWxlLnJlcGxhY2UoY3NzVGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGNzc1RleHQ7XG4gICAgfVxuICAgIHN0eWxlcy5zZXQoc2NvcGVJZCwgc3R5bGUpO1xufTtcbmNvbnN0IGFkZFN0eWxlID0gKHN0eWxlQ29udGFpbmVyTm9kZSwgY21wTWV0YSwgbW9kZSwgaG9zdEVsbSkgPT4ge1xuICAgIGxldCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmICghQlVJTEQuYXR0YWNoU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUlkO1xuICAgIH1cbiAgICAvLyBpZiBhbiBlbGVtZW50IGlzIE5PVCBjb25uZWN0ZWQgdGhlbiBnZXRSb290Tm9kZSgpIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyByb290IG5vZGVcbiAgICAvLyBzbyB0aGUgZmFsbGJhY2sgaXMgdG8gYWx3YXlzIHVzZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSByb290IG5vZGUgaW4gdGhvc2UgY2FzZXNcbiAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gPyBzdHlsZUNvbnRhaW5lck5vZGUgOiBkb2M7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUuaGVhZCB8fCBzdHlsZUNvbnRhaW5lck5vZGU7XG4gICAgICAgICAgICBsZXQgYXBwbGllZFN0eWxlcyA9IHJvb3RBcHBsaWVkU3R5bGVzLmdldChzdHlsZUNvbnRhaW5lck5vZGUpO1xuICAgICAgICAgICAgbGV0IHN0eWxlRWxtO1xuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcm9vdEFwcGxpZWRTdHlsZXMuc2V0KHN0eWxlQ29udGFpbmVyTm9kZSwgKGFwcGxpZWRTdHlsZXMgPSBuZXcgU2V0KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmhvc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlRWxtID0gc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoYFske0hZRFJBVEVEX1NUWUxFX0lEfT1cIiR7c2NvcGVJZH1cIl1gKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGhhcHBlbmluZyBvbiBuYXRpdmUgc2hhZG93LWRvbSwgZG8gbm90IG5lZWRzIENTUyB2YXIgc2hpbVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtID0gcGx0LiRjc3NTaGltJC5jcmVhdGVIb3N0U3R5bGUoaG9zdEVsbSwgc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NvcGVJZCA9IHN0eWxlRWxtWydzLXNjJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlSWQgPSBuZXdTY29wZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgc3R5bGVJRCB0byB0aGUgYXBwbGllZFN0eWxlcyBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY3NzVmFyU2hpbSBtaWdodCBuZWVkIHRvIGFwcGx5IHNldmVyYWwgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzaGVldHMgZm9yIHRoZSBzYW1lIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVEX1NUWUxFX0lELCBzY29wZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlRWxtLCBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcignbGluaycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcy5hZGQoc2NvcGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELmNvbnN0cnVjdGFibGVDU1MgJiYgIXN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuYWRvcHRlZFN0eWxlU2hlZXRzID0gWy4uLnN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMsIHN0eWxlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGVJZDtcbn07XG5jb25zdCBhdHRhY2hTdHlsZXMgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgY29uc3QgZW5kQXR0YWNoU3R5bGVzID0gY3JlYXRlVGltZSgnYXR0YWNoU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHNjb3BlSWQgPSBhZGRTdHlsZShCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgZWxtLnNoYWRvd1Jvb3QgPyBlbG0uc2hhZG93Um9vdCA6IGVsbS5nZXRSb290Tm9kZSgpLCBjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQsIGVsbSk7XG4gICAgaWYgKChCVUlMRC5zaGFkb3dEb20gfHwgQlVJTEQuc2NvcGVkKSAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucyAmJiBmbGFncyAmIDEwIC8qIG5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgICAgIGlmIChCVUlMRC5zY29wZWQgJiYgZmxhZ3MgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmRBdHRhY2hTdHlsZXMoKTtcbn07XG5jb25zdCBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gJ3NjLScgKyAoQlVJTEQubW9kZSAmJiBtb2RlICYmIGNtcC4kZmxhZ3MkICYgMzIgLyogaGFzTW9kZSAqLyA/IGNtcC4kdGFnTmFtZSQgKyAnLScgKyBtb2RlIDogY21wLiR0YWdOYW1lJCk7XG5jb25zdCBjb252ZXJ0U2NvcGVkVG9TaGFkb3cgPSAoY3NzKSA9PiBjc3MucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csICckMXsnKTtcbi8vIFByaXZhdGVcbmNvbnN0IGNvbXB1dGVNb2RlID0gKGVsbSkgPT4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGgpID0+IGgoZWxtKSkuZmluZCgobSkgPT4gISFtKTtcbi8vIFB1YmxpY1xuY29uc3Qgc2V0TW9kZSA9IChoYW5kbGVyKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLnB1c2goaGFuZGxlcik7XG5jb25zdCBnZXRNb2RlID0gKHJlZikgPT4gZ2V0SG9zdFJlZihyZWYpLiRtb2RlTmFtZSQ7XG4vKipcbiAqIERlZmF1bHQgc3R5bGUgbW9kZSBpZFxuICovXG4vKipcbiAqIFJldXNhYmxlIGVtcHR5IG9iai9hcnJheVxuICogRG9uJ3QgYWRkIHZhbHVlcyB0byB0aGVzZSEhXG4gKi9cbmNvbnN0IEVNUFRZX09CSiA9IHt9O1xuLyoqXG4gKiBOYW1lc3BhY2VzXG4gKi9cbmNvbnN0IFNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5jb25zdCBIVE1MX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuY29uc3QgaXNEZWYgPSAodikgPT4gdiAhPSBudWxsO1xuY29uc3QgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3R5cGVvZi1mbi1vYmplY3QvNVxuICAgIG8gPSB0eXBlb2YgbztcbiAgICByZXR1cm4gbyA9PT0gJ29iamVjdCcgfHwgbyA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gaCgpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG4vLyBjb25zdCBzdGFjazogYW55W10gPSBbXTtcbi8vIGV4cG9ydCBmdW5jdGlvbiBoKG5vZGVOYW1lOiBzdHJpbmcgfCBkLkZ1bmN0aW9uYWxDb21wb25lbnQsIHZub2RlRGF0YTogZC5Qcm9wc1R5cGUsIGNoaWxkPzogZC5DaGlsZFR5cGUpOiBkLlZOb2RlO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgLi4uY2hpbGRyZW46IGQuQ2hpbGRUeXBlW10pOiBkLlZOb2RlO1xuY29uc3QgaCA9IChub2RlTmFtZSwgdm5vZGVEYXRhLCAuLi5jaGlsZHJlbikgPT4ge1xuICAgIGxldCBjaGlsZCA9IG51bGw7XG4gICAgbGV0IGtleSA9IG51bGw7XG4gICAgbGV0IHNsb3ROYW1lID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgdk5vZGVDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gY1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmICgoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nICYmICFpc0NvbXBsZXhUeXBlKGNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBTdHJpbmcoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5pc0RldiAmJiB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgY2hpbGQuJGZsYWdzJCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZFcnJvcihgdk5vZGUgcGFzc2VkIGFzIGNoaWxkcmVuIGhhcyB1bmV4cGVjdGVkIHR5cGUuXG5NYWtlIHN1cmUgaXQncyB1c2luZyB0aGUgY29ycmVjdCBoKCkgZnVuY3Rpb24uXG5FbXB0eSBvYmplY3RzIGNhbiBhbHNvIGJlIHRoZSBjYXVzZSwgbG9vayBmb3IgSlNYIGNvbW1lbnRzIHRoYXQgYmVjYW1lIG9iamVjdHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYgJiYgbm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzKHZub2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGNsYXNzIC8gY2xhc3NuYW1lIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgdm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGVEYXRhLm5hbWUpIHtcbiAgICAgICAgICAgIHNsb3ROYW1lID0gdm5vZGVEYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NEYXRhID0gdm5vZGVEYXRhLmNsYXNzTmFtZSB8fCB2bm9kZURhdGEuY2xhc3M7XG4gICAgICAgICAgICBpZiAoY2xhc3NEYXRhKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEYXRhLmNsYXNzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNsYXNzRGF0YSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xhc3NEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKGNsYXNzRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChrKSA9PiBjbGFzc0RhdGFba10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdk5vZGVDaGlsZHJlbi5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC4gTWFrZSBzdXJlOlxuLSBZb3UgYXJlIE5PVCB1c2luZyBob3N0RGF0YSgpIGFuZCA8SG9zdD4gaW4gdGhlIHNhbWUgY29tcG9uZW50LlxuLSA8SG9zdD4gaXMgdXNlZCBvbmNlLCBhbmQgaXQncyB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50IG9mIHRoZSByZW5kZXIoKSBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21GdW5jdGlvbmFsICYmIHR5cGVvZiBub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub2RlTmFtZSBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICAgIHJldHVybiBub2RlTmFtZSh2bm9kZURhdGEgPT09IG51bGwgPyB7fSA6IHZub2RlRGF0YSwgdk5vZGVDaGlsZHJlbiwgdmRvbUZuVXRpbHMpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGVOYW1lLCBudWxsKTtcbiAgICB2bm9kZS4kYXR0cnMkID0gdm5vZGVEYXRhO1xuICAgIGlmICh2Tm9kZUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdm5vZGUuJGNoaWxkcmVuJCA9IHZOb2RlQ2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0ga2V5O1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgdm5vZGUuJG5hbWUkID0gc2xvdE5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBuZXdWTm9kZSA9ICh0YWcsIHRleHQpID0+IHtcbiAgICBjb25zdCB2bm9kZSA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJHRhZyQ6IHRhZyxcbiAgICAgICAgJHRleHQkOiB0ZXh0LFxuICAgICAgICAkZWxtJDogbnVsbCxcbiAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICB9O1xuICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgIHZub2RlLiRhdHRycyQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICB2bm9kZS4ka2V5JCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgSG9zdCA9IHt9O1xuY29uc3QgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbmNvbnN0IHZkb21GblV0aWxzID0ge1xuICAgIGZvckVhY2g6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLmZvckVhY2goY2IpLFxuICAgIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSksXG59O1xuY29uc3QgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gICAgdmF0dHJzOiBub2RlLiRhdHRycyQsXG4gICAgdmNoaWxkcmVuOiBub2RlLiRjaGlsZHJlbiQsXG4gICAgdmtleTogbm9kZS4ka2V5JCxcbiAgICB2bmFtZTogbm9kZS4kbmFtZSQsXG4gICAgdnRhZzogbm9kZS4kdGFnJCxcbiAgICB2dGV4dDogbm9kZS4kdGV4dCQsXG59KTtcbmNvbnN0IGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52dGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHZub2RlRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUudmF0dHJzKTtcbiAgICAgICAgaWYgKG5vZGUudmtleSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLmtleSA9IG5vZGUudmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52bmFtZSkge1xuICAgICAgICAgICAgdm5vZGVEYXRhLm5hbWUgPSBub2RlLnZuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi4obm9kZS52Y2hpbGRyZW4gfHwgW10pKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICAgIHZub2RlLiRhdHRycyQgPSBub2RlLnZhdHRycztcbiAgICB2bm9kZS4kY2hpbGRyZW4kID0gbm9kZS52Y2hpbGRyZW47XG4gICAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gICAgdm5vZGUuJG5hbWUkID0gbm9kZS52bmFtZTtcbiAgICByZXR1cm4gdm5vZGU7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG9yZGVyaW5nIG9mIGF0dHJpYnV0ZXMgb24gYW4gaW5wdXQgZWxlbWVudFxuICogQHBhcmFtIGlucHV0RWxtIHRoZSBlbGVtZW50IHRvIHZhbGlkYXRlXG4gKi9cbmNvbnN0IHZhbGlkYXRlSW5wdXRQcm9wZXJ0aWVzID0gKGlucHV0RWxtKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhpbnB1dEVsbSk7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wcy5pbmRleE9mKCd2YWx1ZScpO1xuICAgIGlmICh2YWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlSW5kZXggPSBwcm9wcy5pbmRleE9mKCd0eXBlJyk7XG4gICAgY29uc3QgbWluSW5kZXggPSBwcm9wcy5pbmRleE9mKCdtaW4nKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IHByb3BzLmluZGV4T2YoJ21heCcpO1xuICAgIGNvbnN0IHN0ZXBJbmRleCA9IHByb3BzLmluZGV4T2YoJ3N0ZXAnKTtcbiAgICBpZiAodmFsdWUgPCB0eXBlSW5kZXggfHwgdmFsdWUgPCBtaW5JbmRleCB8fCB2YWx1ZSA8IG1heEluZGV4IHx8IHZhbHVlIDwgc3RlcEluZGV4KSB7XG4gICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgXCJ2YWx1ZVwiIHByb3Agb2YgPGlucHV0PiBzaG91bGQgYmUgc2V0IGFmdGVyIFwibWluXCIsIFwibWF4XCIsIFwidHlwZVwiIGFuZCBcInN0ZXBcImApO1xuICAgIH1cbn07XG4vKipcbiAqIFByb2R1Y3Rpb24gc2V0QWNjZXNzb3IoKSBmdW5jdGlvbiBiYXNlZCBvbiBQcmVhY3QgYnlcbiAqIEphc29uIE1pbGxlciAoQGRldmVsb3BpdClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1vZGlmaWVkIGZvciBTdGVuY2lsJ3MgY29tcGlsZXIgYW5kIHZkb21cbiAqL1xuY29uc3Qgc2V0QWNjZXNzb3IgPSAoZWxtLCBtZW1iZXJOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGlzU3ZnLCBmbGFncykgPT4ge1xuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IGlzUHJvcCA9IGlzTWVtYmVySW5FbGVtZW50KGVsbSwgbWVtYmVyTmFtZSk7XG4gICAgICAgIGxldCBsbiA9IG1lbWJlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKEJVSUxELnZkb21DbGFzcyAmJiBtZW1iZXJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbG0uY2xhc3NMaXN0O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG9sZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLm9sZENsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFuZXdDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMuZmlsdGVyKChjKSA9PiBjICYmICFvbGRDbGFzc2VzLmluY2x1ZGVzKGMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbVN0eWxlICYmIG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBwcm9wLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSBuZXdWYWx1ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tS2V5ICYmIG1lbWJlck5hbWUgPT09ICdrZXknKVxuICAgICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUmVmICYmIG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudmRvbUxpc3RlbmVyICYmXG4gICAgICAgICAgICAoQlVJTEQubGF6eUxvYWQgPyAhaXNQcm9wIDogIWVsbS5fX2xvb2t1cFNldHRlcl9fKG1lbWJlck5hbWUpKSAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVswXSA9PT0gJ28nICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tUHJvcE9yQXR0cikge1xuICAgICAgICAgICAgLy8gU2V0IHByb3BlcnR5IGlmIGl0IGV4aXN0cyBhbmQgaXQncyBub3QgYSBTVkdcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKChpc1Byb3AgfHwgKGlzQ29tcGxleCAmJiBuZXdWYWx1ZSAhPT0gbnVsbCkpICYmICFpc1N2Zykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxtLnRhZ05hbWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tWGxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUobWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoIWlzUHJvcCB8fCBmbGFncyAmIDQgLyogaXNIb3N0ICovIHx8IGlzU3ZnKSAmJiAhaXNDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluayAmJiB4bGluaykge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUobWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwYXJzZUNsYXNzTGlzdFJlZ2V4ID0gL1xccy87XG5jb25zdCBwYXJzZUNsYXNzTGlzdCA9ICh2YWx1ZSkgPT4gKCF2YWx1ZSA/IFtdIDogdmFsdWUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCkpO1xuY29uc3QgdXBkYXRlRWxlbWVudCA9IChvbGRWbm9kZSwgbmV3Vm5vZGUsIGlzU3ZnTW9kZSwgbWVtYmVyTmFtZSkgPT4ge1xuICAgIC8vIGlmIHRoZSBlbGVtZW50IHBhc3NlZCBpbiBpcyBhIHNoYWRvdyByb290LCB3aGljaCBpcyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgLy8gdGhlbiB3ZSB3YW50IHRvIGJlIGFkZGluZyBhdHRycy9wcm9wcyB0byB0aGUgc2hhZG93IHJvb3QncyBcImhvc3RcIiBlbGVtZW50XG4gICAgLy8gaWYgaXQncyBub3QgYSBzaGFkb3cgcm9vdCwgdGhlbiB3ZSBhZGQgYXR0cnMvcHJvcHMgdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgIGNvbnN0IGVsbSA9IG5ld1Zub2RlLiRlbG0kLm5vZGVUeXBlID09PSAxMSAvKiBEb2N1bWVudEZyYWdtZW50ICovICYmIG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgPyBuZXdWbm9kZS4kZWxtJC5ob3N0XG4gICAgICAgIDogbmV3Vm5vZGUuJGVsbSQ7XG4gICAgY29uc3Qgb2xkVm5vZGVBdHRycyA9IChvbGRWbm9kZSAmJiBvbGRWbm9kZS4kYXR0cnMkKSB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3Vm5vZGVBdHRycyA9IG5ld1Zub2RlLiRhdHRycyQgfHwgRU1QVFlfT0JKO1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgbm8gbG9uZ2VyIHByZXNlbnQgb24gdGhlIHZub2RlIGJ5IHNldHRpbmcgdGhlbSB0byB1bmRlZmluZWRcbiAgICAgICAgZm9yIChtZW1iZXJOYW1lIGluIG9sZFZub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghKG1lbWJlck5hbWUgaW4gbmV3Vm5vZGVBdHRycykpIHtcbiAgICAgICAgICAgICAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIHVuZGVmaW5lZCwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgIGZvciAobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgbmV3Vm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgaXNTdmdNb2RlLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICB9XG59O1xuY29uc3QgY3JlYXRlRWxtID0gKG9sZFBhcmVudFZOb2RlLCBuZXdQYXJlbnRWTm9kZSwgY2hpbGRJbmRleCwgcGFyZW50RWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgbmV3Vk5vZGUgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZWxtO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG9sZFZOb2RlO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhdXNlTmF0aXZlU2hhZG93RG9tKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZvciBsYXRlciB3ZSBuZWVkIHRvIGNoZWNrIHRvIHJlbG9jYXRlIG5vZGVzXG4gICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NvcGVkIGNzcyBuZWVkcyB0byBhZGQgaXRzIHNjb3BlZCBpZCB0byB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBwYXJlbnRFbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWTm9kZS4kZmxhZ3MkIHw9IG5ld1ZOb2RlLiRjaGlsZHJlbiRcbiAgICAgICAgICAgICAgICA/IC8vIHNsb3QgZWxlbWVudCBoYXMgZmFsbGJhY2sgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgOiAvLyBzbG90IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDEgLyogaXNTbG90UmVmZXJlbmNlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiBuZXdWTm9kZS4kZWxtJCkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSBKU1ggJHtuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwgPyBgXCIke25ld1ZOb2RlLiR0ZXh0JH1cIiB0ZXh0YCA6IGBcIiR7bmV3Vk5vZGUuJHRhZyR9XCIgZWxlbWVudGB9IG5vZGUgc2hvdWxkIG5vdCBiZSBzaGFyZWQgd2l0aGluIHRoZSBzYW1lIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2FjaGVzIGVsZW1lbnQgbG9va3VwcyBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLiBIb3dldmVyLCBhIHNpZGUgZWZmZWN0IGZyb20gdGhpcyBpcyB0aGF0IHRoZSBleGFjdCBzYW1lIEpTWCBub2RlIHNob3VsZCBub3QgYmUgcmV1c2VkLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2Ugc2VlIGh0dHBzOi8vc3RlbmNpbGpzLmNvbS9kb2NzL3RlbXBsYXRpbmctanN4I2F2b2lkLXNoYXJlZC1qc3gtbm9kZXNgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21UZXh0ICYmIG5ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZVRleHROb2RlKG5ld1ZOb2RlLiR0ZXh0JCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAxIC8qIGlzU2xvdFJlZmVyZW5jZSAqLykge1xuICAgICAgICAvLyBjcmVhdGUgYSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID1cbiAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBzbG90UmVmZXJlbmNlRGVidWdOb2RlKG5ld1ZOb2RlKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmICFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChCVUlMRC5zdmdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhpc1N2Z01vZGUgPyBTVkdfTlMgOiBIVE1MX05TLCBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJClcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA/ICdzbG90LWZiJ1xuICAgICAgICAgICAgICAgIDogbmV3Vk5vZGUuJHRhZyQpKTtcbiAgICAgICAgaWYgKEJVSUxELnN2ZyAmJiBpc1N2Z01vZGUgJiYgbmV3Vk5vZGUuJHRhZyQgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICBpZiAoQlVJTEQudmRvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChudWxsLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGksIGVsbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIG5vZGUgY291bGQgaGF2ZSBiZWVuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBvdXIgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWTm9kZS4kdGFnJCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRoZSBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPHN2Zz4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlZW50ZXIgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxmb3JlaWduT2JqZWN0PiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgZWxtWydzLWhuJ10gPSBob3N0VGFnTmFtZTtcbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRmbGFncyQgJiAoMiAvKiBpc1Nsb3RGYWxsYmFjayAqLyB8IDEgLyogaXNTbG90UmVmZXJlbmNlICovKSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50XG4gICAgICAgICAgICBlbG1bJ3MtY3InXSA9IGNvbnRlbnRSZWY7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgc2xvdCBuYW1lLCBvciBlbXB0eSBzdHJpbmcgZm9yIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgZWxtWydzLXNuJ10gPSBuZXdWTm9kZS4kbmFtZSQgfHwgJyc7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYW4gb2xkIHZub2RlIGZvciB0aGlzIHNsb3RcbiAgICAgICAgICAgIG9sZFZOb2RlID0gb2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuJGNoaWxkcmVuJCAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9sZFZOb2RlICYmIG9sZFZOb2RlLiR0YWckID09PSBuZXdWTm9kZS4kdGFnJCAmJiBvbGRQYXJlbnRWTm9kZS4kZWxtJCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGdvdCBhbiBvbGQgc2xvdCB2bm9kZSBhbmQgdGhlIHdyYXBwZXIgaXMgYmVpbmcgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAvLyBzbyBsZXQncyBtb3ZlIHRoZSBvbGQgc2xvdCBjb250ZW50IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkUGFyZW50Vk5vZGUuJGVsbSQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxtO1xufTtcbmNvbnN0IHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24gPSAocGFyZW50RWxtLCByZWN1cnNpdmUpID0+IHtcbiAgICBwbHQuJGZsYWdzJCB8PSAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xuICAgIGNvbnN0IG9sZFNsb3RDaGlsZE5vZGVzID0gcGFyZW50RWxtLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IG9sZFNsb3RDaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG9sZFNsb3RDaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLWhuJ10gIT09IGhvc3RUYWdOYW1lICYmIGNoaWxkTm9kZVsncy1vbCddKSB7XG4gICAgICAgICAgICAvLyAvLyB0aGlzIGNoaWxkIG5vZGUgaW4gdGhlIG9sZCBlbGVtZW50IGlzIGZyb20gYW5vdGhlciBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgb2xkIHNsb3QncyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNoaWxkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIC8vIGFuZCByZWxvY2F0ZSBpdCBiYWNrIHRvIGl0J3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHBhcmVudFJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudCBlbnRpcmVseVxuICAgICAgICAgICAgLy8gbGF0ZXIgb24gdGhlIHBhdGNoIGZ1bmN0aW9uIHdpbGwga25vdyB3aGF0IHRvIGRvXG4gICAgICAgICAgICAvLyBhbmQgbW92ZSB0aGlzIHRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gbmVlZCBiZVxuICAgICAgICAgICAgY2hpbGROb2RlWydzLW9sJ10ucmVtb3ZlKCk7XG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoZWNrU2xvdFJlbG9jYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGNoaWxkTm9kZSwgcmVjdXJzaXZlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBwYXJlbnRFbG1bJ3MtY3InXSAmJiBwYXJlbnRFbG1bJ3MtY3InXS5wYXJlbnROb2RlKSB8fCBwYXJlbnRFbG0pO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyRWxtID0gY29udGFpbmVyRWxtLnNoYWRvd1Jvb3Q7XG4gICAgfVxuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVzW3N0YXJ0SWR4XS4kZWxtJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbG0uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgQlVJTEQuc2xvdFJlbG9jYXRpb24gPyByZWZlcmVuY2VOb2RlKGJlZm9yZSkgOiBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgcmVtb3ZpbmcgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvIHNob3cgc2xvdCBmYWxsYmFjayBjb250ZW50IG5vd1xuICAgICAgICAgICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsbVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBlbG1bJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCBjaGlsZCBub2RlcyBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0J3MgYmVpbmcgcmVtb3ZlZCBhcmUgc2xvdCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGVsbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUsIG5ld0NoKSA9PiB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBpZHhJbk9sZCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGVsbVRvTW92ZTtcbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtaWdodCBoYXZlIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZEVuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld0VuZFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChvbGRTdGFydFZub2RlLiR0YWckID09PSAnc2xvdCcgfHwgbmV3RW5kVm5vZGUuJHRhZyQgPT09ICdzbG90JykpIHtcbiAgICAgICAgICAgICAgICBwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKG9sZEVuZFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGVLZXlUb09sZElkeFxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gb2xkU3RhcnRJZHg7IGkgPD0gb2xkRW5kSWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENoW2ldICYmIG9sZENoW2ldLiRrZXkkICE9PSBudWxsICYmIG9sZENoW2ldLiRrZXkkID09PSBuZXdTdGFydFZub2RlLiRrZXkkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tS2V5ICYmIGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsbVRvTW92ZS4kdGFnJCAhPT0gbmV3U3RhcnRWbm9kZS4kdGFnJCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIGlkeEluT2xkLCBwYXJlbnRFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxtVG9Nb3ZlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgbmV3U3RhcnRJZHgsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmZXJlbmNlTm9kZShvbGRTdGFydFZub2RlLiRlbG0kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxufTtcbmNvbnN0IGlzU2FtZVZub2RlID0gKHZub2RlMSwgdm5vZGUyKSA9PiB7XG4gICAgLy8gY29tcGFyZSBpZiB0d28gdm5vZGUgdG8gc2VlIGlmIHRoZXkncmUgXCJ0ZWNobmljYWxseVwiIHRoZSBzYW1lXG4gICAgLy8gbmVlZCB0byBoYXZlIHRoZSBzYW1lIGVsZW1lbnQgdGFnLCBhbmQgc2FtZSBrZXkgdG8gYmUgdGhlIHNhbWVcbiAgICBpZiAodm5vZGUxLiR0YWckID09PSB2bm9kZTIuJHRhZyQpIHtcbiAgICAgICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHZub2RlMS4kdGFnJCA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRuYW1lJCA9PT0gdm5vZGUyLiRuYW1lJDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS4ka2V5JCA9PT0gdm5vZGUyLiRrZXkkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgcmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgLy8gdGhpcyBub2RlIHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGRvbVxuICAgIC8vIGJlY2F1c2Ugb2Ygc29tZSBvdGhlciBjb21wb25lbnQncyBzbG90XG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYW4gaHRtbCBjb21tZW50IGluIHBsYWNlIG9mIHdoZXJlXG4gICAgLy8gaXQncyBvcmlnaW5hbCBsb2NhdGlvbiB3YXMgYWNjb3JkaW5nIHRvIGl0J3Mgb3JpZ2luYWwgdmRvbVxuICAgIHJldHVybiAobm9kZSAmJiBub2RlWydzLW9sJ10pIHx8IG5vZGU7XG59O1xuY29uc3QgcGFyZW50UmVmZXJlbmNlTm9kZSA9IChub2RlKSA9PiAobm9kZVsncy1vbCddID8gbm9kZVsncy1vbCddIDogbm9kZSkucGFyZW50Tm9kZTtcbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgbGV0IGRlZmF1bHRIb2xkZXI7XG4gICAgaWYgKCFCVUlMRC52ZG9tVGV4dCB8fCB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcpIHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVuZGVyaW5nIGFuIHN2ZyBlbGVtZW50LCBvciBzdGlsbCByZW5kZXJpbmcgbm9kZXMgaW5zaWRlIG9mIG9uZVxuICAgICAgICAgICAgLy8gb25seSBhZGQgdGhpcyB0byB0aGUgd2hlbiB0aGUgY29tcGlsZXIgc2VlcyB3ZSdyZSB1c2luZyBhbiBzdmcgc29tZXdoZXJlXG4gICAgICAgICAgICBpc1N2Z01vZGUgPSB0YWcgPT09ICdzdmcnID8gdHJ1ZSA6IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnID8gZmFsc2UgOiBpc1N2Z01vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudCBub2RlXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90ICYmIHRhZyA9PT0gJ3Nsb3QnKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgb2YgYW4gZWxlbWVudCBPUiBpdCdzIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBhbHJlYWR5IGtub3cgaXQncyBwb3NzaWJsZSBpdCBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIGVsZW1lbnQncyBjc3MgY2xhc3NlcywgYXR0cnMsIHByb3BzLCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KG9sZFZOb2RlLCBuZXdWTm9kZSwgaXNTdmdNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXJlJ3MgY2hpbGQgdm5vZGVzIGZvciBib3RoIHRoZSBvbGQgYW5kIG5ldyB2bm9kZXNcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2hpbGRyZW4sIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG9sZCBjaGlsZCB2bm9kZXMsIGJ1dCB0aGVyZSBhcmUgbmV3IGNoaWxkIHZub2RlcyB0byBhZGRcbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgQlVJTEQudmRvbVRleHQgJiYgb2xkVk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2bm9kZSB3YXMgdGV4dCwgc28gYmUgc3VyZSB0byBjbGVhciBpdCBvdXRcbiAgICAgICAgICAgICAgICBlbG0udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHZub2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBuZXdWTm9kZSwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiB0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAoZGVmYXVsdEhvbGRlciA9IGVsbVsncy1jciddKSkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaGFzIHNsb3R0ZWQgY29udGVudFxuICAgICAgICBkZWZhdWx0SG9sZGVyLnBhcmVudE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSB0ZXh0IG9ubHkgdm5vZGVcbiAgICAgICAgLy8gYW5kIGFsc28gb25seSBpZiB0aGUgdGV4dCBpcyBkaWZmZXJlbnQgdGhhbiBiZWZvcmVcbiAgICAgICAgZWxtLmRhdGEgPSB0ZXh0O1xuICAgIH1cbn07XG5jb25zdCB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGxldCBpO1xuICAgIGxldCBpbGVuO1xuICAgIGxldCBqO1xuICAgIGxldCBzbG90TmFtZUF0dHI7XG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdCBmYWxsYmFjayBub2RlXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBzbG90IG5hbWUgZm9yIHRoaXMgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIHNob3cgYSBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgaWYgdGhlcmUgYXJlIG90aGVyIHNsb3RzIGluIHRoZSBsaWdodCBkb21cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGlsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNoaWxkTm9kZXNbal0ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdWydzLWhuJ10gIT09IGNoaWxkTm9kZVsncy1obiddIHx8IHNsb3ROYW1lQXR0ciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgc2libGluZyBub2RlIGlzIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IE9SIGlzIGEgbmFtZWQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiYgc2xvdE5hbWVBdHRyID09PSBjaGlsZE5vZGVzW2pdLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBlbGVtZW50IG9yIHRleHQgbm9kZSAod2l0aCBjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGhpZGUgdGhlIGRlZmF1bHQgZmFsbGJhY2sgc2xvdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8gJiYgY2hpbGROb2Rlc1tqXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duXG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVsb2NhdGVOb2RlcyA9IFtdO1xuY29uc3QgcmVsb2NhdGVTbG90Q29udGVudCA9IChlbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGhvc3RDb250ZW50Tm9kZXM7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgcmVsb2NhdGVOb2RlRGF0YTtcbiAgICBsZXQgajtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBlbG0uY2hpbGROb2RlcztcbiAgICBsZXQgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiAobm9kZSA9IGNoaWxkTm9kZVsncy1jciddKSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGdvdCB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudCBub2RlXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGdvdCBpdCdzIHBhcmVudCwgd2hpY2ggaXMgd2hlcmUgYWxsIHRoZSBob3N0IGNvbnRlbnQgaXMgaW4gbm93XG4gICAgICAgICAgICBob3N0Q29udGVudE5vZGVzID0gbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBzbG90TmFtZUF0dHIgPSBjaGlsZE5vZGVbJ3Mtc24nXTtcbiAgICAgICAgICAgIGZvciAoaiA9IGhvc3RDb250ZW50Tm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gaG9zdENvbnRlbnROb2Rlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVbJ3MtY24nXSAmJiAhbm9kZVsncy1uciddICYmIG5vZGVbJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZG8gc29tZSByZWxvY2F0aW5nIHRvIGl0cyBuZXcgaG9tZVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgbmV2ZXIgcmVsb2NhdGUgYSBjb250ZW50IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgaXMgc3VwcG9zZSB0byBhbHdheXMgcmVwcmVzZW50IHRoZSBvcmlnaW5hbCBjb250ZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KG5vZGUsIHNsb3ROYW1lQXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgd2UndmUgYWxyZWFkeSBkZWNpZGVkIHRvIHJlbG9jYXRlIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hZGUgc29tZSBjaGFuZ2VzIHRvIHNsb3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgd2UgYWxzbyBkb3VibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrcyBhcmUgY29ycmVjdGx5IGhpZGRlbiBvciBzaG93blxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IG5vZGVbJ3Mtc24nXSB8fCBzbG90TmFtZUF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVOb2RlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgd2UgbmV2ZXIgZm91bmQgYSBzbG90IGhvbWUgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0dXJucyBvdXQgd2UgZGlkLCBzbyBsZXQncyByZW1lbWJlciBpdCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gb3VyIGxpc3Qgb2Ygbm9kZXMgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2xvdFJlZk5vZGUkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVsncy1zciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2Rlcy5tYXAoKHJlbG9jYXRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlTG9jYXRlZEluU2xvdChyZWxvY2F0ZU5vZGUuJG5vZGVUb1JlbG9jYXRlJCwgbm9kZVsncy1zbiddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlRGF0YSA9IHJlbG9jYXRlTm9kZXMuZmluZCgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhICYmICFyZWxvY2F0ZU5vZGUuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkID0gcmVsb2NhdGVOb2RlRGF0YS4kc2xvdFJlZk5vZGUkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbG9jYXRlTm9kZXMuc29tZSgocikgPT4gci4kbm9kZVRvUmVsb2NhdGUkID09PSBub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gZmFyIHRoaXMgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgc2xvdCBob21lLCBub3Qgc2V0dGluZyBzbG90UmVmTm9kZSBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZXZlciBmaW5kIGEgaG9tZSBmb3IgdGhpcyBlbGVtZW50IHRoZW4gd2UnbGwgbmVlZCB0byBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRub2RlVG9SZWxvY2F0ZSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNOb2RlTG9jYXRlZEluU2xvdCA9IChub2RlVG9SZWxvY2F0ZSwgc2xvdE5hbWVBdHRyKSA9PiB7XG4gICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gbnVsbCAmJiBzbG90TmFtZUF0dHIgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUuZ2V0QXR0cmlidXRlKCdzbG90JykgPT09IHNsb3ROYW1lQXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5hbWVBdHRyID09PSAnJztcbn07XG5jb25zdCBjYWxsTm9kZVJlZnMgPSAodk5vZGUpID0+IHtcbiAgICBpZiAoQlVJTEQudmRvbVJlZikge1xuICAgICAgICB2Tm9kZS4kYXR0cnMkICYmIHZOb2RlLiRhdHRycyQucmVmICYmIHZOb2RlLiRhdHRycyQucmVmKG51bGwpO1xuICAgICAgICB2Tm9kZS4kY2hpbGRyZW4kICYmIHZOb2RlLiRjaGlsZHJlbiQubWFwKGNhbGxOb2RlUmVmcyk7XG4gICAgfVxufTtcbmNvbnN0IHJlbmRlclZkb20gPSAoaG9zdFJlZiwgcmVuZGVyRm5SZXN1bHRzKSA9PiB7XG4gICAgY29uc3QgaG9zdEVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgY29uc3Qgb2xkVk5vZGUgPSBob3N0UmVmLiR2bm9kZSQgfHwgbmV3Vk5vZGUobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgcm9vdFZub2RlID0gaXNIb3N0KHJlbmRlckZuUmVzdWx0cykgPyByZW5kZXJGblJlc3VsdHMgOiBoKG51bGwsIG51bGwsIHJlbmRlckZuUmVzdWx0cyk7XG4gICAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gICAgLy8gPEhvc3Q+IHJ1bnRpbWUgY2hlY2tcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgQXJyYXkuaXNBcnJheShyZW5kZXJGblJlc3VsdHMpICYmIHJlbmRlckZuUmVzdWx0cy5zb21lKGlzSG9zdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEhvc3Q+IG11c3QgYmUgdGhlIHNpbmdsZSByb290IGNvbXBvbmVudC5cbkxvb2tzIGxpa2UgdGhlIHJlbmRlcigpIGZ1bmN0aW9uIG9mIFwiJHtob3N0VGFnTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGlzIHJldHVybmluZyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSA8SG9zdD4uXG5cblRoZSByZW5kZXIoKSBmdW5jdGlvbiBzaG91bGQgbG9vayBsaWtlIHRoaXMgaW5zdGVhZDpcblxucmVuZGVyKCkge1xuICAvLyBEbyBub3QgcmV0dXJuIGFuIGFycmF5XG4gIHJldHVybiAoXG4gICAgPEhvc3Q+e2NvbnRlbnR9PC9Ib3N0PlxuICApO1xufVxuICBgKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkID0gcm9vdFZub2RlLiRhdHRycyQgfHwge307XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5tYXAoKFtwcm9wTmFtZSwgYXR0cmlidXRlXSkgPT4gKHJvb3RWbm9kZS4kYXR0cnMkW2F0dHJpYnV0ZV0gPSBob3N0RWxtW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICByb290Vm5vZGUuJHRhZyQgPSBudWxsO1xuICAgIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogaXNIb3N0ICovO1xuICAgIGhvc3RSZWYuJHZub2RlJCA9IHJvb3RWbm9kZTtcbiAgICByb290Vm5vZGUuJGVsbSQgPSBvbGRWTm9kZS4kZWxtJCA9IChCVUlMRC5zaGFkb3dEb20gPyBob3N0RWxtLnNoYWRvd1Jvb3QgfHwgaG9zdEVsbSA6IGhvc3RFbG0pO1xuICAgIGlmIChCVUlMRC5zY29wZWQgfHwgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIHNjb3BlSWQgPSBob3N0RWxtWydzLXNjJ107XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBjb250ZW50UmVmID0gaG9zdEVsbVsncy1jciddO1xuICAgICAgICB1c2VOYXRpdmVTaGFkb3dEb20gPSBzdXBwb3J0c1NoYWRvdyAmJiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSAhPT0gMDtcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBzeW5jaHJvbm91cyBwYXRjaFxuICAgIHBhdGNoKG9sZFZOb2RlLCByb290Vm5vZGUpO1xuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAvLyB3aGlsZSB3ZSdyZSBtb3Zpbmcgbm9kZXMgYXJvdW5kIGV4aXN0aW5nIG5vZGVzLCB0ZW1wb3JhcmlseSBkaXNhYmxlXG4gICAgICAgIC8vIHRoZSBkaXNjb25uZWN0Q2FsbGJhY2sgZnJvbSB3b3JraW5nXG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIGlmIChjaGVja1Nsb3RSZWxvY2F0ZSkge1xuICAgICAgICAgICAgcmVsb2NhdGVTbG90Q29udGVudChyb290Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgbGV0IHJlbG9jYXRlRGF0YTtcbiAgICAgICAgICAgIGxldCBub2RlVG9SZWxvY2F0ZTtcbiAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICBsZXQgcGFyZW50Tm9kZVJlZjtcbiAgICAgICAgICAgIGxldCBpbnNlcnRCZWZvcmVOb2RlO1xuICAgICAgICAgICAgbGV0IHJlZk5vZGU7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlbG9jYXRlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZWxvY2F0ZURhdGEgPSByZWxvY2F0ZU5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlID0gcmVsb2NhdGVEYXRhLiRub2RlVG9SZWxvY2F0ZSQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1vbCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIHJlZmVyZW5jZSBub2RlIG1hcmtpbmcgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgZm9yIGxhdGVyIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEJVSUxELmlzRGVidWcgfHwgQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9yaWdpbmFsTG9jYXRpb25EZWJ1Z05vZGUobm9kZVRvUmVsb2NhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXSA9IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgobm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZSksIG5vZGVUb1JlbG9jYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAocmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGluc2VydCBpdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2xvdCByZWZlcmVuY2Ugbm9kZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlbG9jYXRlRGF0YS4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPSBub2RlVG9SZWxvY2F0ZVsncy1vbCddO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG9yZ0xvY2F0aW9uTm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSAmJiByZWZOb2RlWydzLXNuJ10gPT09IG5vZGVUb1JlbG9jYXRlWydzLXNuJ10gJiYgcGFyZW50Tm9kZVJlZiA9PT0gcmVmTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IHJlZk5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlIHx8ICFyZWZOb2RlWydzLW5yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZSA9IHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbnNlcnRCZWZvcmVOb2RlICYmIHBhcmVudE5vZGVSZWYgIT09IG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5uZXh0U2libGluZyAhPT0gaW5zZXJ0QmVmb3JlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UndmUgY2hlY2tlZCB0aGF0IGl0J3Mgd29ydGggd2hpbGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoYXQgdGhlIG5vZGUgdG8gcmVsb2NhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBuZXh0IHNpYmxpbmcgb3IgcGFyZW50IHJlbG9jYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlVG9SZWxvY2F0ZVsncy1obiddICYmIG5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmFibHkgYSBjb21wb25lbnQgaW4gdGhlIGluZGV4Lmh0bWwgdGhhdCBkb2Vzbid0IGhhdmUgaXQncyBob3N0bmFtZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGVbJ3MtaG4nXSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ10ucGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGl0IGJhY2sgdG8gdGhlIGRvbSBidXQgaW4gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZVJlZi5pbnNlcnRCZWZvcmUobm9kZVRvUmVsb2NhdGUsIGluc2VydEJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG5vZGUgZG9lc24ndCBoYXZlIGEgc2xvdCBob21lIHRvIGdvIHRvLCBzbyBsZXQncyBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uZSBtb3Zpbmcgbm9kZXMgYXJvdW5kXG4gICAgICAgIC8vIGFsbG93IHRoZSBkaXNjb25uZWN0IGNhbGxiYWNrIHRvIHdvcmsgYWdhaW5cbiAgICAgICAgcGx0LiRmbGFncyQgJj0gfjEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgICAgIC8vIGFsd2F5cyByZXNldFxuICAgICAgICByZWxvY2F0ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgfVxufTtcbi8vIHNsb3QgY29tbWVudCBkZWJ1ZyBub2RlcyBvbmx5IGNyZWF0ZWQgd2l0aCB0aGUgYC0tZGVidWdgIGZsYWdcbi8vIG90aGVyd2lzZSB0aGVzZSBub2RlcyBhcmUgdGV4dCBub2RlcyB3L291dCBjb250ZW50XG5jb25zdCBzbG90UmVmZXJlbmNlRGVidWdOb2RlID0gKHNsb3RWTm9kZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYDxzbG90JHtzbG90Vk5vZGUuJG5hbWUkID8gJyBuYW1lPVwiJyArIHNsb3RWTm9kZS4kbmFtZSQgKyAnXCInIDogJyd9PiAoaG9zdD0ke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9KWApO1xuY29uc3Qgb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZSA9IChub2RlVG9SZWxvY2F0ZSkgPT4gZG9jLmNyZWF0ZUNvbW1lbnQoYG9yZy1sb2NhdGlvbiBmb3IgYCArXG4gICAgKG5vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZVxuICAgICAgICA/IGA8JHtub2RlVG9SZWxvY2F0ZS5sb2NhbE5hbWV9PiAoaG9zdD0ke25vZGVUb1JlbG9jYXRlWydzLWhuJ119KWBcbiAgICAgICAgOiBgWyR7bm9kZVRvUmVsb2NhdGUudGV4dENvbnRlbnR9XWApKTtcbmNvbnN0IGdldEVsZW1lbnQgPSAocmVmKSA9PiAoQlVJTEQubGF6eUxvYWQgPyBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA6IHJlZik7XG5jb25zdCBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gICAgY29uc3QgZWxtID0gZ2V0RWxlbWVudChyZWYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVtaXQ6IChkZXRhaWwpID0+IHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiAhZWxtLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcIiR7bmFtZX1cIiBldmVudCB3YXMgZW1pdHRlZCwgYnV0IHRoZSBkaXNwYXRjaGVyIG5vZGUgaXMgbm8gbG9uZ2VyIGNvbm5lY3RlZCB0byB0aGUgZG9tLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVtaXRFdmVudChlbG0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgICAgICAgICAgY29tcG9zZWQ6ICEhKGZsYWdzICYgMiAvKiBDb21wb3NlZCAqLyksXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogISEoZmxhZ3MgJiAxIC8qIENhbmNlbGxhYmxlICovKSxcbiAgICAgICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSAmIGRpc3BhdGNoIGEgY3VzdG9tIEV2ZW50IG9uIGEgcHJvdmlkZWQgdGFyZ2V0XG4gKiBAcGFyYW0gZWxtIHRoZSB0YXJnZXQgb2YgdGhlIEV2ZW50XG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSB0byBnaXZlIHRoZSBjdXN0b20gRXZlbnRcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIGEgY3VzdG9tIEV2ZW50XG4gKiBAcmV0dXJucyB0aGUgY3VzdG9tIEV2ZW50XG4gKi9cbmNvbnN0IGVtaXRFdmVudCA9IChlbG0sIG5hbWUsIG9wdHMpID0+IHtcbiAgICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgICBlbG0uZGlzcGF0Y2hFdmVudChldik7XG4gICAgcmV0dXJuIGV2O1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmICFob3N0UmVmLiRvblJlbmRlclJlc29sdmUkICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10ucHVzaChuZXcgUHJvbWlzZSgocikgPT4gKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSkpO1xuICAgIH1cbn07XG5jb25zdCBzY2hlZHVsZVVwZGF0ZSA9IChob3N0UmVmLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gICAgaWYgKEJVSUxELnRhc2tRdWV1ZSAmJiBCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGhvc3RSZWYuJGZsYWdzJCAmIDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8pIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiBCVUlMRC50YXNrUXVldWUgPyB3cml0ZVRhc2soZGlzcGF0Y2gpIDogZGlzcGF0Y2goKTtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kU2NoZWR1bGUgPSBjcmVhdGVUaW1lKCdzY2hlZHVsZVVwZGF0ZScsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDI1NiAvKiBpc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxMb2FkJyk7XG4gICAgICAgIGlmIChCVUlMRC5jbXBXaWxsTG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFJlbmRlcicpO1xuICAgIGlmIChCVUlMRC5jbXBXaWxsUmVuZGVyKSB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIGF3YWl0IGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsUmVuZGVyKGhvc3RSZWYsIGluc3RhbmNlLCBlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgIHBsdC4kY3NzU2hpbSQudXBkYXRlSG9zdChlbG0pO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgaG9zdFJlZi4kcmVuZGVyQ291bnQkKys7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICB9XG4gICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBtYW51YWxseSBjb25uZWN0ZWQgY2hpbGQgY29tcG9uZW50cyBkdXJpbmcgc2VydmVyLXNpZGUgaHlkcmF0ZVxuICAgICAgICAgICAgc2VydmVyU2lkZUNvbm5lY3RlZChlbG0pO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBvbmx5IGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICAgICAgaWYgKGhvc3RSZWYuJGNtcE1ldGEkLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtWydzLWVuJ10gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICdjJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgcmMpIHtcbiAgICAgICAgLy8gb2ssIHNvIHR1cm5zIG91dCB0aGVyZSBhcmUgc29tZSBjaGlsZCBob3N0IGVsZW1lbnRzXG4gICAgICAgIC8vIHdhaXRpbmcgb24gdGhpcyBwYXJlbnQgZWxlbWVudCB0byBsb2FkXG4gICAgICAgIC8vIGxldCdzIGZpcmUgb2ZmIGFsbCB1cGRhdGUgY2FsbGJhY2tzIHdhaXRpbmdcbiAgICAgICAgcmMubWFwKChjYikgPT4gY2IoKSk7XG4gICAgICAgIGVsbVsncy1yYyddID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRSZW5kZXIoKTtcbiAgICBlbmRVcGRhdGUoKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUHJvbWlzZXMgPSBlbG1bJ3MtcCddO1xuICAgICAgICBjb25zdCBwb3N0VXBkYXRlID0gKCkgPT4gcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwb3N0VXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChjaGlsZHJlblByb21pc2VzKS50aGVuKHBvc3RVcGRhdGUpO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICAgICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvc3RVcGRhdGVDb21wb25lbnQoaG9zdFJlZik7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIC8vIGluIG9yZGVyIGZvciBidW5kbGVycyB0byBjb3JyZWN0bHkgdHJlZXNoYWtlIHRoZSBCVUlMRCBvYmplY3RcbiAgICAvLyB3ZSBuZWVkIHRvIGVuc3VyZSBCVUlMRCBpcyBub3QgZGVvcHRpbWl6ZWQgd2l0aGluIGEgdHJ5L2NhdGNoXG4gICAgLy8gaHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4vI3RyZWVzaGFrZSB0cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgY29uc3QgYWxsUmVuZGVyRm4gPSBCVUlMRC5hbGxSZW5kZXJGbiA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCBsYXp5TG9hZCA9IEJVSUxELmxhenlMb2FkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHRhc2tRdWV1ZSA9IEJVSUxELnRhc2tRdWV1ZSA/IHRydWUgOiBmYWxzZTtcbiAgICBjb25zdCB1cGRhdGFibGUgPSBCVUlMRC51cGRhdGFibGUgPyB0cnVlIDogZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyaW5nUmVmID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlID0gYWxsUmVuZGVyRm4gPyBpbnN0YW5jZS5yZW5kZXIoKSA6IGluc3RhbmNlLnJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgaWYgKHVwZGF0YWJsZSAmJiB0YXNrUXVldWUpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0YWJsZSB8fCBsYXp5TG9hZCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogaGFzUmVuZGVyZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmhhc1JlbmRlckZuIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC52ZG9tUmVuZGVyIHx8IEJVSUxELnJlZmxlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBjaGlsZCBub2RlcyB0byByZW5kZXIgaW50byB0aGlzIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIG9yIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjc3MgY2xhc3MvYXR0cnMgb24gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSkudGhlbigodmFsdWUpID0+IHJlbmRlclZkb20oaG9zdFJlZiwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclZkb20oaG9zdFJlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICAgIH1cbiAgICByZW5kZXJpbmdSZWYgPSBudWxsO1xuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldFJlbmRlcmluZ1JlZiA9ICgpID0+IHJlbmRlcmluZ1JlZjtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgOiBlbG07XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgaWYgKEJVSUxELmNtcERpZFJlbmRlcikge1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgQlVJTEQuY3NzQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRMb2FkKSB7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MjA0OCAvKiBkZXZPbkRpZExvYWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZExvYWQnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgICAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQoZWxtKTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBhcHBEaWRMb2FkKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gZmlyZSBvZmYgdGhlIHVzZXIncyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIChpZiBvbmUgd2FzIHByb3ZpZGVkKVxuICAgICAgICAgICAgLy8gY29tcG9uZW50RGlkVXBkYXRlIHJ1bnMgQUZURVIgcmVuZGVyKCkgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgICAgICAvLyBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgZWxtWydzLWhtci1sb2FkJ10gJiYgZWxtWydzLWhtci1sb2FkJ10oKTtcbiAgICB9XG4gICAgaWYgKEJVSUxELm1ldGhvZCAmJiBCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKSB7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+KDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi8gfCA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICBpZiAoQlVJTEQudXBkYXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIFwidHJ1ZVwiIHdoZW4gdGhlIGZvcmNlZCB1cGRhdGUgd2FzIHN1Y2Nlc3NmdWxseSBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgYXBwRGlkTG9hZCA9ICh3aG8pID0+IHtcbiAgICAvLyBvbiBhcHBsb2FkXG4gICAgLy8gd2UgaGF2ZSBmaW5pc2ggdGhlIGZpcnN0IGJpZyBpbml0aWFsIHJlbmRlclxuICAgIGlmIChCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICBhZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBuZXh0VGljaygoKSA9PiBlbWl0RXZlbnQod2luLCAnYXBwbG9hZCcsIHsgZGV0YWlsOiB7IG5hbWVzcGFjZTogTkFNRVNQQUNFIH0gfSkpO1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1lYXN1cmUpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7TkFNRVNQQUNFfSBpbml0aWFsIGxvYWQgKGJ5ICR7d2hvfSlgLCAnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxufTtcbmNvbnN0IHNhZmVDYWxsID0gKGluc3RhbmNlLCBtZXRob2QsIGFyZykgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2RdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCB0aGVuID0gKHByb21pc2UsIHRoZW5GbikgPT4ge1xuICAgIHJldHVybiBwcm9taXNlICYmIHByb21pc2UudGhlbiA/IHByb21pc2UudGhlbih0aGVuRm4pIDogdGhlbkZuKCk7XG59O1xuY29uc3QgZW1pdExpZmVjeWNsZUV2ZW50ID0gKGVsbSwgbGlmZWN5Y2xlTmFtZSkgPT4ge1xuICAgIGlmIChCVUlMRC5saWZlY3ljbGVET01FdmVudHMpIHtcbiAgICAgICAgZW1pdEV2ZW50KGVsbSwgJ3N0ZW5jaWxfJyArIGxpZmVjeWNsZU5hbWUsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogTkFNRVNQQUNFLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGFkZEh5ZHJhdGVkRmxhZyA9IChlbG0pID0+IEJVSUxELmh5ZHJhdGVkQ2xhc3NcbiAgICA/IGVsbS5jbGFzc0xpc3QuYWRkKCdoeWRyYXRlZCcpXG4gICAgOiBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZVxuICAgICAgICA/IGVsbS5zZXRBdHRyaWJ1dGUoJ2h5ZHJhdGVkJywgJycpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuY29uc3Qgc2VydmVyU2lkZUNvbm5lY3RlZCA9IChlbG0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGVsbS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZEVsbSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZEVsbS5jb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGNoaWxkRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZSA9IChob3N0RWxtLCB0YWdOYW1lLCBob3N0SWQsIGhvc3RSZWYpID0+IHtcbiAgICBjb25zdCBlbmRIeWRyYXRlID0gY3JlYXRlVGltZSgnaHlkcmF0ZUNsaWVudCcsIHRhZ05hbWUpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBob3N0RWxtLnNoYWRvd1Jvb3Q7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNsb3ROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3ROb2RlcyA9IEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290ID8gW10gOiBudWxsO1xuICAgIGNvbnN0IHZub2RlID0gKGhvc3RSZWYuJHZub2RlJCA9IG5ld1ZOb2RlKHRhZ05hbWUsIG51bGwpKTtcbiAgICBpZiAoIXBsdC4kb3JnTG9jTm9kZXMkKSB7XG4gICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUoZG9jLmJvZHksIChwbHQuJG9yZ0xvY05vZGVzJCA9IG5ldyBNYXAoKSkpO1xuICAgIH1cbiAgICBob3N0RWxtW0hZRFJBVEVfSURdID0gaG9zdElkO1xuICAgIGhvc3RFbG0ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfSUQpO1xuICAgIGNsaWVudEh5ZHJhdGUodm5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBob3N0RWxtLCBob3N0SWQpO1xuICAgIGNoaWxkUmVuZGVyTm9kZXMubWFwKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uSWQgPSBjLiRob3N0SWQkICsgJy4nICsgYy4kbm9kZUlkJDtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlID0gcGx0LiRvcmdMb2NOb2RlcyQuZ2V0KG9yZ0xvY2F0aW9uSWQpO1xuICAgICAgICBjb25zdCBub2RlID0gYy4kZWxtJDtcbiAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBvcmdMb2NhdGlvbk5vZGVbJ3MtZW4nXSA9PT0gJycpIHtcbiAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvcmdMb2NhdGlvbk5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbm9kZVsncy1obiddID0gdGFnTmFtZTtcbiAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ10gPSBvcmdMb2NhdGlvbk5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZVsncy1vbCddWydzLW5yJ10gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShvcmdMb2NhdGlvbklkKTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgc2hhZG93Um9vdE5vZGVzLm1hcCgoc2hhZG93Um9vdE5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc2hhZG93Um9vdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kSHlkcmF0ZSgpO1xufTtcbmNvbnN0IGNsaWVudEh5ZHJhdGUgPSAocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLCBob3N0SWQpID0+IHtcbiAgICBsZXQgY2hpbGROb2RlVHlwZTtcbiAgICBsZXQgY2hpbGRJZFNwbHQ7XG4gICAgbGV0IGNoaWxkVk5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGROb2RlVHlwZSA9IG5vZGUuZ2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO1xuICAgICAgICBpZiAoY2hpbGROb2RlVHlwZSkge1xuICAgICAgICAgICAgLy8gZ290IHRoZSBub2RlIGRhdGEgZnJvbSB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgICAgICBjaGlsZElkU3BsdCA9IGNoaWxkTm9kZVR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gaG9zdElkIHx8IGNoaWxkSWRTcGx0WzBdID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICRub2RlSWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICAgICAkdGFnJDogbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAkYXR0cnMkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJG5hbWUkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIG5ldyBjaGlsZCB2bm9kZVxuICAgICAgICAgICAgICAgIC8vIHNvIGVuc3VyZSBpdHMgcGFyZW50IHZub2RlIGhhcyB0aGUgdmNoaWxkcmVuIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIG91ciBjaGlsZCB2bm9kZSB0byBhIHNwZWNpZmljIGluZGV4IG9mIHRoZSB2bm9kZSdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdyB0aGUgbmV3IHBhcmVudCB2bm9kZSBmb3IgYWxsIHRoZSBuZXh0IGNoaWxkIGNoZWNrc1xuICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd1Jvb3ROb2Rlc1tjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZHJpbGwgZG93biwgZW5kIHRvIHN0YXJ0IHNvIHdlIGNhbiByZW1vdmUgbm9kZXNcbiAgICAgICAgZm9yIChpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5jaGlsZE5vZGVzW2ldLCBob3N0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgZHJpbGxpbmcgZG93biB0aHJvdWdoIHRoZSBzaGFkb3cgcm9vdCBub2Rlc1xuICAgICAgICAgICAgZm9yIChpID0gbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbGllbnRIeWRyYXRlKHBhcmVudFZOb2RlLCBjaGlsZFJlbmRlck5vZGVzLCBzbG90Tm9kZXMsIHNoYWRvd1Jvb3ROb2RlcywgaG9zdEVsbSwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICAvLyBgJHtDT01NRU5UX1RZUEV9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gXG4gICAgICAgIGNoaWxkSWRTcGx0ID0gbm9kZS5ub2RlVmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzFdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMV0gPT09ICcwJykge1xuICAgICAgICAgICAgLy8gY29tbWVudCBub2RlIGZvciBlaXRoZXIgdGhlIGhvc3QgaWQgb3IgYSAwIGhvc3QgaWRcbiAgICAgICAgICAgIGNoaWxkTm9kZVR5cGUgPSBjaGlsZElkU3BsdFswXTtcbiAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgICAgICAgICAkaG9zdElkJDogY2hpbGRJZFNwbHRbMV0sXG4gICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzJdLFxuICAgICAgICAgICAgICAgICRkZXB0aCQ6IGNoaWxkSWRTcGx0WzNdLFxuICAgICAgICAgICAgICAgICRpbmRleCQ6IGNoaWxkSWRTcGx0WzRdLFxuICAgICAgICAgICAgICAgICRlbG0kOiBub2RlLFxuICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJGNoaWxkcmVuJDogbnVsbCxcbiAgICAgICAgICAgICAgICAka2V5JDogbnVsbCxcbiAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRhZyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgJHRleHQkOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBURVhUX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZWxtJCAmJiBjaGlsZFZOb2RlLiRlbG0kLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJHRleHQkID0gY2hpbGRWTm9kZS4kZWxtJC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZW5kZXJOb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRleHQgY29tbWVudCBzaW5jZSBpdCdzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZFZOb2RlLiRpbmRleCRdID0gY2hpbGRWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlcyAmJiBjaGlsZFZOb2RlLiRkZXB0aCQgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRWTm9kZS4kaG9zdElkJCA9PT0gaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21tZW50IG5vZGUgaXMgc3BlY2lmY2FsbHkgZm9yIHRoaXMgaG9zdCBpZFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVUeXBlID09PSBTTE9UX05PREVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCR7U0xPVF9OT0RFX0lEfS4ke2hvc3RJZH0uJHtub2RlSWR9LiR7ZGVwdGh9LiR7aW5kZXh9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGFnJCA9ICdzbG90JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSBjaGlsZFZOb2RlLiRuYW1lJCA9IGNoaWxkSWRTcGx0WzVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zciddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgc3VwcG9ydCBzaGFkb3dSb290IGFuZCB0aGlzIGlzIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhY3R1YWwgc2xvdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kID0gZG9jLmNyZWF0ZUVsZW1lbnQoY2hpbGRWTm9kZS4kdGFnJCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kbmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsb3QgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiRlbG0kLnNldEF0dHJpYnV0ZSgnbmFtZScsIGNoaWxkVk5vZGUuJG5hbWUkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbmV3IHNsb3QgZWxlbWVudCBiZWZvcmUgdGhlIHNsb3QgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZFZOb2RlLiRlbG0kLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2xvdCBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2Rlcy5wdXNoKGNoaWxkVk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZE5vZGVUeXBlID09PSBDT05URU5UX1JFRl9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtDT05URU5UX1JFRl9JRH0uJHtob3N0SWR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBzaGFkb3dSb290Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudCByZWYgY29tbWVudCBzaW5jZSBpdCdzIG5vdCBuZWVkZWQgZm9yIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsbVsncy1jciddID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3MtY24nXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Vk5vZGUgJiYgcGFyZW50Vk5vZGUuJHRhZyQgPT09ICdzdHlsZScpIHtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShudWxsLCBub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgdm5vZGUuJGVsbSQgPSBub2RlO1xuICAgICAgICB2bm9kZS4kaW5kZXgkID0gJzAnO1xuICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kID0gW3Zub2RlXTtcbiAgICB9XG59O1xuY29uc3QgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZSA9IChub2RlLCBvcmdMb2NOb2RlcykgPT4ge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVEb2N1bWVudEh5ZHJhdGUobm9kZS5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgb3JnTG9jTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMF0gPT09IE9SR19MT0NBVElPTl9JRCkge1xuICAgICAgICAgICAgb3JnTG9jTm9kZXMuc2V0KGNoaWxkSWRTcGx0WzFdICsgJy4nICsgY2hpbGRJZFNwbHRbMl0sIG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSAnJztcbiAgICAgICAgICAgIC8vIHVzZWZ1bCB0byBrbm93IGlmIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBpc1xuICAgICAgICAgICAgLy8gdGhlIHJvb3QgbGlnaHQtZG9tIG9mIGEgc2hhZG93IGRvbSBjb21wb25lbnRcbiAgICAgICAgICAgIG5vZGVbJ3MtZW4nXSA9IGNoaWxkSWRTcGx0WzNdO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUGFyc2UgYSBuZXcgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gcHJvcGVydHkgdHlwZS5cbiAqXG4gKiBXaGlsZSB0aGUgcHJvcCB2YWx1ZSBjYW4gcmVhc29uYWJseSBiZSBleHBlY3RlZCB0byBiZSBvZiBgYW55YCB0eXBlIGFzIGZhciBhcyBUeXBlU2NyaXB0J3MgdHlwZSBjaGVja2VyIGlzIGNvbmNlcm5lZCxcbiAqIGl0IGlzIG5vdCBzYWZlIHRvIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgZXZhbHVhdGluZyBgdHlwZW9mIHByb3BWYWx1ZWAgbWF0Y2hlczpcbiAqICAgMS4gYGFueWAsIHRoZSB0eXBlIGdpdmVuIHRvIGBwcm9wVmFsdWVgIGluIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAqICAgMi4gdGhlIHR5cGUgc3RvcmVkIGZyb20gYHByb3BUeXBlYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIHRoZSBjYXBhYmlsaXR5IHRvIHBhcnNlL2NvZXJjZSBhIHByb3BlcnR5J3MgdmFsdWUgdG8gcG90ZW50aWFsbHkgYW55IG90aGVyIEphdmFTY3JpcHQgdHlwZS5cbiAqXG4gKiBQcm9wZXJ0eSB2YWx1ZXMgcmVwcmVzZW50ZWQgaW4gVFNYIHByZXNlcnZlIHRoZWlyIHR5cGUgaW5mb3JtYXRpb24uIEluIHRoZSBleGFtcGxlIGJlbG93LCB0aGUgbnVtYmVyIDAgaXMgcGFzc2VkIHRvXG4gKiBhIGNvbXBvbmVudC4gVGhpcyBgcHJvcFZhbHVlYCB3aWxsIHByZXNlcnZlIGl0cyB0eXBlIGluZm9ybWF0aW9uIChgdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ251bWJlcidgKS4gTm90ZSB0aGF0IGlzXG4gKiBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGluLCBub3QgdGhlIHR5cGUgZGVjbGFyZWQgb2YgdGhlIGNsYXNzIG1lbWJlciBkZWNvcmF0ZWQgd2l0aCBgQFByb3BgLlxuICogYGBgdHN4XG4gKiA8bXktY21wIHByb3AtdmFsPXswfT48L215LWNtcD5cbiAqIGBgYFxuICpcbiAqIEhUTUwgcHJvcCB2YWx1ZXMgb24gdGhlIG90aGVyIGhhbmQsIHdpbGwgYWx3YXlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHByb3BWYWx1ZSB0aGUgbmV3IHZhbHVlIHRvIGNvZXJjZSB0byBzb21lIHR5cGVcbiAqIEBwYXJhbSBwcm9wVHlwZSB0aGUgdHlwZSBvZiB0aGUgcHJvcCwgZXhwcmVzc2VkIGFzIGEgYmluYXJ5IG51bWJlclxuICogQHJldHVybnMgdGhlIHBhcnNlZC9jb2VyY2VkIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlUHJvcGVydHlWYWx1ZSA9IChwcm9wVmFsdWUsIHByb3BUeXBlKSA9PiB7XG4gICAgLy8gZW5zdXJlIHRoaXMgdmFsdWUgaXMgb2YgdGhlIGNvcnJlY3QgcHJvcCB0eXBlXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgaWYgKEJVSUxELnByb3BCb29sZWFuICYmIHByb3BUeXBlICYgNCAvKiBCb29sZWFuICovKSB7XG4gICAgICAgICAgICAvLyBwZXIgdGhlIEhUTUwgc3BlYywgYW55IHN0cmluZyB2YWx1ZSBtZWFucyBpdCBpcyBhIGJvb2xlYW4gdHJ1ZSB2YWx1ZVxuICAgICAgICAgICAgLy8gYnV0IHdlJ2xsIGNoZWF0IGhlcmUgYW5kIHNheSB0aGF0IHRoZSBzdHJpbmcgXCJmYWxzZVwiIGlzIHRoZSBib29sZWFuIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiBwcm9wVmFsdWUgPT09ICcnIHx8ICEhcHJvcFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wTnVtYmVyICYmIHByb3BUeXBlICYgMiAvKiBOdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5wcm9wU3RyaW5nICYmIHByb3BUeXBlICYgMSAvKiBTdHJpbmcgKi8pIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBwYXNzZWQgYXMgYSBudW1iZXIgb3IgYm9vbGVhblxuICAgICAgICAgICAgLy8gYnV0IHdlIHN0aWxsIHdhbnQgaXQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1bmRhbnQgcmV0dXJuIGhlcmUgZm9yIGJldHRlciBtaW5pZmljYXRpb25cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgLy8gbm90IHN1cmUgZXhhY3RseSB3aGF0IHR5cGUgd2Ugd2FudFxuICAgIC8vIHNvIG5vIG5lZWQgdG8gY2hhbmdlIHRvIGEgZGlmZmVyZW50IHR5cGVcbiAgICByZXR1cm4gcHJvcFZhbHVlO1xufTtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBCVUlMRC5sYXp5TG9hZCA/IGhvc3RSZWYuJGhvc3RFbGVtZW50JCA6IHJlZjtcbiAgICBjb25zdCBvbGRWYWwgPSBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICAgIC8vIGV4cGxpY2l0bHkgY2hlY2sgZm9yIE5hTiBvbiBib3RoIHNpZGVzLCBhcyBgTmFOID09PSBOYU5gIGlzIGFsd2F5cyBmYWxzZVxuICAgIGNvbnN0IGFyZUJvdGhOYU4gPSBOdW1iZXIuaXNOYU4ob2xkVmFsKSAmJiBOdW1iZXIuaXNOYU4obmV3VmFsKTtcbiAgICBjb25zdCBkaWRWYWx1ZUNoYW5nZSA9IG5ld1ZhbCAhPT0gb2xkVmFsICYmICFhcmVCb3RoTmFOO1xuICAgIGlmICgoIUJVSUxELmxhenlMb2FkIHx8ICEoZmxhZ3MgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pIHx8IG9sZFZhbCA9PT0gdW5kZWZpbmVkKSAmJiBkaWRWYWx1ZUNoYW5nZSkge1xuICAgICAgICAvLyBnYWR6b29rcyEgdGhlIHByb3BlcnR5J3MgdmFsdWUgaGFzIGNoYW5nZWQhIVxuICAgICAgICAvLyBzZXQgb3VyIG5ldyB2YWx1ZSFcbiAgICAgICAgaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLnNldChwcm9wTmFtZSwgbmV3VmFsKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMTAyNCAvKiBkZXZPblJlbmRlciAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBUaGUgc3RhdGUvcHJvcCBcIiR7cHJvcE5hbWV9XCIgY2hhbmdlZCBkdXJpbmcgcmVuZGVyaW5nLiBUaGlzIGNhbiBwb3RlbnRpYWxseSBsZWFkIHRvIGluZmluaXRlLWxvb3BzIGFuZCBvdGhlciBidWdzLmAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDIwNDggLyogZGV2T25EaWRMb2FkICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyBcImNvbXBvbmVudERpZExvYWQoKVwiLCB0aGlzIHRyaWdnZXJzIGV4dHJhIHJlLXJlbmRlcnMsIHRyeSB0byBzZXR1cCBvbiBcImNvbXBvbmVudFdpbGxMb2FkKClcImAsICdcXG5FbGVtZW50JywgZWxtLCAnXFxuTmV3IHZhbHVlJywgbmV3VmFsLCAnXFxuT2xkIHZhbHVlJywgb2xkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJVSUxELmxhenlMb2FkIHx8IGluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgbWV0aG9kIG5hbWVzIG9mIHdhdGNoIGZ1bmN0aW9ucyB0byBjYWxsXG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjayAmJiBjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2F0Y2hNZXRob2RzID0gY21wTWV0YS4kd2F0Y2hlcnMkW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaW5zdGFuY2UgaXMgd2F0Y2hpbmcgZm9yIHdoZW4gdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTWV0aG9kcy5tYXAoKHdhdGNoTWV0aG9kTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIG9mZiBlYWNoIG9mIHRoZSB3YXRjaCBtZXRob2RzIHRoYXQgYXJlIHdhdGNoaW5nIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVt3YXRjaE1ldGhvZE5hbWVdKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQudXBkYXRhYmxlICYmXG4gICAgICAgICAgICAgICAgKGZsYWdzICYgKDIgLyogaGFzUmVuZGVyZWQgKi8gfCAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIGhhc1JlbmRlcmVkICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmNtcFNob3VsZFVwZGF0ZSAmJiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIG9sZFZhbCwgcHJvcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhpcyB2YWx1ZSBhY3R1YWxseSBjaGFuZ2VkLCBzbyB3ZSd2ZSBnb3Qgd29yayB0byBkbyFcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB3ZSd2ZSBhbHJlYWR5IHJlbmRlcmVkLCBvdGhlcndpc2UganVzdCBjaGlsbCBvdXRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSB0aGF0IHdlIG5lZWQgdG8gZG8gYW4gdXBkYXRlLCBidXQgZG9uJ3Qgd29ycnkgYWJvdXQgcXVldWluZ1xuICAgICAgICAgICAgICAgIC8vIHVwIG1pbGxpb25zIGN1eiB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgaXQgb25seSBydW5zIG9uY2VcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoQlVJTEQubWVtYmVyICYmIGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgoQlVJTEQucHJvcCB8fCBCVUlMRC5zdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovIHx8XG4gICAgICAgICAgICAgICAgICAgICgoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIHByb3BcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBnZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGR1cmluZyBkZXYgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHByb3h5aW5nIHRoZSBpbnN0YW5jZSAobm90IGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgbm90IGNvbnN0cnVjdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmLiRmbGFncyQgJiA4IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgYSBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8pICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtZW1iZXIgaXMgbm90IG11dGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMTAyNCAvKiBNdXRhYmxlICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgQFByb3AoKSBcIiR7bWVtYmVyTmFtZX1cIiBvbiA8JHtjbXBNZXRhLiR0YWdOYW1lJH0+IGlzIGltbXV0YWJsZSBidXQgd2FzIG1vZGlmaWVkIGZyb20gd2l0aGluIHRoZSBjb21wb25lbnQuXFxuTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvcHJvcGVydGllcyNwcm9wLW11dGFiaWxpdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgc2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmxhenlMb2FkICYmXG4gICAgICAgICAgICAgICAgQlVJTEQubWV0aG9kICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyRmxhZ3MgJiA2NCAvKiBNZXRob2QgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIG1ldGhvZFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYuJG9uSW5zdGFuY2VQcm9taXNlJC50aGVuKCgpID0+IHJlZi4kbGF6eUluc3RhbmNlJFttZW1iZXJOYW1lXSguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQlVJTEQub2JzZXJ2ZUF0dHJpYnV0ZSAmJiAoIUJVSUxELmxhenlMb2FkIHx8IGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluIGEgd2ViIGNvbXBvbmVudCBsaWZlY3ljbGUgdGhlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBydW5zIHByaW9yIHRvIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgY2FzZSB3aGVyZSBhbiBhdHRyaWJ1dGUgd2FzIHNldCBpbmxpbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBzZXRzIHRoZSBhdHRyaWJ1dGUgaW5saW5lIG9uIGEgY3VzdG9tIGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyBpdCBiZWZvcmUgaXQgaGFzIGJlZW4gdXBncmFkZWQgYXMgc2hvd24gYmVsb3c6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwhLS0gdGhpcyBjb21wb25lbnQgaGFzIF9ub3RfIGJlZW4gdXBncmFkZWQgeWV0IC0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8bXktY29tcG9uZW50IGlkPVwidGVzdFwiIHNvbWUtYXR0cmlidXRlPVwic29tZS12YWx1ZVwiPjwvbXktY29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIGdyYWIgbm9uLXVwZ3JhZGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAvLyB1cGdyYWRlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlIGlmIHdlIGRvIG5vdCB1bnNoYWRvdyBoZXJlIGFuZCB1c2UgdGhlIHZhbHVlIG9mIHRoZSBzaGFkb3dpbmcgcHJvcGVydHksIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyAgd2lsbCBiZSBjYWxsZWQgd2l0aCBgbmV3VmFsdWUgPSBcInNvbWUtdmFsdWVcImAgYW5kIHdpbGwgc2V0IHRoZSBzaGFkb3dlZCBwcm9wZXJ0eSAodGhpcy5zb21lQXR0cmlidXRlID0gXCJhbm90aGVyLXZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vICB0byB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IGlubGluZSBpLmUuIFwic29tZS12YWx1ZVwiIGZyb20gYWJvdmUgZXhhbXBsZS4gV2hlblxuICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGNvbm5lY3RlZENhbGxiYWNrIGF0dGVtcHRzIHRvIHVuc2hhZG93IGl0IHdpbGwgdXNlIFwic29tZS12YWx1ZVwiIGFzIHRoZSBpbml0aWFsIHZhbHVlIHJhdGhlciB0aGFuIFwiYW5vdGhlci12YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIHdhcyBOT1Qgc2V0IGlubGluZSBidXQgd2FzIG5vdCBzZXQgcHJvZ3JhbW1hdGljYWxseSBzaGFsbCBiZSBoYW5kbGVkL3Vuc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJ5IGNvbm5lY3RlZENhbGxiYWNrIGFzIHRoaXMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVE9ETyhTVEVOQ0lMLTE2KSB3ZSBzaG91bGQgdGhpbmsgYWJvdXQgd2hldGhlciBvciBub3Qgd2UgYWN0dWFsbHkgd2FudCB0byBiZSByZWZsZWN0aW5nIHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9wZXJ0aWVzIGhlcmUgZ2l2ZW4gdGhhdCB0aGlzIGdvZXMgYWdhaW5zdCBiZXN0IHByYWN0aWNlcyBvdXRsaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2F2b2lkLXJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcE5hbWUgZXhpc3RzIG9uIHRoZSBwcm90b3R5cGUgb2YgYENzdHJgLCB0aGlzIHVwZGF0ZSBtYXkgYmUgYSByZXN1bHQgb2YgU3RlbmNpbCB1c2luZyBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFQSXMgdG8gcmVmbGVjdCBwcm9wcyBhcyBhdHRyaWJ1dGVzLiBDYWxscyB0byBgc2V0QXR0cmlidXRlKHNvbWVFbGVtZW50LCBwcm9wTmFtZSlgIHdpbGwgcmVzdWx0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvcE5hbWVgIHRvIGJlIGNvbnZlcnRlZCB0byBhIGBET01TdHJpbmdgLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgd2Ugd2FudCBmb3Igb3RoZXIgcHJpbWl0aXZlIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIEhhc0F0dHJpYnV0ZSAqLykgLy8gZmlsdGVyIHRvIG9ubHkga2VlcCBwcm9wcyB0aGF0IHNob3VsZCBtYXRjaCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoW3Byb3BOYW1lLCBtXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZVRvUHJvcE5hbWUuc2V0KGF0dHJOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELnJlZmxlY3QgJiYgbVswXSAmIDUxMiAvKiBSZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSB8fCBCVUlMRC5zdHlsZSkgJiZcbiAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmIDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgfHwgQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgdGhpcyBlbGVtZW50IHlldFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSwgaG9zdFJlZiwgaG1yVmVyc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChDc3RyLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBBd2FpdCBjcmVhdGVzIGEgbWljcm8tdGFzayBhdm9pZCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExvYWQgPSB1bmlxdWVUaW1lKGBzdDpsb2FkOiR7Y21wTWV0YS4kdGFnTmFtZSR9OiR7aG9zdFJlZi4kbW9kZU5hbWUkfWAsIGBbU3RlbmNpbF0gTG9hZCBtb2R1bGUgZm9yIDwke2NtcE1ldGEuJHRhZ05hbWUkfT5gKTtcbiAgICAgICAgICAgICAgICBDc3RyID0gYXdhaXQgQ3N0cjtcbiAgICAgICAgICAgICAgICBlbmRMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKEJVSUxELmlzRGV2IHx8IEJVSUxELmlzRGVidWcpICYmICFDc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyICYmICFDc3RyLmlzUHJveGllZCkge1xuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIG5ldmVyIHByb3hpZWQgdGhpcyBDb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBsZXQncyBhZGQgdGhlIGdldHRlcnMvc2V0dGVycyB0byBpdHMgcHJvdG90eXBlIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0aW1lIHdlIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAyIC8qIHByb3h5U3RhdGUgKi8pO1xuICAgICAgICAgICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZSgnY3JlYXRlSW5zdGFuY2UnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAvLyBvaywgdGltZSB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCB0cmFjayBvZiB3aGVuIHdlIHN0YXJ0IGFuZCBzdG9wXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBnZXR0ZXJzL3NldHRlcnMgZG9uJ3QgaW5jb3JyZWN0bHkgc3RlcCBvbiBkYXRhXG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgbGF6eS1sb2FkZWQgY29tcG9uZW50IGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBwYXNzaW5nIHRoZSBob3N0UmVmIGlzIHZlcnkgaW1wb3J0YW50IGR1cmluZ1xuICAgICAgICAgICAgLy8gY29uc3RydWN0aW9uIGluIG9yZGVyIHRvIGRpcmVjdGx5IHdpcmUgdG9nZXRoZXIgdGhlXG4gICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgYW5kIHRoZSBsYXp5LWxvYWRlZCBpbnN0YW5jZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgQ3N0cihob3N0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzeW5jIGNvbnN0cnVjdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgQ3N0ciA9IGVsbS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLztcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSBDdXN0b21FbGVtZW50UmVnaXN0cnkgdG8gbWFyayB0aGUgY29tcG9uZW50IGFzIHJlYWR5IGJlZm9yZSBzZXR0aW5nIGBpc1dhdGNoUmVhZHlgLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB3YXRjaGVycyBtYXkgZmlyZSBwcmVtYXR1cmVseSBpZiBgY3VzdG9tRWxlbWVudHMuZ2V0KClgL2BjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCgpYCByZXNvbHZlcyBfYmVmb3JlX1xuICAgICAgICAgICAgLy8gU3RlbmNpbCBoYXMgY29tcGxldGVkIGluc3RhbnRpYXRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKGNtcE1ldGEuJHRhZ05hbWUkKS50aGVuKCgpID0+IChob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdHlsZSAmJiBDc3RyLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBoYXMgc3R5bGVzIGJ1dCB3ZSBoYXZlbid0IHJlZ2lzdGVyZWQgdGhlbSB5ZXRcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IENzdHIuc3R5bGU7XG4gICAgICAgICAgICBpZiAoQlVJTEQubW9kZSAmJiB0eXBlb2Ygc3R5bGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBzdHlsZVsoaG9zdFJlZi4kbW9kZU5hbWUkID0gY29tcHV0ZU1vZGUoZWxtKSldO1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBob3N0UmVmLiRtb2RlTmFtZSQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgncy1tb2RlJywgaG9zdFJlZi4kbW9kZU5hbWUkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKCdyZWdpc3RlclN0eWxlcycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbSAmJlxuICAgICAgICAgICAgICAgICAgICBCVUlMRC5zaGFkb3dEb21TaGltICYmXG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gYXdhaXQgaW1wb3J0KCcuL3NoYWRvdy1jc3MuanMnKS50aGVuKChtKSA9PiBtLnNjb3BlQ3NzKHN0eWxlLCBzY29wZUlkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQsIHN0eWxlLCAhIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICBlbmRSZWdpc3RlclN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgbGF6eSBpbnN0YW5jZVxuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBhbmNlc3RvckNvbXBvbmVudCAmJiBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgbG9hZCBhbmQgdGhpcyBjb21wb25lbnQgaXQgaGFzIGFuIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBidXQgdGhlIGFuY2VzdG9yIGNvbXBvbmVudCBoYXMgTk9UIGZpcmVkIGl0cyB3aWxsIHVwZGF0ZSBsaWZlY3ljbGUgeWV0XG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3QgY29vbCBvdXIgamV0cyBhbmQgd2FpdCBmb3IgdGhlIGFuY2VzdG9yIHRvIGNvbnRpbnVlIGZpcnN0XG4gICAgICAgIC8vIHRoaXMgd2lsbCBnZXQgZmlyZWQgb2ZmIHdoZW4gdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAvLyBmaW5hbGx5IGdldHMgYXJvdW5kIHRvIHJlbmRlcmluZyBpdHMgbGF6eSBzZWxmXG4gICAgICAgIC8vIGZpcmUgb2ZmIHRoZSBpbml0aWFsIHVwZGF0ZVxuICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1yYyddLnB1c2goc2NoZWR1bGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuY29uc3QgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKEJVSUxELmxhenlMb2FkICYmIEJVSUxELmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXJUYXJnZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcnVuIGlmIHdlIGhhdmUgbGlzdGVuZXJzIGJlaW5nIGF0dGFjaGVkIHRvIGEgcGFyZW50XG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiAxIC8qIGhhc0Nvbm5lY3RlZCAqLykpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWUgdGhpcyBjb21wb25lbnQgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAgbGV0IGhvc3RJZDtcbiAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgICAgIGhvc3RJZCA9IGVsbS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IEJVSUxELm1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhLCBlbG0uZ2V0QXR0cmlidXRlKCdzLW1vZGUnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290LCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlSWQgKyAnLWgnLCBzY29wZUlkICsgJy1zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZWxtLCBjbXBNZXRhLiR0YWdOYW1lJCwgaG9zdElkLCBob3N0UmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgIWhvc3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRVcGRhdGVcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xvdCBwb2x5ZmlsbCBpcyByZXF1aXJlZCB3ZSdsbCBuZWVkIHRvIHB1dCBzb21lIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gaGVyZSB0byBhY3QgYXMgb3JpZ2luYWwgY29udGVudCBhbmNob3JzIGFzIHdlIG1vdmUgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgLy8gaG9zdCBlbGVtZW50IGhhcyBiZWVuIGNvbm5lY3RlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICgoQlVJTEQuc2xvdCB8fCBCVUlMRC5zaGFkb3dEb20pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRmbGFncyQgJiAoNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLyB8IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudFJlZmVyZW5jZShlbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBhbmNlc3RvciBjb21wb25lbnQgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgYXMgb25lIG9mIHRoZSBhY3RpdmVseSBsb2FkaW5nIGNoaWxkIGNvbXBvbmVudHMgZm9yIGl0cyBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGltYiB1cCB0aGUgYW5jZXN0b3JzIGxvb2tpbmcgZm9yIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgZmluaXNoZWQgaXRzIGxpZmVjeWNsZSB1cGRhdGUgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICgoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudC5oYXNBdHRyaWJ1dGUoJ3MtaWQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCB0aGlzIGNvbXBvbmVudHMgZmlyc3QgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgY29tcG9uZW50J3MgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIChob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQgPSBhbmNlc3RvckNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMYXp5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoQlVJTEQucHJvcCAmJiAhQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjbXBNZXRhLiRtZW1iZXJzJCkubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLyAmJiBlbG0uaGFzT3duUHJvcGVydHkobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaW5pdGlhbGl6ZU5leHRUaWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGVkQ2FsbGJhY2ssIHRhc2tRdWV1ZSwgaW5pdGlhbExvYWRcbiAgICAgICAgICAgICAgICAvLyBhbmd1bGFyIHNldHMgYXR0cmlidXRlIEFGVEVSIGNvbm5lY3RDYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE4OTA5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk5NDBcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IHRoZSBmaXJzdCB0aW1lIHRoaXMgaGFzIGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gcmVhdHRhY2ggYW55IGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaG9zdFxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSB3b3VsZCBoYXZlIGJlZW4gcmVtb3ZlZCB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZmlyZSBvZmYgY29ubmVjdGVkQ2FsbGJhY2soKSBvbiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRDb25uZWN0ZWQoKTtcbiAgICB9XG59O1xuY29uc3Qgc2V0Q29udGVudFJlZmVyZW5jZSA9IChlbG0pID0+IHtcbiAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAvLyBhbmQgdGhpcyBob3N0IGVsZW1lbnQgd2FzIE5PVCBjcmVhdGVkIHdpdGggU1NSXG4gICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgIC8vIGNvbnRlbnQgd2FzIGZpcnN0IHBsYWNlZCwgd2hpY2ggaXMgdXNlZnVsIGxhdGVyIG9uXG4gICAgY29uc3QgY29udGVudFJlZkVsbSA9IChlbG1bJ3MtY3InXSA9IGRvYy5jcmVhdGVDb21tZW50KEJVSUxELmlzRGVidWcgPyBgY29udGVudC1yZWYgKGhvc3Q9JHtlbG0ubG9jYWxOYW1lfSlgIDogJycpKTtcbiAgICBjb250ZW50UmVmRWxtWydzLWNuJ10gPSB0cnVlO1xuICAgIGVsbS5pbnNlcnRCZWZvcmUoY29udGVudFJlZkVsbSwgZWxtLmZpcnN0Q2hpbGQpO1xufTtcbmNvbnN0IGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHJtTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHJtTGlzdGVuZXJzJC5tYXAoKHJtTGlzdGVuZXIpID0+IHJtTGlzdGVuZXIoKSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIENTUyB2YXItc2hpbSB0cmFja2luZ1xuICAgICAgICBpZiAoQlVJTEQuY3NzVmFyU2hpbSAmJiBwbHQuJGNzc1NoaW0kKSB7XG4gICAgICAgICAgICBwbHQuJGNzc1NoaW0kLnJlbW92ZUhvc3QoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuY21wRGlkVW5sb2FkKSB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVubG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSAoQ3N0ciwgY29tcGFjdE1ldGEpID0+IHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoY29tcGFjdE1ldGFbMV0sIHByb3h5Q3VzdG9tRWxlbWVudChDc3RyLCBjb21wYWN0TWV0YSkpO1xufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAgaWYgKEJVSUxELm1lbWJlcikge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci4kd2F0Y2hlcnMkO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQgPSBbXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBPYmplY3QuYXNzaWduKENzdHIucHJvdG90eXBlLCB7XG4gICAgICAgIF9fcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHRoaXMsIGNtcE1ldGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmNvbm5lY3RlZENhbGxiYWNrICYmIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuZGlzY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19hdHRhY2hTaGFkb3coKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIENzdHIuaXMgPSBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICByZXR1cm4gcHJveHlDb21wb25lbnQoQ3N0ciwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLyB8IDIgLyogcHJveHlTdGF0ZSAqLyk7XG59O1xuY29uc3QgZm9yY2VNb2RlVXBkYXRlID0gKGVsbSkgPT4ge1xuICAgIGlmIChCVUlMRC5zdHlsZSAmJiBCVUlMRC5tb2RlICYmICFCVUlMRC5sYXp5TG9hZCkge1xuICAgICAgICBjb25zdCBtb2RlID0gY29tcHV0ZU1vZGUoZWxtKTtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG1vZGVOYW1lJCAhPT0gbW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NvcGVJZCA9IGVsbVsncy1zYyddO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSwgbW9kZSk7XG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsbS5jb25zdHJ1Y3Rvci5zdHlsZVttb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gY21wTWV0YS4kZmxhZ3MkO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGZsYWdzICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJG1vZGVOYW1lJCA9IG1vZGU7XG4gICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUob2xkU2NvcGVJZCArICctaCcsIG9sZFNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBobXJTdGFydCA9IChlbG0sIGNtcE1ldGEsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAvLyByZXNldCBzdGF0ZSBmbGFncyB0byBvbmx5IGhhdmUgYmVlbiBjb25uZWN0ZWRcbiAgICBob3N0UmVmLiRmbGFncyQgPSAxIC8qIGhhc0Nvbm5lY3RlZCAqLztcbiAgICAvLyBUT0RPXG4gICAgLy8gZGV0YXRjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZGRlZFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbm90IHBhc3NpbmcgYW4gZXhhY3QgZXZlbnQgbmFtZSBpdCdsbFxuICAgIC8vIHJlbW92ZSBhbGwgb2YgdGhpcyBlbGVtZW50J3MgZXZlbnQsIHdoaWNoIGlzIGdvb2RcbiAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGlzIGNvbXBvbmVudCBmaW5pc2hlcyBobXJcbiAgICBlbG1bJ3MtaG1yLWxvYWQnXSA9ICgpID0+IHtcbiAgICAgICAgLy8gZmluaXNoZWQgaG1yIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgZGVsZXRlIGVsbVsncy1obXItbG9hZCddO1xuICAgIH07XG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG59O1xuY29uc3QgcGF0Y2hDbG9uZU5vZGUgPSAoSG9zdEVsZW1lbnRQcm90b3R5cGUpID0+IHtcbiAgICBjb25zdCBvcmdDbG9uZU5vZGUgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGU7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuY2xvbmVOb2RlID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjTm9kZSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzU2hhZG93RG9tID0gQlVJTEQuc2hhZG93RG9tID8gc3JjTm9kZS5zaGFkb3dSb290ICYmIHN1cHBvcnRzU2hhZG93IDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBvcmdDbG9uZU5vZGUuY2FsbChzcmNOb2RlLCBpc1NoYWRvd0RvbSA/IGRlZXAgOiBmYWxzZSk7XG4gICAgICAgIGlmIChCVUlMRC5zbG90ICYmICFpc1NoYWRvd0RvbSAmJiBkZWVwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgc2xvdHRlZCwgbm9uU3RlbmNpbE5vZGU7XG4gICAgICAgICAgICBsZXQgc3RlbmNpbFByaXZhdGVzID0gW1xuICAgICAgICAgICAgICAgICdzLWlkJyxcbiAgICAgICAgICAgICAgICAncy1jcicsXG4gICAgICAgICAgICAgICAgJ3MtbHInLFxuICAgICAgICAgICAgICAgICdzLXJjJyxcbiAgICAgICAgICAgICAgICAncy1zYycsXG4gICAgICAgICAgICAgICAgJ3MtcCcsXG4gICAgICAgICAgICAgICAgJ3MtY24nLFxuICAgICAgICAgICAgICAgICdzLXNyJyxcbiAgICAgICAgICAgICAgICAncy1zbicsXG4gICAgICAgICAgICAgICAgJ3MtaG4nLFxuICAgICAgICAgICAgICAgICdzLW9sJyxcbiAgICAgICAgICAgICAgICAncy1ucicsXG4gICAgICAgICAgICAgICAgJ3Mtc2knLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc3JjTm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2xvdHRlZCA9IHNyY05vZGUuY2hpbGROb2Rlc1tpXVsncy1uciddO1xuICAgICAgICAgICAgICAgIG5vblN0ZW5jaWxOb2RlID0gc3RlbmNpbFByaXZhdGVzLmV2ZXJ5KChwcml2YXRlRmllbGQpID0+ICFzcmNOb2RlLmNoaWxkTm9kZXNbaV1bcHJpdmF0ZUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCAmJiBjbG9uZWROb2RlLl9fYXBwZW5kQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZChzbG90dGVkLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uU3RlbmNpbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzcmNOb2RlLmNoaWxkTm9kZXNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgfTtcbn07XG5jb25zdCBwYXRjaFNsb3RBcHBlbmRDaGlsZCA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLl9fYXBwZW5kQ2hpbGQgPSBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZDtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCBzbG90TmFtZSA9IChuZXdDaGlsZFsncy1zbiddID0gZ2V0U2xvdE5hbWUobmV3Q2hpbGQpKTtcbiAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChzbG90Tm9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkTm9kZXMgPSBnZXRIb3N0U2xvdENoaWxkTm9kZXMoc2xvdE5vZGUsIHNsb3ROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVuZEFmdGVyID0gc2xvdENoaWxkTm9kZXNbc2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gYXBwZW5kQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIGFwcGVuZEFmdGVyLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9O1xufTtcbi8qKlxuICogUGF0Y2hlcyB0aGUgdGV4dCBjb250ZW50IG9mIGFuIHVubmFtZWQgc2xvdHRlZCBub2RlIGluc2lkZSBhIHNjb3BlZCBjb21wb25lbnRcbiAqIEBwYXJhbSBob3N0RWxlbWVudFByb3RvdHlwZSB0aGUgYEVsZW1lbnRgIHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBjbXBNZXRhIGNvbXBvbmVudCBydW50aW1lIG1ldGFkYXRhIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHBhdGNoZWQgb3Igbm90XG4gKi9cbmNvbnN0IHBhdGNoVGV4dENvbnRlbnQgPSAoaG9zdEVsZW1lbnRQcm90b3R5cGUsIGNtcE1ldGEpID0+IHtcbiAgICBpZiAoQlVJTEQuc2NvcGVkICYmIGNtcE1ldGEuJGZsYWdzJCAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50Jyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0RWxlbWVudFByb3RvdHlwZSwgJ19fdGV4dENvbnRlbnQnLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgJ2RlZmF1bHQgc2xvdCcsIHdoaWNoIHdvdWxkIGJlIHRoZSBmaXJzdCBzbG90IGluIGEgc2hhZG93IHRyZWUgKGlmIHdlIHdlcmUgdXNpbmcgb25lKSwgd2hvc2UgbmFtZSBpc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsICcnKTtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGEgc2xvdCBub2RlIGlzIGZvdW5kLCB0aGUgdGV4dENvbnRlbnQgX21heV8gYmUgZm91bmQgaW4gdGhlIG5leHQgc2libGluZyAodGV4dCkgbm9kZSwgZGVwZW5kaW5nIG9uIGhvd1xuICAgICAgICAgICAgICAgIC8vIG5vZGVzIHdlcmUgcmVvcmRlcmVkIGR1cmluZyB0aGUgdmRvbSByZW5kZXIuIGZpcnN0IHRyeSB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tIHRoZSBzaWJsaW5nLlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gc2xvdE5vZGUgPT09IG51bGwgfHwgc2xvdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsb3ROb2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVR5cGUpID09PSAzIC8qIFRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBuZWVkIHRvIGJlIHBsYWNlZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLFxuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiBob3cgbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIHNldCB0aGUgdGV4dCBjb250ZW50IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLm5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROb2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZG4ndCBmaW5kIGEgc2xvdCwgYnV0IHRoYXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlcmUgaXNuJ3Qgb25lLiBpZiB0aGlzIGNoZWNrIHJhbiBiZWZvcmUgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAvLyBsb2FkZWQsIHdlIGNvdWxkIGhhdmUgbWlzc2VkIGl0LiBjaGVjayBmb3IgYSBjb250ZW50IHJlZmVyZW5jZSBlbGVtZW50IG9uIHRoZSBzY29wZWQgY29tcG9uZW50IGFuZCBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSZWZFbG0gPSB0aGlzWydzLWNyJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50UmVmRWxtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhdGNoQ2hpbGRTbG90Tm9kZXMgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY2xhc3MgRmFrZU5vZGVMaXN0IGV4dGVuZHMgQXJyYXkge1xuICAgICAgICBpdGVtKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzRm4gPSBlbG0uX19sb29rdXBHZXR0ZXJfXygnY2hpbGROb2RlcycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGRyZW4nLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZEVsZW1lbnRDb3VudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxtLCAnY2hpbGROb2RlcycsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0ZuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEhvc3RSZWYodGhpcykuJGZsYWdzJCAmIDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEZha2VOb2RlTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNsb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGYWtlTm9kZUxpc3QuZnJvbShjaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBnZXRTbG90TmFtZSA9IChub2RlKSA9PiBub2RlWydzLXNuJ10gfHwgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSkgfHwgJyc7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIGEgc2VyaWVzIG9mIGNoaWxkIG5vZGVzIGZvciBhIHNsb3Qgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZS5cbiAqIEBwYXJhbSBjaGlsZE5vZGVzIHRoZSBub2RlcyB0byBzZWFyY2ggZm9yIGEgc2xvdCB3aXRoIGEgc3BlY2lmaWMgbmFtZS5cbiAqIEBwYXJhbSBzbG90TmFtZSB0aGUgbmFtZSBvZiB0aGUgc2xvdCB0byBtYXRjaCBvbi5cbiAqIEByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzbG90IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBuYW1lLCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IGdldEhvc3RTbG90Tm9kZSA9IChjaGlsZE5vZGVzLCBzbG90TmFtZSkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGZvciAoOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICBpZiAoY2hpbGROb2RlWydzLXNyJ10gJiYgY2hpbGROb2RlWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkTm9kZSA9IGdldEhvc3RTbG90Tm9kZShjaGlsZE5vZGUuY2hpbGROb2Rlcywgc2xvdE5hbWUpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldEhvc3RTbG90Q2hpbGROb2RlcyA9IChuLCBzbG90TmFtZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbbl07XG4gICAgd2hpbGUgKChuID0gbi5uZXh0U2libGluZykgJiYgblsncy1zbiddID09PSBzbG90TmFtZSkge1xuICAgICAgICBjaGlsZE5vZGVzLnB1c2gobik7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xufTtcbmNvbnN0IGJvb3RzdHJhcExhenkgPSAobGF6eUJ1bmRsZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChCVUlMRC5wcm9maWxlICYmIHBlcmZvcm1hbmNlLm1hcmspIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnc3Q6YXBwOnN0YXJ0Jyk7XG4gICAgfVxuICAgIGluc3RhbGxEZXZUb29scygpO1xuICAgIGNvbnN0IGVuZEJvb3RzdHJhcCA9IGNyZWF0ZVRpbWUoJ2Jvb3RzdHJhcExhenknKTtcbiAgICBjb25zdCBjbXBUYWdzID0gW107XG4gICAgY29uc3QgZXhjbHVkZSA9IG9wdGlvbnMuZXhjbHVkZSB8fCBbXTtcbiAgICBjb25zdCBjdXN0b21FbGVtZW50cyA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgICBjb25zdCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgY29uc3QgbWV0YUNoYXJzZXQgPSAvKkBfX1BVUkVfXyovIGhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtjaGFyc2V0XScpO1xuICAgIGNvbnN0IHZpc2liaWxpdHlTdHlsZSA9IC8qQF9fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgICBjb25zdCBzdHlsZXMgPSAvKkBfX1BVUkVfXyovIGRvYy5xdWVyeVNlbGVjdG9yQWxsKGBbJHtIWURSQVRFRF9TVFlMRV9JRH1dYCk7XG4gICAgbGV0IGFwcExvYWRGYWxsYmFjaztcbiAgICBsZXQgaXNCb290c3RyYXBwaW5nID0gdHJ1ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgT2JqZWN0LmFzc2lnbihwbHQsIG9wdGlvbnMpO1xuICAgIHBsdC4kcmVzb3VyY2VzVXJsJCA9IG5ldyBVUkwob3B0aW9ucy5yZXNvdXJjZXNVcmwgfHwgJy4vJywgZG9jLmJhc2VVUkkpLmhyZWY7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luY1F1ZXVlKSB7XG4gICAgICAgICAgICBwbHQuJGZsYWdzJCB8PSA0IC8qIHF1ZXVlU3luYyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGFwcCBpcyBhbHJlYWR5IGh5ZHJhdGVkIHRoZXJlIGlzIG5vdCBwb2ludCB0byBkaXNhYmxlIHRoZVxuICAgICAgICAvLyBhc3luYyBxdWV1ZS4gVGhpcyB3aWxsIGltcHJvdmUgdGhlIGZpcnN0IGlucHV0IGRlbGF5XG4gICAgICAgIHBsdC4kZmxhZ3MkIHw9IDIgLyogYXBwTG9hZGVkICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZUNsaWVudFNpZGUgJiYgQlVJTEQuc2hhZG93RG9tKSB7XG4gICAgICAgIGZvciAoOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZWdpc3RlclN0eWxlKHN0eWxlc1tpXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLCBjb252ZXJ0U2NvcGVkVG9TaGFkb3coc3R5bGVzW2ldLmlubmVySFRNTCksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgICAgICBsYXp5QnVuZGxlWzFdLm1hcCgoY29tcGFjdE1ldGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICAgICAgICAgJHRhZ05hbWUkOiBjb21wYWN0TWV0YVsxXSxcbiAgICAgICAgICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAgICAgICAgICRsaXN0ZW5lcnMkOiBjb21wYWN0TWV0YVszXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kbWVtYmVycyQgPSBjb21wYWN0TWV0YVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRsaXN0ZW5lcnMkID0gY29tcGFjdE1ldGFbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgIXN1cHBvcnRzU2hhZG93ICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCB8PSA4IC8qIG5lZWRzU2hhZG93RG9tU2hpbSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBCVUlMRC50cmFuc2Zvcm1UYWdOYW1lICYmIG9wdGlvbnMudHJhbnNmb3JtVGFnTmFtZVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKGNtcE1ldGEuJHRhZ05hbWUkKVxuICAgICAgICAgICAgICAgIDogY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgICAgICAgICBjb25zdCBIb3N0RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIC8vIFN0ZW5jaWxMYXp5SG9zdFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGlzIHVzaW5nIHNoYWRvdyBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSByZWFkLW9ubHkgcHJvcGVydHkgXCJzaGFkb3dSb290XCIgdG8gdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaW5nIHRoZSBzaGFkb3cgcm9vdCBidWlsZCBjb25kaXRpb25hbHMgdG8gbWluaW1pemUgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RlbGVnYXRlc0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlc0ZvY3VzOiAhIShjbXBNZXRhLiRmbGFncyQgJiAxNiAvKiBzaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmICEoJ3NoYWRvd1Jvb3QnIGluIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaGFkb3dSb290ID0gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2xvdENoaWxkTm9kZXNGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRTbG90Tm9kZXMoc2VsZiwgY21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChhcHBMb2FkRmFsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb290c3RyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjayB3aWxsIGJlIHByb2Nlc3NlZCBvbmNlIGFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnRPblJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SG9zdFJlZih0aGlzKS4kb25SZWFkeVByb21pc2UkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoQlVJTEQuY2xvbmVOb2RlRml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hDbG9uZU5vZGUoSG9zdEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5hcHBlbmRDaGlsZFNsb3RGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFNsb3RBcHBlbmRDaGlsZChIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgSG9zdEVsZW1lbnQucHJvdG90eXBlWydzLWhtciddID0gZnVuY3Rpb24gKGhtclZlcnNpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBobXJTdGFydCh0aGlzLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2NvcGVkU2xvdFRleHRDb250ZW50Rml4KSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUZXh0Q29udGVudChIb3N0RWxlbWVudC5wcm90b3R5cGUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21wTWV0YS4kbGF6eUJ1bmRsZUlkJCA9IGxhenlCdW5kbGVbMF07XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXModGFnTmFtZSkgJiYgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgcHJveHlDb21wb25lbnQoSG9zdEVsZW1lbnQsIGNtcE1ldGEsIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKEJVSUxELmludmlzaWJsZVByZWh5ZHJhdGlvbiAmJiAoQlVJTEQuaHlkcmF0ZWRDbGFzcyB8fCBCVUlMRC5oeWRyYXRlZEF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLmlubmVySFRNTCA9IGNtcFRhZ3MgKyBIWURSQVRFRF9DU1M7XG4gICAgICAgIHZpc2liaWxpdHlTdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3R5bGVzJywgJycpO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZSh2aXNpYmlsaXR5U3R5bGUsIG1ldGFDaGFyc2V0ID8gbWV0YUNoYXJzZXQubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGRlZmVycmVkIGNvbm5lY3RlZENhbGxiYWNrcyBub3cgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICBpc0Jvb3RzdHJhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLm1hcCgoaG9zdCkgPT4gaG9zdC5jb25uZWN0ZWRDYWxsYmFjaygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5wcm9maWxlKSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwLCAndGltZW91dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQuam1wKCgpID0+IChhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGFwcExvYWQgZXZlbnRcbiAgICBlbmRCb290c3RyYXAoKTtcbn07XG5jb25zdCBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFzc2V0VXJsID0gbmV3IFVSTChwYXRoLCBwbHQuJHJlc291cmNlc1VybCQpO1xuICAgIHJldHVybiBhc3NldFVybC5vcmlnaW4gIT09IHdpbi5sb2NhdGlvbi5vcmlnaW4gPyBhc3NldFVybC5ocmVmIDogYXNzZXRVcmwucGF0aG5hbWU7XG59O1xuY29uc3Qgc2V0QXNzZXRQYXRoID0gKHBhdGgpID0+IChwbHQuJHJlc291cmNlc1VybCQgPSBwYXRoKTtcbmNvbnN0IGdldENvbm5lY3QgPSAoX3JlZiwgdGFnTmFtZSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudE9uUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBlbG0gPSBkb2MucXVlcnlTZWxlY3Rvcih0YWdOYW1lKTtcbiAgICAgICAgaWYgKCFlbG0pIHtcbiAgICAgICAgICAgIGVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGVsbS5jb21wb25lbnRPblJlYWR5ID09PSAnZnVuY3Rpb24nID8gZWxtLmNvbXBvbmVudE9uUmVhZHkoKSA6IFByb21pc2UucmVzb2x2ZShlbG0pO1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChlbCkgPT4gZWwuY3JlYXRlKC4uLmFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgY29tcG9uZW50T25SZWFkeSxcbiAgICB9O1xufTtcbmNvbnN0IGdldENvbnRleHQgPSAoX2VsbSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0IGluIENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIENvbnRleHRbY29udGV4dF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgIHJldHVybiB3aW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzU2VydmVyJyB8fCBjb250ZXh0ID09PSAnaXNQcmVyZW5kZXInKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2lzQ2xpZW50Jykge1xuICAgICAgICByZXR1cm4gQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdyZXNvdXJjZXNVcmwnIHx8IGNvbnRleHQgPT09ICdwdWJsaWNQYXRoJykge1xuICAgICAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKCcuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdxdWV1ZScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyaXRlOiB3cml0ZVRhc2ssXG4gICAgICAgICAgICByZWFkOiByZWFkVGFzayxcbiAgICAgICAgICAgIHRpY2s6IHtcbiAgICAgICAgICAgICAgICB0aGVuKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGljayhjYik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgaW5zZXJ0VmRvbUFubm90YXRpb25zID0gKGRvYywgc3RhdGljQ29tcG9uZW50cykgPT4ge1xuICAgIGlmIChkb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb2NEYXRhID0ge1xuICAgICAgICAgICAgaG9zdElkczogMCxcbiAgICAgICAgICAgIHJvb3RMZXZlbElkczogMCxcbiAgICAgICAgICAgIHN0YXRpY0NvbXBvbmVudHM6IG5ldyBTZXQoc3RhdGljQ29tcG9uZW50cyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgcGFyc2VWTm9kZUFubm90YXRpb25zKGRvYywgZG9jLmJvZHksIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICBvcmdMb2NhdGlvbk5vZGVzLmZvckVhY2goKG9yZ0xvY2F0aW9uTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlZiA9IG9yZ0xvY2F0aW9uTm9kZVsncy1uciddO1xuICAgICAgICAgICAgICAgIGxldCBob3N0SWQgPSBub2RlUmVmWydzLWhvc3QtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUlkID0gbm9kZVJlZlsncy1ub2RlLWlkJ107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RJZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvY0RhdGEucm9vdExldmVsSWRzKys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCA9IGRvY0RhdGEucm9vdExldmVsSWRzO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RJZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZVJlZi5ub2RlVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlbGVzcyB3aGl0ZXNwYWNlIG5vZGUgYXQgdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEJlZm9yZVRleHROb2RlID0gZG9jLmNyZWF0ZUNvbW1lbnQoY2hpbGRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50QmVmb3JlVGV4dE5vZGUubm9kZVZhbHVlID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBub2RlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb3JnTG9jYXRpb25Ob2RlSWQgPSBgJHtPUkdfTE9DQVRJT05fSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSA9IG9yZ0xvY2F0aW9uTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5cIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTSEFET1cgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICdjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kaW5nIHdpdGggYSBcIi5jXCIgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoaXMgbm9kZSdzIG9yaWdpbmFsIGxvY2F0aW9uIGlzIGEgU0NPUEVEIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaXMgYXBhcnQgb2YgdGhlIHJvb3QgbGV2ZWwgbGlnaHQgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGVJZCArPSBgLmNgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZS5ub2RlVmFsdWUgPSBvcmdMb2NhdGlvbk5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlVk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIG5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpID0+IHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGVbJ3MtbnInXSAhPSBudWxsKSB7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIGlmIChob3N0UmVmICE9IG51bGwgJiYgIWRvY0RhdGEuc3RhdGljQ29tcG9uZW50cy5oYXMoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY21wRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkczogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluc2VydFZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGhvc3RSZWYuJHZub2RlJCwgZG9jRGF0YSwgY21wRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBjaGlsZE5vZGUsIGRvY0RhdGEsIG9yZ0xvY2F0aW9uTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyA9IChkb2MsIGhvc3RFbG0sIHZub2RlLCBkb2NEYXRhLCBjbXBEYXRhKSA9PiB7XG4gICAgaWYgKHZub2RlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaG9zdElkID0gKytkb2NEYXRhLmhvc3RJZHM7XG4gICAgICAgIGhvc3RFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfSUQsIGhvc3RJZCk7XG4gICAgICAgIGlmIChob3N0RWxtWydzLWNyJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9zdEVsbVsncy1jciddLm5vZGVWYWx1ZSA9IGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZub2RlLiRjaGlsZHJlbiQuZm9yRWFjaCgodm5vZGVDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdEVsbSAmJiB2bm9kZSAmJiB2bm9kZS4kZWxtJCAmJiAhaG9zdEVsbS5oYXNBdHRyaWJ1dGUoJ2MtaWQnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gaG9zdEVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudENoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gcGFyZW50Q2hpbGROb2Rlcy5maW5kKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovICYmIG5vZGVbJ3Mtc3InXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZE5vZGVzLmluZGV4T2YoaG9zdEVsbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS4kZWxtJC5zZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCwgYCR7Y29tbWVudFsncy1ob3N0LWlkJ119LiR7Y29tbWVudFsncy1ub2RlLWlkJ119LjAuJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zID0gKGRvYywgdm5vZGVDaGlsZCwgY21wRGF0YSwgaG9zdElkLCBkZXB0aCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZEVsbSA9IHZub2RlQ2hpbGQuJGVsbSQ7XG4gICAgaWYgKGNoaWxkRWxtID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSBjbXBEYXRhLm5vZGVJZHMrKztcbiAgICBjb25zdCBjaGlsZElkID0gYCR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH1gO1xuICAgIGNoaWxkRWxtWydzLWhvc3QtaWQnXSA9IGhvc3RJZDtcbiAgICBjaGlsZEVsbVsncy1ub2RlLWlkJ10gPSBub2RlSWQ7XG4gICAgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgIGNoaWxkRWxtLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNoaWxkRWxtLnBhcmVudE5vZGU7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKG5vZGVOYW1lICE9PSAnU1RZTEUnICYmIG5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGVJZCA9IGAke1RFWFRfTk9ERV9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0Tm9kZUlkKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSwgY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkRWxtLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIGlmIChjaGlsZEVsbVsncy1zciddKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IGNoaWxkRWxtWydzLXNuJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzbG90Tm9kZUlkID0gYCR7U0xPVF9OT0RFX0lEfS4ke2NoaWxkSWR9LiR7c2xvdE5hbWV9YDtcbiAgICAgICAgICAgIGNoaWxkRWxtLm5vZGVWYWx1ZSA9IHNsb3ROb2RlSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlQ2hpbGQuJGNoaWxkcmVuJCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRGVwdGggPSBkZXB0aCArIDE7XG4gICAgICAgIHZub2RlQ2hpbGQuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlLCBjbXBEYXRhLCBob3N0SWQsIGNoaWxkRGVwdGgsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IHNldFBsYXRmb3JtT3B0aW9ucyA9IChvcHRzKSA9PiBPYmplY3QuYXNzaWduKHBsdCwgb3B0cyk7XG5jb25zdCBGcmFnbWVudCA9IChfLCBjaGlsZHJlbikgPT4gY2hpbGRyZW47XG5jb25zdCBob3N0UmVmcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KChob3N0UmVmLiRsYXp5SW5zdGFuY2UkID0gbGF6eUluc3RhbmNlKSwgaG9zdFJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQgPSAwO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25JbnN0YW5jZVJlc29sdmUkID0gcikpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkID0gcikpO1xuICAgICAgICBlbG1bJ3MtcCddID0gW107XG4gICAgICAgIGVsbVsncy1yYyddID0gW107XG4gICAgfVxuICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIGZhbHNlKTtcbiAgICByZXR1cm4gaG9zdFJlZnMuc2V0KGVsbSwgaG9zdFJlZik7XG59O1xuY29uc3QgaXNNZW1iZXJJbkVsZW1lbnQgPSAoZWxtLCBtZW1iZXJOYW1lKSA9PiBtZW1iZXJOYW1lIGluIGVsbTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKGN1c3RvbUVycm9yIHx8IGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcbmNvbnN0IFNURU5DSUxfREVWX01PREUgPSBCVUlMRC5pc1Rlc3RpbmdcbiAgICA/IFsnU1RFTkNJTDonXSAvLyBFMkUgdGVzdGluZ1xuICAgIDogW1xuICAgICAgICAnJWNzdGVuY2lsJyxcbiAgICAgICAgJ2NvbG9yOiB3aGl0ZTtiYWNrZ3JvdW5kOiM0YzQ3ZmY7Zm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZToxMHB4OyBwYWRkaW5nOjJweCA2cHg7IGJvcmRlci1yYWRpdXM6IDVweCcsXG4gICAgXTtcbmNvbnN0IGNvbnNvbGVEZXZFcnJvciA9ICguLi5tKSA9PiBjb25zb2xlLmVycm9yKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldldhcm4gPSAoLi4ubSkgPT4gY29uc29sZS53YXJuKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3QgY29uc29sZURldkluZm8gPSAoLi4ubSkgPT4gY29uc29sZS5pbmZvKC4uLlNURU5DSUxfREVWX01PREUsIC4uLm0pO1xuY29uc3Qgc2V0RXJyb3JIYW5kbGVyID0gKGhhbmRsZXIpID0+IChjdXN0b21FcnJvciA9IGhhbmRsZXIpO1xuY29uc3QgY21wTW9kdWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3QgbG9hZE1vZHVsZSA9IChjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgICAvLyBsb2FkTW9kdWxlSW1wb3J0XG4gICAgY29uc3QgZXhwb3J0TmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICBjb25zdCBidW5kbGVJZCA9IGNtcE1ldGEuJGxhenlCdW5kbGVJZCQ7XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBidW5kbGVJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZURldkVycm9yKGBUcnlpbmcgdG8gbGF6aWx5IGxvYWQgY29tcG9uZW50IDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gd2l0aCBzdHlsZSBtb2RlIFwiJHtob3N0UmVmLiRtb2RlTmFtZSR9XCIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlID0gIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50ID8gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDogZmFsc2U7XG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0KFxuICAgIC8qIHdlYnBhY2tJbmNsdWRlOiAvXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja0V4Y2x1ZGU6IC9cXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrTW9kZTogXCJsYXp5XCIgKi9cbiAgICBgLi8ke2J1bmRsZUlkfS5lbnRyeS5qcyR7QlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgJiYgaG1yVmVyc2lvbklkID8gJz9zLWhtcj0nICsgaG1yVmVyc2lvbklkIDogJyd9YCkudGhlbigoaW1wb3J0ZWRNb2R1bGUpID0+IHtcbiAgICAgICAgaWYgKCFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1wb3J0ZWRNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfSwgY29uc29sZUVycm9yKTtcbn07XG5jb25zdCBzdHlsZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBtb2RlUmVzb2x1dGlvbkNoYWluID0gW107XG5jb25zdCBxdWV1ZURvbVJlYWRzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlcyA9IFtdO1xuY29uc3QgcXVldWVEb21Xcml0ZXNMb3cgPSBbXTtcbmNvbnN0IHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICAgIHF1ZXVlLnB1c2goY2IpO1xuICAgIGlmICghcXVldWVQZW5kaW5nKSB7XG4gICAgICAgIHF1ZXVlUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaV0ocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbn07XG5jb25zdCBjb25zdW1lVGltZW91dCA9IChxdWV1ZSwgdGltZW91dCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgdHMgPSAwO1xuICAgIHdoaWxlIChpIDwgcXVldWUubGVuZ3RoICYmICh0cyA9IHBlcmZvcm1hbmNlLm5vdygpKSA8IHRpbWVvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2krK10odHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgIHF1ZXVlLnNwbGljZSgwLCBpKTtcbiAgICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcXVldWVDb25nZXN0aW9uKys7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBmb3JjZSBhIGJ1bmNoIG9mIG1lZGl1bSBjYWxsYmFja3MgdG8gcnVuLCBidXQgc3RpbGwgaGF2ZVxuICAgIC8vIGEgdGhyb3R0bGUgb24gaG93IG1hbnkgY2FuIHJ1biBpbiBhIGNlcnRhaW4gdGltZVxuICAgIC8vIERPTSBSRUFEUyEhIVxuICAgIGNvbnN1bWUocXVldWVEb21SZWFkcyk7XG4gICAgLy8gRE9NIFdSSVRFUyEhIVxuICAgIGlmIChCVUlMRC5hc3luY1F1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAocGx0LiRmbGFncyQgJiA2IC8qIHF1ZXVlTWFzayAqLykgPT09IDIgLyogYXBwTG9hZGVkICovXG4gICAgICAgICAgICA/IHBlcmZvcm1hbmNlLm5vdygpICsgMTQgKiBNYXRoLmNlaWwocXVldWVDb25nZXN0aW9uICogKDEuMCAvIDEwLjApKVxuICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgY29uc3VtZVRpbWVvdXQocXVldWVEb21Xcml0ZXMsIHRpbWVvdXQpO1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlc0xvdywgdGltZW91dCk7XG4gICAgICAgIGlmIChxdWV1ZURvbVdyaXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZURvbVdyaXRlc0xvdy5wdXNoKC4uLnF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCArIHF1ZXVlRG9tV3JpdGVzTG93Lmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlQ29uZ2VzdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN1bWUocXVldWVEb21Xcml0ZXMpO1xuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5leHRUaWNrID0gLypAX19QVVJFX18qLyAoY2IpID0+IHByb21pc2VSZXNvbHZlKCkudGhlbihjYik7XG5jb25zdCByZWFkVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsIGZhbHNlKTtcbmNvbnN0IHdyaXRlVGFzayA9IC8qQF9fUFVSRV9fKi8gcXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLCB0cnVlKTtcbmNvbnN0IEJ1aWxkID0ge1xuICAgIGlzRGV2OiBCVUlMRC5pc0RldiA/IHRydWUgOiBmYWxzZSxcbiAgICBpc0Jyb3dzZXI6IHRydWUsXG4gICAgaXNTZXJ2ZXI6IGZhbHNlLFxuICAgIGlzVGVzdGluZzogQlVJTEQuaXNUZXN0aW5nID8gdHJ1ZSA6IGZhbHNlLFxufTtcbmV4cG9ydCB7IEJVSUxELCBFbnYsIE5BTUVTUEFDRSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEnO1xuZXhwb3J0IHsgQnVpbGQsIENTUywgQ29udGV4dCwgRnJhZ21lbnQsIEgsIEggYXMgSFRNTEVsZW1lbnQsIEhvc3QsIFNURU5DSUxfREVWX01PREUsIGFkZEhvc3RFdmVudExpc3RlbmVycywgYm9vdHN0cmFwTGF6eSwgY21wTW9kdWxlcywgY29ubmVjdGVkQ2FsbGJhY2ssIGNvbnNvbGVEZXZFcnJvciwgY29uc29sZURldkluZm8sIGNvbnNvbGVEZXZXYXJuLCBjb25zb2xlRXJyb3IsIGNyZWF0ZUV2ZW50LCBkZWZpbmVDdXN0b21FbGVtZW50LCBkaXNjb25uZWN0ZWRDYWxsYmFjaywgZG9jLCBmb3JjZU1vZGVVcGRhdGUsIGZvcmNlVXBkYXRlLCBnZXRBc3NldFBhdGgsIGdldENvbm5lY3QsIGdldENvbnRleHQsIGdldEVsZW1lbnQsIGdldEhvc3RSZWYsIGdldE1vZGUsIGdldFJlbmRlcmluZ1JlZiwgZ2V0VmFsdWUsIGgsIGluc2VydFZkb21Bbm5vdGF0aW9ucywgaXNNZW1iZXJJbkVsZW1lbnQsIGxvYWRNb2R1bGUsIG1vZGVSZXNvbHV0aW9uQ2hhaW4sIG5leHRUaWNrLCBwYXJzZVByb3BlcnR5VmFsdWUsIHBsdCwgcG9zdFVwZGF0ZUNvbXBvbmVudCwgcHJvbWlzZVJlc29sdmUsIHByb3h5Q29tcG9uZW50LCBwcm94eUN1c3RvbUVsZW1lbnQsIHJlYWRUYXNrLCByZWdpc3Rlckhvc3QsIHJlZ2lzdGVySW5zdGFuY2UsIHJlbmRlclZkb20sIHNldEFzc2V0UGF0aCwgc2V0RXJyb3JIYW5kbGVyLCBzZXRNb2RlLCBzZXRQbGF0Zm9ybUhlbHBlcnMsIHNldFBsYXRmb3JtT3B0aW9ucywgc2V0VmFsdWUsIHN0eWxlcywgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMsIHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zLCBzdXBwb3J0c1NoYWRvdywgd2luLCB3cml0ZVRhc2sgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///77210\n")},70655:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ZT": () => (/* binding */ __extends),\n/* harmony export */   "_T": () => (/* binding */ __rest),\n/* harmony export */   "mG": () => (/* binding */ __awaiter),\n/* harmony export */   "Jh": () => (/* binding */ __generator),\n/* harmony export */   "ev": () => (/* binding */ __spreadArray)\n/* harmony export */ });\n/* unused harmony exports __assign, __decorate, __param, __metadata, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA2NTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQztBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzVJLDBCQUEwQiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxrQkFBa0I7QUFDN0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzlhYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70655\n')}}]);