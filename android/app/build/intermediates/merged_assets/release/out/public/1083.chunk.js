"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[1083],{2634:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* unused harmony export Toast */\n/* harmony import */ var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1238);\n\nconst Toast = (0,_capacitor_core__WEBPACK_IMPORTED_MODULE_0__/* .registerPlugin */ .fo)('Toast', {\n    web: () => __webpack_require__.e(/* import() */ 5056).then(__webpack_require__.bind(__webpack_require__, 5056)).then(m => new m.ToastWeb()),\n});\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYzNC5qcyIsIm1hcHBpbmdzIjoiOztBQUFpRDtBQUNqRCxjQUFjLHlFQUFjO0FBQzVCLGVBQWUsb0dBQWU7QUFDOUIsQ0FBQztBQUM2QjtBQUNiO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AY2FwYWNpdG9yL3RvYXN0L2Rpc3QvZXNtL2luZGV4LmpzP2FmNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVnaXN0ZXJQbHVnaW4gfSBmcm9tICdAY2FwYWNpdG9yL2NvcmUnO1xuY29uc3QgVG9hc3QgPSByZWdpc3RlclBsdWdpbignVG9hc3QnLCB7XG4gICAgd2ViOiAoKSA9PiBpbXBvcnQoJy4vd2ViJykudGhlbihtID0+IG5ldyBtLlRvYXN0V2ViKCkpLFxufSk7XG5leHBvcnQgKiBmcm9tICcuL2RlZmluaXRpb25zJztcbmV4cG9ydCB7IFRvYXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2634\n")},6587:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": () => (/* binding */ componentOnReady),\n/* harmony export */   \"j\": () => (/* binding */ clamp),\n/* harmony export */   \"r\": () => (/* binding */ raf),\n/* harmony export */   \"s\": () => (/* binding */ shallowEqualStringMap)\n/* harmony export */ });\n/* unused harmony exports a, b, d, e, f, g, h, i, k, l, m, n, o, p, q, t */\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst transitionEndAsync = (el, expectedDuration = 0) => {\n  return new Promise(resolve => {\n    transitionEnd(el, expectedDuration, resolve);\n  });\n};\n/**\n * Allows developer to wait for a transition\n * to finish and fallback to a timer if the\n * transition is cancelled or otherwise\n * never finishes. Also see transitionEndAsync\n * which is an await-able version of this.\n */\nconst transitionEnd = (el, expectedDuration = 0, callback) => {\n  let unRegTrans;\n  let animationTimeout;\n  const opts = { passive: true };\n  const ANIMATION_FALLBACK_TIMEOUT = 500;\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (ev === undefined || el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n    animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);\n    unRegTrans = () => {\n      if (animationTimeout) {\n        clearTimeout(animationTimeout);\n        animationTimeout = undefined;\n      }\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\n/**\n * Waits for a component to be ready for\n * both custom element and non-custom element builds.\n * If non-custom element build, el.componentOnReady\n * will be used.\n * For custom element builds, we wait a frame\n * so that the inner contents of the component\n * have a chance to render.\n *\n * Use this utility rather than calling\n * el.componentOnReady yourself.\n */\nconst componentOnReady = (el, callback) => {\n  if (el.componentOnReady) {\n    el.componentOnReady().then((resolvedEl) => callback(resolvedEl));\n  }\n  else {\n    raf(() => callback(el));\n  }\n};\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\nconst addEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const ael = config.get('_ael');\n      if (ael) {\n        return ael(el, eventName, callback, opts);\n      }\n      else if (config._ael) {\n        return config._ael(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.addEventListener(eventName, callback, opts);\n};\nconst removeEventListener = (el, eventName, callback, opts) => {\n  if (typeof window !== 'undefined') {\n    const win = window;\n    const config = win && win.Ionic && win.Ionic.config;\n    if (config) {\n      const rel = config.get('_rel');\n      if (rel) {\n        return rel(el, eventName, callback, opts);\n      }\n      else if (config._rel) {\n        return config._rel(el, eventName, callback, opts);\n      }\n    }\n  }\n  return el.removeEventListener(eventName, callback, opts);\n};\n/**\n * Gets the root context of a shadow dom element\n * On newer browsers this will be the shadowRoot,\n * but for older browser this may just be the\n * element itself.\n *\n * Useful for whenever you need to explicitly\n * do \"myElement.shadowRoot!.querySelector(...)\".\n */\nconst getElementRoot = (el, fallback = el) => {\n  return el.shadowRoot || fallback;\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nconst hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\nconst findItemLabel = (componentEl) => {\n  const itemEl = componentEl.closest('ion-item');\n  if (itemEl) {\n    return itemEl.querySelector('ion-label');\n  }\n  return null;\n};\nconst focusElement = (el) => {\n  el.focus();\n  /**\n   * When programmatically focusing an element,\n   * the focus-visible utility will not run because\n   * it is expecting a keyboard event to have triggered this;\n   * however, there are times when we need to manually control\n   * this behavior so we call the `setFocus` method on ion-app\n   * which will let us explicitly set the elements to focus.\n   */\n  if (el.classList.contains('ion-focusable')) {\n    const app = el.closest('ion-app');\n    if (app) {\n      app.setFocus([el]);\n    }\n  }\n};\n/**\n * This method is used for Ionic's input components that use Shadow DOM. In\n * order to properly label the inputs to work with screen readers, we need\n * to get the text content of the label outside of the shadow root and pass\n * it to the input inside of the shadow root.\n *\n * Referencing label elements by id from outside of the component is\n * impossible due to the shadow boundary, read more here:\n * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html\n *\n * @param componentEl The shadow element that needs the aria label\n * @param inputId The unique identifier for the input\n */\nconst getAriaLabel = (componentEl, inputId) => {\n  let labelText;\n  // If the user provides their own label via the aria-labelledby attr\n  // we should use that instead of looking for an ion-label\n  const labelledBy = componentEl.getAttribute('aria-labelledby');\n  // Grab the id off of the component in case they are using\n  // a custom label using the label element\n  const componentId = componentEl.id;\n  let labelId = labelledBy !== null && labelledBy.trim() !== ''\n    ? labelledBy\n    : inputId + '-lbl';\n  let label = labelledBy !== null && labelledBy.trim() !== ''\n    ? document.getElementById(labelledBy)\n    : findItemLabel(componentEl);\n  if (label) {\n    if (labelledBy === null) {\n      label.id = labelId;\n    }\n    labelText = label.textContent;\n    label.setAttribute('aria-hidden', 'true');\n    // if there is no label, check to see if the user has provided\n    // one by setting an id on the component and using the label element\n  }\n  else if (componentId.trim() !== '') {\n    label = document.querySelector(`label[for=\"${componentId}\"]`);\n    if (label) {\n      if (label.id !== '') {\n        labelId = label.id;\n      }\n      else {\n        label.id = labelId = `${componentId}-lbl`;\n      }\n      labelText = label.textContent;\n    }\n  }\n  return { label, labelId, labelText };\n};\n/**\n * This method is used to add a hidden input to a host element that contains\n * a Shadow DOM. It does not add the input inside of the Shadow root which\n * allows it to be picked up inside of forms. It should contain the same\n * values as the host element.\n *\n * @param always Add a hidden input even if the container does not use Shadow\n * @param container The element where the input will be added\n * @param name The name of the input\n * @param value The value of the input\n * @param disabled If true, the input is disabled\n */\nconst renderHiddenInput = (always, container, name, value, disabled) => {\n  if (always || hasShadowDom(container)) {\n    let input = container.querySelector('input.aux-input');\n    if (!input) {\n      input = container.ownerDocument.createElement('input');\n      input.type = 'hidden';\n      input.classList.add('aux-input');\n      container.appendChild(input);\n    }\n    input.disabled = disabled;\n    input.name = name;\n    input.value = value || '';\n  }\n};\nconst clamp = (min, n, max) => {\n  return Math.max(min, Math.min(n, max));\n};\nconst assert = (actual, reason) => {\n  if (!actual) {\n    const message = 'ASSERT: ' + reason;\n    console.error(message);\n    debugger; // tslint:disable-line\n    throw new Error(message);\n  }\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\nconst pointerCoord = (ev) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      return { x: touch.clientX, y: touch.clientY };\n    }\n    if (ev.pageX !== undefined) {\n      return { x: ev.pageX, y: ev.pageY };\n    }\n  }\n  return { x: 0, y: 0 };\n};\n/**\n * @hidden\n * Given a side, return if it should be on the end\n * based on the value of dir\n * @param side the side\n * @param isRTL whether the application dir is rtl\n */\nconst isEndSide = (side) => {\n  const isRTL = document.dir === 'rtl';\n  switch (side) {\n    case 'start': return isRTL;\n    case 'end': return !isRTL;\n    default:\n      throw new Error(`\"${side}\" is not a valid value for [side]. Use \"start\" or \"end\" instead.`);\n  }\n};\nconst debounceEvent = (event, wait) => {\n  const original = event._original || event;\n  return {\n    _original: event,\n    emit: debounce(original.emit.bind(original), wait)\n  };\n};\nconst debounce = (func, wait = 0) => {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(func, wait, ...args);\n  };\n};\n/**\n * Check whether the two string maps are shallow equal.\n *\n * undefined is treated as an empty map.\n *\n * @returns whether the keys are the same and the values are shallow equal.\n */\nconst shallowEqualStringMap = (map1, map2) => {\n  map1 !== null && map1 !== void 0 ? map1 : (map1 = {});\n  map2 !== null && map2 !== void 0 ? map2 : (map2 = {});\n  if (map1 === map2) {\n    return true;\n  }\n  const keys1 = Object.keys(map1);\n  if (keys1.length !== Object.keys(map2).length) {\n    return false;\n  }\n  for (const k1 of keys1) {\n    if (!(k1 in map2)) {\n      return false;\n    }\n    if (map1[k1] !== map2[k1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0WSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9oZWxwZXJzLmpzP2VjMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmNvbnN0IHRyYW5zaXRpb25FbmRBc3luYyA9IChlbCwgZXhwZWN0ZWREdXJhdGlvbiA9IDApID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHRyYW5zaXRpb25FbmQoZWwsIGV4cGVjdGVkRHVyYXRpb24sIHJlc29sdmUpO1xuICB9KTtcbn07XG4vKipcbiAqIEFsbG93cyBkZXZlbG9wZXIgdG8gd2FpdCBmb3IgYSB0cmFuc2l0aW9uXG4gKiB0byBmaW5pc2ggYW5kIGZhbGxiYWNrIHRvIGEgdGltZXIgaWYgdGhlXG4gKiB0cmFuc2l0aW9uIGlzIGNhbmNlbGxlZCBvciBvdGhlcndpc2VcbiAqIG5ldmVyIGZpbmlzaGVzLiBBbHNvIHNlZSB0cmFuc2l0aW9uRW5kQXN5bmNcbiAqIHdoaWNoIGlzIGFuIGF3YWl0LWFibGUgdmVyc2lvbiBvZiB0aGlzLlxuICovXG5jb25zdCB0cmFuc2l0aW9uRW5kID0gKGVsLCBleHBlY3RlZER1cmF0aW9uID0gMCwgY2FsbGJhY2spID0+IHtcbiAgbGV0IHVuUmVnVHJhbnM7XG4gIGxldCBhbmltYXRpb25UaW1lb3V0O1xuICBjb25zdCBvcHRzID0geyBwYXNzaXZlOiB0cnVlIH07XG4gIGNvbnN0IEFOSU1BVElPTl9GQUxMQkFDS19USU1FT1VUID0gNTAwO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gKCkgPT4ge1xuICAgIGlmICh1blJlZ1RyYW5zKSB7XG4gICAgICB1blJlZ1RyYW5zKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSAoZXYpID0+IHtcbiAgICBpZiAoZXYgPT09IHVuZGVmaW5lZCB8fCBlbCA9PT0gZXYudGFyZ2V0KSB7XG4gICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgICBjYWxsYmFjayhldik7XG4gICAgfVxuICB9O1xuICBpZiAoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICBhbmltYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dChvblRyYW5zaXRpb25FbmQsIGV4cGVjdGVkRHVyYXRpb24gKyBBTklNQVRJT05fRkFMTEJBQ0tfVElNRU9VVCk7XG4gICAgdW5SZWdUcmFucyA9ICgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgYW5pbWF0aW9uVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCBvblRyYW5zaXRpb25FbmQsIG9wdHMpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5yZWdpc3Rlcjtcbn07XG4vKipcbiAqIFdhaXRzIGZvciBhIGNvbXBvbmVudCB0byBiZSByZWFkeSBmb3JcbiAqIGJvdGggY3VzdG9tIGVsZW1lbnQgYW5kIG5vbi1jdXN0b20gZWxlbWVudCBidWlsZHMuXG4gKiBJZiBub24tY3VzdG9tIGVsZW1lbnQgYnVpbGQsIGVsLmNvbXBvbmVudE9uUmVhZHlcbiAqIHdpbGwgYmUgdXNlZC5cbiAqIEZvciBjdXN0b20gZWxlbWVudCBidWlsZHMsIHdlIHdhaXQgYSBmcmFtZVxuICogc28gdGhhdCB0aGUgaW5uZXIgY29udGVudHMgb2YgdGhlIGNvbXBvbmVudFxuICogaGF2ZSBhIGNoYW5jZSB0byByZW5kZXIuXG4gKlxuICogVXNlIHRoaXMgdXRpbGl0eSByYXRoZXIgdGhhbiBjYWxsaW5nXG4gKiBlbC5jb21wb25lbnRPblJlYWR5IHlvdXJzZWxmLlxuICovXG5jb25zdCBjb21wb25lbnRPblJlYWR5ID0gKGVsLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoZWwuY29tcG9uZW50T25SZWFkeSkge1xuICAgIGVsLmNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChyZXNvbHZlZEVsKSA9PiBjYWxsYmFjayhyZXNvbHZlZEVsKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmFmKCgpID0+IGNhbGxiYWNrKGVsKSk7XG4gIH1cbn07XG4vKipcbiAqIEVsZW1lbnRzIGluc2lkZSBvZiB3ZWIgY29tcG9uZW50cyBzb21ldGltZXMgbmVlZCB0byBpbmhlcml0IGdsb2JhbCBhdHRyaWJ1dGVzXG4gKiBzZXQgb24gdGhlIGhvc3QuIEZvciBleGFtcGxlLCB0aGUgaW5uZXIgaW5wdXQgaW4gYGlvbi1pbnB1dGAgc2hvdWxkIGluaGVyaXRcbiAqIHRoZSBgdGl0bGVgIGF0dHJpYnV0ZSB0aGF0IGRldmVsb3BlcnMgc2V0IGRpcmVjdGx5IG9uIGBpb24taW5wdXRgLiBUaGlzXG4gKiBoZWxwZXIgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBpbiBjb21wb25lbnRXaWxsTG9hZCBhbmQgYXNzaWduZWQgdG8gYSB2YXJpYWJsZVxuICogdGhhdCBpcyBsYXRlciB1c2VkIGluIHRoZSByZW5kZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlYWN0aXZlIGFzIGNoYW5naW5nIGF0dHJpYnV0ZXMgb24gdGhlIGhvc3QgZWxlbWVudFxuICogZG9lcyBub3QgdHJpZ2dlciBhIHJlLXJlbmRlci5cbiAqL1xuY29uc3QgaW5oZXJpdEF0dHJpYnV0ZXMgPSAoZWwsIGF0dHJpYnV0ZXMgPSBbXSkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVPYmplY3QgPSB7fTtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZU9iamVjdFthdHRyXSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlT2JqZWN0O1xufTtcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSAoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgd2luID0gd2luZG93O1xuICAgIGNvbnN0IGNvbmZpZyA9IHdpbiAmJiB3aW4uSW9uaWMgJiYgd2luLklvbmljLmNvbmZpZztcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBjb25zdCBhZWwgPSBjb25maWcuZ2V0KCdfYWVsJyk7XG4gICAgICBpZiAoYWVsKSB7XG4gICAgICAgIHJldHVybiBhZWwoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29uZmlnLl9hZWwpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5fYWVsKGVsLCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG59O1xuY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gICAgY29uc3QgY29uZmlnID0gd2luICYmIHdpbi5Jb25pYyAmJiB3aW4uSW9uaWMuY29uZmlnO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGNvbnN0IHJlbCA9IGNvbmZpZy5nZXQoJ19yZWwnKTtcbiAgICAgIGlmIChyZWwpIHtcbiAgICAgICAgcmV0dXJuIHJlbChlbCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb25maWcuX3JlbCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLl9yZWwoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIHJvb3QgY29udGV4dCBvZiBhIHNoYWRvdyBkb20gZWxlbWVudFxuICogT24gbmV3ZXIgYnJvd3NlcnMgdGhpcyB3aWxsIGJlIHRoZSBzaGFkb3dSb290LFxuICogYnV0IGZvciBvbGRlciBicm93c2VyIHRoaXMgbWF5IGp1c3QgYmUgdGhlXG4gKiBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBVc2VmdWwgZm9yIHdoZW5ldmVyIHlvdSBuZWVkIHRvIGV4cGxpY2l0bHlcbiAqIGRvIFwibXlFbGVtZW50LnNoYWRvd1Jvb3QhLnF1ZXJ5U2VsZWN0b3IoLi4uKVwiLlxuICovXG5jb25zdCBnZXRFbGVtZW50Um9vdCA9IChlbCwgZmFsbGJhY2sgPSBlbCkgPT4ge1xuICByZXR1cm4gZWwuc2hhZG93Um9vdCB8fCBmYWxsYmFjaztcbn07XG4vKipcbiAqIFBhdGNoZWQgdmVyc2lvbiBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGhhdCBhdm9pZHMgbmd6b25lXG4gKiBVc2Ugb25seSB3aGVuIHlvdSBrbm93IG5nem9uZSBzaG91bGQgbm90IHJ1blxuICovXG5jb25zdCByYWYgPSAoaCkgPT4ge1xuICBpZiAodHlwZW9mIF9fem9uZV9zeW1ib2xfX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBfX3pvbmVfc3ltYm9sX19yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgpO1xuICB9XG4gIHJldHVybiBzZXRUaW1lb3V0KGgpO1xufTtcbmNvbnN0IGhhc1NoYWRvd0RvbSA9IChlbCkgPT4ge1xuICByZXR1cm4gISFlbC5zaGFkb3dSb290ICYmICEhZWwuYXR0YWNoU2hhZG93O1xufTtcbmNvbnN0IGZpbmRJdGVtTGFiZWwgPSAoY29tcG9uZW50RWwpID0+IHtcbiAgY29uc3QgaXRlbUVsID0gY29tcG9uZW50RWwuY2xvc2VzdCgnaW9uLWl0ZW0nKTtcbiAgaWYgKGl0ZW1FbCkge1xuICAgIHJldHVybiBpdGVtRWwucXVlcnlTZWxlY3RvcignaW9uLWxhYmVsJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZm9jdXNFbGVtZW50ID0gKGVsKSA9PiB7XG4gIGVsLmZvY3VzKCk7XG4gIC8qKlxuICAgKiBXaGVuIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNpbmcgYW4gZWxlbWVudCxcbiAgICogdGhlIGZvY3VzLXZpc2libGUgdXRpbGl0eSB3aWxsIG5vdCBydW4gYmVjYXVzZVxuICAgKiBpdCBpcyBleHBlY3RpbmcgYSBrZXlib2FyZCBldmVudCB0byBoYXZlIHRyaWdnZXJlZCB0aGlzO1xuICAgKiBob3dldmVyLCB0aGVyZSBhcmUgdGltZXMgd2hlbiB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNvbnRyb2xcbiAgICogdGhpcyBiZWhhdmlvciBzbyB3ZSBjYWxsIHRoZSBgc2V0Rm9jdXNgIG1ldGhvZCBvbiBpb24tYXBwXG4gICAqIHdoaWNoIHdpbGwgbGV0IHVzIGV4cGxpY2l0bHkgc2V0IHRoZSBlbGVtZW50cyB0byBmb2N1cy5cbiAgICovXG4gIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2lvbi1mb2N1c2FibGUnKSkge1xuICAgIGNvbnN0IGFwcCA9IGVsLmNsb3Nlc3QoJ2lvbi1hcHAnKTtcbiAgICBpZiAoYXBwKSB7XG4gICAgICBhcHAuc2V0Rm9jdXMoW2VsXSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBJb25pYydzIGlucHV0IGNvbXBvbmVudHMgdGhhdCB1c2UgU2hhZG93IERPTS4gSW5cbiAqIG9yZGVyIHRvIHByb3Blcmx5IGxhYmVsIHRoZSBpbnB1dHMgdG8gd29yayB3aXRoIHNjcmVlbiByZWFkZXJzLCB3ZSBuZWVkXG4gKiB0byBnZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbGFiZWwgb3V0c2lkZSBvZiB0aGUgc2hhZG93IHJvb3QgYW5kIHBhc3NcbiAqIGl0IHRvIHRoZSBpbnB1dCBpbnNpZGUgb2YgdGhlIHNoYWRvdyByb290LlxuICpcbiAqIFJlZmVyZW5jaW5nIGxhYmVsIGVsZW1lbnRzIGJ5IGlkIGZyb20gb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IGlzXG4gKiBpbXBvc3NpYmxlIGR1ZSB0byB0aGUgc2hhZG93IGJvdW5kYXJ5LCByZWFkIG1vcmUgaGVyZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLnNhbGVzZm9yY2UuY29tL2Jsb2dzLzIwMjAvMDEvYWNjZXNzaWJpbGl0eS1mb3Itd2ViLWNvbXBvbmVudHMuaHRtbFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRFbCBUaGUgc2hhZG93IGVsZW1lbnQgdGhhdCBuZWVkcyB0aGUgYXJpYSBsYWJlbFxuICogQHBhcmFtIGlucHV0SWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgaW5wdXRcbiAqL1xuY29uc3QgZ2V0QXJpYUxhYmVsID0gKGNvbXBvbmVudEVsLCBpbnB1dElkKSA9PiB7XG4gIGxldCBsYWJlbFRleHQ7XG4gIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVzIHRoZWlyIG93biBsYWJlbCB2aWEgdGhlIGFyaWEtbGFiZWxsZWRieSBhdHRyXG4gIC8vIHdlIHNob3VsZCB1c2UgdGhhdCBpbnN0ZWFkIG9mIGxvb2tpbmcgZm9yIGFuIGlvbi1sYWJlbFxuICBjb25zdCBsYWJlbGxlZEJ5ID0gY29tcG9uZW50RWwuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknKTtcbiAgLy8gR3JhYiB0aGUgaWQgb2ZmIG9mIHRoZSBjb21wb25lbnQgaW4gY2FzZSB0aGV5IGFyZSB1c2luZ1xuICAvLyBhIGN1c3RvbSBsYWJlbCB1c2luZyB0aGUgbGFiZWwgZWxlbWVudFxuICBjb25zdCBjb21wb25lbnRJZCA9IGNvbXBvbmVudEVsLmlkO1xuICBsZXQgbGFiZWxJZCA9IGxhYmVsbGVkQnkgIT09IG51bGwgJiYgbGFiZWxsZWRCeS50cmltKCkgIT09ICcnXG4gICAgPyBsYWJlbGxlZEJ5XG4gICAgOiBpbnB1dElkICsgJy1sYmwnO1xuICBsZXQgbGFiZWwgPSBsYWJlbGxlZEJ5ICE9PSBudWxsICYmIGxhYmVsbGVkQnkudHJpbSgpICE9PSAnJ1xuICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxsZWRCeSlcbiAgICA6IGZpbmRJdGVtTGFiZWwoY29tcG9uZW50RWwpO1xuICBpZiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWxsZWRCeSA9PT0gbnVsbCkge1xuICAgICAgbGFiZWwuaWQgPSBsYWJlbElkO1xuICAgIH1cbiAgICBsYWJlbFRleHQgPSBsYWJlbC50ZXh0Q29udGVudDtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBsYWJlbCwgY2hlY2sgdG8gc2VlIGlmIHRoZSB1c2VyIGhhcyBwcm92aWRlZFxuICAgIC8vIG9uZSBieSBzZXR0aW5nIGFuIGlkIG9uIHRoZSBjb21wb25lbnQgYW5kIHVzaW5nIHRoZSBsYWJlbCBlbGVtZW50XG4gIH1cbiAgZWxzZSBpZiAoY29tcG9uZW50SWQudHJpbSgpICE9PSAnJykge1xuICAgIGxhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGFiZWxbZm9yPVwiJHtjb21wb25lbnRJZH1cIl1gKTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIGlmIChsYWJlbC5pZCAhPT0gJycpIHtcbiAgICAgICAgbGFiZWxJZCA9IGxhYmVsLmlkO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxhYmVsLmlkID0gbGFiZWxJZCA9IGAke2NvbXBvbmVudElkfS1sYmxgO1xuICAgICAgfVxuICAgICAgbGFiZWxUZXh0ID0gbGFiZWwudGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGxhYmVsLCBsYWJlbElkLCBsYWJlbFRleHQgfTtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYWRkIGEgaGlkZGVuIGlucHV0IHRvIGEgaG9zdCBlbGVtZW50IHRoYXQgY29udGFpbnNcbiAqIGEgU2hhZG93IERPTS4gSXQgZG9lcyBub3QgYWRkIHRoZSBpbnB1dCBpbnNpZGUgb2YgdGhlIFNoYWRvdyByb290IHdoaWNoXG4gKiBhbGxvd3MgaXQgdG8gYmUgcGlja2VkIHVwIGluc2lkZSBvZiBmb3Jtcy4gSXQgc2hvdWxkIGNvbnRhaW4gdGhlIHNhbWVcbiAqIHZhbHVlcyBhcyB0aGUgaG9zdCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSBhbHdheXMgQWRkIGEgaGlkZGVuIGlucHV0IGV2ZW4gaWYgdGhlIGNvbnRhaW5lciBkb2VzIG5vdCB1c2UgU2hhZG93XG4gKiBAcGFyYW0gY29udGFpbmVyIFRoZSBlbGVtZW50IHdoZXJlIHRoZSBpbnB1dCB3aWxsIGJlIGFkZGVkXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0gZGlzYWJsZWQgSWYgdHJ1ZSwgdGhlIGlucHV0IGlzIGRpc2FibGVkXG4gKi9cbmNvbnN0IHJlbmRlckhpZGRlbklucHV0ID0gKGFsd2F5cywgY29udGFpbmVyLCBuYW1lLCB2YWx1ZSwgZGlzYWJsZWQpID0+IHtcbiAgaWYgKGFsd2F5cyB8fCBoYXNTaGFkb3dEb20oY29udGFpbmVyKSkge1xuICAgIGxldCBpbnB1dCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dC5hdXgtaW5wdXQnKTtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICBpbnB1dCA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ2hpZGRlbic7XG4gICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdhdXgtaW5wdXQnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgfVxuICAgIGlucHV0LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgfVxufTtcbmNvbnN0IGNsYW1wID0gKG1pbiwgbiwgbWF4KSA9PiB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG4sIG1heCkpO1xufTtcbmNvbnN0IGFzc2VydCA9IChhY3R1YWwsIHJlYXNvbikgPT4ge1xuICBpZiAoIWFjdHVhbCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnQVNTRVJUOiAnICsgcmVhc29uO1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgZGVidWdnZXI7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5jb25zdCBub3cgPSAoZXYpID0+IHtcbiAgcmV0dXJuIGV2LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufTtcbmNvbnN0IHBvaW50ZXJDb29yZCA9IChldikgPT4ge1xuICAvLyBnZXQgWCBjb29yZGluYXRlcyBmb3IgZWl0aGVyIGEgbW91c2UgY2xpY2tcbiAgLy8gb3IgYSB0b3VjaCBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIGV2ZW50XG4gIGlmIChldikge1xuICAgIGNvbnN0IGNoYW5nZWRUb3VjaGVzID0gZXYuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICByZXR1cm4geyB4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZIH07XG4gICAgfVxuICAgIGlmIChldi5wYWdlWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4geyB4OiBldi5wYWdlWCwgeTogZXYucGFnZVkgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICogR2l2ZW4gYSBzaWRlLCByZXR1cm4gaWYgaXQgc2hvdWxkIGJlIG9uIHRoZSBlbmRcbiAqIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBkaXJcbiAqIEBwYXJhbSBzaWRlIHRoZSBzaWRlXG4gKiBAcGFyYW0gaXNSVEwgd2hldGhlciB0aGUgYXBwbGljYXRpb24gZGlyIGlzIHJ0bFxuICovXG5jb25zdCBpc0VuZFNpZGUgPSAoc2lkZSkgPT4ge1xuICBjb25zdCBpc1JUTCA9IGRvY3VtZW50LmRpciA9PT0gJ3J0bCc7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3N0YXJ0JzogcmV0dXJuIGlzUlRMO1xuICAgIGNhc2UgJ2VuZCc6IHJldHVybiAhaXNSVEw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3NpZGV9XCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIFtzaWRlXS4gVXNlIFwic3RhcnRcIiBvciBcImVuZFwiIGluc3RlYWQuYCk7XG4gIH1cbn07XG5jb25zdCBkZWJvdW5jZUV2ZW50ID0gKGV2ZW50LCB3YWl0KSA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsID0gZXZlbnQuX29yaWdpbmFsIHx8IGV2ZW50O1xuICByZXR1cm4ge1xuICAgIF9vcmlnaW5hbDogZXZlbnQsXG4gICAgZW1pdDogZGVib3VuY2Uob3JpZ2luYWwuZW1pdC5iaW5kKG9yaWdpbmFsKSwgd2FpdClcbiAgfTtcbn07XG5jb25zdCBkZWJvdW5jZSA9IChmdW5jLCB3YWl0ID0gMCkgPT4ge1xuICBsZXQgdGltZXI7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmMsIHdhaXQsIC4uLmFyZ3MpO1xuICB9O1xufTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdHdvIHN0cmluZyBtYXBzIGFyZSBzaGFsbG93IGVxdWFsLlxuICpcbiAqIHVuZGVmaW5lZCBpcyB0cmVhdGVkIGFzIGFuIGVtcHR5IG1hcC5cbiAqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBrZXlzIGFyZSB0aGUgc2FtZSBhbmQgdGhlIHZhbHVlcyBhcmUgc2hhbGxvdyBlcXVhbC5cbiAqL1xuY29uc3Qgc2hhbGxvd0VxdWFsU3RyaW5nTWFwID0gKG1hcDEsIG1hcDIpID0+IHtcbiAgbWFwMSAhPT0gbnVsbCAmJiBtYXAxICE9PSB2b2lkIDAgPyBtYXAxIDogKG1hcDEgPSB7fSk7XG4gIG1hcDIgIT09IG51bGwgJiYgbWFwMiAhPT0gdm9pZCAwID8gbWFwMiA6IChtYXAyID0ge30pO1xuICBpZiAobWFwMSA9PT0gbWFwMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMobWFwMSk7XG4gIGlmIChrZXlzMS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG1hcDIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGsxIG9mIGtleXMxKSB7XG4gICAgaWYgKCEoazEgaW4gbWFwMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG1hcDFbazFdICE9PSBtYXAyW2sxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIgYXMgYSwgcmVtb3ZlRXZlbnRMaXN0ZW5lciBhcyBiLCBjb21wb25lbnRPblJlYWR5IGFzIGMsIGdldEFyaWFMYWJlbCBhcyBkLCByZW5kZXJIaWRkZW5JbnB1dCBhcyBlLCBmb2N1c0VsZW1lbnQgYXMgZiwgZ2V0RWxlbWVudFJvb3QgYXMgZywgaGFzU2hhZG93RG9tIGFzIGgsIGluaGVyaXRBdHRyaWJ1dGVzIGFzIGksIGNsYW1wIGFzIGosIGRlYm91bmNlRXZlbnQgYXMgaywgZmluZEl0ZW1MYWJlbCBhcyBsLCBpc0VuZFNpZGUgYXMgbSwgYXNzZXJ0IGFzIG4sIGRlYm91bmNlIGFzIG8sIHBvaW50ZXJDb29yZCBhcyBwLCBub3cgYXMgcSwgcmFmIGFzIHIsIHNoYWxsb3dFcXVhbFN0cmluZ01hcCBhcyBzLCB0cmFuc2l0aW9uRW5kQXN5bmMgYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6587\n")},5026:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"g\": () => (/* binding */ getIonPageElement),\n/* harmony export */   \"t\": () => (/* binding */ transition)\n/* harmony export */ });\n/* unused harmony exports L, a, b, c, d, e, l, s */\n/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7210);\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';\nconst LIFECYCLE_DID_ENTER = 'ionViewDidEnter';\nconst LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';\nconst LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';\nconst LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';\n\nconst iosTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(6338)]).then(__webpack_require__.bind(__webpack_require__, 6338));\nconst mdTransitionAnimation = () => Promise.all(/* import() */[__webpack_require__.e(5980), __webpack_require__.e(4753)]).then(__webpack_require__.bind(__webpack_require__, 4753));\nconst transition = (opts) => {\n  return new Promise((resolve, reject) => {\n    (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .writeTask */ .Iu)(() => {\n      beforeTransition(opts);\n      runTransition(opts).then(result => {\n        if (result.animation) {\n          result.animation.destroy();\n        }\n        afterTransition(opts);\n        resolve(result);\n      }, error => {\n        afterTransition(opts);\n        reject(error);\n      });\n    });\n  });\n};\nconst beforeTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  setZIndex(enteringEl, leavingEl, opts.direction);\n  if (opts.showGoBack) {\n    enteringEl.classList.add('can-go-back');\n  }\n  else {\n    enteringEl.classList.remove('can-go-back');\n  }\n  setPageHidden(enteringEl, false);\n  /**\n   * When transitioning, the page should not\n   * respond to click events. This resolves small\n   * issues like users double tapping the ion-back-button.\n   * These pointer events are removed in `afterTransition`.\n   */\n  enteringEl.style.setProperty('pointer-events', 'none');\n  if (leavingEl) {\n    setPageHidden(leavingEl, false);\n    leavingEl.style.setProperty('pointer-events', 'none');\n  }\n};\nconst runTransition = async (opts) => {\n  const animationBuilder = await getAnimationBuilder(opts);\n  const ani = (animationBuilder && _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__/* .Build.isBrowser */ .Z5.isBrowser)\n    ? animation(animationBuilder, opts)\n    : noAnimation(opts); // fast path for no animation\n  return ani;\n};\nconst afterTransition = (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  enteringEl.classList.remove('ion-page-invisible');\n  enteringEl.style.removeProperty('pointer-events');\n  if (leavingEl !== undefined) {\n    leavingEl.classList.remove('ion-page-invisible');\n    leavingEl.style.removeProperty('pointer-events');\n  }\n};\nconst getAnimationBuilder = async (opts) => {\n  if (!opts.leavingEl || !opts.animated || opts.duration === 0) {\n    return undefined;\n  }\n  if (opts.animationBuilder) {\n    return opts.animationBuilder;\n  }\n  const getAnimation = (opts.mode === 'ios')\n    ? (await iosTransitionAnimation()).iosTransitionAnimation\n    : (await mdTransitionAnimation()).mdTransitionAnimation;\n  return getAnimation;\n};\nconst animation = async (animationBuilder, opts) => {\n  await waitForReady(opts, true);\n  const trans = animationBuilder(opts.baseEl, opts);\n  fireWillEvents(opts.enteringEl, opts.leavingEl);\n  const didComplete = await playTransition(trans, opts);\n  if (opts.progressCallback) {\n    opts.progressCallback(undefined);\n  }\n  if (didComplete) {\n    fireDidEvents(opts.enteringEl, opts.leavingEl);\n  }\n  return {\n    hasCompleted: didComplete,\n    animation: trans\n  };\n};\nconst noAnimation = async (opts) => {\n  const enteringEl = opts.enteringEl;\n  const leavingEl = opts.leavingEl;\n  await waitForReady(opts, false);\n  fireWillEvents(enteringEl, leavingEl);\n  fireDidEvents(enteringEl, leavingEl);\n  return {\n    hasCompleted: true\n  };\n};\nconst waitForReady = async (opts, defaultDeep) => {\n  const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;\n  const promises = deep ? [\n    deepReady(opts.enteringEl),\n    deepReady(opts.leavingEl),\n  ] : [\n    shallowReady(opts.enteringEl),\n    shallowReady(opts.leavingEl),\n  ];\n  await Promise.all(promises);\n  await notifyViewReady(opts.viewIsReady, opts.enteringEl);\n};\nconst notifyViewReady = async (viewIsReady, enteringEl) => {\n  if (viewIsReady) {\n    await viewIsReady(enteringEl);\n  }\n};\nconst playTransition = (trans, opts) => {\n  const progressCallback = opts.progressCallback;\n  const promise = new Promise(resolve => {\n    trans.onFinish((currentStep) => resolve(currentStep === 1));\n  });\n  // cool, let's do this, start the transition\n  if (progressCallback) {\n    // this is a swipe to go back, just get the transition progress ready\n    // kick off the swipe animation start\n    trans.progressStart(true);\n    progressCallback(trans);\n  }\n  else {\n    // only the top level transition should actually start \"play\"\n    // kick it off and let it play through\n    // ******** DOM WRITE ****************\n    trans.play();\n  }\n  // create a callback for when the animation is done\n  return promise;\n};\nconst fireWillEvents = (enteringEl, leavingEl) => {\n  lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);\n  lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);\n};\nconst fireDidEvents = (enteringEl, leavingEl) => {\n  lifecycle(enteringEl, LIFECYCLE_DID_ENTER);\n  lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);\n};\nconst lifecycle = (el, eventName) => {\n  if (el) {\n    const ev = new CustomEvent(eventName, {\n      bubbles: false,\n      cancelable: false,\n    });\n    el.dispatchEvent(ev);\n  }\n};\nconst shallowReady = (el) => {\n  if (el) {\n    return new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, resolve));\n  }\n  return Promise.resolve();\n};\nconst deepReady = async (el) => {\n  const element = el;\n  if (element) {\n    if (element.componentOnReady != null) {\n      const stencilEl = await element.componentOnReady();\n      if (stencilEl != null) {\n        return;\n      }\n      /**\n       * Custom elements in Stencil will have __registerHost.\n       */\n    }\n    else if (element.__registerHost != null) {\n      /**\n       * Non-lazy loaded custom elements need to wait\n       * one frame for component to be loaded.\n       */\n      const waitForCustomElement = new Promise(resolve => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.r)(resolve));\n      await waitForCustomElement;\n      return;\n    }\n    await Promise.all(Array.from(element.children).map(deepReady));\n  }\n};\nconst setPageHidden = (el, hidden) => {\n  if (hidden) {\n    el.setAttribute('aria-hidden', 'true');\n    el.classList.add('ion-page-hidden');\n  }\n  else {\n    el.hidden = false;\n    el.removeAttribute('aria-hidden');\n    el.classList.remove('ion-page-hidden');\n  }\n};\nconst setZIndex = (enteringEl, leavingEl, direction) => {\n  if (enteringEl !== undefined) {\n    enteringEl.style.zIndex = (direction === 'back')\n      ? '99'\n      : '101';\n  }\n  if (leavingEl !== undefined) {\n    leavingEl.style.zIndex = '100';\n  }\n};\nconst getIonPageElement = (element) => {\n  if (element.classList.contains('ion-page')) {\n    return element;\n  }\n  const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');\n  if (ionPage) {\n    return ionPage;\n  }\n  // idk, return the original element so at least something animates and we don't have a null pointer\n  return element;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAyNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ2lFO0FBQ0Y7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLCtJQUE2QjtBQUNsRSxvQ0FBb0MsK0lBQTRCO0FBQ2hFO0FBQ0E7QUFDQSxJQUFJLGtGQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEZBQWU7QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOENBQUc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNk8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW5kZXg0LmpzPzY3OWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHdyaXRlVGFzaywgQnVpbGQgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudE9uUmVhZHksIHIgYXMgcmFmIH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcblxuY29uc3QgTElGRUNZQ0xFX1dJTExfRU5URVIgPSAnaW9uVmlld1dpbGxFbnRlcic7XG5jb25zdCBMSUZFQ1lDTEVfRElEX0VOVEVSID0gJ2lvblZpZXdEaWRFbnRlcic7XG5jb25zdCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSA9ICdpb25WaWV3V2lsbExlYXZlJztcbmNvbnN0IExJRkVDWUNMRV9ESURfTEVBVkUgPSAnaW9uVmlld0RpZExlYXZlJztcbmNvbnN0IExJRkVDWUNMRV9XSUxMX1VOTE9BRCA9ICdpb25WaWV3V2lsbFVubG9hZCc7XG5cbmNvbnN0IGlvc1RyYW5zaXRpb25BbmltYXRpb24gPSAoKSA9PiBpbXBvcnQoJy4vaW9zLnRyYW5zaXRpb24uanMnKTtcbmNvbnN0IG1kVHJhbnNpdGlvbkFuaW1hdGlvbiA9ICgpID0+IGltcG9ydCgnLi9tZC50cmFuc2l0aW9uLmpzJyk7XG5jb25zdCB0cmFuc2l0aW9uID0gKG9wdHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZVRhc2soKCkgPT4ge1xuICAgICAgYmVmb3JlVHJhbnNpdGlvbihvcHRzKTtcbiAgICAgIHJ1blRyYW5zaXRpb24ob3B0cykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmFuaW1hdGlvbikge1xuICAgICAgICAgIHJlc3VsdC5hbmltYXRpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGFmdGVyVHJhbnNpdGlvbihvcHRzKTtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICBhZnRlclRyYW5zaXRpb24ob3B0cyk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuY29uc3QgYmVmb3JlVHJhbnNpdGlvbiA9IChvcHRzKSA9PiB7XG4gIGNvbnN0IGVudGVyaW5nRWwgPSBvcHRzLmVudGVyaW5nRWw7XG4gIGNvbnN0IGxlYXZpbmdFbCA9IG9wdHMubGVhdmluZ0VsO1xuICBzZXRaSW5kZXgoZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzLmRpcmVjdGlvbik7XG4gIGlmIChvcHRzLnNob3dHb0JhY2spIHtcbiAgICBlbnRlcmluZ0VsLmNsYXNzTGlzdC5hZGQoJ2Nhbi1nby1iYWNrJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZW50ZXJpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdjYW4tZ28tYmFjaycpO1xuICB9XG4gIHNldFBhZ2VIaWRkZW4oZW50ZXJpbmdFbCwgZmFsc2UpO1xuICAvKipcbiAgICogV2hlbiB0cmFuc2l0aW9uaW5nLCB0aGUgcGFnZSBzaG91bGQgbm90XG4gICAqIHJlc3BvbmQgdG8gY2xpY2sgZXZlbnRzLiBUaGlzIHJlc29sdmVzIHNtYWxsXG4gICAqIGlzc3VlcyBsaWtlIHVzZXJzIGRvdWJsZSB0YXBwaW5nIHRoZSBpb24tYmFjay1idXR0b24uXG4gICAqIFRoZXNlIHBvaW50ZXIgZXZlbnRzIGFyZSByZW1vdmVkIGluIGBhZnRlclRyYW5zaXRpb25gLlxuICAgKi9cbiAgZW50ZXJpbmdFbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICBpZiAobGVhdmluZ0VsKSB7XG4gICAgc2V0UGFnZUhpZGRlbihsZWF2aW5nRWwsIGZhbHNlKTtcbiAgICBsZWF2aW5nRWwuc3R5bGUuc2V0UHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcbiAgfVxufTtcbmNvbnN0IHJ1blRyYW5zaXRpb24gPSBhc3luYyAob3B0cykgPT4ge1xuICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gYXdhaXQgZ2V0QW5pbWF0aW9uQnVpbGRlcihvcHRzKTtcbiAgY29uc3QgYW5pID0gKGFuaW1hdGlvbkJ1aWxkZXIgJiYgQnVpbGQuaXNCcm93c2VyKVxuICAgID8gYW5pbWF0aW9uKGFuaW1hdGlvbkJ1aWxkZXIsIG9wdHMpXG4gICAgOiBub0FuaW1hdGlvbihvcHRzKTsgLy8gZmFzdCBwYXRoIGZvciBubyBhbmltYXRpb25cbiAgcmV0dXJuIGFuaTtcbn07XG5jb25zdCBhZnRlclRyYW5zaXRpb24gPSAob3B0cykgPT4ge1xuICBjb25zdCBlbnRlcmluZ0VsID0gb3B0cy5lbnRlcmluZ0VsO1xuICBjb25zdCBsZWF2aW5nRWwgPSBvcHRzLmxlYXZpbmdFbDtcbiAgZW50ZXJpbmdFbC5jbGFzc0xpc3QucmVtb3ZlKCdpb24tcGFnZS1pbnZpc2libGUnKTtcbiAgZW50ZXJpbmdFbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgaWYgKGxlYXZpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGVhdmluZ0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2lvbi1wYWdlLWludmlzaWJsZScpO1xuICAgIGxlYXZpbmdFbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgfVxufTtcbmNvbnN0IGdldEFuaW1hdGlvbkJ1aWxkZXIgPSBhc3luYyAob3B0cykgPT4ge1xuICBpZiAoIW9wdHMubGVhdmluZ0VsIHx8ICFvcHRzLmFuaW1hdGVkIHx8IG9wdHMuZHVyYXRpb24gPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChvcHRzLmFuaW1hdGlvbkJ1aWxkZXIpIHtcbiAgICByZXR1cm4gb3B0cy5hbmltYXRpb25CdWlsZGVyO1xuICB9XG4gIGNvbnN0IGdldEFuaW1hdGlvbiA9IChvcHRzLm1vZGUgPT09ICdpb3MnKVxuICAgID8gKGF3YWl0IGlvc1RyYW5zaXRpb25BbmltYXRpb24oKSkuaW9zVHJhbnNpdGlvbkFuaW1hdGlvblxuICAgIDogKGF3YWl0IG1kVHJhbnNpdGlvbkFuaW1hdGlvbigpKS5tZFRyYW5zaXRpb25BbmltYXRpb247XG4gIHJldHVybiBnZXRBbmltYXRpb247XG59O1xuY29uc3QgYW5pbWF0aW9uID0gYXN5bmMgKGFuaW1hdGlvbkJ1aWxkZXIsIG9wdHMpID0+IHtcbiAgYXdhaXQgd2FpdEZvclJlYWR5KG9wdHMsIHRydWUpO1xuICBjb25zdCB0cmFucyA9IGFuaW1hdGlvbkJ1aWxkZXIob3B0cy5iYXNlRWwsIG9wdHMpO1xuICBmaXJlV2lsbEV2ZW50cyhvcHRzLmVudGVyaW5nRWwsIG9wdHMubGVhdmluZ0VsKTtcbiAgY29uc3QgZGlkQ29tcGxldGUgPSBhd2FpdCBwbGF5VHJhbnNpdGlvbih0cmFucywgb3B0cyk7XG4gIGlmIChvcHRzLnByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICBvcHRzLnByb2dyZXNzQ2FsbGJhY2sodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoZGlkQ29tcGxldGUpIHtcbiAgICBmaXJlRGlkRXZlbnRzKG9wdHMuZW50ZXJpbmdFbCwgb3B0cy5sZWF2aW5nRWwpO1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFzQ29tcGxldGVkOiBkaWRDb21wbGV0ZSxcbiAgICBhbmltYXRpb246IHRyYW5zXG4gIH07XG59O1xuY29uc3Qgbm9BbmltYXRpb24gPSBhc3luYyAob3B0cykgPT4ge1xuICBjb25zdCBlbnRlcmluZ0VsID0gb3B0cy5lbnRlcmluZ0VsO1xuICBjb25zdCBsZWF2aW5nRWwgPSBvcHRzLmxlYXZpbmdFbDtcbiAgYXdhaXQgd2FpdEZvclJlYWR5KG9wdHMsIGZhbHNlKTtcbiAgZmlyZVdpbGxFdmVudHMoZW50ZXJpbmdFbCwgbGVhdmluZ0VsKTtcbiAgZmlyZURpZEV2ZW50cyhlbnRlcmluZ0VsLCBsZWF2aW5nRWwpO1xuICByZXR1cm4ge1xuICAgIGhhc0NvbXBsZXRlZDogdHJ1ZVxuICB9O1xufTtcbmNvbnN0IHdhaXRGb3JSZWFkeSA9IGFzeW5jIChvcHRzLCBkZWZhdWx0RGVlcCkgPT4ge1xuICBjb25zdCBkZWVwID0gb3B0cy5kZWVwV2FpdCAhPT0gdW5kZWZpbmVkID8gb3B0cy5kZWVwV2FpdCA6IGRlZmF1bHREZWVwO1xuICBjb25zdCBwcm9taXNlcyA9IGRlZXAgPyBbXG4gICAgZGVlcFJlYWR5KG9wdHMuZW50ZXJpbmdFbCksXG4gICAgZGVlcFJlYWR5KG9wdHMubGVhdmluZ0VsKSxcbiAgXSA6IFtcbiAgICBzaGFsbG93UmVhZHkob3B0cy5lbnRlcmluZ0VsKSxcbiAgICBzaGFsbG93UmVhZHkob3B0cy5sZWF2aW5nRWwpLFxuICBdO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGF3YWl0IG5vdGlmeVZpZXdSZWFkeShvcHRzLnZpZXdJc1JlYWR5LCBvcHRzLmVudGVyaW5nRWwpO1xufTtcbmNvbnN0IG5vdGlmeVZpZXdSZWFkeSA9IGFzeW5jICh2aWV3SXNSZWFkeSwgZW50ZXJpbmdFbCkgPT4ge1xuICBpZiAodmlld0lzUmVhZHkpIHtcbiAgICBhd2FpdCB2aWV3SXNSZWFkeShlbnRlcmluZ0VsKTtcbiAgfVxufTtcbmNvbnN0IHBsYXlUcmFuc2l0aW9uID0gKHRyYW5zLCBvcHRzKSA9PiB7XG4gIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRzLnByb2dyZXNzQ2FsbGJhY2s7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB0cmFucy5vbkZpbmlzaCgoY3VycmVudFN0ZXApID0+IHJlc29sdmUoY3VycmVudFN0ZXAgPT09IDEpKTtcbiAgfSk7XG4gIC8vIGNvb2wsIGxldCdzIGRvIHRoaXMsIHN0YXJ0IHRoZSB0cmFuc2l0aW9uXG4gIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgLy8gdGhpcyBpcyBhIHN3aXBlIHRvIGdvIGJhY2ssIGp1c3QgZ2V0IHRoZSB0cmFuc2l0aW9uIHByb2dyZXNzIHJlYWR5XG4gICAgLy8ga2ljayBvZmYgdGhlIHN3aXBlIGFuaW1hdGlvbiBzdGFydFxuICAgIHRyYW5zLnByb2dyZXNzU3RhcnQodHJ1ZSk7XG4gICAgcHJvZ3Jlc3NDYWxsYmFjayh0cmFucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gb25seSB0aGUgdG9wIGxldmVsIHRyYW5zaXRpb24gc2hvdWxkIGFjdHVhbGx5IHN0YXJ0IFwicGxheVwiXG4gICAgLy8ga2ljayBpdCBvZmYgYW5kIGxldCBpdCBwbGF5IHRocm91Z2hcbiAgICAvLyAqKioqKioqKiBET00gV1JJVEUgKioqKioqKioqKioqKioqKlxuICAgIHRyYW5zLnBsYXkoKTtcbiAgfVxuICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGRvbmVcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuY29uc3QgZmlyZVdpbGxFdmVudHMgPSAoZW50ZXJpbmdFbCwgbGVhdmluZ0VsKSA9PiB7XG4gIGxpZmVjeWNsZShsZWF2aW5nRWwsIExJRkVDWUNMRV9XSUxMX0xFQVZFKTtcbiAgbGlmZWN5Y2xlKGVudGVyaW5nRWwsIExJRkVDWUNMRV9XSUxMX0VOVEVSKTtcbn07XG5jb25zdCBmaXJlRGlkRXZlbnRzID0gKGVudGVyaW5nRWwsIGxlYXZpbmdFbCkgPT4ge1xuICBsaWZlY3ljbGUoZW50ZXJpbmdFbCwgTElGRUNZQ0xFX0RJRF9FTlRFUik7XG4gIGxpZmVjeWNsZShsZWF2aW5nRWwsIExJRkVDWUNMRV9ESURfTEVBVkUpO1xufTtcbmNvbnN0IGxpZmVjeWNsZSA9IChlbCwgZXZlbnROYW1lKSA9PiB7XG4gIGlmIChlbCkge1xuICAgIGNvbnN0IGV2ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgfVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkeSA9IChlbCkgPT4ge1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjb21wb25lbnRPblJlYWR5KGVsLCByZXNvbHZlKSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcbmNvbnN0IGRlZXBSZWFkeSA9IGFzeW5jIChlbCkgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gZWw7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuY29tcG9uZW50T25SZWFkeSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzdGVuY2lsRWwgPSBhd2FpdCBlbGVtZW50LmNvbXBvbmVudE9uUmVhZHkoKTtcbiAgICAgIGlmIChzdGVuY2lsRWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEN1c3RvbSBlbGVtZW50cyBpbiBTdGVuY2lsIHdpbGwgaGF2ZSBfX3JlZ2lzdGVySG9zdC5cbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50Ll9fcmVnaXN0ZXJIb3N0ICE9IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm9uLWxhenkgbG9hZGVkIGN1c3RvbSBlbGVtZW50cyBuZWVkIHRvIHdhaXRcbiAgICAgICAqIG9uZSBmcmFtZSBmb3IgY29tcG9uZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgd2FpdEZvckN1c3RvbUVsZW1lbnQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJhZihyZXNvbHZlKSk7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ3VzdG9tRWxlbWVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkcmVuKS5tYXAoZGVlcFJlYWR5KSk7XG4gIH1cbn07XG5jb25zdCBzZXRQYWdlSGlkZGVuID0gKGVsLCBoaWRkZW4pID0+IHtcbiAgaWYgKGhpZGRlbikge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2lvbi1wYWdlLWhpZGRlbicpO1xuICB9XG4gIGVsc2Uge1xuICAgIGVsLmhpZGRlbiA9IGZhbHNlO1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdpb24tcGFnZS1oaWRkZW4nKTtcbiAgfVxufTtcbmNvbnN0IHNldFpJbmRleCA9IChlbnRlcmluZ0VsLCBsZWF2aW5nRWwsIGRpcmVjdGlvbikgPT4ge1xuICBpZiAoZW50ZXJpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW50ZXJpbmdFbC5zdHlsZS56SW5kZXggPSAoZGlyZWN0aW9uID09PSAnYmFjaycpXG4gICAgICA/ICc5OSdcbiAgICAgIDogJzEwMSc7XG4gIH1cbiAgaWYgKGxlYXZpbmdFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGVhdmluZ0VsLnN0eWxlLnpJbmRleCA9ICcxMDAnO1xuICB9XG59O1xuY29uc3QgZ2V0SW9uUGFnZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2lvbi1wYWdlJykpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBjb25zdCBpb25QYWdlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiAuaW9uLXBhZ2UsIDpzY29wZSA+IGlvbi1uYXYsIDpzY29wZSA+IGlvbi10YWJzJyk7XG4gIGlmIChpb25QYWdlKSB7XG4gICAgcmV0dXJuIGlvblBhZ2U7XG4gIH1cbiAgLy8gaWRrLCByZXR1cm4gdGhlIG9yaWdpbmFsIGVsZW1lbnQgc28gYXQgbGVhc3Qgc29tZXRoaW5nIGFuaW1hdGVzIGFuZCB3ZSBkb24ndCBoYXZlIGEgbnVsbCBwb2ludGVyXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZXhwb3J0IHsgTElGRUNZQ0xFX1dJTExfRU5URVIgYXMgTCwgTElGRUNZQ0xFX0RJRF9FTlRFUiBhcyBhLCBMSUZFQ1lDTEVfV0lMTF9MRUFWRSBhcyBiLCBMSUZFQ1lDTEVfRElEX0xFQVZFIGFzIGMsIExJRkVDWUNMRV9XSUxMX1VOTE9BRCBhcyBkLCBkZWVwUmVhZHkgYXMgZSwgZ2V0SW9uUGFnZUVsZW1lbnQgYXMgZywgbGlmZWN5Y2xlIGFzIGwsIHNldFBhZ2VIaWRkZW4gYXMgcywgdHJhbnNpdGlvbiBhcyB0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5026\n")},7434:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": () => (/* binding */ createAnimation)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var animationPrefix;var processKeyframes=function(e){e.forEach((function(e){for(var n in e){if(e.hasOwnProperty(n)){var r=e[n];if(n==="easing"){var t="animation-timing-function";e[t]=r;delete e[n]}else{var t=convertCamelCaseToHypen(n);if(t!==n){e[t]=r;delete e[n]}}}}}));return e};var convertCamelCaseToHypen=function(e){return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()};var getAnimationPrefix=function(e){if(animationPrefix===undefined){var n=e.style.animationName!==undefined;var r=e.style.webkitAnimationName!==undefined;animationPrefix=!n&&r?"-webkit-":""}return animationPrefix};var setStyleProperty=function(e,n,r){var t=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.setProperty(t+n,r)};var removeStyleProperty=function(e,n){var r=n.startsWith("animation")?getAnimationPrefix(e):"";e.style.removeProperty(r+n)};var animationEnd=function(e,n){var r;var t={passive:true};var a=function(){if(r){r()}};var i=function(r){if(e===r.target){a();n(r)}};if(e){e.addEventListener("webkitAnimationEnd",i,t);e.addEventListener("animationend",i,t);r=function(){e.removeEventListener("webkitAnimationEnd",i,t);e.removeEventListener("animationend",i,t)}}return a};var generateKeyframeRules=function(e){if(e===void 0){e=[]}return e.map((function(e){var n=e.offset;var r=[];for(var t in e){if(e.hasOwnProperty(t)&&t!=="offset"){r.push("".concat(t,": ").concat(e[t],";"))}}return"".concat(n*100,"% { ").concat(r.join(" ")," }")})).join(" ")};var keyframeIds=[];var generateKeyframeName=function(e){var n=keyframeIds.indexOf(e);if(n<0){n=keyframeIds.push(e)-1}return"ion-animation-".concat(n)};var getStyleContainer=function(e){var n=e.getRootNode();return n.head||n};var createKeyframeStylesheet=function(e,n,r){var t=getStyleContainer(r);var a=getAnimationPrefix(r);var i=t.querySelector("#"+e);if(i){return i}var o=(r.ownerDocument||document).createElement("style");o.id=e;o.textContent="@".concat(a,"keyframes ").concat(e," { ").concat(n," } @").concat(a,"keyframes ").concat(e,"-alt { ").concat(n," }");t.appendChild(o);return o};var addClassToArray=function(e,n){if(e===void 0){e=[]}if(n!==undefined){var r=Array.isArray(n)?n:[n];return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e,true),r,true)}return e};var createAnimation=function(e){var n;var r;var t;var a;var i;var o;var f=[];var u=[];var c=[];var s=false;var v;var l={};var d=[];var y=[];var m={};var p=0;var h=false;var g=false;var E;var P;var S;var A;var C=true;var T=false;var b=true;var k;var w;var x=e;var K=[];var _=[];var I=[];var D=[];var L=[];var N=[];var R=[];var F=[];var O=[];var W=[];var j=typeof AnimationEffect==="function"||typeof window.AnimationEffect==="function";var H=typeof Element==="function"&&typeof Element.prototype.animate==="function"&&j;var M=100;var $=function(){return W};var q=function(e){D.forEach((function(n){n.destroy(e)}));z(e);I.length=0;D.length=0;f.length=0;G();s=false;b=true;return w};var z=function(e){J();if(e){Q()}};var Z=function(){h=false;g=false;b=true;P=undefined;S=undefined;A=undefined;p=0;T=false;C=true};var B=function(e,n){var r=n&&n.oneTimeCallback?_:K;r.push({c:e,o:n});return w};var G=function(){K.length=0;_.length=0;return w};var J=function(){if(H){W.forEach((function(e){e.cancel()}));W.length=0}else{var e=I.slice();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){e.forEach((function(e){removeStyleProperty(e,"animation-name");removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-timing-function");removeStyleProperty(e,"animation-iteration-count");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state");removeStyleProperty(e,"animation-fill-mode");removeStyleProperty(e,"animation-direction")}))}))}};var Q=function(){L.forEach((function(e){if(e&&e.parentNode){e.parentNode.removeChild(e)}}));L.length=0};var U=function(e){N.push(e);return w};var V=function(e){R.push(e);return w};var X=function(e){F.push(e);return w};var Y=function(e){O.push(e);return w};var ee=function(e){u=addClassToArray(u,e);return w};var ne=function(e){c=addClassToArray(c,e);return w};var re=function(e){if(e===void 0){e={}}l=e;return w};var te=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];l[t]=""}return w};var ae=function(e){d=addClassToArray(d,e);return w};var ie=function(e){y=addClassToArray(y,e);return w};var oe=function(e){if(e===void 0){e={}}m=e;return w};var fe=function(e){if(e===void 0){e=[]}for(var n=0,r=e;n<r.length;n++){var t=r[n];m[t]=""}return w};var ue=function(){if(i!==undefined){return i}if(v){return v.getFill()}return"both"};var ce=function(){if(P!==undefined){return P}if(o!==undefined){return o}if(v){return v.getDirection()}return"normal"};var se=function(){if(h){return"linear"}if(t!==undefined){return t}if(v){return v.getEasing()}return"linear"};var ve=function(){if(g){return 0}if(S!==undefined){return S}if(r!==undefined){return r}if(v){return v.getDuration()}return 0};var le=function(){if(a!==undefined){return a}if(v){return v.getIterations()}return 1};var de=function(){if(A!==undefined){return A}if(n!==undefined){return n}if(v){return v.getDelay()}return 0};var ye=function(){return f};var me=function(e){o=e;Re(true);return w};var pe=function(e){i=e;Re(true);return w};var he=function(e){n=e;Re(true);return w};var ge=function(e){t=e;Re(true);return w};var Ee=function(e){if(!H&&e===0){e=1}r=e;Re(true);return w};var Pe=function(e){a=e;Re(true);return w};var Se=function(e){v=e;return w};var Ae=function(e){if(e!=null){if(e.nodeType===1){I.push(e)}else if(e.length>=0){for(var n=0;n<e.length;n++){I.push(e[n])}}else{console.error("Invalid addElement value")}}return w};var Ce=function(e){if(e!=null){if(Array.isArray(e)){for(var n=0,r=e;n<r.length;n++){var t=r[n];t.parent(w);D.push(t)}}else{e.parent(w);D.push(e)}}return w};var Te=function(e){var n=f!==e;f=e;if(n){be(f)}return w};var be=function(e){if(H){$().forEach((function(n){if(n.effect.setKeyframes){n.effect.setKeyframes(e)}else{var r=new KeyframeEffect(n.effect.target,e,n.effect.getTiming());n.effect=r}}))}else{Ke()}};var ke=function(){N.forEach((function(e){return e()}));R.forEach((function(e){return e()}));var e=u;var n=c;var r=l;I.forEach((function(t){var a=t.classList;e.forEach((function(e){return a.add(e)}));n.forEach((function(e){return a.remove(e)}));for(var i in r){if(r.hasOwnProperty(i)){setStyleProperty(t,i,r[i])}}}))};var we=function(){$e();F.forEach((function(e){return e()}));O.forEach((function(e){return e()}));var e=C?1:0;var n=d;var r=y;var t=m;I.forEach((function(e){var a=e.classList;n.forEach((function(e){return a.add(e)}));r.forEach((function(e){return a.remove(e)}));for(var i in t){if(t.hasOwnProperty(i)){setStyleProperty(e,i,t[i])}}}));K.forEach((function(n){return n.c(e,w)}));_.forEach((function(n){return n.c(e,w)}));_.length=0;b=true;if(C){T=true}C=true};var xe=function(){if(p===0){return}p--;if(p===0){we();if(v){v.animationFinish()}}};var Ke=function(n){if(n===void 0){n=true}Q();var r=processKeyframes(f);I.forEach((function(t){if(r.length>0){var a=generateKeyframeRules(r);k=e!==undefined?e:generateKeyframeName(a);var i=createKeyframeStylesheet(k,a,t);L.push(i);setStyleProperty(t,"animation-duration","".concat(ve(),"ms"));setStyleProperty(t,"animation-timing-function",se());setStyleProperty(t,"animation-delay","".concat(de(),"ms"));setStyleProperty(t,"animation-fill-mode",ue());setStyleProperty(t,"animation-direction",ce());var o=le()===Infinity?"infinite":le().toString();setStyleProperty(t,"animation-iteration-count",o);setStyleProperty(t,"animation-play-state","paused");if(n){setStyleProperty(t,"animation-name","".concat(i.id,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(t,"animation-name",i.id||null)}))}}))};var _e=function(){I.forEach((function(e){var n=e.animate(f,{id:x,delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()});n.pause();W.push(n)}));if(W.length>0){W[0].onfinish=function(){xe()}}};var Ie=function(e){if(e===void 0){e=true}ke();if(f.length>0){if(H){_e()}else{Ke(e)}}s=true};var De=function(e){e=Math.min(Math.max(e,0),.9999);if(H){W.forEach((function(n){n.currentTime=n.effect.getComputedTiming().delay+ve()*e;n.pause()}))}else{var n="-".concat(ve()*e,"ms");I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-delay",n);setStyleProperty(e,"animation-play-state","paused")}}))}};var Le=function(e){W.forEach((function(e){e.effect.updateTiming({delay:de(),duration:ve(),easing:se(),iterations:le(),fill:ue(),direction:ce()})}));if(e!==undefined){De(e)}};var Ne=function(e,n){if(e===void 0){e=true}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(r){setStyleProperty(r,"animation-name",k||null);setStyleProperty(r,"animation-duration","".concat(ve(),"ms"));setStyleProperty(r,"animation-timing-function",se());setStyleProperty(r,"animation-delay",n!==undefined?"-".concat(n*ve(),"ms"):"".concat(de(),"ms"));setStyleProperty(r,"animation-fill-mode",ue()||null);setStyleProperty(r,"animation-direction",ce()||null);var t=le()===Infinity?"infinite":le().toString();setStyleProperty(r,"animation-iteration-count",t);if(e){setStyleProperty(r,"animation-name","".concat(k,"-alt"))}(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){setStyleProperty(r,"animation-name",k||null)}))}))}))};var Re=function(e,n,r){if(e===void 0){e=false}if(n===void 0){n=true}if(e){D.forEach((function(t){t.update(e,n,r)}))}if(H){Le(r)}else{Ne(n,r)}return w};var Fe=function(e,n){if(e===void 0){e=false}D.forEach((function(r){r.progressStart(e,n)}));je();h=e;if(!s){Ie()}Re(false,true,n);return w};var Oe=function(e){D.forEach((function(n){n.progressStep(e)}));De(e);return w};var We=function(e,n,r){h=false;D.forEach((function(t){t.progressEnd(e,n,r)}));if(r!==undefined){S=r}T=false;C=true;if(e===0){P=ce()==="reverse"?"normal":"reverse";if(P==="reverse"){C=false}if(H){Re();De(1-n)}else{A=(1-n)*ve()*-1;Re(false,false)}}else if(e===1){if(H){Re();De(n)}else{A=n*ve()*-1;Re(false,false)}}if(e!==undefined){B((function(){S=undefined;P=undefined;A=undefined}),{oneTimeCallback:true});if(!v){Ge()}}return w};var je=function(){if(s){if(H){W.forEach((function(e){e.pause()}))}else{I.forEach((function(e){setStyleProperty(e,"animation-play-state","paused")}))}}};var He=function(){D.forEach((function(e){e.pause()}));je();return w};var Me=function(){E=undefined;xe()};var $e=function(){if(E){clearTimeout(E)}};var qe=function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){I.forEach((function(e){if(f.length>0){setStyleProperty(e,"animation-play-state","running")}}))}));if(f.length===0||I.length===0){xe()}else{var e=de()||0;var n=ve()||0;var r=le()||1;if(isFinite(r)){E=setTimeout(Me,e+n*r+M)}animationEnd(I[0],(function(){$e();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)((function(){ze();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_1__.r)(xe)}))}))}};var ze=function(){I.forEach((function(e){removeStyleProperty(e,"animation-duration");removeStyleProperty(e,"animation-delay");removeStyleProperty(e,"animation-play-state")}))};var Ze=function(){W.forEach((function(e){e.play()}));if(f.length===0||I.length===0){xe()}};var Be=function(){if(H){De(0);Le()}else{Ne()}};var Ge=function(e){return new Promise((function(n){if(e&&e.sync){g=true;B((function(){return g=false}),{oneTimeCallback:true})}if(!s){Ie()}if(T){Be();T=false}if(b){p=D.length+1;b=false}B((function(){return n()}),{oneTimeCallback:true});D.forEach((function(e){e.play()}));if(H){Ze()}else{qe()}}))};var Je=function(){D.forEach((function(e){e.stop()}));if(s){J();s=false}Z()};var Qe=function(e,n){var r;var t=f[0];if(t!==undefined&&(t.offset===undefined||t.offset===0)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([(r={offset:0},r[e]=n,r)],f,true)}return w};var Ue=function(e,n){var r;var t=f[f.length-1];if(t!==undefined&&(t.offset===undefined||t.offset===1)){t[e]=n}else{f=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],f,true),[(r={offset:1},r[e]=n,r)],false)}return w};var Ve=function(e,n,r){return Qe(e,n).to(e,r)};return w={parentAnimation:v,elements:I,childAnimations:D,id:x,animationFinish:xe,from:Qe,to:Ue,fromTo:Ve,parent:Se,play:Ge,pause:He,stop:Je,destroy:q,keyframes:Te,addAnimation:Ce,addElement:Ae,update:Re,fill:pe,direction:me,iterations:Pe,duration:Ee,easing:ge,delay:he,getWebAnimations:$,getKeyframes:ye,getFill:ue,getDirection:ce,getDelay:de,getIterations:le,getEasing:se,getDuration:ve,afterAddRead:X,afterAddWrite:Y,afterClearStyles:fe,afterStyles:oe,afterRemoveClass:ie,afterAddClass:ae,beforeAddRead:U,beforeAddWrite:V,beforeClearStyles:te,beforeStyles:re,beforeRemoveClass:ne,beforeAddClass:ee,onFinish:B,progressStart:Fe,progressStep:Oe,progressEnd:We}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dUIsVUFBVSxHQUFHLEtBQUssdUJBQXVCLG9EQUFvRCxNQUFNLGtCQUFrQix1QkFBdUIsVUFBVSxHQUFHLEtBQUssVUFBVSxrQkFBa0IsWUFBWSxNQUFNLGtCQUFrQixNQUFNLGtCQUFrQixrQkFBa0IsS0FBSyx1REFBRyxhQUFhLHVCQUF1QixlQUFlLHNEQUFzRCxHQUFHLEdBQUcsK0JBQStCLEtBQUssS0FBSyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IseUJBQXlCLDhCQUE4QixLQUFLLHVEQUFHLGFBQWEsS0FBSyx1REFBRyxLQUFLLEdBQUcsS0FBSyxrQkFBa0IsdUJBQXVCLDRDQUE0Qyx5Q0FBeUMsOENBQThDLElBQUksa0JBQWtCLHVCQUF1QixTQUFTLEdBQUcsK0JBQStCLE9BQU8sa0JBQWtCLE1BQU0sTUFBTSxLQUFLLEtBQUssT0FBTyxtQkFBbUIsZ0NBQWdDLGNBQWMsT0FBTyxjQUFjLGVBQWUsR0FBRyxxQkFBcUIsRUFBRSxPQUFPLEtBQUssTUFBTSxLQUFLLFFBQVEsTUFBTSxhQUFhLFFBQVEsY0FBYyxXQUFXLEdBQUcscUJBQXFCLEVBQUUsdUJBQXVCLFNBQVMsR0FBRyxNQUFNLEtBQUssS0FBSyxNQUFNLElBQUksa0JBQWtCLHVCQUF1QixTQUFTLEdBQUcsTUFBTSxJQUFJLFFBQVEsS0FBSyxxQkFBcUIsTUFBTSxXQUFXLHdEQUF3RCxPQUFPLEtBQUssRUFBRSw4REFBYSxNQUFNLFNBQVMsb0JBQW9CLFVBQVUscUJBQXFCLE1BQU0sb0JBQW9CLHdEQUF3RCxPQUFPLEtBQUssRUFBRSw4REFBYSxDQUFDLDhEQUFhLGlCQUFpQixTQUFTLG1CQUFtQixVQUFVLHVCQUF1Qix3QkFBd0IsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2FuaW1hdGlvbi0xOWRiZjliZi5qcz83ZTBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtyIGFzIHJhZn1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjt2YXIgYW5pbWF0aW9uUHJlZml4O3ZhciBwcm9jZXNzS2V5ZnJhbWVzPWZ1bmN0aW9uKGUpe2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Zm9yKHZhciBuIGluIGUpe2lmKGUuaGFzT3duUHJvcGVydHkobikpe3ZhciByPWVbbl07aWYobj09PVwiZWFzaW5nXCIpe3ZhciB0PVwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiO2VbdF09cjtkZWxldGUgZVtuXX1lbHNle3ZhciB0PWNvbnZlcnRDYW1lbENhc2VUb0h5cGVuKG4pO2lmKHQhPT1uKXtlW3RdPXI7ZGVsZXRlIGVbbl19fX19fSkpO3JldHVybiBlfTt2YXIgY29udmVydENhbWVsQ2FzZVRvSHlwZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZyxcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCl9O3ZhciBnZXRBbmltYXRpb25QcmVmaXg9ZnVuY3Rpb24oZSl7aWYoYW5pbWF0aW9uUHJlZml4PT09dW5kZWZpbmVkKXt2YXIgbj1lLnN0eWxlLmFuaW1hdGlvbk5hbWUhPT11bmRlZmluZWQ7dmFyIHI9ZS5zdHlsZS53ZWJraXRBbmltYXRpb25OYW1lIT09dW5kZWZpbmVkO2FuaW1hdGlvblByZWZpeD0hbiYmcj9cIi13ZWJraXQtXCI6XCJcIn1yZXR1cm4gYW5pbWF0aW9uUHJlZml4fTt2YXIgc2V0U3R5bGVQcm9wZXJ0eT1mdW5jdGlvbihlLG4scil7dmFyIHQ9bi5zdGFydHNXaXRoKFwiYW5pbWF0aW9uXCIpP2dldEFuaW1hdGlvblByZWZpeChlKTpcIlwiO2Uuc3R5bGUuc2V0UHJvcGVydHkodCtuLHIpfTt2YXIgcmVtb3ZlU3R5bGVQcm9wZXJ0eT1mdW5jdGlvbihlLG4pe3ZhciByPW4uc3RhcnRzV2l0aChcImFuaW1hdGlvblwiKT9nZXRBbmltYXRpb25QcmVmaXgoZSk6XCJcIjtlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHIrbil9O3ZhciBhbmltYXRpb25FbmQ9ZnVuY3Rpb24oZSxuKXt2YXIgcjt2YXIgdD17cGFzc2l2ZTp0cnVlfTt2YXIgYT1mdW5jdGlvbigpe2lmKHIpe3IoKX19O3ZhciBpPWZ1bmN0aW9uKHIpe2lmKGU9PT1yLnRhcmdldCl7YSgpO24ocil9fTtpZihlKXtlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRBbmltYXRpb25FbmRcIixpLHQpO2UuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLGksdCk7cj1mdW5jdGlvbigpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdEFuaW1hdGlvbkVuZFwiLGksdCk7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsaSx0KX19cmV0dXJuIGF9O3ZhciBnZW5lcmF0ZUtleWZyYW1lUnVsZXM9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1bXX1yZXR1cm4gZS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciBuPWUub2Zmc2V0O3ZhciByPVtdO2Zvcih2YXIgdCBpbiBlKXtpZihlLmhhc093blByb3BlcnR5KHQpJiZ0IT09XCJvZmZzZXRcIil7ci5wdXNoKFwiXCIuY29uY2F0KHQsXCI6IFwiKS5jb25jYXQoZVt0XSxcIjtcIikpfX1yZXR1cm5cIlwiLmNvbmNhdChuKjEwMCxcIiUgeyBcIikuY29uY2F0KHIuam9pbihcIiBcIiksXCIgfVwiKX0pKS5qb2luKFwiIFwiKX07dmFyIGtleWZyYW1lSWRzPVtdO3ZhciBnZW5lcmF0ZUtleWZyYW1lTmFtZT1mdW5jdGlvbihlKXt2YXIgbj1rZXlmcmFtZUlkcy5pbmRleE9mKGUpO2lmKG48MCl7bj1rZXlmcmFtZUlkcy5wdXNoKGUpLTF9cmV0dXJuXCJpb24tYW5pbWF0aW9uLVwiLmNvbmNhdChuKX07dmFyIGdldFN0eWxlQ29udGFpbmVyPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZ2V0Um9vdE5vZGUoKTtyZXR1cm4gbi5oZWFkfHxufTt2YXIgY3JlYXRlS2V5ZnJhbWVTdHlsZXNoZWV0PWZ1bmN0aW9uKGUsbixyKXt2YXIgdD1nZXRTdHlsZUNvbnRhaW5lcihyKTt2YXIgYT1nZXRBbmltYXRpb25QcmVmaXgocik7dmFyIGk9dC5xdWVyeVNlbGVjdG9yKFwiI1wiK2UpO2lmKGkpe3JldHVybiBpfXZhciBvPShyLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50KS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7by5pZD1lO28udGV4dENvbnRlbnQ9XCJAXCIuY29uY2F0KGEsXCJrZXlmcmFtZXMgXCIpLmNvbmNhdChlLFwiIHsgXCIpLmNvbmNhdChuLFwiIH0gQFwiKS5jb25jYXQoYSxcImtleWZyYW1lcyBcIikuY29uY2F0KGUsXCItYWx0IHsgXCIpLmNvbmNhdChuLFwiIH1cIik7dC5hcHBlbmRDaGlsZChvKTtyZXR1cm4gb307dmFyIGFkZENsYXNzVG9BcnJheT1mdW5jdGlvbihlLG4pe2lmKGU9PT12b2lkIDApe2U9W119aWYobiE9PXVuZGVmaW5lZCl7dmFyIHI9QXJyYXkuaXNBcnJheShuKT9uOltuXTtyZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLGUsdHJ1ZSkscix0cnVlKX1yZXR1cm4gZX07dmFyIGNyZWF0ZUFuaW1hdGlvbj1mdW5jdGlvbihlKXt2YXIgbjt2YXIgcjt2YXIgdDt2YXIgYTt2YXIgaTt2YXIgbzt2YXIgZj1bXTt2YXIgdT1bXTt2YXIgYz1bXTt2YXIgcz1mYWxzZTt2YXIgdjt2YXIgbD17fTt2YXIgZD1bXTt2YXIgeT1bXTt2YXIgbT17fTt2YXIgcD0wO3ZhciBoPWZhbHNlO3ZhciBnPWZhbHNlO3ZhciBFO3ZhciBQO3ZhciBTO3ZhciBBO3ZhciBDPXRydWU7dmFyIFQ9ZmFsc2U7dmFyIGI9dHJ1ZTt2YXIgazt2YXIgdzt2YXIgeD1lO3ZhciBLPVtdO3ZhciBfPVtdO3ZhciBJPVtdO3ZhciBEPVtdO3ZhciBMPVtdO3ZhciBOPVtdO3ZhciBSPVtdO3ZhciBGPVtdO3ZhciBPPVtdO3ZhciBXPVtdO3ZhciBqPXR5cGVvZiBBbmltYXRpb25FZmZlY3Q9PT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiB3aW5kb3cuQW5pbWF0aW9uRWZmZWN0PT09XCJmdW5jdGlvblwiO3ZhciBIPXR5cGVvZiBFbGVtZW50PT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT09PVwiZnVuY3Rpb25cIiYmajt2YXIgTT0xMDA7dmFyICQ9ZnVuY3Rpb24oKXtyZXR1cm4gV307dmFyIHE9ZnVuY3Rpb24oZSl7RC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmRlc3Ryb3koZSl9KSk7eihlKTtJLmxlbmd0aD0wO0QubGVuZ3RoPTA7Zi5sZW5ndGg9MDtHKCk7cz1mYWxzZTtiPXRydWU7cmV0dXJuIHd9O3ZhciB6PWZ1bmN0aW9uKGUpe0ooKTtpZihlKXtRKCl9fTt2YXIgWj1mdW5jdGlvbigpe2g9ZmFsc2U7Zz1mYWxzZTtiPXRydWU7UD11bmRlZmluZWQ7Uz11bmRlZmluZWQ7QT11bmRlZmluZWQ7cD0wO1Q9ZmFsc2U7Qz10cnVlfTt2YXIgQj1mdW5jdGlvbihlLG4pe3ZhciByPW4mJm4ub25lVGltZUNhbGxiYWNrP186SztyLnB1c2goe2M6ZSxvOm59KTtyZXR1cm4gd307dmFyIEc9ZnVuY3Rpb24oKXtLLmxlbmd0aD0wO18ubGVuZ3RoPTA7cmV0dXJuIHd9O3ZhciBKPWZ1bmN0aW9uKCl7aWYoSCl7Vy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmNhbmNlbCgpfSkpO1cubGVuZ3RoPTB9ZWxzZXt2YXIgZT1JLnNsaWNlKCk7cmFmKChmdW5jdGlvbigpe2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLW5hbWVcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZGVsYXlcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiKTtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZGlyZWN0aW9uXCIpfSkpfSkpfX07dmFyIFE9ZnVuY3Rpb24oKXtMLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGUmJmUucGFyZW50Tm9kZSl7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfX0pKTtMLmxlbmd0aD0wfTt2YXIgVT1mdW5jdGlvbihlKXtOLnB1c2goZSk7cmV0dXJuIHd9O3ZhciBWPWZ1bmN0aW9uKGUpe1IucHVzaChlKTtyZXR1cm4gd307dmFyIFg9ZnVuY3Rpb24oZSl7Ri5wdXNoKGUpO3JldHVybiB3fTt2YXIgWT1mdW5jdGlvbihlKXtPLnB1c2goZSk7cmV0dXJuIHd9O3ZhciBlZT1mdW5jdGlvbihlKXt1PWFkZENsYXNzVG9BcnJheSh1LGUpO3JldHVybiB3fTt2YXIgbmU9ZnVuY3Rpb24oZSl7Yz1hZGRDbGFzc1RvQXJyYXkoYyxlKTtyZXR1cm4gd307dmFyIHJlPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9e319bD1lO3JldHVybiB3fTt2YXIgdGU9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1bXX1mb3IodmFyIG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciB0PXJbbl07bFt0XT1cIlwifXJldHVybiB3fTt2YXIgYWU9ZnVuY3Rpb24oZSl7ZD1hZGRDbGFzc1RvQXJyYXkoZCxlKTtyZXR1cm4gd307dmFyIGllPWZ1bmN0aW9uKGUpe3k9YWRkQ2xhc3NUb0FycmF5KHksZSk7cmV0dXJuIHd9O3ZhciBvZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXt9fW09ZTtyZXR1cm4gd307dmFyIGZlPWZ1bmN0aW9uKGUpe2lmKGU9PT12b2lkIDApe2U9W119Zm9yKHZhciBuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgdD1yW25dO21bdF09XCJcIn1yZXR1cm4gd307dmFyIHVlPWZ1bmN0aW9uKCl7aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGl9aWYodil7cmV0dXJuIHYuZ2V0RmlsbCgpfXJldHVyblwiYm90aFwifTt2YXIgY2U9ZnVuY3Rpb24oKXtpZihQIT09dW5kZWZpbmVkKXtyZXR1cm4gUH1pZihvIT09dW5kZWZpbmVkKXtyZXR1cm4gb31pZih2KXtyZXR1cm4gdi5nZXREaXJlY3Rpb24oKX1yZXR1cm5cIm5vcm1hbFwifTt2YXIgc2U9ZnVuY3Rpb24oKXtpZihoKXtyZXR1cm5cImxpbmVhclwifWlmKHQhPT11bmRlZmluZWQpe3JldHVybiB0fWlmKHYpe3JldHVybiB2LmdldEVhc2luZygpfXJldHVyblwibGluZWFyXCJ9O3ZhciB2ZT1mdW5jdGlvbigpe2lmKGcpe3JldHVybiAwfWlmKFMhPT11bmRlZmluZWQpe3JldHVybiBTfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiByfWlmKHYpe3JldHVybiB2LmdldER1cmF0aW9uKCl9cmV0dXJuIDB9O3ZhciBsZT1mdW5jdGlvbigpe2lmKGEhPT11bmRlZmluZWQpe3JldHVybiBhfWlmKHYpe3JldHVybiB2LmdldEl0ZXJhdGlvbnMoKX1yZXR1cm4gMX07dmFyIGRlPWZ1bmN0aW9uKCl7aWYoQSE9PXVuZGVmaW5lZCl7cmV0dXJuIEF9aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG59aWYodil7cmV0dXJuIHYuZ2V0RGVsYXkoKX1yZXR1cm4gMH07dmFyIHllPWZ1bmN0aW9uKCl7cmV0dXJuIGZ9O3ZhciBtZT1mdW5jdGlvbihlKXtvPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBwZT1mdW5jdGlvbihlKXtpPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBoZT1mdW5jdGlvbihlKXtuPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBnZT1mdW5jdGlvbihlKXt0PWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBFZT1mdW5jdGlvbihlKXtpZighSCYmZT09PTApe2U9MX1yPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBQZT1mdW5jdGlvbihlKXthPWU7UmUodHJ1ZSk7cmV0dXJuIHd9O3ZhciBTZT1mdW5jdGlvbihlKXt2PWU7cmV0dXJuIHd9O3ZhciBBZT1mdW5jdGlvbihlKXtpZihlIT1udWxsKXtpZihlLm5vZGVUeXBlPT09MSl7SS5wdXNoKGUpfWVsc2UgaWYoZS5sZW5ndGg+PTApe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXtJLnB1c2goZVtuXSl9fWVsc2V7Y29uc29sZS5lcnJvcihcIkludmFsaWQgYWRkRWxlbWVudCB2YWx1ZVwiKX19cmV0dXJuIHd9O3ZhciBDZT1mdW5jdGlvbihlKXtpZihlIT1udWxsKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciB0PXJbbl07dC5wYXJlbnQodyk7RC5wdXNoKHQpfX1lbHNle2UucGFyZW50KHcpO0QucHVzaChlKX19cmV0dXJuIHd9O3ZhciBUZT1mdW5jdGlvbihlKXt2YXIgbj1mIT09ZTtmPWU7aWYobil7YmUoZil9cmV0dXJuIHd9O3ZhciBiZT1mdW5jdGlvbihlKXtpZihIKXskKCkuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYobi5lZmZlY3Quc2V0S2V5ZnJhbWVzKXtuLmVmZmVjdC5zZXRLZXlmcmFtZXMoZSl9ZWxzZXt2YXIgcj1uZXcgS2V5ZnJhbWVFZmZlY3Qobi5lZmZlY3QudGFyZ2V0LGUsbi5lZmZlY3QuZ2V0VGltaW5nKCkpO24uZWZmZWN0PXJ9fSkpfWVsc2V7S2UoKX19O3ZhciBrZT1mdW5jdGlvbigpe04uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKTtSLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7dmFyIGU9dTt2YXIgbj1jO3ZhciByPWw7SS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT10LmNsYXNzTGlzdDtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFkZChlKX0pKTtuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBhLnJlbW92ZShlKX0pKTtmb3IodmFyIGkgaW4gcil7aWYoci5oYXNPd25Qcm9wZXJ0eShpKSl7c2V0U3R5bGVQcm9wZXJ0eSh0LGkscltpXSl9fX0pKX07dmFyIHdlPWZ1bmN0aW9uKCl7JGUoKTtGLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7Ty5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSkpO3ZhciBlPUM/MTowO3ZhciBuPWQ7dmFyIHI9eTt2YXIgdD1tO0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIGE9ZS5jbGFzc0xpc3Q7bi5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5hZGQoZSl9KSk7ci5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gYS5yZW1vdmUoZSl9KSk7Zm9yKHZhciBpIGluIHQpe2lmKHQuaGFzT3duUHJvcGVydHkoaSkpe3NldFN0eWxlUHJvcGVydHkoZSxpLHRbaV0pfX19KSk7Sy5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbi5jKGUsdyl9KSk7Xy5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbi5jKGUsdyl9KSk7Xy5sZW5ndGg9MDtiPXRydWU7aWYoQyl7VD10cnVlfUM9dHJ1ZX07dmFyIHhlPWZ1bmN0aW9uKCl7aWYocD09PTApe3JldHVybn1wLS07aWYocD09PTApe3dlKCk7aWYodil7di5hbmltYXRpb25GaW5pc2goKX19fTt2YXIgS2U9ZnVuY3Rpb24obil7aWYobj09PXZvaWQgMCl7bj10cnVlfVEoKTt2YXIgcj1wcm9jZXNzS2V5ZnJhbWVzKGYpO0kuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYoci5sZW5ndGg+MCl7dmFyIGE9Z2VuZXJhdGVLZXlmcmFtZVJ1bGVzKHIpO2s9ZSE9PXVuZGVmaW5lZD9lOmdlbmVyYXRlS2V5ZnJhbWVOYW1lKGEpO3ZhciBpPWNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldChrLGEsdCk7TC5wdXNoKGkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kdXJhdGlvblwiLFwiXCIuY29uY2F0KHZlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLHNlKCkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kZWxheVwiLFwiXCIuY29uY2F0KGRlKCksXCJtc1wiKSk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiLHVlKCkpO3NldFN0eWxlUHJvcGVydHkodCxcImFuaW1hdGlvbi1kaXJlY3Rpb25cIixjZSgpKTt2YXIgbz1sZSgpPT09SW5maW5pdHk/XCJpbmZpbml0ZVwiOmxlKCkudG9TdHJpbmcoKTtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCIsbyk7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcInBhdXNlZFwiKTtpZihuKXtzZXRTdHlsZVByb3BlcnR5KHQsXCJhbmltYXRpb24tbmFtZVwiLFwiXCIuY29uY2F0KGkuaWQsXCItYWx0XCIpKX1yYWYoKGZ1bmN0aW9uKCl7c2V0U3R5bGVQcm9wZXJ0eSh0LFwiYW5pbWF0aW9uLW5hbWVcIixpLmlkfHxudWxsKX0pKX19KSl9O3ZhciBfZT1mdW5jdGlvbigpe0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5hbmltYXRlKGYse2lkOngsZGVsYXk6ZGUoKSxkdXJhdGlvbjp2ZSgpLGVhc2luZzpzZSgpLGl0ZXJhdGlvbnM6bGUoKSxmaWxsOnVlKCksZGlyZWN0aW9uOmNlKCl9KTtuLnBhdXNlKCk7Vy5wdXNoKG4pfSkpO2lmKFcubGVuZ3RoPjApe1dbMF0ub25maW5pc2g9ZnVuY3Rpb24oKXt4ZSgpfX19O3ZhciBJZT1mdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXRydWV9a2UoKTtpZihmLmxlbmd0aD4wKXtpZihIKXtfZSgpfWVsc2V7S2UoZSl9fXM9dHJ1ZX07dmFyIERlPWZ1bmN0aW9uKGUpe2U9TWF0aC5taW4oTWF0aC5tYXgoZSwwKSwuOTk5OSk7aWYoSCl7Vy5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmN1cnJlbnRUaW1lPW4uZWZmZWN0LmdldENvbXB1dGVkVGltaW5nKCkuZGVsYXkrdmUoKSplO24ucGF1c2UoKX0pKX1lbHNle3ZhciBuPVwiLVwiLmNvbmNhdCh2ZSgpKmUsXCJtc1wiKTtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGYubGVuZ3RoPjApe3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1kZWxheVwiLG4pO3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJwYXVzZWRcIil9fSkpfX07dmFyIExlPWZ1bmN0aW9uKGUpe1cuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5lZmZlY3QudXBkYXRlVGltaW5nKHtkZWxheTpkZSgpLGR1cmF0aW9uOnZlKCksZWFzaW5nOnNlKCksaXRlcmF0aW9uczpsZSgpLGZpbGw6dWUoKSxkaXJlY3Rpb246Y2UoKX0pfSkpO2lmKGUhPT11bmRlZmluZWQpe0RlKGUpfX07dmFyIE5lPWZ1bmN0aW9uKGUsbil7aWYoZT09PXZvaWQgMCl7ZT10cnVlfXJhZigoZnVuY3Rpb24oKXtJLmZvckVhY2goKGZ1bmN0aW9uKHIpe3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1uYW1lXCIsa3x8bnVsbCk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIsXCJcIi5jb25jYXQodmUoKSxcIm1zXCIpKTtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsc2UoKSk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWRlbGF5XCIsbiE9PXVuZGVmaW5lZD9cIi1cIi5jb25jYXQobip2ZSgpLFwibXNcIik6XCJcIi5jb25jYXQoZGUoKSxcIm1zXCIpKTtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tZmlsbC1tb2RlXCIsdWUoKXx8bnVsbCk7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLWRpcmVjdGlvblwiLGNlKCl8fG51bGwpO3ZhciB0PWxlKCk9PT1JbmZpbml0eT9cImluZmluaXRlXCI6bGUoKS50b1N0cmluZygpO3NldFN0eWxlUHJvcGVydHkocixcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIix0KTtpZihlKXtzZXRTdHlsZVByb3BlcnR5KHIsXCJhbmltYXRpb24tbmFtZVwiLFwiXCIuY29uY2F0KGssXCItYWx0XCIpKX1yYWYoKGZ1bmN0aW9uKCl7c2V0U3R5bGVQcm9wZXJ0eShyLFwiYW5pbWF0aW9uLW5hbWVcIixrfHxudWxsKX0pKX0pKX0pKX07dmFyIFJlPWZ1bmN0aW9uKGUsbixyKXtpZihlPT09dm9pZCAwKXtlPWZhbHNlfWlmKG49PT12b2lkIDApe249dHJ1ZX1pZihlKXtELmZvckVhY2goKGZ1bmN0aW9uKHQpe3QudXBkYXRlKGUsbixyKX0pKX1pZihIKXtMZShyKX1lbHNle05lKG4scil9cmV0dXJuIHd9O3ZhciBGZT1mdW5jdGlvbihlLG4pe2lmKGU9PT12b2lkIDApe2U9ZmFsc2V9RC5mb3JFYWNoKChmdW5jdGlvbihyKXtyLnByb2dyZXNzU3RhcnQoZSxuKX0pKTtqZSgpO2g9ZTtpZighcyl7SWUoKX1SZShmYWxzZSx0cnVlLG4pO3JldHVybiB3fTt2YXIgT2U9ZnVuY3Rpb24oZSl7RC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLnByb2dyZXNzU3RlcChlKX0pKTtEZShlKTtyZXR1cm4gd307dmFyIFdlPWZ1bmN0aW9uKGUsbixyKXtoPWZhbHNlO0QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wcm9ncmVzc0VuZChlLG4scil9KSk7aWYociE9PXVuZGVmaW5lZCl7Uz1yfVQ9ZmFsc2U7Qz10cnVlO2lmKGU9PT0wKXtQPWNlKCk9PT1cInJldmVyc2VcIj9cIm5vcm1hbFwiOlwicmV2ZXJzZVwiO2lmKFA9PT1cInJldmVyc2VcIil7Qz1mYWxzZX1pZihIKXtSZSgpO0RlKDEtbil9ZWxzZXtBPSgxLW4pKnZlKCkqLTE7UmUoZmFsc2UsZmFsc2UpfX1lbHNlIGlmKGU9PT0xKXtpZihIKXtSZSgpO0RlKG4pfWVsc2V7QT1uKnZlKCkqLTE7UmUoZmFsc2UsZmFsc2UpfX1pZihlIT09dW5kZWZpbmVkKXtCKChmdW5jdGlvbigpe1M9dW5kZWZpbmVkO1A9dW5kZWZpbmVkO0E9dW5kZWZpbmVkfSkse29uZVRpbWVDYWxsYmFjazp0cnVlfSk7aWYoIXYpe0dlKCl9fXJldHVybiB3fTt2YXIgamU9ZnVuY3Rpb24oKXtpZihzKXtpZihIKXtXLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGF1c2UoKX0pKX1lbHNle0kuZm9yRWFjaCgoZnVuY3Rpb24oZSl7c2V0U3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcInBhdXNlZFwiKX0pKX19fTt2YXIgSGU9ZnVuY3Rpb24oKXtELmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGF1c2UoKX0pKTtqZSgpO3JldHVybiB3fTt2YXIgTWU9ZnVuY3Rpb24oKXtFPXVuZGVmaW5lZDt4ZSgpfTt2YXIgJGU9ZnVuY3Rpb24oKXtpZihFKXtjbGVhclRpbWVvdXQoRSl9fTt2YXIgcWU9ZnVuY3Rpb24oKXskZSgpO3JhZigoZnVuY3Rpb24oKXtJLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGYubGVuZ3RoPjApe3NldFN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIsXCJydW5uaW5nXCIpfX0pKX0pKTtpZihmLmxlbmd0aD09PTB8fEkubGVuZ3RoPT09MCl7eGUoKX1lbHNle3ZhciBlPWRlKCl8fDA7dmFyIG49dmUoKXx8MDt2YXIgcj1sZSgpfHwxO2lmKGlzRmluaXRlKHIpKXtFPXNldFRpbWVvdXQoTWUsZStuKnIrTSl9YW5pbWF0aW9uRW5kKElbMF0sKGZ1bmN0aW9uKCl7JGUoKTtyYWYoKGZ1bmN0aW9uKCl7emUoKTtyYWYoeGUpfSkpfSkpfX07dmFyIHplPWZ1bmN0aW9uKCl7SS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZW1vdmVTdHlsZVByb3BlcnR5KGUsXCJhbmltYXRpb24tZHVyYXRpb25cIik7cmVtb3ZlU3R5bGVQcm9wZXJ0eShlLFwiYW5pbWF0aW9uLWRlbGF5XCIpO3JlbW92ZVN0eWxlUHJvcGVydHkoZSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCIpfSkpfTt2YXIgWmU9ZnVuY3Rpb24oKXtXLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UucGxheSgpfSkpO2lmKGYubGVuZ3RoPT09MHx8SS5sZW5ndGg9PT0wKXt4ZSgpfX07dmFyIEJlPWZ1bmN0aW9uKCl7aWYoSCl7RGUoMCk7TGUoKX1lbHNle05lKCl9fTt2YXIgR2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtpZihlJiZlLnN5bmMpe2c9dHJ1ZTtCKChmdW5jdGlvbigpe3JldHVybiBnPWZhbHNlfSkse29uZVRpbWVDYWxsYmFjazp0cnVlfSl9aWYoIXMpe0llKCl9aWYoVCl7QmUoKTtUPWZhbHNlfWlmKGIpe3A9RC5sZW5ndGgrMTtiPWZhbHNlfUIoKGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pLHtvbmVUaW1lQ2FsbGJhY2s6dHJ1ZX0pO0QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5wbGF5KCl9KSk7aWYoSCl7WmUoKX1lbHNle3FlKCl9fSkpfTt2YXIgSmU9ZnVuY3Rpb24oKXtELmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uuc3RvcCgpfSkpO2lmKHMpe0ooKTtzPWZhbHNlfVooKX07dmFyIFFlPWZ1bmN0aW9uKGUsbil7dmFyIHI7dmFyIHQ9ZlswXTtpZih0IT09dW5kZWZpbmVkJiYodC5vZmZzZXQ9PT11bmRlZmluZWR8fHQub2Zmc2V0PT09MCkpe3RbZV09bn1lbHNle2Y9X19zcHJlYWRBcnJheShbKHI9e29mZnNldDowfSxyW2VdPW4scildLGYsdHJ1ZSl9cmV0dXJuIHd9O3ZhciBVZT1mdW5jdGlvbihlLG4pe3ZhciByO3ZhciB0PWZbZi5sZW5ndGgtMV07aWYodCE9PXVuZGVmaW5lZCYmKHQub2Zmc2V0PT09dW5kZWZpbmVkfHx0Lm9mZnNldD09PTEpKXt0W2VdPW59ZWxzZXtmPV9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxmLHRydWUpLFsocj17b2Zmc2V0OjF9LHJbZV09bixyKV0sZmFsc2UpfXJldHVybiB3fTt2YXIgVmU9ZnVuY3Rpb24oZSxuLHIpe3JldHVybiBRZShlLG4pLnRvKGUscil9O3JldHVybiB3PXtwYXJlbnRBbmltYXRpb246dixlbGVtZW50czpJLGNoaWxkQW5pbWF0aW9uczpELGlkOngsYW5pbWF0aW9uRmluaXNoOnhlLGZyb206UWUsdG86VWUsZnJvbVRvOlZlLHBhcmVudDpTZSxwbGF5OkdlLHBhdXNlOkhlLHN0b3A6SmUsZGVzdHJveTpxLGtleWZyYW1lczpUZSxhZGRBbmltYXRpb246Q2UsYWRkRWxlbWVudDpBZSx1cGRhdGU6UmUsZmlsbDpwZSxkaXJlY3Rpb246bWUsaXRlcmF0aW9uczpQZSxkdXJhdGlvbjpFZSxlYXNpbmc6Z2UsZGVsYXk6aGUsZ2V0V2ViQW5pbWF0aW9uczokLGdldEtleWZyYW1lczp5ZSxnZXRGaWxsOnVlLGdldERpcmVjdGlvbjpjZSxnZXREZWxheTpkZSxnZXRJdGVyYXRpb25zOmxlLGdldEVhc2luZzpzZSxnZXREdXJhdGlvbjp2ZSxhZnRlckFkZFJlYWQ6WCxhZnRlckFkZFdyaXRlOlksYWZ0ZXJDbGVhclN0eWxlczpmZSxhZnRlclN0eWxlczpvZSxhZnRlclJlbW92ZUNsYXNzOmllLGFmdGVyQWRkQ2xhc3M6YWUsYmVmb3JlQWRkUmVhZDpVLGJlZm9yZUFkZFdyaXRlOlYsYmVmb3JlQ2xlYXJTdHlsZXM6dGUsYmVmb3JlU3R5bGVzOnJlLGJlZm9yZVJlbW92ZUNsYXNzOm5lLGJlZm9yZUFkZENsYXNzOmVlLG9uRmluaXNoOkIscHJvZ3Jlc3NTdGFydDpGZSxwcm9ncmVzc1N0ZXA6T2UscHJvZ3Jlc3NFbmQ6V2V9fTtleHBvcnR7Y3JlYXRlQW5pbWF0aW9uIGFzIGN9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7434\n')},3544:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "g": () => (/* binding */ getTimeGivenProgression)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar getTimeGivenProgression=function(t,r,a,e,o){return solveCubicBezier(t[1],r[1],a[1],e[1],o).map((function(o){return solveCubicParametricEquation(t[0],r[0],a[0],e[0],o)}))};var solveCubicParametricEquation=function(t,r,a,e,o){var i=3*r*Math.pow(o-1,2);var n=-3*a*o+3*a+e*o;var u=t*Math.pow(o-1,3);return o*(i+o*n)-u};var solveCubicBezier=function(t,r,a,e,o){t-=o;r-=o;a-=o;e-=o;var i=solveCubicEquation(e-3*a+3*r-t,3*a-6*r+3*t,3*r-3*t,t);return i.filter((function(t){return t>=0&&t<=1}))};var solveQuadraticEquation=function(t,r,a){var e=r*r-4*t*a;if(e<0){return[]}else{return[(-r+Math.sqrt(e))/(2*t),(-r-Math.sqrt(e))/(2*t)]}};var solveCubicEquation=function(t,r,a,e){if(t===0){return solveQuadraticEquation(r,a,e)}r/=t;a/=t;e/=t;var o=(3*a-r*r)/3;var i=(2*r*r*r-9*r*a+27*e)/27;if(o===0){return[Math.pow(-i,1/3)]}else if(i===0){return[Math.sqrt(-o),-Math.sqrt(-o)]}var n=Math.pow(i/2,2)+Math.pow(o/3,3);if(n===0){return[Math.pow(i/2,1/2)-r/3]}else if(n>0){return[Math.pow(-(i/2)+Math.sqrt(n),1/3)-Math.pow(i/2+Math.sqrt(n),1/3)-r/3]}var u=Math.sqrt(Math.pow(-(o/3),3));var s=Math.acos(-(i/(2*Math.sqrt(Math.pow(-(o/3),3)))));var v=2*Math.pow(u,1/3);return[v*Math.cos(s/3)-r/3,v*Math.cos((s+2*Math.PI)/3)-r/3,v*Math.cos((s+4*Math.PI)/3)-r/3]};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0NC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdFQUFnRSwyREFBMkQsSUFBSSxxREFBcUQsMEJBQTBCLHFCQUFxQix3QkFBd0Isb0JBQW9CLHlDQUF5QyxLQUFLLEtBQUssS0FBSyxLQUFLLDREQUE0RCw2QkFBNkIsa0JBQWtCLElBQUksMkNBQTJDLGdCQUFnQixRQUFRLFNBQVMsS0FBSywwREFBMEQseUNBQXlDLFVBQVUscUNBQXFDLEtBQUssS0FBSyxLQUFLLGtCQUFrQiw4QkFBOEIsVUFBVSx5QkFBeUIsZUFBZSxxQ0FBcUMsc0NBQXNDLFVBQVUsOEJBQThCLGFBQWEsNkVBQTZFLG9DQUFvQyx3REFBd0Qsd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvY3ViaWMtYmV6aWVyLTE1NGE1M2E1LmpzPzA0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbnZhciBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbj1mdW5jdGlvbih0LHIsYSxlLG8pe3JldHVybiBzb2x2ZUN1YmljQmV6aWVyKHRbMV0sclsxXSxhWzFdLGVbMV0sbykubWFwKChmdW5jdGlvbihvKXtyZXR1cm4gc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbih0WzBdLHJbMF0sYVswXSxlWzBdLG8pfSkpfTt2YXIgc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbj1mdW5jdGlvbih0LHIsYSxlLG8pe3ZhciBpPTMqcipNYXRoLnBvdyhvLTEsMik7dmFyIG49LTMqYSpvKzMqYStlKm87dmFyIHU9dCpNYXRoLnBvdyhvLTEsMyk7cmV0dXJuIG8qKGkrbypuKS11fTt2YXIgc29sdmVDdWJpY0Jlemllcj1mdW5jdGlvbih0LHIsYSxlLG8pe3QtPW87ci09bzthLT1vO2UtPW87dmFyIGk9c29sdmVDdWJpY0VxdWF0aW9uKGUtMyphKzMqci10LDMqYS02KnIrMyp0LDMqci0zKnQsdCk7cmV0dXJuIGkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdD49MCYmdDw9MX0pKX07dmFyIHNvbHZlUXVhZHJhdGljRXF1YXRpb249ZnVuY3Rpb24odCxyLGEpe3ZhciBlPXIqci00KnQqYTtpZihlPDApe3JldHVybltdfWVsc2V7cmV0dXJuWygtcitNYXRoLnNxcnQoZSkpLygyKnQpLCgtci1NYXRoLnNxcnQoZSkpLygyKnQpXX19O3ZhciBzb2x2ZUN1YmljRXF1YXRpb249ZnVuY3Rpb24odCxyLGEsZSl7aWYodD09PTApe3JldHVybiBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uKHIsYSxlKX1yLz10O2EvPXQ7ZS89dDt2YXIgbz0oMyphLXIqcikvMzt2YXIgaT0oMipyKnIqci05KnIqYSsyNyplKS8yNztpZihvPT09MCl7cmV0dXJuW01hdGgucG93KC1pLDEvMyldfWVsc2UgaWYoaT09PTApe3JldHVybltNYXRoLnNxcnQoLW8pLC1NYXRoLnNxcnQoLW8pXX12YXIgbj1NYXRoLnBvdyhpLzIsMikrTWF0aC5wb3coby8zLDMpO2lmKG49PT0wKXtyZXR1cm5bTWF0aC5wb3coaS8yLDEvMiktci8zXX1lbHNlIGlmKG4+MCl7cmV0dXJuW01hdGgucG93KC0oaS8yKStNYXRoLnNxcnQobiksMS8zKS1NYXRoLnBvdyhpLzIrTWF0aC5zcXJ0KG4pLDEvMyktci8zXX12YXIgdT1NYXRoLnNxcnQoTWF0aC5wb3coLShvLzMpLDMpKTt2YXIgcz1NYXRoLmFjb3MoLShpLygyKk1hdGguc3FydChNYXRoLnBvdygtKG8vMyksMykpKSkpO3ZhciB2PTIqTWF0aC5wb3codSwxLzMpO3JldHVyblt2Kk1hdGguY29zKHMvMyktci8zLHYqTWF0aC5jb3MoKHMrMipNYXRoLlBJKS8zKS1yLzMsdipNYXRoLmNvcygocys0Kk1hdGguUEkpLzMpLXIvM119O2V4cG9ydHtnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbiBhcyBnfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3544\n')},4988:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "G": () => (/* binding */ GESTURE_CONTROLLER)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar GestureController=function(){function t(){this.gestureId=0;this.requestedStart=new Map;this.disabledGestures=new Map;this.disabledScroll=new Set}t.prototype.createGesture=function(t){return new GestureDelegate(this,this.newID(),t.name,t.priority||0,!!t.disableScroll)};t.prototype.createBlocker=function(t){if(t===void 0){t={}}return new BlockerDelegate(this,this.newID(),t.disable,!!t.disableScroll)};t.prototype.start=function(t,e,r){if(!this.canStart(t)){this.requestedStart.delete(e);return false}this.requestedStart.set(e,r);return true};t.prototype.capture=function(t,e,r){if(!this.start(t,e,r)){return false}var i=this.requestedStart;var s=-1e4;i.forEach((function(t){s=Math.max(s,t)}));if(s===r){this.capturedId=e;i.clear();var l=new CustomEvent("ionGestureCaptured",{detail:{gestureName:t}});document.dispatchEvent(l);return true}i.delete(e);return false};t.prototype.release=function(t){this.requestedStart.delete(t);if(this.capturedId===t){this.capturedId=undefined}};t.prototype.disableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r===undefined){r=new Set;this.disabledGestures.set(t,r)}r.add(e)};t.prototype.enableGesture=function(t,e){var r=this.disabledGestures.get(t);if(r!==undefined){r.delete(e)}};t.prototype.disableScroll=function(t){this.disabledScroll.add(t);if(this.disabledScroll.size===1){document.body.classList.add(BACKDROP_NO_SCROLL)}};t.prototype.enableScroll=function(t){this.disabledScroll.delete(t);if(this.disabledScroll.size===0){document.body.classList.remove(BACKDROP_NO_SCROLL)}};t.prototype.canStart=function(t){if(this.capturedId!==undefined){return false}if(this.isDisabled(t)){return false}return true};t.prototype.isCaptured=function(){return this.capturedId!==undefined};t.prototype.isScrollDisabled=function(){return this.disabledScroll.size>0};t.prototype.isDisabled=function(t){var e=this.disabledGestures.get(t);if(e&&e.size>0){return true}return false};t.prototype.newID=function(){this.gestureId++;return this.gestureId};return t}();var GestureDelegate=function(){function t(t,e,r,i,s){this.id=e;this.name=r;this.disableScroll=s;this.priority=i*1e6+e;this.ctrl=t}t.prototype.canStart=function(){if(!this.ctrl){return false}return this.ctrl.canStart(this.name)};t.prototype.start=function(){if(!this.ctrl){return false}return this.ctrl.start(this.name,this.id,this.priority)};t.prototype.capture=function(){if(!this.ctrl){return false}var t=this.ctrl.capture(this.name,this.id,this.priority);if(t&&this.disableScroll){this.ctrl.disableScroll(this.id)}return t};t.prototype.release=function(){if(this.ctrl){this.ctrl.release(this.id);if(this.disableScroll){this.ctrl.enableScroll(this.id)}}};t.prototype.destroy=function(){this.release();this.ctrl=undefined};return t}();var BlockerDelegate=function(){function t(t,e,r,i){this.id=e;this.disable=r;this.disableScroll=i;this.ctrl=t}t.prototype.block=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.disableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.disableScroll(this.id)}};t.prototype.unblock=function(){if(!this.ctrl){return}if(this.disable){for(var t=0,e=this.disable;t<e.length;t++){var r=e[t];this.ctrl.enableGesture(r,this.id)}}if(this.disableScroll){this.ctrl.enableScroll(this.id)}};t.prototype.destroy=function(){this.unblock();this.ctrl=undefined};return t}();var BACKDROP_NO_SCROLL="backdrop-no-scroll";var GESTURE_CONTROLLER=new GestureController;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk4OC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsaUJBQWlCLDRCQUE0Qiw4QkFBOEIsNEJBQTRCLHNDQUFzQyxzRkFBc0Ysc0NBQXNDLGVBQWUsS0FBSywyRUFBMkUsa0NBQWtDLHNCQUFzQiw4QkFBOEIsYUFBYSw2QkFBNkIsYUFBYSxvQ0FBb0MsdUJBQXVCLGFBQWEsMEJBQTBCLFdBQVcsdUJBQXVCLGdCQUFnQixHQUFHLFVBQVUsa0JBQWtCLFVBQVUsNENBQTRDLFFBQVEsZUFBZSxFQUFFLDBCQUEwQixZQUFZLFlBQVksY0FBYyxnQ0FBZ0MsOEJBQThCLHdCQUF3Qiw0QkFBNEIseUNBQXlDLG1DQUFtQyxrQkFBa0IsVUFBVSwrQkFBK0IsVUFBVSx3Q0FBd0MsbUNBQW1DLGtCQUFrQixjQUFjLHNDQUFzQywyQkFBMkIsaUNBQWlDLGtEQUFrRCxxQ0FBcUMsOEJBQThCLGlDQUFpQyxxREFBcUQsaUNBQWlDLGdDQUFnQyxhQUFhLHVCQUF1QixhQUFhLGFBQWEsa0NBQWtDLG9DQUFvQyx3Q0FBd0MsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsZ0JBQWdCLFlBQVksY0FBYyw2QkFBNkIsaUJBQWlCLHVCQUF1QixTQUFTLEdBQUcsK0JBQStCLHNCQUFzQixVQUFVLFlBQVkscUJBQXFCLHNCQUFzQixZQUFZLGdDQUFnQyxlQUFlLGFBQWEsc0NBQXNDLDZCQUE2QixlQUFlLGFBQWEseURBQXlELCtCQUErQixlQUFlLGFBQWEseURBQXlELDBCQUEwQixpQ0FBaUMsVUFBVSwrQkFBK0IsY0FBYywyQkFBMkIsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxxQkFBcUIsU0FBUyxHQUFHLCtCQUErQixvQkFBb0IsVUFBVSxlQUFlLHFCQUFxQixZQUFZLDZCQUE2QixlQUFlLE9BQU8saUJBQWlCLDJCQUEyQixXQUFXLEtBQUssV0FBVyxxQ0FBcUMsdUJBQXVCLG1DQUFtQywrQkFBK0IsZUFBZSxPQUFPLGlCQUFpQiwyQkFBMkIsV0FBVyxLQUFLLFdBQVcsb0NBQW9DLHVCQUF1QixrQ0FBa0MsK0JBQStCLGVBQWUscUJBQXFCLFNBQVMsR0FBRyw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9nZXN0dXJlLWNvbnRyb2xsZXItNjhjMDIzYTQuanM/NGFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xudmFyIEdlc3R1cmVDb250cm9sbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuZ2VzdHVyZUlkPTA7dGhpcy5yZXF1ZXN0ZWRTdGFydD1uZXcgTWFwO3RoaXMuZGlzYWJsZWRHZXN0dXJlcz1uZXcgTWFwO3RoaXMuZGlzYWJsZWRTY3JvbGw9bmV3IFNldH10LnByb3RvdHlwZS5jcmVhdGVHZXN0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgR2VzdHVyZURlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQubmFtZSx0LnByaW9yaXR5fHwwLCEhdC5kaXNhYmxlU2Nyb2xsKX07dC5wcm90b3R5cGUuY3JlYXRlQmxvY2tlcj1mdW5jdGlvbih0KXtpZih0PT09dm9pZCAwKXt0PXt9fXJldHVybiBuZXcgQmxvY2tlckRlbGVnYXRlKHRoaXMsdGhpcy5uZXdJRCgpLHQuZGlzYWJsZSwhIXQuZGlzYWJsZVNjcm9sbCl9O3QucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHQsZSxyKXtpZighdGhpcy5jYW5TdGFydCh0KSl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUoZSk7cmV0dXJuIGZhbHNlfXRoaXMucmVxdWVzdGVkU3RhcnQuc2V0KGUscik7cmV0dXJuIHRydWV9O3QucHJvdG90eXBlLmNhcHR1cmU9ZnVuY3Rpb24odCxlLHIpe2lmKCF0aGlzLnN0YXJ0KHQsZSxyKSl7cmV0dXJuIGZhbHNlfXZhciBpPXRoaXMucmVxdWVzdGVkU3RhcnQ7dmFyIHM9LTFlNDtpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3M9TWF0aC5tYXgocyx0KX0pKTtpZihzPT09cil7dGhpcy5jYXB0dXJlZElkPWU7aS5jbGVhcigpO3ZhciBsPW5ldyBDdXN0b21FdmVudChcImlvbkdlc3R1cmVDYXB0dXJlZFwiLHtkZXRhaWw6e2dlc3R1cmVOYW1lOnR9fSk7ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChsKTtyZXR1cm4gdHJ1ZX1pLmRlbGV0ZShlKTtyZXR1cm4gZmFsc2V9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24odCl7dGhpcy5yZXF1ZXN0ZWRTdGFydC5kZWxldGUodCk7aWYodGhpcy5jYXB0dXJlZElkPT09dCl7dGhpcy5jYXB0dXJlZElkPXVuZGVmaW5lZH19O3QucHJvdG90eXBlLmRpc2FibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyPT09dW5kZWZpbmVkKXtyPW5ldyBTZXQ7dGhpcy5kaXNhYmxlZEdlc3R1cmVzLnNldCh0LHIpfXIuYWRkKGUpfTt0LnByb3RvdHlwZS5lbmFibGVHZXN0dXJlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihyIT09dW5kZWZpbmVkKXtyLmRlbGV0ZShlKX19O3QucHJvdG90eXBlLmRpc2FibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5hZGQodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MSl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5lbmFibGVTY3JvbGw9ZnVuY3Rpb24odCl7dGhpcy5kaXNhYmxlZFNjcm9sbC5kZWxldGUodCk7aWYodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPT09MCl7ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKEJBQ0tEUk9QX05PX1NDUk9MTCl9fTt0LnByb3RvdHlwZS5jYW5TdGFydD1mdW5jdGlvbih0KXtpZih0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWQpe3JldHVybiBmYWxzZX1pZih0aGlzLmlzRGlzYWJsZWQodCkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX07dC5wcm90b3R5cGUuaXNDYXB0dXJlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhcHR1cmVkSWQhPT11bmRlZmluZWR9O3QucHJvdG90eXBlLmlzU2Nyb2xsRGlzYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplPjB9O3QucHJvdG90eXBlLmlzRGlzYWJsZWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldCh0KTtpZihlJiZlLnNpemU+MCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTt0LnByb3RvdHlwZS5uZXdJRD1mdW5jdGlvbigpe3RoaXMuZ2VzdHVyZUlkKys7cmV0dXJuIHRoaXMuZ2VzdHVyZUlkfTtyZXR1cm4gdH0oKTt2YXIgR2VzdHVyZURlbGVnYXRlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpLHMpe3RoaXMuaWQ9ZTt0aGlzLm5hbWU9cjt0aGlzLmRpc2FibGVTY3JvbGw9czt0aGlzLnByaW9yaXR5PWkqMWU2K2U7dGhpcy5jdHJsPXR9dC5wcm90b3R5cGUuY2FuU3RhcnQ9ZnVuY3Rpb24oKXtpZighdGhpcy5jdHJsKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRoaXMuY3RybC5jYW5TdGFydCh0aGlzLm5hbWUpfTt0LnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe2lmKCF0aGlzLmN0cmwpe3JldHVybiBmYWxzZX1yZXR1cm4gdGhpcy5jdHJsLnN0YXJ0KHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpfTt0LnByb3RvdHlwZS5jYXB0dXJlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJuIGZhbHNlfXZhciB0PXRoaXMuY3RybC5jYXB0dXJlKHRoaXMubmFtZSx0aGlzLmlkLHRoaXMucHJpb3JpdHkpO2lmKHQmJnRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9cmV0dXJuIHR9O3QucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24oKXtpZih0aGlzLmN0cmwpe3RoaXMuY3RybC5yZWxlYXNlKHRoaXMuaWQpO2lmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmVuYWJsZVNjcm9sbCh0aGlzLmlkKX19fTt0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5yZWxlYXNlKCk7dGhpcy5jdHJsPXVuZGVmaW5lZH07cmV0dXJuIHR9KCk7dmFyIEJsb2NrZXJEZWxlZ2F0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsaSl7dGhpcy5pZD1lO3RoaXMuZGlzYWJsZT1yO3RoaXMuZGlzYWJsZVNjcm9sbD1pO3RoaXMuY3RybD10fXQucHJvdG90eXBlLmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmRpc2FibGVHZXN0dXJlKHIsdGhpcy5pZCl9fWlmKHRoaXMuZGlzYWJsZVNjcm9sbCl7dGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCl9fTt0LnByb3RvdHlwZS51bmJsb2NrPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY3RybCl7cmV0dXJufWlmKHRoaXMuZGlzYWJsZSl7Zm9yKHZhciB0PTAsZT10aGlzLmRpc2FibGU7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07dGhpcy5jdHJsLmVuYWJsZUdlc3R1cmUocix0aGlzLmlkKX19aWYodGhpcy5kaXNhYmxlU2Nyb2xsKXt0aGlzLmN0cmwuZW5hYmxlU2Nyb2xsKHRoaXMuaWQpfX07dC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5ibG9jaygpO3RoaXMuY3RybD11bmRlZmluZWR9O3JldHVybiB0fSgpO3ZhciBCQUNLRFJPUF9OT19TQ1JPTEw9XCJiYWNrZHJvcC1uby1zY3JvbGxcIjt2YXIgR0VTVFVSRV9DT05UUk9MTEVSPW5ldyBHZXN0dXJlQ29udHJvbGxlcjtleHBvcnR7R0VTVFVSRV9DT05UUk9MTEVSIGFzIEd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4988\n')},7292:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MENU_BACK_BUTTON_PRIORITY": () => (/* binding */ MENU_BACK_BUTTON_PRIORITY),\n/* harmony export */   "OVERLAY_BACK_BUTTON_PRIORITY": () => (/* binding */ OVERLAY_BACK_BUTTON_PRIORITY),\n/* harmony export */   "blockHardwareBackButton": () => (/* binding */ blockHardwareBackButton),\n/* harmony export */   "startHardwareBackButton": () => (/* binding */ startHardwareBackButton)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var blockHardwareBackButton=function(){document.addEventListener("backbutton",(function(){}))};var startHardwareBackButton=function(){var r=document;var t=false;r.addEventListener("backbutton",(function(){if(t){return}var n=0;var e=[];var a=new CustomEvent("ionBackButton",{bubbles:false,detail:{register:function(r,t){e.push({priority:r,handler:t,id:n++})}}});r.dispatchEvent(a);var i=function(r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(e){switch(e.label){case 0:e.trys.push([0,3,,4]);if(!(r&&r.handler))return[3,2];t=r.handler(o);if(!(t!=null))return[3,2];return[4,t];case 1:e.sent();e.label=2;case 2:return[3,4];case 3:n=e.sent();console.error(n);return[3,4];case 4:return[2]}}))}))};var o=function(){if(e.length>0){var r={priority:Number.MIN_SAFE_INTEGER,handler:function(){return undefined},id:-1};e.forEach((function(t){if(t.priority>=r.priority){r=t}}));t=true;e=e.filter((function(t){return t.id!==r.id}));i(r).then((function(){return t=false}))}};o()}))};var OVERLAY_BACK_BUTTON_PRIORITY=100;var MENU_BACK_BUTTON_PRIORITY=99;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0EsMENBQTBDLG9EQUFvRCxJQUFJLHVDQUF1QyxlQUFlLFlBQVksNENBQTRDLE1BQU0sT0FBTyxRQUFRLFNBQVMsdUNBQXVDLHNCQUFzQix1QkFBdUIsUUFBUSw0QkFBNEIsSUFBSSxFQUFFLG1CQUFtQixrQkFBa0IsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0IsNkJBQTZCLCtCQUErQixlQUFlLDBCQUEwQixZQUFZLGdCQUFnQixVQUFVLG1CQUFtQixrQkFBa0IsaUJBQWlCLFlBQVksa0JBQWtCLEdBQUcsSUFBSSxpQkFBaUIsZUFBZSxPQUFPLG9EQUFvRCxpQkFBaUIsUUFBUSx1QkFBdUIsMkJBQTJCLEtBQUssR0FBRyxPQUFPLHdCQUF3QixtQkFBbUIsR0FBRyxzQkFBc0IsZUFBZSxLQUFLLElBQUksSUFBSSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9oYXJkd2FyZS1iYWNrLWJ1dHRvbi1hY2U2YTcxYi5qcz85NWRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydHtfX2F3YWl0ZXIsX19nZW5lcmF0b3J9ZnJvbVwidHNsaWJcIjtcbi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovdmFyIGJsb2NrSGFyZHdhcmVCYWNrQnV0dG9uPWZ1bmN0aW9uKCl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJhY2tidXR0b25cIiwoZnVuY3Rpb24oKXt9KSl9O3ZhciBzdGFydEhhcmR3YXJlQmFja0J1dHRvbj1mdW5jdGlvbigpe3ZhciByPWRvY3VtZW50O3ZhciB0PWZhbHNlO3IuYWRkRXZlbnRMaXN0ZW5lcihcImJhY2tidXR0b25cIiwoZnVuY3Rpb24oKXtpZih0KXtyZXR1cm59dmFyIG49MDt2YXIgZT1bXTt2YXIgYT1uZXcgQ3VzdG9tRXZlbnQoXCJpb25CYWNrQnV0dG9uXCIse2J1YmJsZXM6ZmFsc2UsZGV0YWlsOntyZWdpc3RlcjpmdW5jdGlvbihyLHQpe2UucHVzaCh7cHJpb3JpdHk6cixoYW5kbGVyOnQsaWQ6bisrfSl9fX0pO3IuZGlzcGF0Y2hFdmVudChhKTt2YXIgaT1mdW5jdGlvbihyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6ZS50cnlzLnB1c2goWzAsMywsNF0pO2lmKCEociYmci5oYW5kbGVyKSlyZXR1cm5bMywyXTt0PXIuaGFuZGxlcihvKTtpZighKHQhPW51bGwpKXJldHVyblszLDJdO3JldHVybls0LHRdO2Nhc2UgMTplLnNlbnQoKTtlLmxhYmVsPTI7Y2FzZSAyOnJldHVyblszLDRdO2Nhc2UgMzpuPWUuc2VudCgpO2NvbnNvbGUuZXJyb3Iobik7cmV0dXJuWzMsNF07Y2FzZSA0OnJldHVyblsyXX19KSl9KSl9O3ZhciBvPWZ1bmN0aW9uKCl7aWYoZS5sZW5ndGg+MCl7dmFyIHI9e3ByaW9yaXR5Ok51bWJlci5NSU5fU0FGRV9JTlRFR0VSLGhhbmRsZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdW5kZWZpbmVkfSxpZDotMX07ZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZih0LnByaW9yaXR5Pj1yLnByaW9yaXR5KXtyPXR9fSkpO3Q9dHJ1ZTtlPWUuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZCE9PXIuaWR9KSk7aShyKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0PWZhbHNlfSkpfX07bygpfSkpfTt2YXIgT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWT0xMDA7dmFyIE1FTlVfQkFDS19CVVRUT05fUFJJT1JJVFk9OTk7ZXhwb3J0e01FTlVfQkFDS19CVVRUT05fUFJJT1JJVFksT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWSxibG9ja0hhcmR3YXJlQmFja0J1dHRvbixzdGFydEhhcmR3YXJlQmFja0J1dHRvbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7292\n')},7504:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ addEventListener),\n/* harmony export */   "b": () => (/* binding */ removeEventListener),\n/* harmony export */   "c": () => (/* binding */ componentOnReady),\n/* harmony export */   "d": () => (/* binding */ getAriaLabel),\n/* harmony export */   "e": () => (/* binding */ renderHiddenInput),\n/* harmony export */   "f": () => (/* binding */ focusElement),\n/* harmony export */   "g": () => (/* binding */ getElementRoot),\n/* harmony export */   "h": () => (/* binding */ debounceEvent),\n/* harmony export */   "i": () => (/* binding */ inheritAttributes),\n/* harmony export */   "j": () => (/* binding */ findItemLabel),\n/* harmony export */   "k": () => (/* binding */ clamp),\n/* harmony export */   "l": () => (/* binding */ hasShadowDom),\n/* harmony export */   "m": () => (/* binding */ assert),\n/* harmony export */   "n": () => (/* binding */ isEndSide),\n/* harmony export */   "o": () => (/* binding */ debounce),\n/* harmony export */   "p": () => (/* binding */ pointerCoord),\n/* harmony export */   "q": () => (/* binding */ now),\n/* harmony export */   "r": () => (/* binding */ raf),\n/* harmony export */   "s": () => (/* binding */ shallowEqualStringMap),\n/* harmony export */   "t": () => (/* binding */ transitionEndAsync)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var transitionEndAsync=function(e,n){if(n===void 0){n=0}return new Promise((function(t){transitionEnd(e,n,t)}))};var transitionEnd=function(e,n,t){if(n===void 0){n=0}var r;var i;var a={passive:true};var o=500;var u=function(){if(r){r()}};var s=function(n){if(n===undefined||e===n.target){u();t(n)}};if(e){e.addEventListener("webkitTransitionEnd",s,a);e.addEventListener("transitionend",s,a);i=setTimeout(s,n+o);r=function(){if(i){clearTimeout(i);i=undefined}e.removeEventListener("webkitTransitionEnd",s,a);e.removeEventListener("transitionend",s,a)}}return u};var componentOnReady=function(e,n){if(e.componentOnReady){e.componentOnReady().then((function(e){return n(e)}))}else{raf((function(){return n(e)}))}};var inheritAttributes=function(e,n){if(n===void 0){n=[]}var t={};n.forEach((function(n){if(e.hasAttribute(n)){var r=e.getAttribute(n);if(r!==null){t[n]=e.getAttribute(n)}e.removeAttribute(n)}}));return t};var addEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_ael");if(o){return o(e,n,t,r)}else if(a._ael){return a._ael(e,n,t,r)}}}return e.addEventListener(n,t,r)};var removeEventListener=function(e,n,t,r){if(typeof window!=="undefined"){var i=window;var a=i&&i.Ionic&&i.Ionic.config;if(a){var o=a.get("_rel");if(o){return o(e,n,t,r)}else if(a._rel){return a._rel(e,n,t,r)}}}return e.removeEventListener(n,t,r)};var getElementRoot=function(e,n){if(n===void 0){n=e}return e.shadowRoot||n};var raf=function(e){if(typeof __zone_symbol__requestAnimationFrame==="function"){return __zone_symbol__requestAnimationFrame(e)}if(typeof requestAnimationFrame==="function"){return requestAnimationFrame(e)}return setTimeout(e)};var hasShadowDom=function(e){return!!e.shadowRoot&&!!e.attachShadow};var findItemLabel=function(e){var n=e.closest("ion-item");if(n){return n.querySelector("ion-label")}return null};var focusElement=function(e){e.focus();if(e.classList.contains("ion-focusable")){var n=e.closest("ion-app");if(n){n.setFocus([e])}}};var getAriaLabel=function(e,n){var t;var r=e.getAttribute("aria-labelledby");var i=e.id;var a=r!==null&&r.trim()!==""?r:n+"-lbl";var o=r!==null&&r.trim()!==""?document.getElementById(r):findItemLabel(e);if(o){if(r===null){o.id=a}t=o.textContent;o.setAttribute("aria-hidden","true")}else if(i.trim()!==""){o=document.querySelector(\'label[for="\'.concat(i,\'"]\'));if(o){if(o.id!==""){a=o.id}else{o.id=a="".concat(i,"-lbl")}t=o.textContent}}return{label:o,labelId:a,labelText:t}};var renderHiddenInput=function(e,n,t,r,i){if(e||hasShadowDom(n)){var a=n.querySelector("input.aux-input");if(!a){a=n.ownerDocument.createElement("input");a.type="hidden";a.classList.add("aux-input");n.appendChild(a)}a.disabled=i;a.name=t;a.value=r||""}};var clamp=function(e,n,t){return Math.max(e,Math.min(n,t))};var assert=function(e,n){if(!e){var t="ASSERT: "+n;console.error(t);debugger;throw new Error(t)}};var now=function(e){return e.timeStamp||Date.now()};var pointerCoord=function(e){if(e){var n=e.changedTouches;if(n&&n.length>0){var t=n[0];return{x:t.clientX,y:t.clientY}}if(e.pageX!==undefined){return{x:e.pageX,y:e.pageY}}}return{x:0,y:0}};var isEndSide=function(e){var n=document.dir==="rtl";switch(e){case"start":return n;case"end":return!n;default:throw new Error(\'"\'.concat(e,\'" is not a valid value for [side]. Use "start" or "end" instead.\'))}};var debounceEvent=function(e,n){var t=e._original||e;return{_original:e,emit:debounce(t.emit.bind(t),n)}};var debounce=function(e,n){if(n===void 0){n=0}var t;return function(){var r=[];for(var i=0;i<arguments.length;i++){r[i]=arguments[i]}clearTimeout(t);t=setTimeout.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e,n],r,false))}};var shallowEqualStringMap=function(e,n){e!==null&&e!==void 0?e:e={};n!==null&&n!==void 0?n:n={};if(e===n){return true}var t=Object.keys(e);if(t.length!==Object.keys(n).length){return false}for(var r=0,i=t;r<i.length;r++){var a=i[r];if(!(a in n)){return false}if(e[a]!==n[a]){return false}}return true};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUwNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxlQUFlLElBQUksZ0NBQWdDLHFCQUFxQixJQUFJLGtDQUFrQyxlQUFlLElBQUksTUFBTSxNQUFNLE9BQU8sY0FBYyxVQUFVLGlCQUFpQixNQUFNLE1BQU0sa0JBQWtCLGdDQUFnQyxJQUFJLE9BQU8sTUFBTSw4Q0FBOEMsd0NBQXdDLG9CQUFvQixhQUFhLE1BQU0sZ0JBQWdCLFlBQVksaURBQWlELDRDQUE0QyxVQUFVLG1DQUFtQyx1QkFBdUIsdUNBQXVDLFlBQVksR0FBRyxLQUFLLGdCQUFnQixZQUFZLEtBQUssb0NBQW9DLGVBQWUsS0FBSyxTQUFTLHVCQUF1QixzQkFBc0Isd0JBQXdCLGFBQWEsdUJBQXVCLHNCQUFzQixHQUFHLFVBQVUsdUNBQXVDLGdDQUFnQyxhQUFhLGlDQUFpQyxNQUFNLG9CQUFvQixNQUFNLGtCQUFrQixnQkFBZ0IseUJBQXlCLGtDQUFrQywwQ0FBMEMsZ0NBQWdDLGFBQWEsaUNBQWlDLE1BQU0sb0JBQW9CLE1BQU0sa0JBQWtCLGdCQUFnQix5QkFBeUIscUNBQXFDLGlDQUFpQyxlQUFlLElBQUksd0JBQXdCLG9CQUFvQiw2REFBNkQsK0NBQStDLDhDQUE4QyxnQ0FBZ0Msc0JBQXNCLDZCQUE2Qix3Q0FBd0MsOEJBQThCLDRCQUE0QixNQUFNLG9DQUFvQyxhQUFhLDZCQUE2QixVQUFVLDBDQUEwQywyQkFBMkIsTUFBTSxtQkFBbUIsK0JBQStCLE1BQU0sd0NBQXdDLFdBQVcseUNBQXlDLDBFQUEwRSxNQUFNLGFBQWEsT0FBTyxnQkFBZ0IscUNBQXFDLHVCQUF1Qix1REFBdUQsTUFBTSxjQUFjLE9BQU8sS0FBSywyQkFBMkIsaUJBQWlCLE9BQU8sZ0NBQWdDLDBDQUEwQyx1QkFBdUIseUNBQXlDLE9BQU8seUNBQXlDLGdCQUFnQiw2QkFBNkIsaUJBQWlCLGFBQWEsU0FBUyxnQkFBZ0IsMEJBQTBCLGtDQUFrQyx5QkFBeUIsT0FBTyxtQkFBbUIsaUJBQWlCLFNBQVMscUJBQXFCLG9CQUFvQixnQ0FBZ0MsNkJBQTZCLE1BQU0sdUJBQXVCLGtCQUFrQixXQUFXLE9BQU8seUJBQXlCLHdCQUF3QixPQUFPLHNCQUFzQixPQUFPLFVBQVUsMEJBQTBCLDJCQUEyQixVQUFVLHFCQUFxQixtQkFBbUIsNEdBQTRHLGdDQUFnQyxxQkFBcUIsT0FBTyw4Q0FBOEMsMkJBQTJCLGVBQWUsSUFBSSxNQUFNLGtCQUFrQixTQUFTLFlBQVksbUJBQW1CLEtBQUssa0JBQWtCLGdCQUFnQiwwQkFBMEIsOERBQWEsbUJBQW1CLHdDQUF3Qyw0QkFBNEIsNEJBQTRCLFVBQVUsWUFBWSxxQkFBcUIscUNBQXFDLGFBQWEsZ0JBQWdCLFdBQVcsS0FBSyxXQUFXLGNBQWMsYUFBYSxnQkFBZ0IsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2hlbHBlcnMtNmUxZTViNjUuanM/YThlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19zcHJlYWRBcnJheX1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi92YXIgdHJhbnNpdGlvbkVuZEFzeW5jPWZ1bmN0aW9uKGUsbil7aWYobj09PXZvaWQgMCl7bj0wfXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dHJhbnNpdGlvbkVuZChlLG4sdCl9KSl9O3ZhciB0cmFuc2l0aW9uRW5kPWZ1bmN0aW9uKGUsbix0KXtpZihuPT09dm9pZCAwKXtuPTB9dmFyIHI7dmFyIGk7dmFyIGE9e3Bhc3NpdmU6dHJ1ZX07dmFyIG89NTAwO3ZhciB1PWZ1bmN0aW9uKCl7aWYocil7cigpfX07dmFyIHM9ZnVuY3Rpb24obil7aWYobj09PXVuZGVmaW5lZHx8ZT09PW4udGFyZ2V0KXt1KCk7dChuKX19O2lmKGUpe2UuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIixzLGEpO2UuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIixzLGEpO2k9c2V0VGltZW91dChzLG4rbyk7cj1mdW5jdGlvbigpe2lmKGkpe2NsZWFyVGltZW91dChpKTtpPXVuZGVmaW5lZH1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIscyxhKTtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIscyxhKX19cmV0dXJuIHV9O3ZhciBjb21wb25lbnRPblJlYWR5PWZ1bmN0aW9uKGUsbil7aWYoZS5jb21wb25lbnRPblJlYWR5KXtlLmNvbXBvbmVudE9uUmVhZHkoKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gbihlKX0pKX1lbHNle3JhZigoZnVuY3Rpb24oKXtyZXR1cm4gbihlKX0pKX19O3ZhciBpbmhlcml0QXR0cmlidXRlcz1mdW5jdGlvbihlLG4pe2lmKG49PT12b2lkIDApe249W119dmFyIHQ9e307bi5mb3JFYWNoKChmdW5jdGlvbihuKXtpZihlLmhhc0F0dHJpYnV0ZShuKSl7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUobik7aWYociE9PW51bGwpe3Rbbl09ZS5nZXRBdHRyaWJ1dGUobil9ZS5yZW1vdmVBdHRyaWJ1dGUobil9fSkpO3JldHVybiB0fTt2YXIgYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLG4sdCxyKXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7dmFyIGk9d2luZG93O3ZhciBhPWkmJmkuSW9uaWMmJmkuSW9uaWMuY29uZmlnO2lmKGEpe3ZhciBvPWEuZ2V0KFwiX2FlbFwiKTtpZihvKXtyZXR1cm4gbyhlLG4sdCxyKX1lbHNlIGlmKGEuX2FlbCl7cmV0dXJuIGEuX2FlbChlLG4sdCxyKX19fXJldHVybiBlLmFkZEV2ZW50TGlzdGVuZXIobix0LHIpfTt2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLG4sdCxyKXtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7dmFyIGk9d2luZG93O3ZhciBhPWkmJmkuSW9uaWMmJmkuSW9uaWMuY29uZmlnO2lmKGEpe3ZhciBvPWEuZ2V0KFwiX3JlbFwiKTtpZihvKXtyZXR1cm4gbyhlLG4sdCxyKX1lbHNlIGlmKGEuX3JlbCl7cmV0dXJuIGEuX3JlbChlLG4sdCxyKX19fXJldHVybiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIobix0LHIpfTt2YXIgZ2V0RWxlbWVudFJvb3Q9ZnVuY3Rpb24oZSxuKXtpZihuPT09dm9pZCAwKXtuPWV9cmV0dXJuIGUuc2hhZG93Um9vdHx8bn07dmFyIHJhZj1mdW5jdGlvbihlKXtpZih0eXBlb2YgX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gX196b25lX3N5bWJvbF9fcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpfWlmKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU9PT1cImZ1bmN0aW9uXCIpe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSl9cmV0dXJuIHNldFRpbWVvdXQoZSl9O3ZhciBoYXNTaGFkb3dEb209ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnNoYWRvd1Jvb3QmJiEhZS5hdHRhY2hTaGFkb3d9O3ZhciBmaW5kSXRlbUxhYmVsPWZ1bmN0aW9uKGUpe3ZhciBuPWUuY2xvc2VzdChcImlvbi1pdGVtXCIpO2lmKG4pe3JldHVybiBuLnF1ZXJ5U2VsZWN0b3IoXCJpb24tbGFiZWxcIil9cmV0dXJuIG51bGx9O3ZhciBmb2N1c0VsZW1lbnQ9ZnVuY3Rpb24oZSl7ZS5mb2N1cygpO2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaW9uLWZvY3VzYWJsZVwiKSl7dmFyIG49ZS5jbG9zZXN0KFwiaW9uLWFwcFwiKTtpZihuKXtuLnNldEZvY3VzKFtlXSl9fX07dmFyIGdldEFyaWFMYWJlbD1mdW5jdGlvbihlLG4pe3ZhciB0O3ZhciByPWUuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIpO3ZhciBpPWUuaWQ7dmFyIGE9ciE9PW51bGwmJnIudHJpbSgpIT09XCJcIj9yOm4rXCItbGJsXCI7dmFyIG89ciE9PW51bGwmJnIudHJpbSgpIT09XCJcIj9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChyKTpmaW5kSXRlbUxhYmVsKGUpO2lmKG8pe2lmKHI9PT1udWxsKXtvLmlkPWF9dD1vLnRleHRDb250ZW50O28uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIil9ZWxzZSBpZihpLnRyaW0oKSE9PVwiXCIpe289ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPVwiJy5jb25jYXQoaSwnXCJdJykpO2lmKG8pe2lmKG8uaWQhPT1cIlwiKXthPW8uaWR9ZWxzZXtvLmlkPWE9XCJcIi5jb25jYXQoaSxcIi1sYmxcIil9dD1vLnRleHRDb250ZW50fX1yZXR1cm57bGFiZWw6byxsYWJlbElkOmEsbGFiZWxUZXh0OnR9fTt2YXIgcmVuZGVySGlkZGVuSW5wdXQ9ZnVuY3Rpb24oZSxuLHQscixpKXtpZihlfHxoYXNTaGFkb3dEb20obikpe3ZhciBhPW4ucXVlcnlTZWxlY3RvcihcImlucHV0LmF1eC1pbnB1dFwiKTtpZighYSl7YT1uLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2EudHlwZT1cImhpZGRlblwiO2EuY2xhc3NMaXN0LmFkZChcImF1eC1pbnB1dFwiKTtuLmFwcGVuZENoaWxkKGEpfWEuZGlzYWJsZWQ9aTthLm5hbWU9dDthLnZhbHVlPXJ8fFwiXCJ9fTt2YXIgY2xhbXA9ZnVuY3Rpb24oZSxuLHQpe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKG4sdCkpfTt2YXIgYXNzZXJ0PWZ1bmN0aW9uKGUsbil7aWYoIWUpe3ZhciB0PVwiQVNTRVJUOiBcIituO2NvbnNvbGUuZXJyb3IodCk7ZGVidWdnZXI7dGhyb3cgbmV3IEVycm9yKHQpfX07dmFyIG5vdz1mdW5jdGlvbihlKXtyZXR1cm4gZS50aW1lU3RhbXB8fERhdGUubm93KCl9O3ZhciBwb2ludGVyQ29vcmQ9ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIG49ZS5jaGFuZ2VkVG91Y2hlcztpZihuJiZuLmxlbmd0aD4wKXt2YXIgdD1uWzBdO3JldHVybnt4OnQuY2xpZW50WCx5OnQuY2xpZW50WX19aWYoZS5wYWdlWCE9PXVuZGVmaW5lZCl7cmV0dXJue3g6ZS5wYWdlWCx5OmUucGFnZVl9fX1yZXR1cm57eDowLHk6MH19O3ZhciBpc0VuZFNpZGU9ZnVuY3Rpb24oZSl7dmFyIG49ZG9jdW1lbnQuZGlyPT09XCJydGxcIjtzd2l0Y2goZSl7Y2FzZVwic3RhcnRcIjpyZXR1cm4gbjtjYXNlXCJlbmRcIjpyZXR1cm4hbjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcignXCInLmNvbmNhdChlLCdcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgW3NpZGVdLiBVc2UgXCJzdGFydFwiIG9yIFwiZW5kXCIgaW5zdGVhZC4nKSl9fTt2YXIgZGVib3VuY2VFdmVudD1mdW5jdGlvbihlLG4pe3ZhciB0PWUuX29yaWdpbmFsfHxlO3JldHVybntfb3JpZ2luYWw6ZSxlbWl0OmRlYm91bmNlKHQuZW1pdC5iaW5kKHQpLG4pfX07dmFyIGRlYm91bmNlPWZ1bmN0aW9uKGUsbil7aWYobj09PXZvaWQgMCl7bj0wfXZhciB0O3JldHVybiBmdW5jdGlvbigpe3ZhciByPVtdO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe3JbaV09YXJndW1lbnRzW2ldfWNsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQuYXBwbHkodm9pZCAwLF9fc3ByZWFkQXJyYXkoW2Usbl0scixmYWxzZSkpfX07dmFyIHNoYWxsb3dFcXVhbFN0cmluZ01hcD1mdW5jdGlvbihlLG4pe2UhPT1udWxsJiZlIT09dm9pZCAwP2U6ZT17fTtuIT09bnVsbCYmbiE9PXZvaWQgMD9uOm49e307aWYoZT09PW4pe3JldHVybiB0cnVlfXZhciB0PU9iamVjdC5rZXlzKGUpO2lmKHQubGVuZ3RoIT09T2JqZWN0LmtleXMobikubGVuZ3RoKXtyZXR1cm4gZmFsc2V9Zm9yKHZhciByPTAsaT10O3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pW3JdO2lmKCEoYSBpbiBuKSl7cmV0dXJuIGZhbHNlfWlmKGVbYV0hPT1uW2FdKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfTtleHBvcnR7YWRkRXZlbnRMaXN0ZW5lciBhcyBhLHJlbW92ZUV2ZW50TGlzdGVuZXIgYXMgYixjb21wb25lbnRPblJlYWR5IGFzIGMsZ2V0QXJpYUxhYmVsIGFzIGQscmVuZGVySGlkZGVuSW5wdXQgYXMgZSxmb2N1c0VsZW1lbnQgYXMgZixnZXRFbGVtZW50Um9vdCBhcyBnLGRlYm91bmNlRXZlbnQgYXMgaCxpbmhlcml0QXR0cmlidXRlcyBhcyBpLGZpbmRJdGVtTGFiZWwgYXMgaixjbGFtcCBhcyBrLGhhc1NoYWRvd0RvbSBhcyBsLGFzc2VydCBhcyBtLGlzRW5kU2lkZSBhcyBuLGRlYm91bmNlIGFzIG8scG9pbnRlckNvb3JkIGFzIHAsbm93IGFzIHEscmFmIGFzIHIsc2hhbGxvd0VxdWFsU3RyaW5nTWFwIGFzIHMsdHJhbnNpdGlvbkVuZEFzeW5jIGFzIHR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7504\n')},3876:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "GESTURE_CONTROLLER": () => (/* reexport safe */ _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   "createGesture": () => (/* binding */ createGesture)\n/* harmony export */ });\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4988);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar addEventListener=function(e,r,t,a){var n=supportsPassive(e)?{capture:!!a.capture,passive:!!a.passive}:!!a.capture;var i;var u;if(e["__zone_symbol__addEventListener"]){i="__zone_symbol__addEventListener";u="__zone_symbol__removeEventListener"}else{i="addEventListener";u="removeEventListener"}e[i](r,t,n);return function(){e[u](r,t,n)}};var supportsPassive=function(e){if(_sPassive===undefined){try{var r=Object.defineProperty({},"passive",{get:function(){_sPassive=true}});e.addEventListener("optsTest",(function(){return}),r)}catch(e){_sPassive=false}}return!!_sPassive};var _sPassive;var MOUSE_WAIT=2e3;var createPointerEvents=function(e,r,t,a,n){var i;var u;var s;var v;var f;var o;var c;var l=0;var d=function(a){l=Date.now()+MOUSE_WAIT;if(!r(a)){return}if(!u&&t){u=addEventListener(e,"touchmove",t,n)}if(!s){s=addEventListener(a.target,"touchend",p,n)}if(!v){v=addEventListener(a.target,"touchcancel",p,n)}};var m=function(a){if(l>Date.now()){return}if(!r(a)){return}if(!o&&t){o=addEventListener(getDocument(e),"mousemove",t,n)}if(!c){c=addEventListener(getDocument(e),"mouseup",E,n)}};var p=function(e){_();if(a){a(e)}};var E=function(e){g();if(a){a(e)}};var _=function(){if(u){u()}if(s){s()}if(v){v()}u=s=v=undefined};var g=function(){if(o){o()}if(c){c()}o=c=undefined};var y=function(){_();g()};var X=function(r){if(r===void 0){r=true}if(!r){if(i){i()}if(f){f()}i=f=undefined;y()}else{if(!i){i=addEventListener(e,"touchstart",d,n)}if(!f){f=addEventListener(e,"mousedown",m,n)}}};var Y=function(){X(false);a=t=r=undefined};return{enable:X,stop:y,destroy:Y}};var getDocument=function(e){return e instanceof Document?e:e.ownerDocument};var createPanRecognizer=function(e,r,t){var a=t*(Math.PI/180);var n=e==="x";var i=Math.cos(a);var u=r*r;var s=0;var v=0;var f=false;var o=0;return{start:function(e,r){s=e;v=r;o=0;f=true},detect:function(e,r){if(!f){return false}var t=e-s;var a=r-v;var c=t*t+a*a;if(c<u){return false}var l=Math.sqrt(c);var d=(n?t:a)/l;if(d>i){o=1}else if(d<-i){o=-1}else{o=0}f=false;return true},isGesture:function(){return o!==0},getDirection:function(){return o}}};var createGesture=function(e){var r=false;var t=false;var a=true;var n=false;var i=Object.assign({disableScroll:false,direction:"x",gesturePriority:0,passive:true,maxAngle:40,threshold:10},e);var u=i.canStart;var s=i.onWillStart;var v=i.onStart;var f=i.onEnd;var o=i.notCaptured;var c=i.onMove;var l=i.threshold;var d=i.passive;var m=i.blurOnStart;var p={type:"pan",startX:0,startY:0,startTime:0,currentX:0,currentY:0,velocityX:0,velocityY:0,deltaX:0,deltaY:0,currentTime:0,event:undefined,data:undefined};var E=createPanRecognizer(i.direction,i.threshold,i.maxAngle);var _=_gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_0__.G.createGesture({name:e.gestureName,priority:e.gesturePriority,disableScroll:e.disableScroll});var g=function(e){var r=now(e);if(t||!a){return false}updateDetail(e,p);p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime=r;p.velocityX=p.velocityY=p.deltaX=p.deltaY=0;p.event=e;if(u&&u(p)===false){return false}_.release();if(!_.start()){return false}t=true;if(l===0){return Y()}E.start(p.startX,p.startY);return true};var y=function(e){if(r){if(!n&&a){n=true;calcGestureData(p,e);requestAnimationFrame(X)}return}calcGestureData(p,e);if(E.detect(p.currentX,p.currentY)){if(!E.isGesture()||!Y()){b()}}};var X=function(){if(!r){return}n=false;if(c){c(p)}};var Y=function(){if(_&&!_.capture()){return false}r=true;a=false;p.startX=p.currentX;p.startY=p.currentY;p.startTime=p.currentTime;if(s){s(p).then(h)}else{h()}return true};var L=function(){if(typeof document!=="undefined"){var e=document.activeElement;if(e!==null&&e.blur){e.blur()}}};var h=function(){if(m){L()}if(v){v(p)}a=true};var T=function(){r=false;t=false;n=false;a=true;_.release()};var D=function(e){var t=r;var n=a;T();if(!n){return}calcGestureData(p,e);if(t){if(f){f(p)}return}if(o){o(p)}};var P=createPointerEvents(i.el,g,y,D,{capture:false,passive:d});var b=function(){T();P.stop();if(o){o(p)}};return{enable:function(e){if(e===void 0){e=true}if(!e){if(r){D(undefined)}T()}P.enable(e)},destroy:function(){_.destroy();P.destroy()}}};var calcGestureData=function(e,r){if(!r){return}var t=e.currentX;var a=e.currentY;var n=e.currentTime;updateDetail(r,e);var i=e.currentX;var u=e.currentY;var s=e.currentTime=now(r);var v=s-n;if(v>0&&v<100){var f=(i-t)/v;var o=(u-a)/v;e.velocityX=f*.7+e.velocityX*.3;e.velocityY=o*.7+e.velocityY*.3}e.deltaX=i-e.startX;e.deltaY=u-e.startY;e.event=r};var updateDetail=function(e,r){var t=0;var a=0;if(e){var n=e.changedTouches;if(n&&n.length>0){var i=n[0];t=i.clientX;a=i.clientY}else if(e.pageX!==undefined){t=e.pageX;a=e.pageY}}r.currentX=t;r.currentY=a};var now=function(e){return e.timeStamp||Date.now()};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtNDFiZjQxZjIuanM/YzhiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0e0cgYXMgR0VTVFVSRV9DT05UUk9MTEVSfWZyb21cIi4vZ2VzdHVyZS1jb250cm9sbGVyLTY4YzAyM2E0LmpzXCI7ZXhwb3J0e0cgYXMgR0VTVFVSRV9DT05UUk9MTEVSfWZyb21cIi4vZ2VzdHVyZS1jb250cm9sbGVyLTY4YzAyM2E0LmpzXCI7dmFyIGFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZSxyLHQsYSl7dmFyIG49c3VwcG9ydHNQYXNzaXZlKGUpP3tjYXB0dXJlOiEhYS5jYXB0dXJlLHBhc3NpdmU6ISFhLnBhc3NpdmV9OiEhYS5jYXB0dXJlO3ZhciBpO3ZhciB1O2lmKGVbXCJfX3pvbmVfc3ltYm9sX19hZGRFdmVudExpc3RlbmVyXCJdKXtpPVwiX196b25lX3N5bWJvbF9fYWRkRXZlbnRMaXN0ZW5lclwiO3U9XCJfX3pvbmVfc3ltYm9sX19yZW1vdmVFdmVudExpc3RlbmVyXCJ9ZWxzZXtpPVwiYWRkRXZlbnRMaXN0ZW5lclwiO3U9XCJyZW1vdmVFdmVudExpc3RlbmVyXCJ9ZVtpXShyLHQsbik7cmV0dXJuIGZ1bmN0aW9uKCl7ZVt1XShyLHQsbil9fTt2YXIgc3VwcG9ydHNQYXNzaXZlPWZ1bmN0aW9uKGUpe2lmKF9zUGFzc2l2ZT09PXVuZGVmaW5lZCl7dHJ5e3ZhciByPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7X3NQYXNzaXZlPXRydWV9fSk7ZS5hZGRFdmVudExpc3RlbmVyKFwib3B0c1Rlc3RcIiwoZnVuY3Rpb24oKXtyZXR1cm59KSxyKX1jYXRjaChlKXtfc1Bhc3NpdmU9ZmFsc2V9fXJldHVybiEhX3NQYXNzaXZlfTt2YXIgX3NQYXNzaXZlO3ZhciBNT1VTRV9XQUlUPTJlMzt2YXIgY3JlYXRlUG9pbnRlckV2ZW50cz1mdW5jdGlvbihlLHIsdCxhLG4pe3ZhciBpO3ZhciB1O3ZhciBzO3ZhciB2O3ZhciBmO3ZhciBvO3ZhciBjO3ZhciBsPTA7dmFyIGQ9ZnVuY3Rpb24oYSl7bD1EYXRlLm5vdygpK01PVVNFX1dBSVQ7aWYoIXIoYSkpe3JldHVybn1pZighdSYmdCl7dT1hZGRFdmVudExpc3RlbmVyKGUsXCJ0b3VjaG1vdmVcIix0LG4pfWlmKCFzKXtzPWFkZEV2ZW50TGlzdGVuZXIoYS50YXJnZXQsXCJ0b3VjaGVuZFwiLHAsbil9aWYoIXYpe3Y9YWRkRXZlbnRMaXN0ZW5lcihhLnRhcmdldCxcInRvdWNoY2FuY2VsXCIscCxuKX19O3ZhciBtPWZ1bmN0aW9uKGEpe2lmKGw+RGF0ZS5ub3coKSl7cmV0dXJufWlmKCFyKGEpKXtyZXR1cm59aWYoIW8mJnQpe289YWRkRXZlbnRMaXN0ZW5lcihnZXREb2N1bWVudChlKSxcIm1vdXNlbW92ZVwiLHQsbil9aWYoIWMpe2M9YWRkRXZlbnRMaXN0ZW5lcihnZXREb2N1bWVudChlKSxcIm1vdXNldXBcIixFLG4pfX07dmFyIHA9ZnVuY3Rpb24oZSl7XygpO2lmKGEpe2EoZSl9fTt2YXIgRT1mdW5jdGlvbihlKXtnKCk7aWYoYSl7YShlKX19O3ZhciBfPWZ1bmN0aW9uKCl7aWYodSl7dSgpfWlmKHMpe3MoKX1pZih2KXt2KCl9dT1zPXY9dW5kZWZpbmVkfTt2YXIgZz1mdW5jdGlvbigpe2lmKG8pe28oKX1pZihjKXtjKCl9bz1jPXVuZGVmaW5lZH07dmFyIHk9ZnVuY3Rpb24oKXtfKCk7ZygpfTt2YXIgWD1mdW5jdGlvbihyKXtpZihyPT09dm9pZCAwKXtyPXRydWV9aWYoIXIpe2lmKGkpe2koKX1pZihmKXtmKCl9aT1mPXVuZGVmaW5lZDt5KCl9ZWxzZXtpZighaSl7aT1hZGRFdmVudExpc3RlbmVyKGUsXCJ0b3VjaHN0YXJ0XCIsZCxuKX1pZighZil7Zj1hZGRFdmVudExpc3RlbmVyKGUsXCJtb3VzZWRvd25cIixtLG4pfX19O3ZhciBZPWZ1bmN0aW9uKCl7WChmYWxzZSk7YT10PXI9dW5kZWZpbmVkfTtyZXR1cm57ZW5hYmxlOlgsc3RvcDp5LGRlc3Ryb3k6WX19O3ZhciBnZXREb2N1bWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERvY3VtZW50P2U6ZS5vd25lckRvY3VtZW50fTt2YXIgY3JlYXRlUGFuUmVjb2duaXplcj1mdW5jdGlvbihlLHIsdCl7dmFyIGE9dCooTWF0aC5QSS8xODApO3ZhciBuPWU9PT1cInhcIjt2YXIgaT1NYXRoLmNvcyhhKTt2YXIgdT1yKnI7dmFyIHM9MDt2YXIgdj0wO3ZhciBmPWZhbHNlO3ZhciBvPTA7cmV0dXJue3N0YXJ0OmZ1bmN0aW9uKGUscil7cz1lO3Y9cjtvPTA7Zj10cnVlfSxkZXRlY3Q6ZnVuY3Rpb24oZSxyKXtpZighZil7cmV0dXJuIGZhbHNlfXZhciB0PWUtczt2YXIgYT1yLXY7dmFyIGM9dCp0K2EqYTtpZihjPHUpe3JldHVybiBmYWxzZX12YXIgbD1NYXRoLnNxcnQoYyk7dmFyIGQ9KG4/dDphKS9sO2lmKGQ+aSl7bz0xfWVsc2UgaWYoZDwtaSl7bz0tMX1lbHNle289MH1mPWZhbHNlO3JldHVybiB0cnVlfSxpc0dlc3R1cmU6ZnVuY3Rpb24oKXtyZXR1cm4gbyE9PTB9LGdldERpcmVjdGlvbjpmdW5jdGlvbigpe3JldHVybiBvfX19O3ZhciBjcmVhdGVHZXN0dXJlPWZ1bmN0aW9uKGUpe3ZhciByPWZhbHNlO3ZhciB0PWZhbHNlO3ZhciBhPXRydWU7dmFyIG49ZmFsc2U7dmFyIGk9T2JqZWN0LmFzc2lnbih7ZGlzYWJsZVNjcm9sbDpmYWxzZSxkaXJlY3Rpb246XCJ4XCIsZ2VzdHVyZVByaW9yaXR5OjAscGFzc2l2ZTp0cnVlLG1heEFuZ2xlOjQwLHRocmVzaG9sZDoxMH0sZSk7dmFyIHU9aS5jYW5TdGFydDt2YXIgcz1pLm9uV2lsbFN0YXJ0O3ZhciB2PWkub25TdGFydDt2YXIgZj1pLm9uRW5kO3ZhciBvPWkubm90Q2FwdHVyZWQ7dmFyIGM9aS5vbk1vdmU7dmFyIGw9aS50aHJlc2hvbGQ7dmFyIGQ9aS5wYXNzaXZlO3ZhciBtPWkuYmx1ck9uU3RhcnQ7dmFyIHA9e3R5cGU6XCJwYW5cIixzdGFydFg6MCxzdGFydFk6MCxzdGFydFRpbWU6MCxjdXJyZW50WDowLGN1cnJlbnRZOjAsdmVsb2NpdHlYOjAsdmVsb2NpdHlZOjAsZGVsdGFYOjAsZGVsdGFZOjAsY3VycmVudFRpbWU6MCxldmVudDp1bmRlZmluZWQsZGF0YTp1bmRlZmluZWR9O3ZhciBFPWNyZWF0ZVBhblJlY29nbml6ZXIoaS5kaXJlY3Rpb24saS50aHJlc2hvbGQsaS5tYXhBbmdsZSk7dmFyIF89R0VTVFVSRV9DT05UUk9MTEVSLmNyZWF0ZUdlc3R1cmUoe25hbWU6ZS5nZXN0dXJlTmFtZSxwcmlvcml0eTplLmdlc3R1cmVQcmlvcml0eSxkaXNhYmxlU2Nyb2xsOmUuZGlzYWJsZVNjcm9sbH0pO3ZhciBnPWZ1bmN0aW9uKGUpe3ZhciByPW5vdyhlKTtpZih0fHwhYSl7cmV0dXJuIGZhbHNlfXVwZGF0ZURldGFpbChlLHApO3Auc3RhcnRYPXAuY3VycmVudFg7cC5zdGFydFk9cC5jdXJyZW50WTtwLnN0YXJ0VGltZT1wLmN1cnJlbnRUaW1lPXI7cC52ZWxvY2l0eVg9cC52ZWxvY2l0eVk9cC5kZWx0YVg9cC5kZWx0YVk9MDtwLmV2ZW50PWU7aWYodSYmdShwKT09PWZhbHNlKXtyZXR1cm4gZmFsc2V9Xy5yZWxlYXNlKCk7aWYoIV8uc3RhcnQoKSl7cmV0dXJuIGZhbHNlfXQ9dHJ1ZTtpZihsPT09MCl7cmV0dXJuIFkoKX1FLnN0YXJ0KHAuc3RhcnRYLHAuc3RhcnRZKTtyZXR1cm4gdHJ1ZX07dmFyIHk9ZnVuY3Rpb24oZSl7aWYocil7aWYoIW4mJmEpe249dHJ1ZTtjYWxjR2VzdHVyZURhdGEocCxlKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoWCl9cmV0dXJufWNhbGNHZXN0dXJlRGF0YShwLGUpO2lmKEUuZGV0ZWN0KHAuY3VycmVudFgscC5jdXJyZW50WSkpe2lmKCFFLmlzR2VzdHVyZSgpfHwhWSgpKXtiKCl9fX07dmFyIFg9ZnVuY3Rpb24oKXtpZighcil7cmV0dXJufW49ZmFsc2U7aWYoYyl7YyhwKX19O3ZhciBZPWZ1bmN0aW9uKCl7aWYoXyYmIV8uY2FwdHVyZSgpKXtyZXR1cm4gZmFsc2V9cj10cnVlO2E9ZmFsc2U7cC5zdGFydFg9cC5jdXJyZW50WDtwLnN0YXJ0WT1wLmN1cnJlbnRZO3Auc3RhcnRUaW1lPXAuY3VycmVudFRpbWU7aWYocyl7cyhwKS50aGVuKGgpfWVsc2V7aCgpfXJldHVybiB0cnVlfTt2YXIgTD1mdW5jdGlvbigpe2lmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCIpe3ZhciBlPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoZSE9PW51bGwmJmUuYmx1cil7ZS5ibHVyKCl9fX07dmFyIGg9ZnVuY3Rpb24oKXtpZihtKXtMKCl9aWYodil7dihwKX1hPXRydWV9O3ZhciBUPWZ1bmN0aW9uKCl7cj1mYWxzZTt0PWZhbHNlO249ZmFsc2U7YT10cnVlO18ucmVsZWFzZSgpfTt2YXIgRD1mdW5jdGlvbihlKXt2YXIgdD1yO3ZhciBuPWE7VCgpO2lmKCFuKXtyZXR1cm59Y2FsY0dlc3R1cmVEYXRhKHAsZSk7aWYodCl7aWYoZil7ZihwKX1yZXR1cm59aWYobyl7byhwKX19O3ZhciBQPWNyZWF0ZVBvaW50ZXJFdmVudHMoaS5lbCxnLHksRCx7Y2FwdHVyZTpmYWxzZSxwYXNzaXZlOmR9KTt2YXIgYj1mdW5jdGlvbigpe1QoKTtQLnN0b3AoKTtpZihvKXtvKHApfX07cmV0dXJue2VuYWJsZTpmdW5jdGlvbihlKXtpZihlPT09dm9pZCAwKXtlPXRydWV9aWYoIWUpe2lmKHIpe0QodW5kZWZpbmVkKX1UKCl9UC5lbmFibGUoZSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtfLmRlc3Ryb3koKTtQLmRlc3Ryb3koKX19fTt2YXIgY2FsY0dlc3R1cmVEYXRhPWZ1bmN0aW9uKGUscil7aWYoIXIpe3JldHVybn12YXIgdD1lLmN1cnJlbnRYO3ZhciBhPWUuY3VycmVudFk7dmFyIG49ZS5jdXJyZW50VGltZTt1cGRhdGVEZXRhaWwocixlKTt2YXIgaT1lLmN1cnJlbnRYO3ZhciB1PWUuY3VycmVudFk7dmFyIHM9ZS5jdXJyZW50VGltZT1ub3cocik7dmFyIHY9cy1uO2lmKHY+MCYmdjwxMDApe3ZhciBmPShpLXQpL3Y7dmFyIG89KHUtYSkvdjtlLnZlbG9jaXR5WD1mKi43K2UudmVsb2NpdHlYKi4zO2UudmVsb2NpdHlZPW8qLjcrZS52ZWxvY2l0eVkqLjN9ZS5kZWx0YVg9aS1lLnN0YXJ0WDtlLmRlbHRhWT11LWUuc3RhcnRZO2UuZXZlbnQ9cn07dmFyIHVwZGF0ZURldGFpbD1mdW5jdGlvbihlLHIpe3ZhciB0PTA7dmFyIGE9MDtpZihlKXt2YXIgbj1lLmNoYW5nZWRUb3VjaGVzO2lmKG4mJm4ubGVuZ3RoPjApe3ZhciBpPW5bMF07dD1pLmNsaWVudFg7YT1pLmNsaWVudFl9ZWxzZSBpZihlLnBhZ2VYIT09dW5kZWZpbmVkKXt0PWUucGFnZVg7YT1lLnBhZ2VZfX1yLmN1cnJlbnRYPXQ7ci5jdXJyZW50WT1hfTt2YXIgbm93PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX07ZXhwb3J0e2NyZWF0ZUdlc3R1cmV9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3876\n')},2896:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ Build),\n/* harmony export */   "H": () => (/* binding */ Host),\n/* harmony export */   "N": () => (/* binding */ NAMESPACE),\n/* harmony export */   "a": () => (/* binding */ setMode),\n/* harmony export */   "b": () => (/* binding */ bootstrapLazy),\n/* harmony export */   "c": () => (/* binding */ writeTask),\n/* harmony export */   "d": () => (/* binding */ doc),\n/* harmony export */   "e": () => (/* binding */ createEvent),\n/* harmony export */   "f": () => (/* binding */ readTask),\n/* harmony export */   "g": () => (/* binding */ getMode),\n/* harmony export */   "h": () => (/* binding */ h),\n/* harmony export */   "i": () => (/* binding */ getElement),\n/* harmony export */   "j": () => (/* binding */ forceUpdate),\n/* harmony export */   "k": () => (/* binding */ getAssetPath),\n/* harmony export */   "p": () => (/* binding */ promiseResolve),\n/* harmony export */   "r": () => (/* binding */ registerInstance),\n/* harmony export */   "s": () => (/* binding */ setPlatformHelpers),\n/* harmony export */   "w": () => (/* binding */ win)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(655);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var NAMESPACE="ionic";var scopeId;var contentRef;var hostTagName;var useNativeShadowDom=false;var checkSlotFallbackVisibility=false;var checkSlotRelocate=false;var isSvgMode=false;var queuePending=false;var win=typeof window!=="undefined"?window:{};var doc=win.document||{head:{}};var plt={$flags$:0,$resourcesUrl$:"",jmp:function(e){return e()},raf:function(e){return requestAnimationFrame(e)},ael:function(e,t,r,n){return e.addEventListener(t,r,n)},rel:function(e,t,r,n){return e.removeEventListener(t,r,n)},ce:function(e,t){return new CustomEvent(e,t)}};var setPlatformHelpers=function(e){Object.assign(plt,e)};var supportsShadow=true;var promiseResolve=function(e){return Promise.resolve(e)};var supportsConstructibleStylesheets=function(){try{new CSSStyleSheet;return typeof(new CSSStyleSheet).replace==="function"}catch(e){}return false}();var addHostEventListeners=function(e,t,r,n){if(r){r.map((function(r){var n=r[0],a=r[1],o=r[2];var s=getHostListenerTarget(e,n);var i=hostListenerProxy(t,o);var l=hostListenerOpts(n);plt.ael(s,a,i,l);(t.$rmListeners$=t.$rmListeners$||[]).push((function(){return plt.rel(s,a,i,l)}))}))}};var hostListenerProxy=function(e,t){return function(r){try{{if(e.$flags$&256){e.$lazyInstance$[t](r)}else{(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,r])}}}catch(e){consoleError(e)}}};var getHostListenerTarget=function(e,t){if(t&4)return doc;if(t&8)return win;if(t&16)return doc.body;return e};var hostListenerOpts=function(e){return(e&2)!==0};var CONTENT_REF_ID="r";var ORG_LOCATION_ID="o";var SLOT_NODE_ID="s";var TEXT_NODE_ID="t";var HYDRATE_ID="s-id";var HYDRATED_STYLE_ID="sty-id";var HYDRATE_CHILD_ID="c-id";var HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}";var XLINK_NS="http://www.w3.org/1999/xlink";var createTime=function(e,t){if(t===void 0){t=""}{return function(){return}}};var uniqueTime=function(e,t){{return function(){return}}};var rootAppliedStyles=new WeakMap;var registerStyle=function(e,t,r){var n=styles.get(e);if(supportsConstructibleStylesheets&&r){n=n||new CSSStyleSheet;n.replace(t)}else{n=t}styles.set(e,n)};var addStyle=function(e,t,r,n){var a=getScopeId(t,r);var o=styles.get(a);e=e.nodeType===11?e:doc;if(o){if(typeof o==="string"){e=e.head||e;var s=rootAppliedStyles.get(e);var i=void 0;if(!s){rootAppliedStyles.set(e,s=new Set)}if(!s.has(a)){if(e.host&&(i=e.querySelector("[".concat(HYDRATED_STYLE_ID,\'="\').concat(a,\'"]\')))){i.innerHTML=o}else{{i=doc.createElement("style");i.innerHTML=o}e.insertBefore(i,e.querySelector("link"))}if(s){s.add(a)}}}else if(!e.adoptedStyleSheets.includes(o)){e.adoptedStyleSheets=(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([],e.adoptedStyleSheets,true),[o],false)}}return a};var attachStyles=function(e){var t=e.$cmpMeta$;var r=e.$hostElement$;var n=t.$flags$;var a=createTime("attachStyles",t.$tagName$);var o=addStyle(r.shadowRoot?r.shadowRoot:r.getRootNode(),t,e.$modeName$);if(n&10){r["s-sc"]=o;r.classList.add(o+"-h");if(n&2){r.classList.add(o+"-s")}}a()};var getScopeId=function(e,t){return"sc-"+(t&&e.$flags$&32?e.$tagName$+"-"+t:e.$tagName$)};var convertScopedToShadow=function(e){return e.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g,"$1{")};var computeMode=function(e){return modeResolutionChain.map((function(t){return t(e)})).find((function(e){return!!e}))};var setMode=function(e){return modeResolutionChain.push(e)};var getMode=function(e){return getHostRef(e).$modeName$};var EMPTY_OBJ={};var SVG_NS="http://www.w3.org/2000/svg";var HTML_NS="http://www.w3.org/1999/xhtml";var isDef=function(e){return e!=null};var isComplexType=function(e){e=typeof e;return e==="object"||e==="function"};var h=function(e,t){var r=[];for(var n=2;n<arguments.length;n++){r[n-2]=arguments[n]}var a=null;var o=null;var s=null;var i=false;var l=false;var $=[];var c=function(t){for(var r=0;r<t.length;r++){a=t[r];if(Array.isArray(a)){c(a)}else if(a!=null&&typeof a!=="boolean"){if(i=typeof e!=="function"&&!isComplexType(a)){a=String(a)}if(i&&l){$[$.length-1].$text$+=a}else{$.push(i?newVNode(null,a):a)}l=i}}};c(r);if(t){if(t.key){o=t.key}if(t.name){s=t.name}{var f=t.className||t.class;if(f){t.class=typeof f!=="object"?f:Object.keys(f).filter((function(e){return f[e]})).join(" ")}}}if(typeof e==="function"){return e(t===null?{}:t,$,vdomFnUtils)}var u=newVNode(e,null);u.$attrs$=t;if($.length>0){u.$children$=$}{u.$key$=o}{u.$name$=s}return u};var newVNode=function(e,t){var r={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};{r.$attrs$=null}{r.$key$=null}{r.$name$=null}return r};var Host={};var isHost=function(e){return e&&e.$tag$===Host};var vdomFnUtils={forEach:function(e,t){return e.map(convertToPublic).forEach(t)},map:function(e,t){return e.map(convertToPublic).map(t).map(convertToPrivate)}};var convertToPublic=function(e){return{vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}};var convertToPrivate=function(e){if(typeof e.vtag==="function"){var t=Object.assign({},e.vattrs);if(e.vkey){t.key=e.vkey}if(e.vname){t.name=e.vname}return h.apply(void 0,(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__spreadArray */ .ev)([e.vtag,t],e.vchildren||[],false))}var r=newVNode(e.vtag,e.vtext);r.$attrs$=e.vattrs;r.$children$=e.vchildren;r.$key$=e.vkey;r.$name$=e.vname;return r};var setAccessor=function(e,t,r,n,a,o){if(r!==n){var s=isMemberInElement(e,t);var i=t.toLowerCase();if(t==="class"){var l=e.classList;var $=parseClassList(r);var c=parseClassList(n);l.remove.apply(l,$.filter((function(e){return e&&!c.includes(e)})));l.add.apply(l,c.filter((function(e){return e&&!$.includes(e)})))}else if(t==="style"){{for(var f in r){if(!n||n[f]==null){if(f.includes("-")){e.style.removeProperty(f)}else{e.style[f]=""}}}}for(var f in n){if(!r||n[f]!==r[f]){if(f.includes("-")){e.style.setProperty(f,n[f])}else{e.style[f]=n[f]}}}}else if(t==="key");else if(t==="ref"){if(n){n(e)}}else if(!s&&t[0]==="o"&&t[1]==="n"){if(t[2]==="-"){t=t.slice(3)}else if(isMemberInElement(win,i)){t=i.slice(2)}else{t=i[2]+t.slice(3)}if(r){plt.rel(e,t,r,false)}if(n){plt.ael(e,t,n,false)}}else{var u=isComplexType(n);if((s||u&&n!==null)&&!a){try{if(!e.tagName.includes("-")){var d=n==null?"":n;if(t==="list"){s=false}else if(r==null||e[t]!=d){e[t]=d}}else{e[t]=n}}catch(e){}}var v=false;{if(i!==(i=i.replace(/^xlink\\:?/,""))){t=i;v=true}}if(n==null||n===false){if(n!==false||e.getAttribute(t)===""){if(v){e.removeAttributeNS(XLINK_NS,t)}else{e.removeAttribute(t)}}}else if((!s||o&4||a)&&!u){n=n===true?"":n;if(v){e.setAttributeNS(XLINK_NS,t,n)}else{e.setAttribute(t,n)}}}}};var parseClassListRegex=/\\s/;var parseClassList=function(e){return!e?[]:e.split(parseClassListRegex)};var updateElement=function(e,t,r,n){var a=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$;var o=e&&e.$attrs$||EMPTY_OBJ;var s=t.$attrs$||EMPTY_OBJ;{for(n in o){if(!(n in s)){setAccessor(a,n,o[n],undefined,r,t.$flags$)}}}for(n in s){setAccessor(a,n,o[n],s[n],r,t.$flags$)}};var createElm=function(e,t,r,n){var a=t.$children$[r];var o=0;var s;var i;var l;if(!useNativeShadowDom){checkSlotRelocate=true;if(a.$tag$==="slot"){if(scopeId){n.classList.add(scopeId+"-s")}a.$flags$|=a.$children$?2:1}}if(a.$text$!==null){s=a.$elm$=doc.createTextNode(a.$text$)}else if(a.$flags$&1){s=a.$elm$=doc.createTextNode("")}else{if(!isSvgMode){isSvgMode=a.$tag$==="svg"}s=a.$elm$=doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,a.$flags$&2?"slot-fb":a.$tag$);if(isSvgMode&&a.$tag$==="foreignObject"){isSvgMode=false}{updateElement(null,a,isSvgMode)}if(isDef(scopeId)&&s["s-si"]!==scopeId){s.classList.add(s["s-si"]=scopeId)}if(a.$children$){for(o=0;o<a.$children$.length;++o){i=createElm(e,a,o,s);if(i){s.appendChild(i)}}}{if(a.$tag$==="svg"){isSvgMode=false}else if(s.tagName==="foreignObject"){isSvgMode=true}}}{s["s-hn"]=hostTagName;if(a.$flags$&(2|1)){s["s-sr"]=true;s["s-cr"]=contentRef;s["s-sn"]=a.$name$||"";l=e&&e.$children$&&e.$children$[r];if(l&&l.$tag$===a.$tag$&&e.$elm$){putBackInOriginalLocation(e.$elm$,false)}}}return s};var putBackInOriginalLocation=function(e,t){plt.$flags$|=1;var r=e.childNodes;for(var n=r.length-1;n>=0;n--){var a=r[n];if(a["s-hn"]!==hostTagName&&a["s-ol"]){parentReferenceNode(a).insertBefore(a,referenceNode(a));a["s-ol"].remove();a["s-ol"]=undefined;checkSlotRelocate=true}if(t){putBackInOriginalLocation(a,t)}}plt.$flags$&=~1};var addVnodes=function(e,t,r,n,a,o){var s=e["s-cr"]&&e["s-cr"].parentNode||e;var i;if(s.shadowRoot&&s.tagName===hostTagName){s=s.shadowRoot}for(;a<=o;++a){if(n[a]){i=createElm(null,r,a,e);if(i){n[a].$elm$=i;s.insertBefore(i,referenceNode(t))}}}};var removeVnodes=function(e,t,r,n,a){for(;t<=r;++t){if(n=e[t]){a=n.$elm$;callNodeRefs(n);{checkSlotFallbackVisibility=true;if(a["s-ol"]){a["s-ol"].remove()}else{putBackInOriginalLocation(a,true)}}a.remove()}}};var updateChildren=function(e,t,r,n){var a=0;var o=0;var s=0;var i=0;var l=t.length-1;var $=t[0];var c=t[l];var f=n.length-1;var u=n[0];var d=n[f];var v;var p;while(a<=l&&o<=f){if($==null){$=t[++a]}else if(c==null){c=t[--l]}else if(u==null){u=n[++o]}else if(d==null){d=n[--f]}else if(isSameVnode($,u)){patch($,u);$=t[++a];u=n[++o]}else if(isSameVnode(c,d)){patch(c,d);c=t[--l];d=n[--f]}else if(isSameVnode($,d)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation($.$elm$.parentNode,false)}patch($,d);e.insertBefore($.$elm$,c.$elm$.nextSibling);$=t[++a];d=n[--f]}else if(isSameVnode(c,u)){if($.$tag$==="slot"||d.$tag$==="slot"){putBackInOriginalLocation(c.$elm$.parentNode,false)}patch(c,u);e.insertBefore(c.$elm$,$.$elm$);c=t[--l];u=n[++o]}else{s=-1;{for(i=a;i<=l;++i){if(t[i]&&t[i].$key$!==null&&t[i].$key$===u.$key$){s=i;break}}}if(s>=0){p=t[s];if(p.$tag$!==u.$tag$){v=createElm(t&&t[o],r,s,e)}else{patch(p,u);t[s]=undefined;v=p.$elm$}u=n[++o]}else{v=createElm(t&&t[o],r,o,e);u=n[++o]}if(v){{parentReferenceNode($.$elm$).insertBefore(v,referenceNode($.$elm$))}}}}if(a>l){addVnodes(e,n[f+1]==null?null:n[f+1].$elm$,r,n,o,f)}else if(o>f){removeVnodes(t,a,l)}};var isSameVnode=function(e,t){if(e.$tag$===t.$tag$){if(e.$tag$==="slot"){return e.$name$===t.$name$}{return e.$key$===t.$key$}}return false};var referenceNode=function(e){return e&&e["s-ol"]||e};var parentReferenceNode=function(e){return(e["s-ol"]?e["s-ol"]:e).parentNode};var patch=function(e,t){var r=t.$elm$=e.$elm$;var n=e.$children$;var a=t.$children$;var o=t.$tag$;var s=t.$text$;var i;if(s===null){{isSvgMode=o==="svg"?true:o==="foreignObject"?false:isSvgMode}{if(o==="slot");else{updateElement(e,t,isSvgMode)}}if(n!==null&&a!==null){updateChildren(r,n,t,a)}else if(a!==null){if(e.$text$!==null){r.textContent=""}addVnodes(r,null,t,a,0,a.length-1)}else if(n!==null){removeVnodes(n,0,n.length-1)}if(isSvgMode&&o==="svg"){isSvgMode=false}}else if(i=r["s-cr"]){i.parentNode.textContent=s}else if(e.$text$!==s){r.data=s}};var updateFallbackSlotVisibility=function(e){var t=e.childNodes;var r;var n;var a;var o;var s;var i;for(n=0,a=t.length;n<a;n++){r=t[n];if(r.nodeType===1){if(r["s-sr"]){s=r["s-sn"];r.hidden=false;for(o=0;o<a;o++){i=t[o].nodeType;if(t[o]["s-hn"]!==r["s-hn"]||s!==""){if(i===1&&s===t[o].getAttribute("slot")){r.hidden=true;break}}else{if(i===1||i===3&&t[o].textContent.trim()!==""){r.hidden=true;break}}}}updateFallbackSlotVisibility(r)}}};var relocateNodes=[];var relocateSlotContent=function(e){var t;var r;var n;var a;var o;var s;var i=0;var l=e.childNodes;var $=l.length;for(;i<$;i++){t=l[i];if(t["s-sr"]&&(r=t["s-cr"])&&r.parentNode){n=r.parentNode.childNodes;a=t["s-sn"];for(s=n.length-1;s>=0;s--){r=n[s];if(!r["s-cn"]&&!r["s-nr"]&&r["s-hn"]!==t["s-hn"]){if(isNodeLocatedInSlot(r,a)){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));checkSlotFallbackVisibility=true;r["s-sn"]=r["s-sn"]||a;if(o){o.$slotRefNode$=t}else{relocateNodes.push({$slotRefNode$:t,$nodeToRelocate$:r})}if(r["s-sr"]){relocateNodes.map((function(e){if(isNodeLocatedInSlot(e.$nodeToRelocate$,r["s-sn"])){o=relocateNodes.find((function(e){return e.$nodeToRelocate$===r}));if(o&&!e.$slotRefNode$){e.$slotRefNode$=o.$slotRefNode$}}}))}}else if(!relocateNodes.some((function(e){return e.$nodeToRelocate$===r}))){relocateNodes.push({$nodeToRelocate$:r})}}}}if(t.nodeType===1){relocateSlotContent(t)}}};var isNodeLocatedInSlot=function(e,t){if(e.nodeType===1){if(e.getAttribute("slot")===null&&t===""){return true}if(e.getAttribute("slot")===t){return true}return false}if(e["s-sn"]===t){return true}return t===""};var callNodeRefs=function(e){{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null);e.$children$&&e.$children$.map(callNodeRefs)}};var renderVdom=function(e,t){var r=e.$hostElement$;var n=e.$cmpMeta$;var a=e.$vnode$||newVNode(null,null);var o=isHost(t)?t:h(null,null,t);hostTagName=r.tagName;if(n.$attrsToReflect$){o.$attrs$=o.$attrs$||{};n.$attrsToReflect$.map((function(e){var t=e[0],n=e[1];return o.$attrs$[n]=r[t]}))}o.$tag$=null;o.$flags$|=4;e.$vnode$=o;o.$elm$=a.$elm$=r.shadowRoot||r;{scopeId=r["s-sc"]}{contentRef=r["s-cr"];useNativeShadowDom=(n.$flags$&1)!==0;checkSlotFallbackVisibility=false}patch(a,o);{plt.$flags$|=1;if(checkSlotRelocate){relocateSlotContent(o.$elm$);var s=void 0;var i=void 0;var l=void 0;var $=void 0;var c=void 0;var f=void 0;var u=0;for(;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(!i["s-ol"]){l=doc.createTextNode("");l["s-nr"]=i;i.parentNode.insertBefore(i["s-ol"]=l,i)}}for(u=0;u<relocateNodes.length;u++){s=relocateNodes[u];i=s.$nodeToRelocate$;if(s.$slotRefNode$){$=s.$slotRefNode$.parentNode;c=s.$slotRefNode$.nextSibling;l=i["s-ol"];while(l=l.previousSibling){f=l["s-nr"];if(f&&f["s-sn"]===i["s-sn"]&&$===f.parentNode){f=f.nextSibling;if(!f||!f["s-nr"]){c=f;break}}}if(!c&&$!==i.parentNode||i.nextSibling!==c){if(i!==c){if(!i["s-hn"]&&i["s-ol"]){i["s-hn"]=i["s-ol"].parentNode.nodeName}$.insertBefore(i,c)}}}else{if(i.nodeType===1){i.hidden=true}}}}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(o.$elm$)}plt.$flags$&=~1;relocateNodes.length=0}};var getElement=function(e){return getHostRef(e).$hostElement$};var createEvent=function(e,t,r){var n=getElement(e);return{emit:function(e){return emitEvent(n,t,{bubbles:!!(r&4),composed:!!(r&2),cancelable:!!(r&1),detail:e})}}};var emitEvent=function(e,t,r){var n=plt.ce(t,r);e.dispatchEvent(n);return n};var attachToAncestor=function(e,t){if(t&&!e.$onRenderResolve$&&t["s-p"]){t["s-p"].push(new Promise((function(t){return e.$onRenderResolve$=t})))}};var scheduleUpdate=function(e,t){{e.$flags$|=16}if(e.$flags$&4){e.$flags$|=512;return}attachToAncestor(e,e.$ancestorComponent$);var r=function(){return dispatchHooks(e,t)};return writeTask(r)};var dispatchHooks=function(e,t){var r=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$);var n=e.$lazyInstance$;var a;if(t){{e.$flags$|=256;if(e.$queuedListeners$){e.$queuedListeners$.map((function(e){var t=e[0],r=e[1];return safeCall(n,t,r)}));e.$queuedListeners$=null}}{a=safeCall(n,"componentWillLoad")}}{a=then(a,(function(){return safeCall(n,"componentWillRender")}))}r();return then(a,(function(){return updateComponent(e,n,t)}))};var updateComponent=function(e,t,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,a,o,s,i,l;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function($){n=e.$hostElement$;a=createTime("update",e.$cmpMeta$.$tagName$);o=n["s-rc"];if(r){attachStyles(e)}s=createTime("render",e.$cmpMeta$.$tagName$);{callRender(e,t)}if(o){o.map((function(e){return e()}));n["s-rc"]=undefined}s();a();{i=n["s-p"];l=function(){return postUpdateComponent(e)};if(i.length===0){l()}else{Promise.all(i).then(l);e.$flags$|=4;i.length=0}}return[2]}))}))};var callRender=function(e,t,r){try{t=t.render&&t.render();{e.$flags$&=~16}{e.$flags$|=2}{{{renderVdom(e,t)}}}}catch(t){consoleError(t,e.$hostElement$)}return null};var postUpdateComponent=function(e){var t=e.$cmpMeta$.$tagName$;var r=e.$hostElement$;var n=createTime("postUpdate",t);var a=e.$lazyInstance$;var o=e.$ancestorComponent$;{safeCall(a,"componentDidRender")}if(!(e.$flags$&64)){e.$flags$|=64;{addHydratedFlag(r)}{safeCall(a,"componentDidLoad")}n();{e.$onReadyResolve$(r);if(!o){appDidLoad()}}}else{{safeCall(a,"componentDidUpdate")}n()}{e.$onInstanceResolve$(r)}{if(e.$onRenderResolve$){e.$onRenderResolve$();e.$onRenderResolve$=undefined}if(e.$flags$&512){nextTick((function(){return scheduleUpdate(e,false)}))}e.$flags$&=~(4|512)}};var forceUpdate=function(e){{var t=getHostRef(e);var r=t.$hostElement$.isConnected;if(r&&(t.$flags$&(2|16))===2){scheduleUpdate(t,false)}return r}};var appDidLoad=function(e){{addHydratedFlag(doc.documentElement)}nextTick((function(){return emitEvent(win,"appload",{detail:{namespace:NAMESPACE}})}))};var safeCall=function(e,t,r){if(e&&e[t]){try{return e[t](r)}catch(e){consoleError(e)}}return undefined};var then=function(e,t){return e&&e.then?e.then(t):t()};var addHydratedFlag=function(e){return e.classList.add("hydrated")};var initializeClientHydrate=function(e,t,r,n){var a=createTime("hydrateClient",t);var o=e.shadowRoot;var s=[];var i=[];var l=o?[]:null;var $=n.$vnode$=newVNode(t,null);if(!plt.$orgLocNodes$){initializeDocumentHydrate(doc.body,plt.$orgLocNodes$=new Map)}e[HYDRATE_ID]=r;e.removeAttribute(HYDRATE_ID);clientHydrate($,s,i,l,e,e,r);s.map((function(e){var r=e.$hostId$+"."+e.$nodeId$;var n=plt.$orgLocNodes$.get(r);var a=e.$elm$;if(n&&supportsShadow&&n["s-en"]===""){n.parentNode.insertBefore(a,n.nextSibling)}if(!o){a["s-hn"]=t;if(n){a["s-ol"]=n;a["s-ol"]["s-nr"]=a}}plt.$orgLocNodes$.delete(r)}));if(o){l.map((function(e){if(e){o.appendChild(e)}}))}a()};var clientHydrate=function(e,t,r,n,a,o,s){var i;var l;var $;var c;if(o.nodeType===1){i=o.getAttribute(HYDRATE_CHILD_ID);if(i){l=i.split(".");if(l[0]===s||l[0]==="0"){$={$flags$:0,$hostId$:l[0],$nodeId$:l[1],$depth$:l[2],$index$:l[3],$tag$:o.tagName.toLowerCase(),$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null};t.push($);o.removeAttribute(HYDRATE_CHILD_ID);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;e=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}for(c=o.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.childNodes[c],s)}if(o.shadowRoot){for(c=o.shadowRoot.childNodes.length-1;c>=0;c--){clientHydrate(e,t,r,n,a,o.shadowRoot.childNodes[c],s)}}}else if(o.nodeType===8){l=o.nodeValue.split(".");if(l[1]===s||l[1]==="0"){i=l[0];$={$flags$:0,$hostId$:l[1],$nodeId$:l[2],$depth$:l[3],$index$:l[4],$elm$:o,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null};if(i===TEXT_NODE_ID){$.$elm$=o.nextSibling;if($.$elm$&&$.$elm$.nodeType===3){$.$text$=$.$elm$.textContent;t.push($);o.remove();if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$;if(n&&$.$depth$==="0"){n[$.$index$]=$.$elm$}}}else if($.$hostId$===s){if(i===SLOT_NODE_ID){$.$tag$="slot";if(l[5]){o["s-sn"]=$.$name$=l[5]}else{o["s-sn"]=""}o["s-sr"]=true;if(n){$.$elm$=doc.createElement($.$tag$);if($.$name$){$.$elm$.setAttribute("name",$.$name$)}o.parentNode.insertBefore($.$elm$,o);o.remove();if($.$depth$==="0"){n[$.$index$]=$.$elm$}}r.push($);if(!e.$children$){e.$children$=[]}e.$children$[$.$index$]=$}else if(i===CONTENT_REF_ID){if(n){o.remove()}else{a["s-cr"]=o;o["s-cn"]=true}}}}}else if(e&&e.$tag$==="style"){var f=newVNode(null,o.textContent);f.$elm$=o;f.$index$="0";e.$children$=[f]}};var initializeDocumentHydrate=function(e,t){if(e.nodeType===1){var r=0;for(;r<e.childNodes.length;r++){initializeDocumentHydrate(e.childNodes[r],t)}if(e.shadowRoot){for(r=0;r<e.shadowRoot.childNodes.length;r++){initializeDocumentHydrate(e.shadowRoot.childNodes[r],t)}}}else if(e.nodeType===8){var n=e.nodeValue.split(".");if(n[0]===ORG_LOCATION_ID){t.set(n[1]+"."+n[2],e);e.nodeValue="";e["s-en"]=n[3]}}};var parsePropertyValue=function(e,t){if(e!=null&&!isComplexType(e)){if(t&4){return e==="false"?false:e===""||!!e}if(t&2){return parseFloat(e)}if(t&1){return String(e)}return e}return e};var getValue=function(e,t){return getHostRef(e).$instanceValues$.get(t)};var setValue=function(e,t,r,n){var a=getHostRef(e);var o=a.$hostElement$;var s=a.$instanceValues$.get(t);var i=a.$flags$;var l=a.$lazyInstance$;r=parsePropertyValue(r,n.$members$[t][0]);var $=Number.isNaN(s)&&Number.isNaN(r);var c=r!==s&&!$;if((!(i&8)||s===undefined)&&c){a.$instanceValues$.set(t,r);if(l){if(n.$watchers$&&i&128){var f=n.$watchers$[t];if(f){f.map((function(e){try{l[e](r,s,t)}catch(e){consoleError(e,o)}}))}}if((i&(2|16))===2){scheduleUpdate(a,false)}}}};var proxyComponent=function(e,t,r){if(t.$members$){if(e.watchers){t.$watchers$=e.watchers}var n=Object.entries(t.$members$);var a=e.prototype;n.map((function(e){var n=e[0],o=e[1][0];if(o&31||r&2&&o&32){Object.defineProperty(a,n,{get:function(){return getValue(this,n)},set:function(e){setValue(this,n,e,t)},configurable:true,enumerable:true})}else if(r&1&&o&64){Object.defineProperty(a,n,{value:function(){var e=[];for(var t=0;t<arguments.length;t++){e[t]=arguments[t]}var r=getHostRef(this);return r.$onInstancePromise$.then((function(){var t;return(t=r.$lazyInstance$)[n].apply(t,e)}))}})}}));if(r&1){var o=new Map;a.attributeChangedCallback=function(e,t,r){var n=this;plt.jmp((function(){var t=o.get(e);if(n.hasOwnProperty(t)){r=n[t];delete n[t]}else if(a.hasOwnProperty(t)&&typeof n[t]==="number"&&n[t]==r){return}n[t]=r===null&&typeof n[t]==="boolean"?false:r}))};e.observedAttributes=n.filter((function(e){var t=e[0],r=e[1];return r[0]&15})).map((function(e){var r=e[0],n=e[1];var a=n[1]||r;o.set(a,r);if(n[0]&512){t.$attrsToReflect$.push([r,a])}return a}))}}return e};var initializeComponent=function(e,t,r,n,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,o,s,i,l,$,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__generator */ .Jh)(this,(function(f){switch(f.label){case 0:if(!((t.$flags$&32)===0))return[3,3];t.$flags$|=32;a=loadModule(r);if(!a.then)return[3,2];n=uniqueTime();return[4,a];case 1:a=f.sent();n();f.label=2;case 2:if(!a.isProxied){{r.$watchers$=a.watchers}proxyComponent(a,r,2);a.isProxied=true}o=createTime("createInstance",r.$tagName$);{t.$flags$|=8}try{new a(t)}catch(e){consoleError(e)}{t.$flags$&=~8}{t.$flags$|=128}o();fireConnectedCallback(t.$lazyInstance$);if(a.style){s=a.style;if(typeof s!=="string"){s=s[t.$modeName$=computeMode(e)]}i=getScopeId(r,t.$modeName$);if(!styles.has(i)){l=createTime("registerStyles",r.$tagName$);registerStyle(i,s,!!(r.$flags$&1));l()}}f.label=3;case 3:$=t.$ancestorComponent$;c=function(){return scheduleUpdate(t,true)};if($&&$["s-rc"]){$["s-rc"].push(c)}else{c()}return[2]}}))}))};var fireConnectedCallback=function(e){{safeCall(e,"connectedCallback")}};var connectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$cmpMeta$;var n=createTime("connectedCallback",r.$tagName$);if(!(t.$flags$&1)){t.$flags$|=1;var a=void 0;{a=e.getAttribute(HYDRATE_ID);if(a){if(r.$flags$&1){var o=addStyle(e.shadowRoot,r,e.getAttribute("s-mode"));e.classList.remove(o+"-h",o+"-s")}initializeClientHydrate(e,r.$tagName$,a,t)}}if(!a){if(r.$flags$&(4|8)){setContentReference(e)}}{var s=e;while(s=s.parentNode||s.host){if(s.nodeType===1&&s.hasAttribute("s-id")&&s["s-p"]||s["s-p"]){attachToAncestor(t,t.$ancestorComponent$=s);break}}}if(r.$members$){Object.entries(r.$members$).map((function(t){var r=t[0],n=t[1][0];if(n&31&&e.hasOwnProperty(r)){var a=e[r];delete e[r];e[r]=a}}))}{nextTick((function(){return initializeComponent(e,t,r)}))}}else{addHostEventListeners(e,t,r.$listeners$);fireConnectedCallback(t.$lazyInstance$)}n()}};var setContentReference=function(e){var t=e["s-cr"]=doc.createComment("");t["s-cn"]=true;e.insertBefore(t,e.firstChild)};var disconnectedCallback=function(e){if((plt.$flags$&1)===0){var t=getHostRef(e);var r=t.$lazyInstance$;{if(t.$rmListeners$){t.$rmListeners$.map((function(e){return e()}));t.$rmListeners$=undefined}}{safeCall(r,"disconnectedCallback")}}};var bootstrapLazy=function(e,t){if(t===void 0){t={}}var r=createTime();var n=[];var a=t.exclude||[];var o=win.customElements;var s=doc.head;var i=s.querySelector("meta[charset]");var l=doc.createElement("style");var $=[];var c=doc.querySelectorAll("[".concat(HYDRATED_STYLE_ID,"]"));var f;var u=true;var d=0;Object.assign(plt,t);plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href;{plt.$flags$|=2}{for(;d<c.length;d++){registerStyle(c[d].getAttribute(HYDRATED_STYLE_ID),convertScopedToShadow(c[d].innerHTML),true)}}e.map((function(e){e[1].map((function(t){var r={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};{r.$members$=t[2]}{r.$listeners$=t[3]}{r.$attrsToReflect$=[]}{r.$watchers$={}}var s=r.$tagName$;var i=function(e){(0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT)(t,e);function t(t){var n=e.call(this,t)||this;t=n;registerHost(t,r);if(r.$flags$&1){{{t.attachShadow({mode:"open",delegatesFocus:!!(r.$flags$&16)})}}}return n}t.prototype.connectedCallback=function(){var e=this;if(f){clearTimeout(f);f=null}if(u){$.push(this)}else{plt.jmp((function(){return connectedCallback(e)}))}};t.prototype.disconnectedCallback=function(){var e=this;plt.jmp((function(){return disconnectedCallback(e)}))};t.prototype.componentOnReady=function(){return getHostRef(this).$onReadyPromise$};return t}(HTMLElement);r.$lazyBundleId$=e[0];if(!a.includes(s)&&!o.get(s)){n.push(s);o.define(s,proxyComponent(i,r,1))}}))}));{l.innerHTML=n+HYDRATED_CSS;l.setAttribute("data-styles","");s.insertBefore(l,i?i.nextSibling:s.firstChild)}u=false;if($.length){$.map((function(e){return e.connectedCallback()}))}else{{plt.jmp((function(){return f=setTimeout(appDidLoad,30)}))}}r()};var getAssetPath=function(e){var t=new URL(e,plt.$resourcesUrl$);return t.origin!==win.location.origin?t.href:t.pathname};var hostRefs=new WeakMap;var getHostRef=function(e){return hostRefs.get(e)};var registerInstance=function(e,t){return hostRefs.set(t.$lazyInstance$=e,t)};var registerHost=function(e,t){var r={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};{r.$onInstancePromise$=new Promise((function(e){return r.$onInstanceResolve$=e}))}{r.$onReadyPromise$=new Promise((function(e){return r.$onReadyResolve$=e}));e["s-p"]=[];e["s-rc"]=[]}addHostEventListeners(e,r,t.$listeners$);return hostRefs.set(e,r)};var isMemberInElement=function(e,t){return t in e};var consoleError=function(e,t){return(0,console.error)(e,t)};var cmpModules=new Map;var loadModule=function(e,t,r){var n=e.$tagName$.replace(/-/g,"_");var a=e.$lazyBundleId$;var o=cmpModules.get(a);if(o){return o[n]}return __webpack_require__(3076)("./".concat(a,".entry.js").concat("")).then((function(e){{cmpModules.set(a,e)}return e[n]}),consoleError)};var styles=new Map;var modeResolutionChain=[];var queueDomReads=[];var queueDomWrites=[];var queueTask=function(e,t){return function(r){e.push(r);if(!queuePending){queuePending=true;if(t&&plt.$flags$&4){nextTick(flush)}else{plt.raf(flush)}}}};var consume=function(e){for(var t=0;t<e.length;t++){try{e[t](performance.now())}catch(e){consoleError(e)}}e.length=0};var flush=function(){consume(queueDomReads);{consume(queueDomWrites);if(queuePending=queueDomReads.length>0){plt.raf(flush)}}};var nextTick=function(e){return promiseResolve().then(e)};var readTask=queueTask(queueDomReads,false);var writeTask=queueTask(queueDomWrites,true);var Build={isDev:false,isBrowser:true,isServer:false,isTesting:false};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NENBQTRDLDZDQUE2QyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtYjNlZWNiMTQuanM/YjNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZXh0ZW5kcyxfX2dlbmVyYXRvcixfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL3ZhciBOQU1FU1BBQ0U9XCJpb25pY1wiO3ZhciBzY29wZUlkO3ZhciBjb250ZW50UmVmO3ZhciBob3N0VGFnTmFtZTt2YXIgdXNlTmF0aXZlU2hhZG93RG9tPWZhbHNlO3ZhciBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHk9ZmFsc2U7dmFyIGNoZWNrU2xvdFJlbG9jYXRlPWZhbHNlO3ZhciBpc1N2Z01vZGU9ZmFsc2U7dmFyIHF1ZXVlUGVuZGluZz1mYWxzZTt2YXIgd2luPXR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fTt2YXIgZG9jPXdpbi5kb2N1bWVudHx8e2hlYWQ6e319O3ZhciBwbHQ9eyRmbGFncyQ6MCwkcmVzb3VyY2VzVXJsJDpcIlwiLGptcDpmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSxyYWY6ZnVuY3Rpb24oZSl7cmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShlKX0sYWVsOmZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBlLmFkZEV2ZW50TGlzdGVuZXIodCxyLG4pfSxyZWw6ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LHIsbil9LGNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBDdXN0b21FdmVudChlLHQpfX07dmFyIHNldFBsYXRmb3JtSGVscGVycz1mdW5jdGlvbihlKXtPYmplY3QuYXNzaWduKHBsdCxlKX07dmFyIHN1cHBvcnRzU2hhZG93PXRydWU7dmFyIHByb21pc2VSZXNvbHZlPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoZSl9O3ZhciBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cz1mdW5jdGlvbigpe3RyeXtuZXcgQ1NTU3R5bGVTaGVldDtyZXR1cm4gdHlwZW9mKG5ldyBDU1NTdHlsZVNoZWV0KS5yZXBsYWNlPT09XCJmdW5jdGlvblwifWNhdGNoKGUpe31yZXR1cm4gZmFsc2V9KCk7dmFyIGFkZEhvc3RFdmVudExpc3RlbmVycz1mdW5jdGlvbihlLHQscixuKXtpZihyKXtyLm1hcCgoZnVuY3Rpb24ocil7dmFyIG49clswXSxhPXJbMV0sbz1yWzJdO3ZhciBzPWdldEhvc3RMaXN0ZW5lclRhcmdldChlLG4pO3ZhciBpPWhvc3RMaXN0ZW5lclByb3h5KHQsbyk7dmFyIGw9aG9zdExpc3RlbmVyT3B0cyhuKTtwbHQuYWVsKHMsYSxpLGwpOyh0LiRybUxpc3RlbmVycyQ9dC4kcm1MaXN0ZW5lcnMkfHxbXSkucHVzaCgoZnVuY3Rpb24oKXtyZXR1cm4gcGx0LnJlbChzLGEsaSxsKX0pKX0pKX19O3ZhciBob3N0TGlzdGVuZXJQcm94eT1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihyKXt0cnl7e2lmKGUuJGZsYWdzJCYyNTYpe2UuJGxhenlJbnN0YW5jZSRbdF0ocil9ZWxzZXsoZS4kcXVldWVkTGlzdGVuZXJzJD1lLiRxdWV1ZWRMaXN0ZW5lcnMkfHxbXSkucHVzaChbdCxyXSl9fX1jYXRjaChlKXtjb25zb2xlRXJyb3IoZSl9fX07dmFyIGdldEhvc3RMaXN0ZW5lclRhcmdldD1mdW5jdGlvbihlLHQpe2lmKHQmNClyZXR1cm4gZG9jO2lmKHQmOClyZXR1cm4gd2luO2lmKHQmMTYpcmV0dXJuIGRvYy5ib2R5O3JldHVybiBlfTt2YXIgaG9zdExpc3RlbmVyT3B0cz1mdW5jdGlvbihlKXtyZXR1cm4oZSYyKSE9PTB9O3ZhciBDT05URU5UX1JFRl9JRD1cInJcIjt2YXIgT1JHX0xPQ0FUSU9OX0lEPVwib1wiO3ZhciBTTE9UX05PREVfSUQ9XCJzXCI7dmFyIFRFWFRfTk9ERV9JRD1cInRcIjt2YXIgSFlEUkFURV9JRD1cInMtaWRcIjt2YXIgSFlEUkFURURfU1RZTEVfSUQ9XCJzdHktaWRcIjt2YXIgSFlEUkFURV9DSElMRF9JRD1cImMtaWRcIjt2YXIgSFlEUkFURURfQ1NTPVwie3Zpc2liaWxpdHk6aGlkZGVufS5oeWRyYXRlZHt2aXNpYmlsaXR5OmluaGVyaXR9XCI7dmFyIFhMSU5LX05TPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO3ZhciBjcmVhdGVUaW1lPWZ1bmN0aW9uKGUsdCl7aWYodD09PXZvaWQgMCl7dD1cIlwifXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm59fX07dmFyIHVuaXF1ZVRpbWU9ZnVuY3Rpb24oZSx0KXt7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJufX19O3ZhciByb290QXBwbGllZFN0eWxlcz1uZXcgV2Vha01hcDt2YXIgcmVnaXN0ZXJTdHlsZT1mdW5jdGlvbihlLHQscil7dmFyIG49c3R5bGVzLmdldChlKTtpZihzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cyYmcil7bj1ufHxuZXcgQ1NTU3R5bGVTaGVldDtuLnJlcGxhY2UodCl9ZWxzZXtuPXR9c3R5bGVzLnNldChlLG4pfTt2YXIgYWRkU3R5bGU9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9Z2V0U2NvcGVJZCh0LHIpO3ZhciBvPXN0eWxlcy5nZXQoYSk7ZT1lLm5vZGVUeXBlPT09MTE/ZTpkb2M7aWYobyl7aWYodHlwZW9mIG89PT1cInN0cmluZ1wiKXtlPWUuaGVhZHx8ZTt2YXIgcz1yb290QXBwbGllZFN0eWxlcy5nZXQoZSk7dmFyIGk9dm9pZCAwO2lmKCFzKXtyb290QXBwbGllZFN0eWxlcy5zZXQoZSxzPW5ldyBTZXQpfWlmKCFzLmhhcyhhKSl7aWYoZS5ob3N0JiYoaT1lLnF1ZXJ5U2VsZWN0b3IoXCJbXCIuY29uY2F0KEhZRFJBVEVEX1NUWUxFX0lELCc9XCInKS5jb25jYXQoYSwnXCJdJykpKSl7aS5pbm5lckhUTUw9b31lbHNle3tpPWRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aS5pbm5lckhUTUw9b31lLmluc2VydEJlZm9yZShpLGUucXVlcnlTZWxlY3RvcihcImxpbmtcIikpfWlmKHMpe3MuYWRkKGEpfX19ZWxzZSBpZighZS5hZG9wdGVkU3R5bGVTaGVldHMuaW5jbHVkZXMobykpe2UuYWRvcHRlZFN0eWxlU2hlZXRzPV9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxlLmFkb3B0ZWRTdHlsZVNoZWV0cyx0cnVlKSxbb10sZmFsc2UpfX1yZXR1cm4gYX07dmFyIGF0dGFjaFN0eWxlcz1mdW5jdGlvbihlKXt2YXIgdD1lLiRjbXBNZXRhJDt2YXIgcj1lLiRob3N0RWxlbWVudCQ7dmFyIG49dC4kZmxhZ3MkO3ZhciBhPWNyZWF0ZVRpbWUoXCJhdHRhY2hTdHlsZXNcIix0LiR0YWdOYW1lJCk7dmFyIG89YWRkU3R5bGUoci5zaGFkb3dSb290P3Iuc2hhZG93Um9vdDpyLmdldFJvb3ROb2RlKCksdCxlLiRtb2RlTmFtZSQpO2lmKG4mMTApe3JbXCJzLXNjXCJdPW87ci5jbGFzc0xpc3QuYWRkKG8rXCItaFwiKTtpZihuJjIpe3IuY2xhc3NMaXN0LmFkZChvK1wiLXNcIil9fWEoKX07dmFyIGdldFNjb3BlSWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInNjLVwiKyh0JiZlLiRmbGFncyQmMzI/ZS4kdGFnTmFtZSQrXCItXCIrdDplLiR0YWdOYW1lJCl9O3ZhciBjb252ZXJ0U2NvcGVkVG9TaGFkb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvXFwvXFwqIUAoW15cXC9dKylcXCpcXC9bXlxce10rXFx7L2csXCIkMXtcIil9O3ZhciBjb21wdXRlTW9kZT1mdW5jdGlvbihlKXtyZXR1cm4gbW9kZVJlc29sdXRpb25DaGFpbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0KGUpfSkpLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKX07dmFyIHNldE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG1vZGVSZXNvbHV0aW9uQ2hhaW4ucHVzaChlKX07dmFyIGdldE1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGdldEhvc3RSZWYoZSkuJG1vZGVOYW1lJH07dmFyIEVNUFRZX09CSj17fTt2YXIgU1ZHX05TPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjt2YXIgSFRNTF9OUz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjt2YXIgaXNEZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPW51bGx9O3ZhciBpc0NvbXBsZXhUeXBlPWZ1bmN0aW9uKGUpe2U9dHlwZW9mIGU7cmV0dXJuIGU9PT1cIm9iamVjdFwifHxlPT09XCJmdW5jdGlvblwifTt2YXIgaD1mdW5jdGlvbihlLHQpe3ZhciByPVtdO2Zvcih2YXIgbj0yO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3Jbbi0yXT1hcmd1bWVudHNbbl19dmFyIGE9bnVsbDt2YXIgbz1udWxsO3ZhciBzPW51bGw7dmFyIGk9ZmFsc2U7dmFyIGw9ZmFsc2U7dmFyICQ9W107dmFyIGM9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe2E9dFtyXTtpZihBcnJheS5pc0FycmF5KGEpKXtjKGEpfWVsc2UgaWYoYSE9bnVsbCYmdHlwZW9mIGEhPT1cImJvb2xlYW5cIil7aWYoaT10eXBlb2YgZSE9PVwiZnVuY3Rpb25cIiYmIWlzQ29tcGxleFR5cGUoYSkpe2E9U3RyaW5nKGEpfWlmKGkmJmwpeyRbJC5sZW5ndGgtMV0uJHRleHQkKz1hfWVsc2V7JC5wdXNoKGk/bmV3Vk5vZGUobnVsbCxhKTphKX1sPWl9fX07YyhyKTtpZih0KXtpZih0LmtleSl7bz10LmtleX1pZih0Lm5hbWUpe3M9dC5uYW1lfXt2YXIgZj10LmNsYXNzTmFtZXx8dC5jbGFzcztpZihmKXt0LmNsYXNzPXR5cGVvZiBmIT09XCJvYmplY3RcIj9mOk9iamVjdC5rZXlzKGYpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGZbZV19KSkuam9pbihcIiBcIil9fX1pZih0eXBlb2YgZT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGUodD09PW51bGw/e306dCwkLHZkb21GblV0aWxzKX12YXIgdT1uZXdWTm9kZShlLG51bGwpO3UuJGF0dHJzJD10O2lmKCQubGVuZ3RoPjApe3UuJGNoaWxkcmVuJD0kfXt1LiRrZXkkPW99e3UuJG5hbWUkPXN9cmV0dXJuIHV9O3ZhciBuZXdWTm9kZT1mdW5jdGlvbihlLHQpe3ZhciByPXskZmxhZ3MkOjAsJHRhZyQ6ZSwkdGV4dCQ6dCwkZWxtJDpudWxsLCRjaGlsZHJlbiQ6bnVsbH07e3IuJGF0dHJzJD1udWxsfXtyLiRrZXkkPW51bGx9e3IuJG5hbWUkPW51bGx9cmV0dXJuIHJ9O3ZhciBIb3N0PXt9O3ZhciBpc0hvc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuJHRhZyQ9PT1Ib3N0fTt2YXIgdmRvbUZuVXRpbHM9e2ZvckVhY2g6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXAoY29udmVydFRvUHVibGljKS5mb3JFYWNoKHQpfSxtYXA6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXAoY29udmVydFRvUHVibGljKS5tYXAodCkubWFwKGNvbnZlcnRUb1ByaXZhdGUpfX07dmFyIGNvbnZlcnRUb1B1YmxpYz1mdW5jdGlvbihlKXtyZXR1cm57dmF0dHJzOmUuJGF0dHJzJCx2Y2hpbGRyZW46ZS4kY2hpbGRyZW4kLHZrZXk6ZS4ka2V5JCx2bmFtZTplLiRuYW1lJCx2dGFnOmUuJHRhZyQsdnRleHQ6ZS4kdGV4dCR9fTt2YXIgY29udmVydFRvUHJpdmF0ZT1mdW5jdGlvbihlKXtpZih0eXBlb2YgZS52dGFnPT09XCJmdW5jdGlvblwiKXt2YXIgdD1PYmplY3QuYXNzaWduKHt9LGUudmF0dHJzKTtpZihlLnZrZXkpe3Qua2V5PWUudmtleX1pZihlLnZuYW1lKXt0Lm5hbWU9ZS52bmFtZX1yZXR1cm4gaC5hcHBseSh2b2lkIDAsX19zcHJlYWRBcnJheShbZS52dGFnLHRdLGUudmNoaWxkcmVufHxbXSxmYWxzZSkpfXZhciByPW5ld1ZOb2RlKGUudnRhZyxlLnZ0ZXh0KTtyLiRhdHRycyQ9ZS52YXR0cnM7ci4kY2hpbGRyZW4kPWUudmNoaWxkcmVuO3IuJGtleSQ9ZS52a2V5O3IuJG5hbWUkPWUudm5hbWU7cmV0dXJuIHJ9O3ZhciBzZXRBY2Nlc3Nvcj1mdW5jdGlvbihlLHQscixuLGEsbyl7aWYociE9PW4pe3ZhciBzPWlzTWVtYmVySW5FbGVtZW50KGUsdCk7dmFyIGk9dC50b0xvd2VyQ2FzZSgpO2lmKHQ9PT1cImNsYXNzXCIpe3ZhciBsPWUuY2xhc3NMaXN0O3ZhciAkPXBhcnNlQ2xhc3NMaXN0KHIpO3ZhciBjPXBhcnNlQ2xhc3NMaXN0KG4pO2wucmVtb3ZlLmFwcGx5KGwsJC5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiYhYy5pbmNsdWRlcyhlKX0pKSk7bC5hZGQuYXBwbHkobCxjLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiEkLmluY2x1ZGVzKGUpfSkpKX1lbHNlIGlmKHQ9PT1cInN0eWxlXCIpe3tmb3IodmFyIGYgaW4gcil7aWYoIW58fG5bZl09PW51bGwpe2lmKGYuaW5jbHVkZXMoXCItXCIpKXtlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGYpfWVsc2V7ZS5zdHlsZVtmXT1cIlwifX19fWZvcih2YXIgZiBpbiBuKXtpZighcnx8bltmXSE9PXJbZl0pe2lmKGYuaW5jbHVkZXMoXCItXCIpKXtlLnN0eWxlLnNldFByb3BlcnR5KGYsbltmXSl9ZWxzZXtlLnN0eWxlW2ZdPW5bZl19fX19ZWxzZSBpZih0PT09XCJrZXlcIik7ZWxzZSBpZih0PT09XCJyZWZcIil7aWYobil7bihlKX19ZWxzZSBpZighcyYmdFswXT09PVwib1wiJiZ0WzFdPT09XCJuXCIpe2lmKHRbMl09PT1cIi1cIil7dD10LnNsaWNlKDMpfWVsc2UgaWYoaXNNZW1iZXJJbkVsZW1lbnQod2luLGkpKXt0PWkuc2xpY2UoMil9ZWxzZXt0PWlbMl0rdC5zbGljZSgzKX1pZihyKXtwbHQucmVsKGUsdCxyLGZhbHNlKX1pZihuKXtwbHQuYWVsKGUsdCxuLGZhbHNlKX19ZWxzZXt2YXIgdT1pc0NvbXBsZXhUeXBlKG4pO2lmKChzfHx1JiZuIT09bnVsbCkmJiFhKXt0cnl7aWYoIWUudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikpe3ZhciBkPW49PW51bGw/XCJcIjpuO2lmKHQ9PT1cImxpc3RcIil7cz1mYWxzZX1lbHNlIGlmKHI9PW51bGx8fGVbdF0hPWQpe2VbdF09ZH19ZWxzZXtlW3RdPW59fWNhdGNoKGUpe319dmFyIHY9ZmFsc2U7e2lmKGkhPT0oaT1pLnJlcGxhY2UoL154bGlua1xcOj8vLFwiXCIpKSl7dD1pO3Y9dHJ1ZX19aWYobj09bnVsbHx8bj09PWZhbHNlKXtpZihuIT09ZmFsc2V8fGUuZ2V0QXR0cmlidXRlKHQpPT09XCJcIil7aWYodil7ZS5yZW1vdmVBdHRyaWJ1dGVOUyhYTElOS19OUyx0KX1lbHNle2UucmVtb3ZlQXR0cmlidXRlKHQpfX19ZWxzZSBpZigoIXN8fG8mNHx8YSkmJiF1KXtuPW49PT10cnVlP1wiXCI6bjtpZih2KXtlLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLHQsbil9ZWxzZXtlLnNldEF0dHJpYnV0ZSh0LG4pfX19fX07dmFyIHBhcnNlQ2xhc3NMaXN0UmVnZXg9L1xccy87dmFyIHBhcnNlQ2xhc3NMaXN0PWZ1bmN0aW9uKGUpe3JldHVybiFlP1tdOmUuc3BsaXQocGFyc2VDbGFzc0xpc3RSZWdleCl9O3ZhciB1cGRhdGVFbGVtZW50PWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPXQuJGVsbSQubm9kZVR5cGU9PT0xMSYmdC4kZWxtJC5ob3N0P3QuJGVsbSQuaG9zdDp0LiRlbG0kO3ZhciBvPWUmJmUuJGF0dHJzJHx8RU1QVFlfT0JKO3ZhciBzPXQuJGF0dHJzJHx8RU1QVFlfT0JKO3tmb3IobiBpbiBvKXtpZighKG4gaW4gcykpe3NldEFjY2Vzc29yKGEsbixvW25dLHVuZGVmaW5lZCxyLHQuJGZsYWdzJCl9fX1mb3IobiBpbiBzKXtzZXRBY2Nlc3NvcihhLG4sb1tuXSxzW25dLHIsdC4kZmxhZ3MkKX19O3ZhciBjcmVhdGVFbG09ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9dC4kY2hpbGRyZW4kW3JdO3ZhciBvPTA7dmFyIHM7dmFyIGk7dmFyIGw7aWYoIXVzZU5hdGl2ZVNoYWRvd0RvbSl7Y2hlY2tTbG90UmVsb2NhdGU9dHJ1ZTtpZihhLiR0YWckPT09XCJzbG90XCIpe2lmKHNjb3BlSWQpe24uY2xhc3NMaXN0LmFkZChzY29wZUlkK1wiLXNcIil9YS4kZmxhZ3MkfD1hLiRjaGlsZHJlbiQ/MjoxfX1pZihhLiR0ZXh0JCE9PW51bGwpe3M9YS4kZWxtJD1kb2MuY3JlYXRlVGV4dE5vZGUoYS4kdGV4dCQpfWVsc2UgaWYoYS4kZmxhZ3MkJjEpe3M9YS4kZWxtJD1kb2MuY3JlYXRlVGV4dE5vZGUoXCJcIil9ZWxzZXtpZighaXNTdmdNb2RlKXtpc1N2Z01vZGU9YS4kdGFnJD09PVwic3ZnXCJ9cz1hLiRlbG0kPWRvYy5jcmVhdGVFbGVtZW50TlMoaXNTdmdNb2RlP1NWR19OUzpIVE1MX05TLGEuJGZsYWdzJCYyP1wic2xvdC1mYlwiOmEuJHRhZyQpO2lmKGlzU3ZnTW9kZSYmYS4kdGFnJD09PVwiZm9yZWlnbk9iamVjdFwiKXtpc1N2Z01vZGU9ZmFsc2V9e3VwZGF0ZUVsZW1lbnQobnVsbCxhLGlzU3ZnTW9kZSl9aWYoaXNEZWYoc2NvcGVJZCkmJnNbXCJzLXNpXCJdIT09c2NvcGVJZCl7cy5jbGFzc0xpc3QuYWRkKHNbXCJzLXNpXCJdPXNjb3BlSWQpfWlmKGEuJGNoaWxkcmVuJCl7Zm9yKG89MDtvPGEuJGNoaWxkcmVuJC5sZW5ndGg7KytvKXtpPWNyZWF0ZUVsbShlLGEsbyxzKTtpZihpKXtzLmFwcGVuZENoaWxkKGkpfX19e2lmKGEuJHRhZyQ9PT1cInN2Z1wiKXtpc1N2Z01vZGU9ZmFsc2V9ZWxzZSBpZihzLnRhZ05hbWU9PT1cImZvcmVpZ25PYmplY3RcIil7aXNTdmdNb2RlPXRydWV9fX17c1tcInMtaG5cIl09aG9zdFRhZ05hbWU7aWYoYS4kZmxhZ3MkJigyfDEpKXtzW1wicy1zclwiXT10cnVlO3NbXCJzLWNyXCJdPWNvbnRlbnRSZWY7c1tcInMtc25cIl09YS4kbmFtZSR8fFwiXCI7bD1lJiZlLiRjaGlsZHJlbiQmJmUuJGNoaWxkcmVuJFtyXTtpZihsJiZsLiR0YWckPT09YS4kdGFnJCYmZS4kZWxtJCl7cHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihlLiRlbG0kLGZhbHNlKX19fXJldHVybiBzfTt2YXIgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbj1mdW5jdGlvbihlLHQpe3BsdC4kZmxhZ3MkfD0xO3ZhciByPWUuY2hpbGROb2Rlcztmb3IodmFyIG49ci5sZW5ndGgtMTtuPj0wO24tLSl7dmFyIGE9cltuXTtpZihhW1wicy1oblwiXSE9PWhvc3RUYWdOYW1lJiZhW1wicy1vbFwiXSl7cGFyZW50UmVmZXJlbmNlTm9kZShhKS5pbnNlcnRCZWZvcmUoYSxyZWZlcmVuY2VOb2RlKGEpKTthW1wicy1vbFwiXS5yZW1vdmUoKTthW1wicy1vbFwiXT11bmRlZmluZWQ7Y2hlY2tTbG90UmVsb2NhdGU9dHJ1ZX1pZih0KXtwdXRCYWNrSW5PcmlnaW5hbExvY2F0aW9uKGEsdCl9fXBsdC4kZmxhZ3MkJj1+MX07dmFyIGFkZFZub2Rlcz1mdW5jdGlvbihlLHQscixuLGEsbyl7dmFyIHM9ZVtcInMtY3JcIl0mJmVbXCJzLWNyXCJdLnBhcmVudE5vZGV8fGU7dmFyIGk7aWYocy5zaGFkb3dSb290JiZzLnRhZ05hbWU9PT1ob3N0VGFnTmFtZSl7cz1zLnNoYWRvd1Jvb3R9Zm9yKDthPD1vOysrYSl7aWYoblthXSl7aT1jcmVhdGVFbG0obnVsbCxyLGEsZSk7aWYoaSl7blthXS4kZWxtJD1pO3MuaW5zZXJ0QmVmb3JlKGkscmVmZXJlbmNlTm9kZSh0KSl9fX19O3ZhciByZW1vdmVWbm9kZXM9ZnVuY3Rpb24oZSx0LHIsbixhKXtmb3IoO3Q8PXI7Kyt0KXtpZihuPWVbdF0pe2E9bi4kZWxtJDtjYWxsTm9kZVJlZnMobik7e2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT10cnVlO2lmKGFbXCJzLW9sXCJdKXthW1wicy1vbFwiXS5yZW1vdmUoKX1lbHNle3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oYSx0cnVlKX19YS5yZW1vdmUoKX19fTt2YXIgdXBkYXRlQ2hpbGRyZW49ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9MDt2YXIgbz0wO3ZhciBzPTA7dmFyIGk9MDt2YXIgbD10Lmxlbmd0aC0xO3ZhciAkPXRbMF07dmFyIGM9dFtsXTt2YXIgZj1uLmxlbmd0aC0xO3ZhciB1PW5bMF07dmFyIGQ9bltmXTt2YXIgdjt2YXIgcDt3aGlsZShhPD1sJiZvPD1mKXtpZigkPT1udWxsKXskPXRbKythXX1lbHNlIGlmKGM9PW51bGwpe2M9dFstLWxdfWVsc2UgaWYodT09bnVsbCl7dT1uWysrb119ZWxzZSBpZihkPT1udWxsKXtkPW5bLS1mXX1lbHNlIGlmKGlzU2FtZVZub2RlKCQsdSkpe3BhdGNoKCQsdSk7JD10WysrYV07dT1uWysrb119ZWxzZSBpZihpc1NhbWVWbm9kZShjLGQpKXtwYXRjaChjLGQpO2M9dFstLWxdO2Q9blstLWZdfWVsc2UgaWYoaXNTYW1lVm5vZGUoJCxkKSl7aWYoJC4kdGFnJD09PVwic2xvdFwifHxkLiR0YWckPT09XCJzbG90XCIpe3B1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oJC4kZWxtJC5wYXJlbnROb2RlLGZhbHNlKX1wYXRjaCgkLGQpO2UuaW5zZXJ0QmVmb3JlKCQuJGVsbSQsYy4kZWxtJC5uZXh0U2libGluZyk7JD10WysrYV07ZD1uWy0tZl19ZWxzZSBpZihpc1NhbWVWbm9kZShjLHUpKXtpZigkLiR0YWckPT09XCJzbG90XCJ8fGQuJHRhZyQ9PT1cInNsb3RcIil7cHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihjLiRlbG0kLnBhcmVudE5vZGUsZmFsc2UpfXBhdGNoKGMsdSk7ZS5pbnNlcnRCZWZvcmUoYy4kZWxtJCwkLiRlbG0kKTtjPXRbLS1sXTt1PW5bKytvXX1lbHNle3M9LTE7e2ZvcihpPWE7aTw9bDsrK2kpe2lmKHRbaV0mJnRbaV0uJGtleSQhPT1udWxsJiZ0W2ldLiRrZXkkPT09dS4ka2V5JCl7cz1pO2JyZWFrfX19aWYocz49MCl7cD10W3NdO2lmKHAuJHRhZyQhPT11LiR0YWckKXt2PWNyZWF0ZUVsbSh0JiZ0W29dLHIscyxlKX1lbHNle3BhdGNoKHAsdSk7dFtzXT11bmRlZmluZWQ7dj1wLiRlbG0kfXU9blsrK29dfWVsc2V7dj1jcmVhdGVFbG0odCYmdFtvXSxyLG8sZSk7dT1uWysrb119aWYodil7e3BhcmVudFJlZmVyZW5jZU5vZGUoJC4kZWxtJCkuaW5zZXJ0QmVmb3JlKHYscmVmZXJlbmNlTm9kZSgkLiRlbG0kKSl9fX19aWYoYT5sKXthZGRWbm9kZXMoZSxuW2YrMV09PW51bGw/bnVsbDpuW2YrMV0uJGVsbSQscixuLG8sZil9ZWxzZSBpZihvPmYpe3JlbW92ZVZub2Rlcyh0LGEsbCl9fTt2YXIgaXNTYW1lVm5vZGU9ZnVuY3Rpb24oZSx0KXtpZihlLiR0YWckPT09dC4kdGFnJCl7aWYoZS4kdGFnJD09PVwic2xvdFwiKXtyZXR1cm4gZS4kbmFtZSQ9PT10LiRuYW1lJH17cmV0dXJuIGUuJGtleSQ9PT10LiRrZXkkfX1yZXR1cm4gZmFsc2V9O3ZhciByZWZlcmVuY2VOb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlW1wicy1vbFwiXXx8ZX07dmFyIHBhcmVudFJlZmVyZW5jZU5vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuKGVbXCJzLW9sXCJdP2VbXCJzLW9sXCJdOmUpLnBhcmVudE5vZGV9O3ZhciBwYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQuJGVsbSQ9ZS4kZWxtJDt2YXIgbj1lLiRjaGlsZHJlbiQ7dmFyIGE9dC4kY2hpbGRyZW4kO3ZhciBvPXQuJHRhZyQ7dmFyIHM9dC4kdGV4dCQ7dmFyIGk7aWYocz09PW51bGwpe3tpc1N2Z01vZGU9bz09PVwic3ZnXCI/dHJ1ZTpvPT09XCJmb3JlaWduT2JqZWN0XCI/ZmFsc2U6aXNTdmdNb2RlfXtpZihvPT09XCJzbG90XCIpO2Vsc2V7dXBkYXRlRWxlbWVudChlLHQsaXNTdmdNb2RlKX19aWYobiE9PW51bGwmJmEhPT1udWxsKXt1cGRhdGVDaGlsZHJlbihyLG4sdCxhKX1lbHNlIGlmKGEhPT1udWxsKXtpZihlLiR0ZXh0JCE9PW51bGwpe3IudGV4dENvbnRlbnQ9XCJcIn1hZGRWbm9kZXMocixudWxsLHQsYSwwLGEubGVuZ3RoLTEpfWVsc2UgaWYobiE9PW51bGwpe3JlbW92ZVZub2RlcyhuLDAsbi5sZW5ndGgtMSl9aWYoaXNTdmdNb2RlJiZvPT09XCJzdmdcIil7aXNTdmdNb2RlPWZhbHNlfX1lbHNlIGlmKGk9cltcInMtY3JcIl0pe2kucGFyZW50Tm9kZS50ZXh0Q29udGVudD1zfWVsc2UgaWYoZS4kdGV4dCQhPT1zKXtyLmRhdGE9c319O3ZhciB1cGRhdGVGYWxsYmFja1Nsb3RWaXNpYmlsaXR5PWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2hpbGROb2Rlczt2YXIgcjt2YXIgbjt2YXIgYTt2YXIgbzt2YXIgczt2YXIgaTtmb3Iobj0wLGE9dC5sZW5ndGg7bjxhO24rKyl7cj10W25dO2lmKHIubm9kZVR5cGU9PT0xKXtpZihyW1wicy1zclwiXSl7cz1yW1wicy1zblwiXTtyLmhpZGRlbj1mYWxzZTtmb3Iobz0wO288YTtvKyspe2k9dFtvXS5ub2RlVHlwZTtpZih0W29dW1wicy1oblwiXSE9PXJbXCJzLWhuXCJdfHxzIT09XCJcIil7aWYoaT09PTEmJnM9PT10W29dLmdldEF0dHJpYnV0ZShcInNsb3RcIikpe3IuaGlkZGVuPXRydWU7YnJlYWt9fWVsc2V7aWYoaT09PTF8fGk9PT0zJiZ0W29dLnRleHRDb250ZW50LnRyaW0oKSE9PVwiXCIpe3IuaGlkZGVuPXRydWU7YnJlYWt9fX19dXBkYXRlRmFsbGJhY2tTbG90VmlzaWJpbGl0eShyKX19fTt2YXIgcmVsb2NhdGVOb2Rlcz1bXTt2YXIgcmVsb2NhdGVTbG90Q29udGVudD1mdW5jdGlvbihlKXt2YXIgdDt2YXIgcjt2YXIgbjt2YXIgYTt2YXIgbzt2YXIgczt2YXIgaT0wO3ZhciBsPWUuY2hpbGROb2Rlczt2YXIgJD1sLmxlbmd0aDtmb3IoO2k8JDtpKyspe3Q9bFtpXTtpZih0W1wicy1zclwiXSYmKHI9dFtcInMtY3JcIl0pJiZyLnBhcmVudE5vZGUpe249ci5wYXJlbnROb2RlLmNoaWxkTm9kZXM7YT10W1wicy1zblwiXTtmb3Iocz1uLmxlbmd0aC0xO3M+PTA7cy0tKXtyPW5bc107aWYoIXJbXCJzLWNuXCJdJiYhcltcInMtbnJcIl0mJnJbXCJzLWhuXCJdIT09dFtcInMtaG5cIl0pe2lmKGlzTm9kZUxvY2F0ZWRJblNsb3QocixhKSl7bz1yZWxvY2F0ZU5vZGVzLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiBlLiRub2RlVG9SZWxvY2F0ZSQ9PT1yfSkpO2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT10cnVlO3JbXCJzLXNuXCJdPXJbXCJzLXNuXCJdfHxhO2lmKG8pe28uJHNsb3RSZWZOb2RlJD10fWVsc2V7cmVsb2NhdGVOb2Rlcy5wdXNoKHskc2xvdFJlZk5vZGUkOnQsJG5vZGVUb1JlbG9jYXRlJDpyfSl9aWYocltcInMtc3JcIl0pe3JlbG9jYXRlTm9kZXMubWFwKChmdW5jdGlvbihlKXtpZihpc05vZGVMb2NhdGVkSW5TbG90KGUuJG5vZGVUb1JlbG9jYXRlJCxyW1wicy1zblwiXSkpe289cmVsb2NhdGVOb2Rlcy5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gZS4kbm9kZVRvUmVsb2NhdGUkPT09cn0pKTtpZihvJiYhZS4kc2xvdFJlZk5vZGUkKXtlLiRzbG90UmVmTm9kZSQ9by4kc2xvdFJlZk5vZGUkfX19KSl9fWVsc2UgaWYoIXJlbG9jYXRlTm9kZXMuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuJG5vZGVUb1JlbG9jYXRlJD09PXJ9KSkpe3JlbG9jYXRlTm9kZXMucHVzaCh7JG5vZGVUb1JlbG9jYXRlJDpyfSl9fX19aWYodC5ub2RlVHlwZT09PTEpe3JlbG9jYXRlU2xvdENvbnRlbnQodCl9fX07dmFyIGlzTm9kZUxvY2F0ZWRJblNsb3Q9ZnVuY3Rpb24oZSx0KXtpZihlLm5vZGVUeXBlPT09MSl7aWYoZS5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpPT09bnVsbCYmdD09PVwiXCIpe3JldHVybiB0cnVlfWlmKGUuZ2V0QXR0cmlidXRlKFwic2xvdFwiKT09PXQpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1pZihlW1wicy1zblwiXT09PXQpe3JldHVybiB0cnVlfXJldHVybiB0PT09XCJcIn07dmFyIGNhbGxOb2RlUmVmcz1mdW5jdGlvbihlKXt7ZS4kYXR0cnMkJiZlLiRhdHRycyQucmVmJiZlLiRhdHRycyQucmVmKG51bGwpO2UuJGNoaWxkcmVuJCYmZS4kY2hpbGRyZW4kLm1hcChjYWxsTm9kZVJlZnMpfX07dmFyIHJlbmRlclZkb209ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLiRob3N0RWxlbWVudCQ7dmFyIG49ZS4kY21wTWV0YSQ7dmFyIGE9ZS4kdm5vZGUkfHxuZXdWTm9kZShudWxsLG51bGwpO3ZhciBvPWlzSG9zdCh0KT90OmgobnVsbCxudWxsLHQpO2hvc3RUYWdOYW1lPXIudGFnTmFtZTtpZihuLiRhdHRyc1RvUmVmbGVjdCQpe28uJGF0dHJzJD1vLiRhdHRycyR8fHt9O24uJGF0dHJzVG9SZWZsZWN0JC5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVybiBvLiRhdHRycyRbbl09clt0XX0pKX1vLiR0YWckPW51bGw7by4kZmxhZ3MkfD00O2UuJHZub2RlJD1vO28uJGVsbSQ9YS4kZWxtJD1yLnNoYWRvd1Jvb3R8fHI7e3Njb3BlSWQ9cltcInMtc2NcIl19e2NvbnRlbnRSZWY9cltcInMtY3JcIl07dXNlTmF0aXZlU2hhZG93RG9tPShuLiRmbGFncyQmMSkhPT0wO2NoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eT1mYWxzZX1wYXRjaChhLG8pO3twbHQuJGZsYWdzJHw9MTtpZihjaGVja1Nsb3RSZWxvY2F0ZSl7cmVsb2NhdGVTbG90Q29udGVudChvLiRlbG0kKTt2YXIgcz12b2lkIDA7dmFyIGk9dm9pZCAwO3ZhciBsPXZvaWQgMDt2YXIgJD12b2lkIDA7dmFyIGM9dm9pZCAwO3ZhciBmPXZvaWQgMDt2YXIgdT0wO2Zvcig7dTxyZWxvY2F0ZU5vZGVzLmxlbmd0aDt1Kyspe3M9cmVsb2NhdGVOb2Rlc1t1XTtpPXMuJG5vZGVUb1JlbG9jYXRlJDtpZighaVtcInMtb2xcIl0pe2w9ZG9jLmNyZWF0ZVRleHROb2RlKFwiXCIpO2xbXCJzLW5yXCJdPWk7aS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpW1wicy1vbFwiXT1sLGkpfX1mb3IodT0wO3U8cmVsb2NhdGVOb2Rlcy5sZW5ndGg7dSsrKXtzPXJlbG9jYXRlTm9kZXNbdV07aT1zLiRub2RlVG9SZWxvY2F0ZSQ7aWYocy4kc2xvdFJlZk5vZGUkKXskPXMuJHNsb3RSZWZOb2RlJC5wYXJlbnROb2RlO2M9cy4kc2xvdFJlZk5vZGUkLm5leHRTaWJsaW5nO2w9aVtcInMtb2xcIl07d2hpbGUobD1sLnByZXZpb3VzU2libGluZyl7Zj1sW1wicy1uclwiXTtpZihmJiZmW1wicy1zblwiXT09PWlbXCJzLXNuXCJdJiYkPT09Zi5wYXJlbnROb2RlKXtmPWYubmV4dFNpYmxpbmc7aWYoIWZ8fCFmW1wicy1uclwiXSl7Yz1mO2JyZWFrfX19aWYoIWMmJiQhPT1pLnBhcmVudE5vZGV8fGkubmV4dFNpYmxpbmchPT1jKXtpZihpIT09Yyl7aWYoIWlbXCJzLWhuXCJdJiZpW1wicy1vbFwiXSl7aVtcInMtaG5cIl09aVtcInMtb2xcIl0ucGFyZW50Tm9kZS5ub2RlTmFtZX0kLmluc2VydEJlZm9yZShpLGMpfX19ZWxzZXtpZihpLm5vZGVUeXBlPT09MSl7aS5oaWRkZW49dHJ1ZX19fX1pZihjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpe3VwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkoby4kZWxtJCl9cGx0LiRmbGFncyQmPX4xO3JlbG9jYXRlTm9kZXMubGVuZ3RoPTB9fTt2YXIgZ2V0RWxlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZ2V0SG9zdFJlZihlKS4kaG9zdEVsZW1lbnQkfTt2YXIgY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWdldEVsZW1lbnQoZSk7cmV0dXJue2VtaXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVtaXRFdmVudChuLHQse2J1YmJsZXM6ISEociY0KSxjb21wb3NlZDohIShyJjIpLGNhbmNlbGFibGU6ISEociYxKSxkZXRhaWw6ZX0pfX19O3ZhciBlbWl0RXZlbnQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXBsdC5jZSh0LHIpO2UuZGlzcGF0Y2hFdmVudChuKTtyZXR1cm4gbn07dmFyIGF0dGFjaFRvQW5jZXN0b3I9ZnVuY3Rpb24oZSx0KXtpZih0JiYhZS4kb25SZW5kZXJSZXNvbHZlJCYmdFtcInMtcFwiXSl7dFtcInMtcFwiXS5wdXNoKG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gZS4kb25SZW5kZXJSZXNvbHZlJD10fSkpKX19O3ZhciBzY2hlZHVsZVVwZGF0ZT1mdW5jdGlvbihlLHQpe3tlLiRmbGFncyR8PTE2fWlmKGUuJGZsYWdzJCY0KXtlLiRmbGFncyR8PTUxMjtyZXR1cm59YXR0YWNoVG9BbmNlc3RvcihlLGUuJGFuY2VzdG9yQ29tcG9uZW50JCk7dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4gZGlzcGF0Y2hIb29rcyhlLHQpfTtyZXR1cm4gd3JpdGVUYXNrKHIpfTt2YXIgZGlzcGF0Y2hIb29rcz1mdW5jdGlvbihlLHQpe3ZhciByPWNyZWF0ZVRpbWUoXCJzY2hlZHVsZVVwZGF0ZVwiLGUuJGNtcE1ldGEkLiR0YWdOYW1lJCk7dmFyIG49ZS4kbGF6eUluc3RhbmNlJDt2YXIgYTtpZih0KXt7ZS4kZmxhZ3MkfD0yNTY7aWYoZS4kcXVldWVkTGlzdGVuZXJzJCl7ZS4kcXVldWVkTGlzdGVuZXJzJC5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0scj1lWzFdO3JldHVybiBzYWZlQ2FsbChuLHQscil9KSk7ZS4kcXVldWVkTGlzdGVuZXJzJD1udWxsfX17YT1zYWZlQ2FsbChuLFwiY29tcG9uZW50V2lsbExvYWRcIil9fXthPXRoZW4oYSwoZnVuY3Rpb24oKXtyZXR1cm4gc2FmZUNhbGwobixcImNvbXBvbmVudFdpbGxSZW5kZXJcIil9KSl9cigpO3JldHVybiB0aGVuKGEsKGZ1bmN0aW9uKCl7cmV0dXJuIHVwZGF0ZUNvbXBvbmVudChlLG4sdCl9KSl9O3ZhciB1cGRhdGVDb21wb25lbnQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sYSxvLHMsaSxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbigkKXtuPWUuJGhvc3RFbGVtZW50JDthPWNyZWF0ZVRpbWUoXCJ1cGRhdGVcIixlLiRjbXBNZXRhJC4kdGFnTmFtZSQpO289bltcInMtcmNcIl07aWYocil7YXR0YWNoU3R5bGVzKGUpfXM9Y3JlYXRlVGltZShcInJlbmRlclwiLGUuJGNtcE1ldGEkLiR0YWdOYW1lJCk7e2NhbGxSZW5kZXIoZSx0KX1pZihvKXtvLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKTtuW1wicy1yY1wiXT11bmRlZmluZWR9cygpO2EoKTt7aT1uW1wicy1wXCJdO2w9ZnVuY3Rpb24oKXtyZXR1cm4gcG9zdFVwZGF0ZUNvbXBvbmVudChlKX07aWYoaS5sZW5ndGg9PT0wKXtsKCl9ZWxzZXtQcm9taXNlLmFsbChpKS50aGVuKGwpO2UuJGZsYWdzJHw9NDtpLmxlbmd0aD0wfX1yZXR1cm5bMl19KSl9KSl9O3ZhciBjYWxsUmVuZGVyPWZ1bmN0aW9uKGUsdCxyKXt0cnl7dD10LnJlbmRlciYmdC5yZW5kZXIoKTt7ZS4kZmxhZ3MkJj1+MTZ9e2UuJGZsYWdzJHw9Mn17e3tyZW5kZXJWZG9tKGUsdCl9fX19Y2F0Y2godCl7Y29uc29sZUVycm9yKHQsZS4kaG9zdEVsZW1lbnQkKX1yZXR1cm4gbnVsbH07dmFyIHBvc3RVcGRhdGVDb21wb25lbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS4kY21wTWV0YSQuJHRhZ05hbWUkO3ZhciByPWUuJGhvc3RFbGVtZW50JDt2YXIgbj1jcmVhdGVUaW1lKFwicG9zdFVwZGF0ZVwiLHQpO3ZhciBhPWUuJGxhenlJbnN0YW5jZSQ7dmFyIG89ZS4kYW5jZXN0b3JDb21wb25lbnQkO3tzYWZlQ2FsbChhLFwiY29tcG9uZW50RGlkUmVuZGVyXCIpfWlmKCEoZS4kZmxhZ3MkJjY0KSl7ZS4kZmxhZ3MkfD02NDt7YWRkSHlkcmF0ZWRGbGFnKHIpfXtzYWZlQ2FsbChhLFwiY29tcG9uZW50RGlkTG9hZFwiKX1uKCk7e2UuJG9uUmVhZHlSZXNvbHZlJChyKTtpZighbyl7YXBwRGlkTG9hZCgpfX19ZWxzZXt7c2FmZUNhbGwoYSxcImNvbXBvbmVudERpZFVwZGF0ZVwiKX1uKCl9e2UuJG9uSW5zdGFuY2VSZXNvbHZlJChyKX17aWYoZS4kb25SZW5kZXJSZXNvbHZlJCl7ZS4kb25SZW5kZXJSZXNvbHZlJCgpO2UuJG9uUmVuZGVyUmVzb2x2ZSQ9dW5kZWZpbmVkfWlmKGUuJGZsYWdzJCY1MTIpe25leHRUaWNrKChmdW5jdGlvbigpe3JldHVybiBzY2hlZHVsZVVwZGF0ZShlLGZhbHNlKX0pKX1lLiRmbGFncyQmPX4oNHw1MTIpfX07dmFyIGZvcmNlVXBkYXRlPWZ1bmN0aW9uKGUpe3t2YXIgdD1nZXRIb3N0UmVmKGUpO3ZhciByPXQuJGhvc3RFbGVtZW50JC5pc0Nvbm5lY3RlZDtpZihyJiYodC4kZmxhZ3MkJigyfDE2KSk9PT0yKXtzY2hlZHVsZVVwZGF0ZSh0LGZhbHNlKX1yZXR1cm4gcn19O3ZhciBhcHBEaWRMb2FkPWZ1bmN0aW9uKGUpe3thZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCl9bmV4dFRpY2soKGZ1bmN0aW9uKCl7cmV0dXJuIGVtaXRFdmVudCh3aW4sXCJhcHBsb2FkXCIse2RldGFpbDp7bmFtZXNwYWNlOk5BTUVTUEFDRX19KX0pKX07dmFyIHNhZmVDYWxsPWZ1bmN0aW9uKGUsdCxyKXtpZihlJiZlW3RdKXt0cnl7cmV0dXJuIGVbdF0ocil9Y2F0Y2goZSl7Y29uc29sZUVycm9yKGUpfX1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgdGhlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlJiZlLnRoZW4/ZS50aGVuKHQpOnQoKX07dmFyIGFkZEh5ZHJhdGVkRmxhZz1mdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc0xpc3QuYWRkKFwiaHlkcmF0ZWRcIil9O3ZhciBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQscixuKXt2YXIgYT1jcmVhdGVUaW1lKFwiaHlkcmF0ZUNsaWVudFwiLHQpO3ZhciBvPWUuc2hhZG93Um9vdDt2YXIgcz1bXTt2YXIgaT1bXTt2YXIgbD1vP1tdOm51bGw7dmFyICQ9bi4kdm5vZGUkPW5ld1ZOb2RlKHQsbnVsbCk7aWYoIXBsdC4kb3JnTG9jTm9kZXMkKXtpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKGRvYy5ib2R5LHBsdC4kb3JnTG9jTm9kZXMkPW5ldyBNYXApfWVbSFlEUkFURV9JRF09cjtlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0lEKTtjbGllbnRIeWRyYXRlKCQscyxpLGwsZSxlLHIpO3MubWFwKChmdW5jdGlvbihlKXt2YXIgcj1lLiRob3N0SWQkK1wiLlwiK2UuJG5vZGVJZCQ7dmFyIG49cGx0LiRvcmdMb2NOb2RlcyQuZ2V0KHIpO3ZhciBhPWUuJGVsbSQ7aWYobiYmc3VwcG9ydHNTaGFkb3cmJm5bXCJzLWVuXCJdPT09XCJcIil7bi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG4ubmV4dFNpYmxpbmcpfWlmKCFvKXthW1wicy1oblwiXT10O2lmKG4pe2FbXCJzLW9sXCJdPW47YVtcInMtb2xcIl1bXCJzLW5yXCJdPWF9fXBsdC4kb3JnTG9jTm9kZXMkLmRlbGV0ZShyKX0pKTtpZihvKXtsLm1hcCgoZnVuY3Rpb24oZSl7aWYoZSl7by5hcHBlbmRDaGlsZChlKX19KSl9YSgpfTt2YXIgY2xpZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQscixuLGEsbyxzKXt2YXIgaTt2YXIgbDt2YXIgJDt2YXIgYztpZihvLm5vZGVUeXBlPT09MSl7aT1vLmdldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtpZihpKXtsPWkuc3BsaXQoXCIuXCIpO2lmKGxbMF09PT1zfHxsWzBdPT09XCIwXCIpeyQ9eyRmbGFncyQ6MCwkaG9zdElkJDpsWzBdLCRub2RlSWQkOmxbMV0sJGRlcHRoJDpsWzJdLCRpbmRleCQ6bFszXSwkdGFnJDpvLnRhZ05hbWUudG9Mb3dlckNhc2UoKSwkZWxtJDpvLCRhdHRycyQ6bnVsbCwkY2hpbGRyZW4kOm51bGwsJGtleSQ6bnVsbCwkbmFtZSQ6bnVsbCwkdGV4dCQ6bnVsbH07dC5wdXNoKCQpO28ucmVtb3ZlQXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQpO2lmKCFlLiRjaGlsZHJlbiQpe2UuJGNoaWxkcmVuJD1bXX1lLiRjaGlsZHJlbiRbJC4kaW5kZXgkXT0kO2U9JDtpZihuJiYkLiRkZXB0aCQ9PT1cIjBcIil7blskLiRpbmRleCRdPSQuJGVsbSR9fX1mb3IoYz1vLmNoaWxkTm9kZXMubGVuZ3RoLTE7Yz49MDtjLS0pe2NsaWVudEh5ZHJhdGUoZSx0LHIsbixhLG8uY2hpbGROb2Rlc1tjXSxzKX1pZihvLnNoYWRvd1Jvb3Qpe2ZvcihjPW8uc2hhZG93Um9vdC5jaGlsZE5vZGVzLmxlbmd0aC0xO2M+PTA7Yy0tKXtjbGllbnRIeWRyYXRlKGUsdCxyLG4sYSxvLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tjXSxzKX19fWVsc2UgaWYoby5ub2RlVHlwZT09PTgpe2w9by5ub2RlVmFsdWUuc3BsaXQoXCIuXCIpO2lmKGxbMV09PT1zfHxsWzFdPT09XCIwXCIpe2k9bFswXTskPXskZmxhZ3MkOjAsJGhvc3RJZCQ6bFsxXSwkbm9kZUlkJDpsWzJdLCRkZXB0aCQ6bFszXSwkaW5kZXgkOmxbNF0sJGVsbSQ6bywkYXR0cnMkOm51bGwsJGNoaWxkcmVuJDpudWxsLCRrZXkkOm51bGwsJG5hbWUkOm51bGwsJHRhZyQ6bnVsbCwkdGV4dCQ6bnVsbH07aWYoaT09PVRFWFRfTk9ERV9JRCl7JC4kZWxtJD1vLm5leHRTaWJsaW5nO2lmKCQuJGVsbSQmJiQuJGVsbSQubm9kZVR5cGU9PT0zKXskLiR0ZXh0JD0kLiRlbG0kLnRleHRDb250ZW50O3QucHVzaCgkKTtvLnJlbW92ZSgpO2lmKCFlLiRjaGlsZHJlbiQpe2UuJGNoaWxkcmVuJD1bXX1lLiRjaGlsZHJlbiRbJC4kaW5kZXgkXT0kO2lmKG4mJiQuJGRlcHRoJD09PVwiMFwiKXtuWyQuJGluZGV4JF09JC4kZWxtJH19fWVsc2UgaWYoJC4kaG9zdElkJD09PXMpe2lmKGk9PT1TTE9UX05PREVfSUQpeyQuJHRhZyQ9XCJzbG90XCI7aWYobFs1XSl7b1tcInMtc25cIl09JC4kbmFtZSQ9bFs1XX1lbHNle29bXCJzLXNuXCJdPVwiXCJ9b1tcInMtc3JcIl09dHJ1ZTtpZihuKXskLiRlbG0kPWRvYy5jcmVhdGVFbGVtZW50KCQuJHRhZyQpO2lmKCQuJG5hbWUkKXskLiRlbG0kLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwkLiRuYW1lJCl9by5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgkLiRlbG0kLG8pO28ucmVtb3ZlKCk7aWYoJC4kZGVwdGgkPT09XCIwXCIpe25bJC4kaW5kZXgkXT0kLiRlbG0kfX1yLnB1c2goJCk7aWYoIWUuJGNoaWxkcmVuJCl7ZS4kY2hpbGRyZW4kPVtdfWUuJGNoaWxkcmVuJFskLiRpbmRleCRdPSR9ZWxzZSBpZihpPT09Q09OVEVOVF9SRUZfSUQpe2lmKG4pe28ucmVtb3ZlKCl9ZWxzZXthW1wicy1jclwiXT1vO29bXCJzLWNuXCJdPXRydWV9fX19fWVsc2UgaWYoZSYmZS4kdGFnJD09PVwic3R5bGVcIil7dmFyIGY9bmV3Vk5vZGUobnVsbCxvLnRleHRDb250ZW50KTtmLiRlbG0kPW87Zi4kaW5kZXgkPVwiMFwiO2UuJGNoaWxkcmVuJD1bZl19fTt2YXIgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZT1mdW5jdGlvbihlLHQpe2lmKGUubm9kZVR5cGU9PT0xKXt2YXIgcj0wO2Zvcig7cjxlLmNoaWxkTm9kZXMubGVuZ3RoO3IrKyl7aW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShlLmNoaWxkTm9kZXNbcl0sdCl9aWYoZS5zaGFkb3dSb290KXtmb3Iocj0wO3I8ZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoO3IrKyl7aW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tyXSx0KX19fWVsc2UgaWYoZS5ub2RlVHlwZT09PTgpe3ZhciBuPWUubm9kZVZhbHVlLnNwbGl0KFwiLlwiKTtpZihuWzBdPT09T1JHX0xPQ0FUSU9OX0lEKXt0LnNldChuWzFdK1wiLlwiK25bMl0sZSk7ZS5ub2RlVmFsdWU9XCJcIjtlW1wicy1lblwiXT1uWzNdfX19O3ZhciBwYXJzZVByb3BlcnR5VmFsdWU9ZnVuY3Rpb24oZSx0KXtpZihlIT1udWxsJiYhaXNDb21wbGV4VHlwZShlKSl7aWYodCY0KXtyZXR1cm4gZT09PVwiZmFsc2VcIj9mYWxzZTplPT09XCJcInx8ISFlfWlmKHQmMil7cmV0dXJuIHBhcnNlRmxvYXQoZSl9aWYodCYxKXtyZXR1cm4gU3RyaW5nKGUpfXJldHVybiBlfXJldHVybiBlfTt2YXIgZ2V0VmFsdWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZ2V0SG9zdFJlZihlKS4kaW5zdGFuY2VWYWx1ZXMkLmdldCh0KX07dmFyIHNldFZhbHVlPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhPWdldEhvc3RSZWYoZSk7dmFyIG89YS4kaG9zdEVsZW1lbnQkO3ZhciBzPWEuJGluc3RhbmNlVmFsdWVzJC5nZXQodCk7dmFyIGk9YS4kZmxhZ3MkO3ZhciBsPWEuJGxhenlJbnN0YW5jZSQ7cj1wYXJzZVByb3BlcnR5VmFsdWUocixuLiRtZW1iZXJzJFt0XVswXSk7dmFyICQ9TnVtYmVyLmlzTmFOKHMpJiZOdW1iZXIuaXNOYU4ocik7dmFyIGM9ciE9PXMmJiEkO2lmKCghKGkmOCl8fHM9PT11bmRlZmluZWQpJiZjKXthLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHQscik7aWYobCl7aWYobi4kd2F0Y2hlcnMkJiZpJjEyOCl7dmFyIGY9bi4kd2F0Y2hlcnMkW3RdO2lmKGYpe2YubWFwKChmdW5jdGlvbihlKXt0cnl7bFtlXShyLHMsdCl9Y2F0Y2goZSl7Y29uc29sZUVycm9yKGUsbyl9fSkpfX1pZigoaSYoMnwxNikpPT09Mil7c2NoZWR1bGVVcGRhdGUoYSxmYWxzZSl9fX19O3ZhciBwcm94eUNvbXBvbmVudD1mdW5jdGlvbihlLHQscil7aWYodC4kbWVtYmVycyQpe2lmKGUud2F0Y2hlcnMpe3QuJHdhdGNoZXJzJD1lLndhdGNoZXJzfXZhciBuPU9iamVjdC5lbnRyaWVzKHQuJG1lbWJlcnMkKTt2YXIgYT1lLnByb3RvdHlwZTtuLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG49ZVswXSxvPWVbMV1bMF07aWYobyYzMXx8ciYyJiZvJjMyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxuLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0VmFsdWUodGhpcyxuKX0sc2V0OmZ1bmN0aW9uKGUpe3NldFZhbHVlKHRoaXMsbixlLHQpfSxjb25maWd1cmFibGU6dHJ1ZSxlbnVtZXJhYmxlOnRydWV9KX1lbHNlIGlmKHImMSYmbyY2NCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsbix7dmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlW3RdPWFyZ3VtZW50c1t0XX12YXIgcj1nZXRIb3N0UmVmKHRoaXMpO3JldHVybiByLiRvbkluc3RhbmNlUHJvbWlzZSQudGhlbigoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4odD1yLiRsYXp5SW5zdGFuY2UkKVtuXS5hcHBseSh0LGUpfSkpfX0pfX0pKTtpZihyJjEpe3ZhciBvPW5ldyBNYXA7YS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXM7cGx0LmptcCgoZnVuY3Rpb24oKXt2YXIgdD1vLmdldChlKTtpZihuLmhhc093blByb3BlcnR5KHQpKXtyPW5bdF07ZGVsZXRlIG5bdF19ZWxzZSBpZihhLmhhc093blByb3BlcnR5KHQpJiZ0eXBlb2Ygblt0XT09PVwibnVtYmVyXCImJm5bdF09PXIpe3JldHVybn1uW3RdPXI9PT1udWxsJiZ0eXBlb2Ygblt0XT09PVwiYm9vbGVhblwiP2ZhbHNlOnJ9KSl9O2Uub2JzZXJ2ZWRBdHRyaWJ1dGVzPW4uZmlsdGVyKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLHI9ZVsxXTtyZXR1cm4gclswXSYxNX0pKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciByPWVbMF0sbj1lWzFdO3ZhciBhPW5bMV18fHI7by5zZXQoYSxyKTtpZihuWzBdJjUxMil7dC4kYXR0cnNUb1JlZmxlY3QkLnB1c2goW3IsYV0pfXJldHVybiBhfSkpfX1yZXR1cm4gZX07dmFyIGluaXRpYWxpemVDb21wb25lbnQ9ZnVuY3Rpb24oZSx0LHIsbixhKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLG8scyxpLGwsJCxjO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihmKXtzd2l0Y2goZi5sYWJlbCl7Y2FzZSAwOmlmKCEoKHQuJGZsYWdzJCYzMik9PT0wKSlyZXR1cm5bMywzXTt0LiRmbGFncyR8PTMyO2E9bG9hZE1vZHVsZShyKTtpZighYS50aGVuKXJldHVyblszLDJdO249dW5pcXVlVGltZSgpO3JldHVybls0LGFdO2Nhc2UgMTphPWYuc2VudCgpO24oKTtmLmxhYmVsPTI7Y2FzZSAyOmlmKCFhLmlzUHJveGllZCl7e3IuJHdhdGNoZXJzJD1hLndhdGNoZXJzfXByb3h5Q29tcG9uZW50KGEsciwyKTthLmlzUHJveGllZD10cnVlfW89Y3JlYXRlVGltZShcImNyZWF0ZUluc3RhbmNlXCIsci4kdGFnTmFtZSQpO3t0LiRmbGFncyR8PTh9dHJ5e25ldyBhKHQpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlKX17dC4kZmxhZ3MkJj1+OH17dC4kZmxhZ3MkfD0xMjh9bygpO2ZpcmVDb25uZWN0ZWRDYWxsYmFjayh0LiRsYXp5SW5zdGFuY2UkKTtpZihhLnN0eWxlKXtzPWEuc3R5bGU7aWYodHlwZW9mIHMhPT1cInN0cmluZ1wiKXtzPXNbdC4kbW9kZU5hbWUkPWNvbXB1dGVNb2RlKGUpXX1pPWdldFNjb3BlSWQocix0LiRtb2RlTmFtZSQpO2lmKCFzdHlsZXMuaGFzKGkpKXtsPWNyZWF0ZVRpbWUoXCJyZWdpc3RlclN0eWxlc1wiLHIuJHRhZ05hbWUkKTtyZWdpc3RlclN0eWxlKGkscywhIShyLiRmbGFncyQmMSkpO2woKX19Zi5sYWJlbD0zO2Nhc2UgMzokPXQuJGFuY2VzdG9yQ29tcG9uZW50JDtjPWZ1bmN0aW9uKCl7cmV0dXJuIHNjaGVkdWxlVXBkYXRlKHQsdHJ1ZSl9O2lmKCQmJiRbXCJzLXJjXCJdKXskW1wicy1yY1wiXS5wdXNoKGMpfWVsc2V7YygpfXJldHVyblsyXX19KSl9KSl9O3ZhciBmaXJlQ29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7e3NhZmVDYWxsKGUsXCJjb25uZWN0ZWRDYWxsYmFja1wiKX19O3ZhciBjb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbihlKXtpZigocGx0LiRmbGFncyQmMSk9PT0wKXt2YXIgdD1nZXRIb3N0UmVmKGUpO3ZhciByPXQuJGNtcE1ldGEkO3ZhciBuPWNyZWF0ZVRpbWUoXCJjb25uZWN0ZWRDYWxsYmFja1wiLHIuJHRhZ05hbWUkKTtpZighKHQuJGZsYWdzJCYxKSl7dC4kZmxhZ3MkfD0xO3ZhciBhPXZvaWQgMDt7YT1lLmdldEF0dHJpYnV0ZShIWURSQVRFX0lEKTtpZihhKXtpZihyLiRmbGFncyQmMSl7dmFyIG89YWRkU3R5bGUoZS5zaGFkb3dSb290LHIsZS5nZXRBdHRyaWJ1dGUoXCJzLW1vZGVcIikpO2UuY2xhc3NMaXN0LnJlbW92ZShvK1wiLWhcIixvK1wiLXNcIil9aW5pdGlhbGl6ZUNsaWVudEh5ZHJhdGUoZSxyLiR0YWdOYW1lJCxhLHQpfX1pZighYSl7aWYoci4kZmxhZ3MkJig0fDgpKXtzZXRDb250ZW50UmVmZXJlbmNlKGUpfX17dmFyIHM9ZTt3aGlsZShzPXMucGFyZW50Tm9kZXx8cy5ob3N0KXtpZihzLm5vZGVUeXBlPT09MSYmcy5oYXNBdHRyaWJ1dGUoXCJzLWlkXCIpJiZzW1wicy1wXCJdfHxzW1wicy1wXCJdKXthdHRhY2hUb0FuY2VzdG9yKHQsdC4kYW5jZXN0b3JDb21wb25lbnQkPXMpO2JyZWFrfX19aWYoci4kbWVtYmVycyQpe09iamVjdC5lbnRyaWVzKHIuJG1lbWJlcnMkKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sbj10WzFdWzBdO2lmKG4mMzEmJmUuaGFzT3duUHJvcGVydHkocikpe3ZhciBhPWVbcl07ZGVsZXRlIGVbcl07ZVtyXT1hfX0pKX17bmV4dFRpY2soKGZ1bmN0aW9uKCl7cmV0dXJuIGluaXRpYWxpemVDb21wb25lbnQoZSx0LHIpfSkpfX1lbHNle2FkZEhvc3RFdmVudExpc3RlbmVycyhlLHQsci4kbGlzdGVuZXJzJCk7ZmlyZUNvbm5lY3RlZENhbGxiYWNrKHQuJGxhenlJbnN0YW5jZSQpfW4oKX19O3ZhciBzZXRDb250ZW50UmVmZXJlbmNlPWZ1bmN0aW9uKGUpe3ZhciB0PWVbXCJzLWNyXCJdPWRvYy5jcmVhdGVDb21tZW50KFwiXCIpO3RbXCJzLWNuXCJdPXRydWU7ZS5pbnNlcnRCZWZvcmUodCxlLmZpcnN0Q2hpbGQpfTt2YXIgZGlzY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oZSl7aWYoKHBsdC4kZmxhZ3MkJjEpPT09MCl7dmFyIHQ9Z2V0SG9zdFJlZihlKTt2YXIgcj10LiRsYXp5SW5zdGFuY2UkO3tpZih0LiRybUxpc3RlbmVycyQpe3QuJHJtTGlzdGVuZXJzJC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSk7dC4kcm1MaXN0ZW5lcnMkPXVuZGVmaW5lZH19e3NhZmVDYWxsKHIsXCJkaXNjb25uZWN0ZWRDYWxsYmFja1wiKX19fTt2YXIgYm9vdHN0cmFwTGF6eT1mdW5jdGlvbihlLHQpe2lmKHQ9PT12b2lkIDApe3Q9e319dmFyIHI9Y3JlYXRlVGltZSgpO3ZhciBuPVtdO3ZhciBhPXQuZXhjbHVkZXx8W107dmFyIG89d2luLmN1c3RvbUVsZW1lbnRzO3ZhciBzPWRvYy5oZWFkO3ZhciBpPXMucXVlcnlTZWxlY3RvcihcIm1ldGFbY2hhcnNldF1cIik7dmFyIGw9ZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTt2YXIgJD1bXTt2YXIgYz1kb2MucXVlcnlTZWxlY3RvckFsbChcIltcIi5jb25jYXQoSFlEUkFURURfU1RZTEVfSUQsXCJdXCIpKTt2YXIgZjt2YXIgdT10cnVlO3ZhciBkPTA7T2JqZWN0LmFzc2lnbihwbHQsdCk7cGx0LiRyZXNvdXJjZXNVcmwkPW5ldyBVUkwodC5yZXNvdXJjZXNVcmx8fFwiLi9cIixkb2MuYmFzZVVSSSkuaHJlZjt7cGx0LiRmbGFncyR8PTJ9e2Zvcig7ZDxjLmxlbmd0aDtkKyspe3JlZ2lzdGVyU3R5bGUoY1tkXS5nZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQpLGNvbnZlcnRTY29wZWRUb1NoYWRvdyhjW2RdLmlubmVySFRNTCksdHJ1ZSl9fWUubWFwKChmdW5jdGlvbihlKXtlWzFdLm1hcCgoZnVuY3Rpb24odCl7dmFyIHI9eyRmbGFncyQ6dFswXSwkdGFnTmFtZSQ6dFsxXSwkbWVtYmVycyQ6dFsyXSwkbGlzdGVuZXJzJDp0WzNdfTt7ci4kbWVtYmVycyQ9dFsyXX17ci4kbGlzdGVuZXJzJD10WzNdfXtyLiRhdHRyc1RvUmVmbGVjdCQ9W119e3IuJHdhdGNoZXJzJD17fX12YXIgcz1yLiR0YWdOYW1lJDt2YXIgaT1mdW5jdGlvbihlKXtfX2V4dGVuZHModCxlKTtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3Q9bjtyZWdpc3Rlckhvc3QodCxyKTtpZihyLiRmbGFncyQmMSl7e3t0LmF0dGFjaFNoYWRvdyh7bW9kZTpcIm9wZW5cIixkZWxlZ2F0ZXNGb2N1czohIShyLiRmbGFncyQmMTYpfSl9fX1yZXR1cm4gbn10LnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoZil7Y2xlYXJUaW1lb3V0KGYpO2Y9bnVsbH1pZih1KXskLnB1c2godGhpcyl9ZWxzZXtwbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBjb25uZWN0ZWRDYWxsYmFjayhlKX0pKX19O3QucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztwbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBkaXNjb25uZWN0ZWRDYWxsYmFjayhlKX0pKX07dC5wcm90b3R5cGUuY29tcG9uZW50T25SZWFkeT1mdW5jdGlvbigpe3JldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSR9O3JldHVybiB0fShIVE1MRWxlbWVudCk7ci4kbGF6eUJ1bmRsZUlkJD1lWzBdO2lmKCFhLmluY2x1ZGVzKHMpJiYhby5nZXQocykpe24ucHVzaChzKTtvLmRlZmluZShzLHByb3h5Q29tcG9uZW50KGksciwxKSl9fSkpfSkpO3tsLmlubmVySFRNTD1uK0hZRFJBVEVEX0NTUztsLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVzXCIsXCJcIik7cy5pbnNlcnRCZWZvcmUobCxpP2kubmV4dFNpYmxpbmc6cy5maXJzdENoaWxkKX11PWZhbHNlO2lmKCQubGVuZ3RoKXskLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29ubmVjdGVkQ2FsbGJhY2soKX0pKX1lbHNle3twbHQuam1wKChmdW5jdGlvbigpe3JldHVybiBmPXNldFRpbWVvdXQoYXBwRGlkTG9hZCwzMCl9KSl9fXIoKX07dmFyIGdldEFzc2V0UGF0aD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVVJMKGUscGx0LiRyZXNvdXJjZXNVcmwkKTtyZXR1cm4gdC5vcmlnaW4hPT13aW4ubG9jYXRpb24ub3JpZ2luP3QuaHJlZjp0LnBhdGhuYW1lfTt2YXIgaG9zdFJlZnM9bmV3IFdlYWtNYXA7dmFyIGdldEhvc3RSZWY9ZnVuY3Rpb24oZSl7cmV0dXJuIGhvc3RSZWZzLmdldChlKX07dmFyIHJlZ2lzdGVySW5zdGFuY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaG9zdFJlZnMuc2V0KHQuJGxhenlJbnN0YW5jZSQ9ZSx0KX07dmFyIHJlZ2lzdGVySG9zdD1mdW5jdGlvbihlLHQpe3ZhciByPXskZmxhZ3MkOjAsJGhvc3RFbGVtZW50JDplLCRjbXBNZXRhJDp0LCRpbnN0YW5jZVZhbHVlcyQ6bmV3IE1hcH07e3IuJG9uSW5zdGFuY2VQcm9taXNlJD1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHIuJG9uSW5zdGFuY2VSZXNvbHZlJD1lfSkpfXtyLiRvblJlYWR5UHJvbWlzZSQ9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiByLiRvblJlYWR5UmVzb2x2ZSQ9ZX0pKTtlW1wicy1wXCJdPVtdO2VbXCJzLXJjXCJdPVtdfWFkZEhvc3RFdmVudExpc3RlbmVycyhlLHIsdC4kbGlzdGVuZXJzJCk7cmV0dXJuIGhvc3RSZWZzLnNldChlLHIpfTt2YXIgaXNNZW1iZXJJbkVsZW1lbnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCBpbiBlfTt2YXIgY29uc29sZUVycm9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKDAsY29uc29sZS5lcnJvcikoZSx0KX07dmFyIGNtcE1vZHVsZXM9bmV3IE1hcDt2YXIgbG9hZE1vZHVsZT1mdW5jdGlvbihlLHQscil7dmFyIG49ZS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLFwiX1wiKTt2YXIgYT1lLiRsYXp5QnVuZGxlSWQkO3ZhciBvPWNtcE1vZHVsZXMuZ2V0KGEpO2lmKG8pe3JldHVybiBvW25dfXJldHVybiBpbXBvcnQoXCIuL1wiLmNvbmNhdChhLFwiLmVudHJ5LmpzXCIpLmNvbmNhdChcIlwiKSkudGhlbigoZnVuY3Rpb24oZSl7e2NtcE1vZHVsZXMuc2V0KGEsZSl9cmV0dXJuIGVbbl19KSxjb25zb2xlRXJyb3IpfTt2YXIgc3R5bGVzPW5ldyBNYXA7dmFyIG1vZGVSZXNvbHV0aW9uQ2hhaW49W107dmFyIHF1ZXVlRG9tUmVhZHM9W107dmFyIHF1ZXVlRG9tV3JpdGVzPVtdO3ZhciBxdWV1ZVRhc2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24ocil7ZS5wdXNoKHIpO2lmKCFxdWV1ZVBlbmRpbmcpe3F1ZXVlUGVuZGluZz10cnVlO2lmKHQmJnBsdC4kZmxhZ3MkJjQpe25leHRUaWNrKGZsdXNoKX1lbHNle3BsdC5yYWYoZmx1c2gpfX19fTt2YXIgY29uc3VtZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7dHJ5e2VbdF0ocGVyZm9ybWFuY2Uubm93KCkpfWNhdGNoKGUpe2NvbnNvbGVFcnJvcihlKX19ZS5sZW5ndGg9MH07dmFyIGZsdXNoPWZ1bmN0aW9uKCl7Y29uc3VtZShxdWV1ZURvbVJlYWRzKTt7Y29uc3VtZShxdWV1ZURvbVdyaXRlcyk7aWYocXVldWVQZW5kaW5nPXF1ZXVlRG9tUmVhZHMubGVuZ3RoPjApe3BsdC5yYWYoZmx1c2gpfX19O3ZhciBuZXh0VGljaz1mdW5jdGlvbihlKXtyZXR1cm4gcHJvbWlzZVJlc29sdmUoKS50aGVuKGUpfTt2YXIgcmVhZFRhc2s9cXVldWVUYXNrKHF1ZXVlRG9tUmVhZHMsZmFsc2UpO3ZhciB3cml0ZVRhc2s9cXVldWVUYXNrKHF1ZXVlRG9tV3JpdGVzLHRydWUpO3ZhciBCdWlsZD17aXNEZXY6ZmFsc2UsaXNCcm93c2VyOnRydWUsaXNTZXJ2ZXI6ZmFsc2UsaXNUZXN0aW5nOmZhbHNlfTtleHBvcnR7QnVpbGQgYXMgQixIb3N0IGFzIEgsTkFNRVNQQUNFIGFzIE4sc2V0TW9kZSBhcyBhLGJvb3RzdHJhcExhenkgYXMgYix3cml0ZVRhc2sgYXMgYyxkb2MgYXMgZCxjcmVhdGVFdmVudCBhcyBlLHJlYWRUYXNrIGFzIGYsZ2V0TW9kZSBhcyBnLGgsZ2V0RWxlbWVudCBhcyBpLGZvcmNlVXBkYXRlIGFzIGosZ2V0QXNzZXRQYXRoIGFzIGsscHJvbWlzZVJlc29sdmUgYXMgcCxyZWdpc3Rlckluc3RhbmNlIGFzIHIsc2V0UGxhdGZvcm1IZWxwZXJzIGFzIHMsd2luIGFzIHd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2896\n')},8186:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "I": () => (/* binding */ IonicSafeString),\n/* harmony export */   "s": () => (/* binding */ sanitizeDOMString)\n/* harmony export */ });\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar sanitizeDOMString=function(e){try{if(e instanceof IonicSafeString){return e.value}if(!isSanitizerEnabled()||typeof e!=="string"||e===""){return e}var r=document.createDocumentFragment();var n=document.createElement("div");r.appendChild(n);n.innerHTML=e;blockedTags.forEach((function(e){var n=r.querySelectorAll(e);for(var t=n.length-1;t>=0;t--){var i=n[t];if(i.parentNode){i.parentNode.removeChild(i)}else{r.removeChild(i)}var a=getElementChildren(i);for(var l=0;l<a.length;l++){sanitizeElement(a[l])}}}));var t=getElementChildren(r);for(var i=0;i<t.length;i++){sanitizeElement(t[i])}var a=document.createElement("div");a.appendChild(r);var l=a.querySelector("div");return l!==null?l.innerHTML:a.innerHTML}catch(e){console.error(e);return""}};var sanitizeElement=function(e){if(e.nodeType&&e.nodeType!==1){return}for(var r=e.attributes.length-1;r>=0;r--){var n=e.attributes.item(r);var t=n.name;if(!allowedAttributes.includes(t.toLowerCase())){e.removeAttribute(t);continue}var i=n.value;if(i!=null&&i.toLowerCase().includes("javascript:")){e.removeAttribute(t)}}var a=getElementChildren(e);for(var r=0;r<a.length;r++){sanitizeElement(a[r])}};var getElementChildren=function(e){return e.children!=null?e.children:e.childNodes};var isSanitizerEnabled=function(){var e=window;var r=e&&e.Ionic&&e.Ionic.config;if(r){if(r.get){return r.get("sanitizerEnabled",true)}else{return r.sanitizerEnabled===true||r.sanitizerEnabled===undefined}}return true};var allowedAttributes=["class","id","href","src","name","slot"];var blockedTags=["script","style","iframe","meta","link","object","embed"];var IonicSafeString=function(){function e(e){this.value=e}return e}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLGlDQUFpQyxlQUFlLHVEQUF1RCxTQUFTLHdDQUF3QyxvQ0FBb0MsaUJBQWlCLGNBQWMsaUNBQWlDLDRCQUE0QixxQkFBcUIsS0FBSyxLQUFLLFdBQVcsaUJBQWlCLDRCQUE0QixLQUFLLGlCQUFpQiw0QkFBNEIsWUFBWSxXQUFXLEtBQUssd0JBQXdCLEdBQUcsNEJBQTRCLFlBQVksV0FBVyxLQUFLLHNCQUFzQixvQ0FBb0MsaUJBQWlCLDZCQUE2Qix3Q0FBd0MsU0FBUyxpQkFBaUIsV0FBVyxnQ0FBZ0MsK0JBQStCLE9BQU8sZ0NBQWdDLEtBQUssS0FBSywyQkFBMkIsYUFBYSxpREFBaUQscUJBQXFCLFNBQVMsY0FBYyxxREFBcUQsc0JBQXNCLDRCQUE0QixZQUFZLFdBQVcsS0FBSyx3QkFBd0IsbUNBQW1DLGlEQUFpRCxrQ0FBa0MsYUFBYSxpQ0FBaUMsTUFBTSxVQUFVLHNDQUFzQyxLQUFLLGtFQUFrRSxhQUFhLGdFQUFnRSwyRUFBMkUsK0JBQStCLGNBQWMsYUFBYSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtYzg0MWM5MzMuanM/MWJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xudmFyIHNhbml0aXplRE9NU3RyaW5nPWZ1bmN0aW9uKGUpe3RyeXtpZihlIGluc3RhbmNlb2YgSW9uaWNTYWZlU3RyaW5nKXtyZXR1cm4gZS52YWx1ZX1pZighaXNTYW5pdGl6ZXJFbmFibGVkKCl8fHR5cGVvZiBlIT09XCJzdHJpbmdcInx8ZT09PVwiXCIpe3JldHVybiBlfXZhciByPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt2YXIgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3IuYXBwZW5kQ2hpbGQobik7bi5pbm5lckhUTUw9ZTtibG9ja2VkVGFncy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj1yLnF1ZXJ5U2VsZWN0b3JBbGwoZSk7Zm9yKHZhciB0PW4ubGVuZ3RoLTE7dD49MDt0LS0pe3ZhciBpPW5bdF07aWYoaS5wYXJlbnROb2RlKXtpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaSl9ZWxzZXtyLnJlbW92ZUNoaWxkKGkpfXZhciBhPWdldEVsZW1lbnRDaGlsZHJlbihpKTtmb3IodmFyIGw9MDtsPGEubGVuZ3RoO2wrKyl7c2FuaXRpemVFbGVtZW50KGFbbF0pfX19KSk7dmFyIHQ9Z2V0RWxlbWVudENoaWxkcmVuKHIpO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXtzYW5pdGl6ZUVsZW1lbnQodFtpXSl9dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthLmFwcGVuZENoaWxkKHIpO3ZhciBsPWEucXVlcnlTZWxlY3RvcihcImRpdlwiKTtyZXR1cm4gbCE9PW51bGw/bC5pbm5lckhUTUw6YS5pbm5lckhUTUx9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKTtyZXR1cm5cIlwifX07dmFyIHNhbml0aXplRWxlbWVudD1mdW5jdGlvbihlKXtpZihlLm5vZGVUeXBlJiZlLm5vZGVUeXBlIT09MSl7cmV0dXJufWZvcih2YXIgcj1lLmF0dHJpYnV0ZXMubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciBuPWUuYXR0cmlidXRlcy5pdGVtKHIpO3ZhciB0PW4ubmFtZTtpZighYWxsb3dlZEF0dHJpYnV0ZXMuaW5jbHVkZXModC50b0xvd2VyQ2FzZSgpKSl7ZS5yZW1vdmVBdHRyaWJ1dGUodCk7Y29udGludWV9dmFyIGk9bi52YWx1ZTtpZihpIT1udWxsJiZpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJqYXZhc2NyaXB0OlwiKSl7ZS5yZW1vdmVBdHRyaWJ1dGUodCl9fXZhciBhPWdldEVsZW1lbnRDaGlsZHJlbihlKTtmb3IodmFyIHI9MDtyPGEubGVuZ3RoO3IrKyl7c2FuaXRpemVFbGVtZW50KGFbcl0pfX07dmFyIGdldEVsZW1lbnRDaGlsZHJlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGlsZHJlbiE9bnVsbD9lLmNoaWxkcmVuOmUuY2hpbGROb2Rlc307dmFyIGlzU2FuaXRpemVyRW5hYmxlZD1mdW5jdGlvbigpe3ZhciBlPXdpbmRvdzt2YXIgcj1lJiZlLklvbmljJiZlLklvbmljLmNvbmZpZztpZihyKXtpZihyLmdldCl7cmV0dXJuIHIuZ2V0KFwic2FuaXRpemVyRW5hYmxlZFwiLHRydWUpfWVsc2V7cmV0dXJuIHIuc2FuaXRpemVyRW5hYmxlZD09PXRydWV8fHIuc2FuaXRpemVyRW5hYmxlZD09PXVuZGVmaW5lZH19cmV0dXJuIHRydWV9O3ZhciBhbGxvd2VkQXR0cmlidXRlcz1bXCJjbGFzc1wiLFwiaWRcIixcImhyZWZcIixcInNyY1wiLFwibmFtZVwiLFwic2xvdFwiXTt2YXIgYmxvY2tlZFRhZ3M9W1wic2NyaXB0XCIsXCJzdHlsZVwiLFwiaWZyYW1lXCIsXCJtZXRhXCIsXCJsaW5rXCIsXCJvYmplY3RcIixcImVtYmVkXCJdO3ZhciBJb25pY1NhZmVTdHJpbmc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMudmFsdWU9ZX1yZXR1cm4gZX0oKTtleHBvcnR7SW9uaWNTYWZlU3RyaW5nIGFzIEksc2FuaXRpemVET01TdHJpbmcgYXMgc307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8186\n')},114:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "m": () => (/* binding */ menuController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(655);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7504);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(882);\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7434);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var baseAnimation=function(n){return (0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().duration(n?400:300)};var menuOverlayAnimation=function(n){var e;var r;var t=n.width+8;var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)();if(n.isEndSide){e=t+"px";r="0px"}else{e=-t+"px";r="0px"}i.addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(e,")"),"translateX(".concat(r,")"));var o=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var u=o==="ios";var s=u?.2:.25;a.addElement(n.backdropEl).fromTo("opacity",.01,s);return baseAnimation(u).addAnimation([i,a])};var menuPushAnimation=function(n){var e;var r;var t=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var i=n.width;if(n.isEndSide){e=-i+"px";r=i+"px"}else{e=i+"px";r=-i+"px"}var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.menuInnerEl).fromTo("transform","translateX(".concat(r,")"),"translateX(0px)");var o=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(e,")"));var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.backdropEl).fromTo("opacity",.01,.32);return baseAnimation(t==="ios").addAnimation([a,o,u])};var menuRevealAnimation=function(n){var e=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(n);var r=n.width*(n.isEndSide?-1:1)+"px";var t=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_1__.c)().addElement(n.contentEl).fromTo("transform","translateX(0px)","translateX(".concat(r,")"));return baseAnimation(e==="ios").addAnimation(t)};var createMenuController=function(){var n=new Map;var e=[];var r=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.open()]}return[2,false]}}))}))};var t=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,n!==undefined?c(n):f()];case 1:e=r.sent();if(e!==undefined){return[2,e.close()]}return[2,false]}}))}))};var i=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,e.toggle()]}return[2,false]}}))}))};var a=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.disabled=!n}return[2,r]}}))}))};var o=function(n,e){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,c(e)];case 1:r=t.sent();if(r){r.swipeGesture=n}return[2,r]}}))}))};var u=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e,e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!(n!=null))return[3,2];return[4,c(n)];case 1:e=r.sent();return[2,e!==undefined&&e.isOpen()];case 2:return[4,f()];case 3:e=r.sent();return[2,e!==undefined]}}))}))};var s=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var e;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,c(n)];case 1:e=r.sent();if(e){return[2,!e.disabled]}return[2,false]}}))}))};var c=function(n){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var r,t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:return[4,O()];case 1:i.sent();if(n==="start"||n==="end"){r=E((function(e){return e.side===n&&!e.disabled}));if(r){return[2,r]}return[2,E((function(e){return e.side===n}))]}else if(n!=null){return[2,E((function(e){return e.menuId===n}))]}t=E((function(n){return!n.disabled}));if(t){return[2,t]}return[2,e.length>0?e[0].el:undefined]}}))}))};var f=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,g()]}}))}))};var d=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,w()]}}))}))};var v=function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(n){switch(n.label){case 0:return[4,O()];case 1:n.sent();return[2,A()]}}))}))};var l=function(e,r){n.set(e,r)};var m=function(n){if(e.indexOf(n)<0){if(!n.disabled){p(n)}e.push(n)}};var _=function(n){var r=e.indexOf(n);if(r>-1){e.splice(r,1)}};var p=function(n){var r=n.side;e.filter((function(e){return e.side===r&&e!==n})).forEach((function(n){return n.disabled=true}))};var b=function(n,e,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t;return (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(A()){return[2,false]}if(!e)return[3,3];return[4,f()];case 1:t=i.sent();if(!(t&&n.el!==t))return[3,3];return[4,t.setOpen(false,false)];case 2:i.sent();i.label=3;case 3:return[2,n._setOpen(e,r)]}}))}))};var h=function(e,r){var t=n.get(e);if(!t){throw new Error("animation not registered")}var i=t(r);return i};var g=function(){return E((function(n){return n._isOpen}))};var w=function(){return e.map((function(n){return n.el}))};var A=function(){return e.some((function(n){return n.isAnimating}))};var E=function(n){var r=e.find(n);if(r!==undefined){return r.el}return undefined};var O=function(){return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((function(n){return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_3__.c)(n,e)}))})))};l("reveal",menuRevealAnimation);l("push",menuPushAnimation);l("overlay",menuOverlayAnimation);if(typeof document!=="undefined"){document.addEventListener("ionBackButton",(function(n){var e=g();if(e){n.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_4__.MENU_BACK_BUTTON_PRIORITY,(function(){return e.close()}))}}))}return{registerAnimation:l,get:c,getMenus:d,getOpen:f,isEnabled:s,swipeGesture:o,isAnimating:v,isOpen:u,enable:a,toggle:i,close:t,open:r,_getOpenSync:g,_createAnimation:h,_register:m,_unregister:_,_setOpen:b,_setActiveMenu:p}};var menuController=createMenuController();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFrQyxHQUFHLElBQUksb0JBQW9CLGVBQWUsT0FBTyw0Q0FBNEMsV0FBVyxVQUFVLGlCQUFpQixzQkFBc0IsaUJBQWlCLElBQUksaUJBQWlCLDBCQUEwQixZQUFZLElBQUksaUJBQWlCLDJCQUEyQixxQkFBcUIsSUFBSSxrQkFBa0IsZ0JBQWdCLGtCQUFrQixZQUFZLGtCQUFrQixpQkFBaUIsc0ZBQXNGLGdDQUFnQyxPQUFPLHVEQUFnQixNQUFNLEdBQUcsS0FBSyxnQ0FBZ0MsNEJBQTRCLGtDQUFrQyxrQ0FBa0MsdURBQXVELFVBQVUsTUFBTSxrQkFBa0Isd0ZBQXlCLGFBQWEsaUJBQWlCLElBQUksR0FBRyxPQUFPLDROQUE0TiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2luZGV4LWNkYjFjZjk0LmpzPzY5NDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2dlbmVyYXRvcn1mcm9tXCJ0c2xpYlwiO1xuLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9pbXBvcnR7TUVOVV9CQUNLX0JVVFRPTl9QUklPUklUWX1mcm9tXCIuL2hhcmR3YXJlLWJhY2stYnV0dG9uLWFjZTZhNzFiLmpzXCI7aW1wb3J0e2MgYXMgY29tcG9uZW50T25SZWFkeX1mcm9tXCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjtpbXBvcnR7YiBhcyBnZXRJb25Nb2RlfWZyb21cIi4vaW9uaWMtZ2xvYmFsLTBlYmUzMjFjLmpzXCI7aW1wb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7dmFyIGJhc2VBbmltYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGNyZWF0ZUFuaW1hdGlvbigpLmR1cmF0aW9uKG4/NDAwOjMwMCl9O3ZhciBtZW51T3ZlcmxheUFuaW1hdGlvbj1mdW5jdGlvbihuKXt2YXIgZTt2YXIgcjt2YXIgdD1uLndpZHRoKzg7dmFyIGk9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIGE9Y3JlYXRlQW5pbWF0aW9uKCk7aWYobi5pc0VuZFNpZGUpe2U9dCtcInB4XCI7cj1cIjBweFwifWVsc2V7ZT0tdCtcInB4XCI7cj1cIjBweFwifWkuYWRkRWxlbWVudChuLm1lbnVJbm5lckVsKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGUsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocixcIilcIikpO3ZhciBvPWdldElvbk1vZGUobik7dmFyIHU9bz09PVwiaW9zXCI7dmFyIHM9dT8uMjouMjU7YS5hZGRFbGVtZW50KG4uYmFja2Ryb3BFbCkuZnJvbVRvKFwib3BhY2l0eVwiLC4wMSxzKTtyZXR1cm4gYmFzZUFuaW1hdGlvbih1KS5hZGRBbmltYXRpb24oW2ksYV0pfTt2YXIgbWVudVB1c2hBbmltYXRpb249ZnVuY3Rpb24obil7dmFyIGU7dmFyIHI7dmFyIHQ9Z2V0SW9uTW9kZShuKTt2YXIgaT1uLndpZHRoO2lmKG4uaXNFbmRTaWRlKXtlPS1pK1wicHhcIjtyPWkrXCJweFwifWVsc2V7ZT1pK1wicHhcIjtyPS1pK1wicHhcIn12YXIgYT1jcmVhdGVBbmltYXRpb24oKS5hZGRFbGVtZW50KG4ubWVudUlubmVyRWwpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQocixcIilcIiksXCJ0cmFuc2xhdGVYKDBweClcIik7dmFyIG89Y3JlYXRlQW5pbWF0aW9uKCkuYWRkRWxlbWVudChuLmNvbnRlbnRFbCkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKDBweClcIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGUsXCIpXCIpKTt2YXIgdT1jcmVhdGVBbmltYXRpb24oKS5hZGRFbGVtZW50KG4uYmFja2Ryb3BFbCkuZnJvbVRvKFwib3BhY2l0eVwiLC4wMSwuMzIpO3JldHVybiBiYXNlQW5pbWF0aW9uKHQ9PT1cImlvc1wiKS5hZGRBbmltYXRpb24oW2Esbyx1XSl9O3ZhciBtZW51UmV2ZWFsQW5pbWF0aW9uPWZ1bmN0aW9uKG4pe3ZhciBlPWdldElvbk1vZGUobik7dmFyIHI9bi53aWR0aCoobi5pc0VuZFNpZGU/LTE6MSkrXCJweFwiO3ZhciB0PWNyZWF0ZUFuaW1hdGlvbigpLmFkZEVsZW1lbnQobi5jb250ZW50RWwpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWCgwcHgpXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChyLFwiKVwiKSk7cmV0dXJuIGJhc2VBbmltYXRpb24oZT09PVwiaW9zXCIpLmFkZEFuaW1hdGlvbih0KX07dmFyIGNyZWF0ZU1lbnVDb250cm9sbGVyPWZ1bmN0aW9uKCl7dmFyIG49bmV3IE1hcDt2YXIgZT1bXTt2YXIgcj1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMobildO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUpe3JldHVyblsyLGUub3BlbigpXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgdD1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LG4hPT11bmRlZmluZWQ/YyhuKTpmKCldO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUhPT11bmRlZmluZWQpe3JldHVyblsyLGUuY2xvc2UoKV19cmV0dXJuWzIsZmFsc2VdfX0pKX0pKX07dmFyIGk9ZnVuY3Rpb24obil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxjKG4pXTtjYXNlIDE6ZT1yLnNlbnQoKTtpZihlKXtyZXR1cm5bMixlLnRvZ2dsZSgpXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgYT1mdW5jdGlvbihuLGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsYyhlKV07Y2FzZSAxOnI9dC5zZW50KCk7aWYocil7ci5kaXNhYmxlZD0hbn1yZXR1cm5bMixyXX19KSl9KSl9O3ZhciBvPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgcjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxjKGUpXTtjYXNlIDE6cj10LnNlbnQoKTtpZihyKXtyLnN3aXBlR2VzdHVyZT1ufXJldHVyblsyLHJdfX0pKX0pKX07dmFyIHU9ZnVuY3Rpb24obil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKCEobiE9bnVsbCkpcmV0dXJuWzMsMl07cmV0dXJuWzQsYyhuKV07Y2FzZSAxOmU9ci5zZW50KCk7cmV0dXJuWzIsZSE9PXVuZGVmaW5lZCYmZS5pc09wZW4oKV07Y2FzZSAyOnJldHVybls0LGYoKV07Y2FzZSAzOmU9ci5zZW50KCk7cmV0dXJuWzIsZSE9PXVuZGVmaW5lZF19fSkpfSkpfTt2YXIgcz1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGMobildO2Nhc2UgMTplPXIuc2VudCgpO2lmKGUpe3JldHVyblsyLCFlLmRpc2FibGVkXX1yZXR1cm5bMixmYWxzZV19fSkpfSkpfTt2YXIgYz1mdW5jdGlvbihuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByLHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsTygpXTtjYXNlIDE6aS5zZW50KCk7aWYobj09PVwic3RhcnRcInx8bj09PVwiZW5kXCIpe3I9RSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lkZT09PW4mJiFlLmRpc2FibGVkfSkpO2lmKHIpe3JldHVyblsyLHJdfXJldHVyblsyLEUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpZGU9PT1ufSkpXX1lbHNlIGlmKG4hPW51bGwpe3JldHVyblsyLEUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1lbnVJZD09PW59KSldfXQ9RSgoZnVuY3Rpb24obil7cmV0dXJuIW4uZGlzYWJsZWR9KSk7aWYodCl7cmV0dXJuWzIsdF19cmV0dXJuWzIsZS5sZW5ndGg+MD9lWzBdLmVsOnVuZGVmaW5lZF19fSkpfSkpfTt2YXIgZj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsTygpXTtjYXNlIDE6bi5zZW50KCk7cmV0dXJuWzIsZygpXX19KSl9KSl9O3ZhciBkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxPKCldO2Nhc2UgMTpuLnNlbnQoKTtyZXR1cm5bMix3KCldfX0pKX0pKX07dmFyIHY9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LE8oKV07Y2FzZSAxOm4uc2VudCgpO3JldHVyblsyLEEoKV19fSkpfSkpfTt2YXIgbD1mdW5jdGlvbihlLHIpe24uc2V0KGUscil9O3ZhciBtPWZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihuKTwwKXtpZighbi5kaXNhYmxlZCl7cChuKX1lLnB1c2gobil9fTt2YXIgXz1mdW5jdGlvbihuKXt2YXIgcj1lLmluZGV4T2Yobik7aWYocj4tMSl7ZS5zcGxpY2UociwxKX19O3ZhciBwPWZ1bmN0aW9uKG4pe3ZhciByPW4uc2lkZTtlLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lkZT09PXImJmUhPT1ufSkpLmZvckVhY2goKGZ1bmN0aW9uKG4pe3JldHVybiBuLmRpc2FibGVkPXRydWV9KSl9O3ZhciBiPWZ1bmN0aW9uKG4sZSxyKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOmlmKEEoKSl7cmV0dXJuWzIsZmFsc2VdfWlmKCFlKXJldHVyblszLDNdO3JldHVybls0LGYoKV07Y2FzZSAxOnQ9aS5zZW50KCk7aWYoISh0JiZuLmVsIT09dCkpcmV0dXJuWzMsM107cmV0dXJuWzQsdC5zZXRPcGVuKGZhbHNlLGZhbHNlKV07Y2FzZSAyOmkuc2VudCgpO2kubGFiZWw9MztjYXNlIDM6cmV0dXJuWzIsbi5fc2V0T3BlbihlLHIpXX19KSl9KSl9O3ZhciBoPWZ1bmN0aW9uKGUscil7dmFyIHQ9bi5nZXQoZSk7aWYoIXQpe3Rocm93IG5ldyBFcnJvcihcImFuaW1hdGlvbiBub3QgcmVnaXN0ZXJlZFwiKX12YXIgaT10KHIpO3JldHVybiBpfTt2YXIgZz1mdW5jdGlvbigpe3JldHVybiBFKChmdW5jdGlvbihuKXtyZXR1cm4gbi5faXNPcGVufSkpfTt2YXIgdz1mdW5jdGlvbigpe3JldHVybiBlLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIG4uZWx9KSl9O3ZhciBBPWZ1bmN0aW9uKCl7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24obil7cmV0dXJuIG4uaXNBbmltYXRpbmd9KSl9O3ZhciBFPWZ1bmN0aW9uKG4pe3ZhciByPWUuZmluZChuKTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5lbH1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgTz1mdW5jdGlvbigpe3JldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tbWVudVwiKSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wb25lbnRPblJlYWR5KG4sZSl9KSl9KSkpfTtsKFwicmV2ZWFsXCIsbWVudVJldmVhbEFuaW1hdGlvbik7bChcInB1c2hcIixtZW51UHVzaEFuaW1hdGlvbik7bChcIm92ZXJsYXlcIixtZW51T3ZlcmxheUFuaW1hdGlvbik7aWYodHlwZW9mIGRvY3VtZW50IT09XCJ1bmRlZmluZWRcIil7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlvbkJhY2tCdXR0b25cIiwoZnVuY3Rpb24obil7dmFyIGU9ZygpO2lmKGUpe24uZGV0YWlsLnJlZ2lzdGVyKE1FTlVfQkFDS19CVVRUT05fUFJJT1JJVFksKGZ1bmN0aW9uKCl7cmV0dXJuIGUuY2xvc2UoKX0pKX19KSl9cmV0dXJue3JlZ2lzdGVyQW5pbWF0aW9uOmwsZ2V0OmMsZ2V0TWVudXM6ZCxnZXRPcGVuOmYsaXNFbmFibGVkOnMsc3dpcGVHZXN0dXJlOm8saXNBbmltYXRpbmc6dixpc09wZW46dSxlbmFibGU6YSx0b2dnbGU6aSxjbG9zZTp0LG9wZW46cixfZ2V0T3BlblN5bmM6ZyxfY3JlYXRlQW5pbWF0aW9uOmgsX3JlZ2lzdGVyOm0sX3VucmVnaXN0ZXI6Xyxfc2V0T3BlbjpiLF9zZXRBY3RpdmVNZW51OnB9fTt2YXIgbWVudUNvbnRyb2xsZXI9Y3JlYXRlTWVudUNvbnRyb2xsZXIoKTtleHBvcnR7bWVudUNvbnRyb2xsZXIgYXMgbX07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n')},2032:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L": () => (/* binding */ LIFECYCLE_WILL_ENTER),\n/* harmony export */   "a": () => (/* binding */ LIFECYCLE_DID_ENTER),\n/* harmony export */   "b": () => (/* binding */ LIFECYCLE_WILL_LEAVE),\n/* harmony export */   "c": () => (/* binding */ LIFECYCLE_DID_LEAVE),\n/* harmony export */   "d": () => (/* binding */ LIFECYCLE_WILL_UNLOAD),\n/* harmony export */   "e": () => (/* binding */ deepReady),\n/* harmony export */   "g": () => (/* binding */ getIonPageElement),\n/* harmony export */   "l": () => (/* binding */ lifecycle),\n/* harmony export */   "s": () => (/* binding */ setPageHidden),\n/* harmony export */   "t": () => (/* binding */ transition)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(655);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2896);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var LIFECYCLE_WILL_ENTER="ionViewWillEnter";var LIFECYCLE_DID_ENTER="ionViewDidEnter";var LIFECYCLE_WILL_LEAVE="ionViewWillLeave";var LIFECYCLE_DID_LEAVE="ionViewDidLeave";var LIFECYCLE_WILL_UNLOAD="ionViewWillUnload";var iosTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 8360))};var mdTransitionAnimation=function(){return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 2782))};var transition=function(e){return new Promise((function(n,i){(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.c)((function(){beforeTransition(e);runTransition(e).then((function(i){if(i.animation){i.animation.destroy()}afterTransition(e);n(i)}),(function(n){afterTransition(e);i(n)}))}))}))};var beforeTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;setZIndex(n,i,e.direction);if(e.showGoBack){n.classList.add("can-go-back")}else{n.classList.remove("can-go-back")}setPageHidden(n,false);n.style.setProperty("pointer-events","none");if(i){setPageHidden(i,false);i.style.setProperty("pointer-events","none")}};var runTransition=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:return[4,getAnimationBuilder(e)];case 1:n=r.sent();i=n&&_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.B.isBrowser?animation(n,e):noAnimation(e);return[2,i]}}))}))};var afterTransition=function(e){var n=e.enteringEl;var i=e.leavingEl;n.classList.remove("ion-page-invisible");n.style.removeProperty("pointer-events");if(i!==undefined){i.classList.remove("ion-page-invisible");i.style.removeProperty("pointer-events")}};var getAnimationBuilder=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:if(!e.leavingEl||!e.animated||e.duration===0){return[2,undefined]}if(e.animationBuilder){return[2,e.animationBuilder]}if(!(e.mode==="ios"))return[3,2];return[4,iosTransitionAnimation()];case 1:i=r.sent().iosTransitionAnimation;return[3,4];case 2:return[4,mdTransitionAnimation()];case 3:i=r.sent().mdTransitionAnimation;r.label=4;case 4:n=i;return[2,n]}}))}))};var animation=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:return[4,waitForReady(n,true)];case 1:t.sent();i=e(n.baseEl,n);fireWillEvents(n.enteringEl,n.leavingEl);return[4,playTransition(i,n)];case 2:r=t.sent();if(n.progressCallback){n.progressCallback(undefined)}if(r){fireDidEvents(n.enteringEl,n.leavingEl)}return[2,{hasCompleted:r,animation:i}]}}))}))};var noAnimation=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:n=e.enteringEl;i=e.leavingEl;return[4,waitForReady(e,false)];case 1:r.sent();fireWillEvents(n,i);fireDidEvents(n,i);return[2,{hasCompleted:true}]}}))}))};var waitForReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:i=e.deepWait!==undefined?e.deepWait:n;r=i?[deepReady(e.enteringEl),deepReady(e.leavingEl)]:[shallowReady(e.enteringEl),shallowReady(e.leavingEl)];return[4,Promise.all(r)];case 1:t.sent();return[4,notifyViewReady(e.viewIsReady,e.enteringEl)];case 2:t.sent();return[2]}}))}))};var notifyViewReady=function(e,n){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(i){switch(i.label){case 0:if(!e)return[3,2];return[4,e(n)];case 1:i.sent();i.label=2;case 2:return[2]}}))}))};var playTransition=function(e,n){var i=n.progressCallback;var r=new Promise((function(n){e.onFinish((function(e){return n(e===1)}))}));if(i){e.progressStart(true);i(e)}else{e.play()}return r};var fireWillEvents=function(e,n){lifecycle(n,LIFECYCLE_WILL_LEAVE);lifecycle(e,LIFECYCLE_WILL_ENTER)};var fireDidEvents=function(e,n){lifecycle(e,LIFECYCLE_DID_ENTER);lifecycle(n,LIFECYCLE_DID_LEAVE)};var lifecycle=function(e,n){if(e){var i=new CustomEvent(n,{bubbles:false,cancelable:false});e.dispatchEvent(i)}};var shallowReady=function(e){if(e){return new Promise((function(n){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(e,n)}))}return Promise.resolve()};var deepReady=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var n,i,r;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){switch(t.label){case 0:n=e;if(!n)return[3,6];if(!(n.componentOnReady!=null))return[3,2];return[4,n.componentOnReady()];case 1:i=t.sent();if(i!=null){return[2]}return[3,4];case 2:if(!(n.__registerHost!=null))return[3,4];r=new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.r)(e)}));return[4,r];case 3:t.sent();return[2];case 4:return[4,Promise.all(Array.from(n.children).map(deepReady))];case 5:t.sent();t.label=6;case 6:return[2]}}))}))};var setPageHidden=function(e,n){if(n){e.setAttribute("aria-hidden","true");e.classList.add("ion-page-hidden")}else{e.hidden=false;e.removeAttribute("aria-hidden");e.classList.remove("ion-page-hidden")}};var setZIndex=function(e,n,i){if(e!==undefined){e.style.zIndex=i==="back"?"99":"101"}if(n!==undefined){n.style.zIndex="100"}};var getIonPageElement=function(e){if(e.classList.contains("ion-page")){return e}var n=e.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");if(n){return n}return e};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxHQUFnSSw0Q0FBNEMsMENBQTBDLDRDQUE0QywwQ0FBMEMsOENBQThDLHNDQUFzQyxPQUFPLHlGQUFzQyxFQUFFLHFDQUFxQyxPQUFPLHlGQUFxQyxFQUFFLDJCQUEyQixrQ0FBa0MscURBQVMsYUFBYSxvQkFBb0IsbUNBQW1DLGdCQUFnQixzQkFBc0IsbUJBQW1CLEtBQUssZUFBZSxtQkFBbUIsS0FBSyxHQUFHLEdBQUcsSUFBSSxpQ0FBaUMsbUJBQW1CLGtCQUFrQiwyQkFBMkIsaUJBQWlCLCtCQUErQixLQUFLLGtDQUFrQyx1QkFBdUIsNkNBQTZDLE1BQU0sdUJBQXVCLCtDQUErQyw4QkFBOEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isd0NBQXdDLGtCQUFrQixLQUFLLDJEQUFlLCtCQUErQixhQUFhLEdBQUcsSUFBSSxnQ0FBZ0MsbUJBQW1CLGtCQUFrQix5Q0FBeUMseUNBQXlDLGtCQUFrQix5Q0FBeUMsMkNBQTJDLG9DQUFvQyxPQUFPLDBEQUFTLGtDQUFrQyxRQUFRLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQixxREFBcUQsb0JBQW9CLHVCQUF1Qiw2QkFBNkIsaUNBQWlDLG1DQUFtQyx5Q0FBeUMsWUFBWSx5Q0FBeUMsd0NBQXdDLFVBQVUsV0FBVyxhQUFhLEdBQUcsSUFBSSw0QkFBNEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isc0NBQXNDLGdCQUFnQixnQkFBZ0IseUNBQXlDLDhCQUE4QixrQkFBa0IsdUJBQXVCLDhCQUE4QixNQUFNLHdDQUF3QyxVQUFVLDJCQUEyQixHQUFHLEdBQUcsSUFBSSw0QkFBNEIsT0FBTywwREFBUyxrQ0FBa0MsUUFBUSxPQUFPLDREQUFXLG1CQUFtQixnQkFBZ0Isc0JBQXNCLGNBQWMsZ0NBQWdDLGdCQUFnQixvQkFBb0IsbUJBQW1CLFVBQVUsa0JBQWtCLEdBQUcsR0FBRyxJQUFJLCtCQUErQixPQUFPLDBEQUFTLGtDQUFrQyxRQUFRLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQiw2Q0FBNkMsNEdBQTRHLHlCQUF5QixnQkFBZ0Isc0RBQXNELGdCQUFnQixXQUFXLEdBQUcsSUFBSSxrQ0FBa0MsT0FBTywwREFBUyxrQ0FBa0MsT0FBTyw0REFBVyxtQkFBbUIsZ0JBQWdCLHlCQUF5QixlQUFlLGdCQUFnQixVQUFVLGtCQUFrQixHQUFHLElBQUksaUNBQWlDLHlCQUF5QiwrQkFBK0Isd0JBQXdCLGdCQUFnQixHQUFHLEdBQUcsTUFBTSxzQkFBc0IsS0FBSyxLQUFLLFNBQVMsVUFBVSxpQ0FBaUMsa0NBQWtDLG1DQUFtQyxnQ0FBZ0MsaUNBQWlDLGtDQUFrQyw0QkFBNEIsTUFBTSx5QkFBeUIsK0JBQStCLEVBQUUscUJBQXFCLDZCQUE2QixNQUFNLGdDQUFnQyxPQUFPLHVEQUFnQixNQUFNLEdBQUcsMEJBQTBCLDBCQUEwQixPQUFPLDBEQUFTLGtDQUFrQyxVQUFVLE9BQU8sNERBQVcsbUJBQW1CLGdCQUFnQixXQUFXLGtCQUFrQiwyQ0FBMkMsK0JBQStCLGtCQUFrQixZQUFZLFVBQVUsWUFBWSxnREFBZ0QsMkJBQTJCLE9BQU8sdURBQUcsSUFBSSxHQUFHLFlBQVksZ0JBQWdCLFVBQVUsb0VBQW9FLGdCQUFnQixVQUFVLGtCQUFrQixHQUFHLElBQUksZ0NBQWdDLE1BQU0scUNBQXFDLG1DQUFtQyxLQUFLLGVBQWUsaUNBQWlDLHdDQUF3Qyw4QkFBOEIsa0JBQWtCLHFDQUFxQyxrQkFBa0IsdUJBQXVCLGtDQUFrQyxxQ0FBcUMsU0FBUyxpRkFBaUYsTUFBTSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW5kZXgtZTZjMmM4MjIuanM/ZGFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7X19hd2FpdGVyLF9fZ2VuZXJhdG9yfWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtjIGFzIHdyaXRlVGFzayxCIGFzIEJ1aWxkfWZyb21cIi4vaW5kZXgtYjNlZWNiMTQuanNcIjtpbXBvcnR7YyBhcyBjb21wb25lbnRPblJlYWR5LHIgYXMgcmFmfWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO3ZhciBMSUZFQ1lDTEVfV0lMTF9FTlRFUj1cImlvblZpZXdXaWxsRW50ZXJcIjt2YXIgTElGRUNZQ0xFX0RJRF9FTlRFUj1cImlvblZpZXdEaWRFbnRlclwiO3ZhciBMSUZFQ1lDTEVfV0lMTF9MRUFWRT1cImlvblZpZXdXaWxsTGVhdmVcIjt2YXIgTElGRUNZQ0xFX0RJRF9MRUFWRT1cImlvblZpZXdEaWRMZWF2ZVwiO3ZhciBMSUZFQ1lDTEVfV0lMTF9VTkxPQUQ9XCJpb25WaWV3V2lsbFVubG9hZFwiO3ZhciBpb3NUcmFuc2l0aW9uQW5pbWF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGltcG9ydChcIi4vaW9zLnRyYW5zaXRpb24tOGI2YTc3NmEuanNcIil9O3ZhciBtZFRyYW5zaXRpb25BbmltYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaW1wb3J0KFwiLi9tZC50cmFuc2l0aW9uLWRhODY2MTE5LmpzXCIpfTt2YXIgdHJhbnNpdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4saSl7d3JpdGVUYXNrKChmdW5jdGlvbigpe2JlZm9yZVRyYW5zaXRpb24oZSk7cnVuVHJhbnNpdGlvbihlKS50aGVuKChmdW5jdGlvbihpKXtpZihpLmFuaW1hdGlvbil7aS5hbmltYXRpb24uZGVzdHJveSgpfWFmdGVyVHJhbnNpdGlvbihlKTtuKGkpfSksKGZ1bmN0aW9uKG4pe2FmdGVyVHJhbnNpdGlvbihlKTtpKG4pfSkpfSkpfSkpfTt2YXIgYmVmb3JlVHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgbj1lLmVudGVyaW5nRWw7dmFyIGk9ZS5sZWF2aW5nRWw7c2V0WkluZGV4KG4saSxlLmRpcmVjdGlvbik7aWYoZS5zaG93R29CYWNrKXtuLmNsYXNzTGlzdC5hZGQoXCJjYW4tZ28tYmFja1wiKX1lbHNle24uY2xhc3NMaXN0LnJlbW92ZShcImNhbi1nby1iYWNrXCIpfXNldFBhZ2VIaWRkZW4obixmYWxzZSk7bi5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO2lmKGkpe3NldFBhZ2VIaWRkZW4oaSxmYWxzZSk7aS5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpfX07dmFyIHJ1blRyYW5zaXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LGdldEFuaW1hdGlvbkJ1aWxkZXIoZSldO2Nhc2UgMTpuPXIuc2VudCgpO2k9biYmQnVpbGQuaXNCcm93c2VyP2FuaW1hdGlvbihuLGUpOm5vQW5pbWF0aW9uKGUpO3JldHVyblsyLGldfX0pKX0pKX07dmFyIGFmdGVyVHJhbnNpdGlvbj1mdW5jdGlvbihlKXt2YXIgbj1lLmVudGVyaW5nRWw7dmFyIGk9ZS5sZWF2aW5nRWw7bi5jbGFzc0xpc3QucmVtb3ZlKFwiaW9uLXBhZ2UtaW52aXNpYmxlXCIpO24uc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJwb2ludGVyLWV2ZW50c1wiKTtpZihpIT09dW5kZWZpbmVkKXtpLmNsYXNzTGlzdC5yZW1vdmUoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIpfX07dmFyIGdldEFuaW1hdGlvbkJ1aWxkZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKCFlLmxlYXZpbmdFbHx8IWUuYW5pbWF0ZWR8fGUuZHVyYXRpb249PT0wKXtyZXR1cm5bMix1bmRlZmluZWRdfWlmKGUuYW5pbWF0aW9uQnVpbGRlcil7cmV0dXJuWzIsZS5hbmltYXRpb25CdWlsZGVyXX1pZighKGUubW9kZT09PVwiaW9zXCIpKXJldHVyblszLDJdO3JldHVybls0LGlvc1RyYW5zaXRpb25BbmltYXRpb24oKV07Y2FzZSAxOmk9ci5zZW50KCkuaW9zVHJhbnNpdGlvbkFuaW1hdGlvbjtyZXR1cm5bMyw0XTtjYXNlIDI6cmV0dXJuWzQsbWRUcmFuc2l0aW9uQW5pbWF0aW9uKCldO2Nhc2UgMzppPXIuc2VudCgpLm1kVHJhbnNpdGlvbkFuaW1hdGlvbjtyLmxhYmVsPTQ7Y2FzZSA0Om49aTtyZXR1cm5bMixuXX19KSl9KSl9O3ZhciBhbmltYXRpb249ZnVuY3Rpb24oZSxuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBpLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsd2FpdEZvclJlYWR5KG4sdHJ1ZSldO2Nhc2UgMTp0LnNlbnQoKTtpPWUobi5iYXNlRWwsbik7ZmlyZVdpbGxFdmVudHMobi5lbnRlcmluZ0VsLG4ubGVhdmluZ0VsKTtyZXR1cm5bNCxwbGF5VHJhbnNpdGlvbihpLG4pXTtjYXNlIDI6cj10LnNlbnQoKTtpZihuLnByb2dyZXNzQ2FsbGJhY2spe24ucHJvZ3Jlc3NDYWxsYmFjayh1bmRlZmluZWQpfWlmKHIpe2ZpcmVEaWRFdmVudHMobi5lbnRlcmluZ0VsLG4ubGVhdmluZ0VsKX1yZXR1cm5bMix7aGFzQ29tcGxldGVkOnIsYW5pbWF0aW9uOml9XX19KSl9KSl9O3ZhciBub0FuaW1hdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6bj1lLmVudGVyaW5nRWw7aT1lLmxlYXZpbmdFbDtyZXR1cm5bNCx3YWl0Rm9yUmVhZHkoZSxmYWxzZSldO2Nhc2UgMTpyLnNlbnQoKTtmaXJlV2lsbEV2ZW50cyhuLGkpO2ZpcmVEaWRFdmVudHMobixpKTtyZXR1cm5bMix7aGFzQ29tcGxldGVkOnRydWV9XX19KSl9KSl9O3ZhciB3YWl0Rm9yUmVhZHk9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBpLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6aT1lLmRlZXBXYWl0IT09dW5kZWZpbmVkP2UuZGVlcFdhaXQ6bjtyPWk/W2RlZXBSZWFkeShlLmVudGVyaW5nRWwpLGRlZXBSZWFkeShlLmxlYXZpbmdFbCldOltzaGFsbG93UmVhZHkoZS5lbnRlcmluZ0VsKSxzaGFsbG93UmVhZHkoZS5sZWF2aW5nRWwpXTtyZXR1cm5bNCxQcm9taXNlLmFsbChyKV07Y2FzZSAxOnQuc2VudCgpO3JldHVybls0LG5vdGlmeVZpZXdSZWFkeShlLnZpZXdJc1JlYWR5LGUuZW50ZXJpbmdFbCldO2Nhc2UgMjp0LnNlbnQoKTtyZXR1cm5bMl19fSkpfSkpfTt2YXIgbm90aWZ5Vmlld1JlYWR5PWZ1bmN0aW9uKGUsbil7cmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDppZighZSlyZXR1cm5bMywyXTtyZXR1cm5bNCxlKG4pXTtjYXNlIDE6aS5zZW50KCk7aS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl19fSkpfSkpfTt2YXIgcGxheVRyYW5zaXRpb249ZnVuY3Rpb24oZSxuKXt2YXIgaT1uLnByb2dyZXNzQ2FsbGJhY2s7dmFyIHI9bmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe2Uub25GaW5pc2goKGZ1bmN0aW9uKGUpe3JldHVybiBuKGU9PT0xKX0pKX0pKTtpZihpKXtlLnByb2dyZXNzU3RhcnQodHJ1ZSk7aShlKX1lbHNle2UucGxheSgpfXJldHVybiByfTt2YXIgZmlyZVdpbGxFdmVudHM9ZnVuY3Rpb24oZSxuKXtsaWZlY3ljbGUobixMSUZFQ1lDTEVfV0lMTF9MRUFWRSk7bGlmZWN5Y2xlKGUsTElGRUNZQ0xFX1dJTExfRU5URVIpfTt2YXIgZmlyZURpZEV2ZW50cz1mdW5jdGlvbihlLG4pe2xpZmVjeWNsZShlLExJRkVDWUNMRV9ESURfRU5URVIpO2xpZmVjeWNsZShuLExJRkVDWUNMRV9ESURfTEVBVkUpfTt2YXIgbGlmZWN5Y2xlPWZ1bmN0aW9uKGUsbil7aWYoZSl7dmFyIGk9bmV3IEN1c3RvbUV2ZW50KG4se2J1YmJsZXM6ZmFsc2UsY2FuY2VsYWJsZTpmYWxzZX0pO2UuZGlzcGF0Y2hFdmVudChpKX19O3ZhciBzaGFsbG93UmVhZHk9ZnVuY3Rpb24oZSl7aWYoZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihuKXtyZXR1cm4gY29tcG9uZW50T25SZWFkeShlLG4pfSkpfXJldHVybiBQcm9taXNlLnJlc29sdmUoKX07dmFyIGRlZXBSZWFkeT1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGkscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpuPWU7aWYoIW4pcmV0dXJuWzMsNl07aWYoIShuLmNvbXBvbmVudE9uUmVhZHkhPW51bGwpKXJldHVyblszLDJdO3JldHVybls0LG4uY29tcG9uZW50T25SZWFkeSgpXTtjYXNlIDE6aT10LnNlbnQoKTtpZihpIT1udWxsKXtyZXR1cm5bMl19cmV0dXJuWzMsNF07Y2FzZSAyOmlmKCEobi5fX3JlZ2lzdGVySG9zdCE9bnVsbCkpcmV0dXJuWzMsNF07cj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHJhZihlKX0pKTtyZXR1cm5bNCxyXTtjYXNlIDM6dC5zZW50KCk7cmV0dXJuWzJdO2Nhc2UgNDpyZXR1cm5bNCxQcm9taXNlLmFsbChBcnJheS5mcm9tKG4uY2hpbGRyZW4pLm1hcChkZWVwUmVhZHkpKV07Y2FzZSA1OnQuc2VudCgpO3QubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzJdfX0pKX0pKX07dmFyIHNldFBhZ2VIaWRkZW49ZnVuY3Rpb24oZSxuKXtpZihuKXtlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpO2UuY2xhc3NMaXN0LmFkZChcImlvbi1wYWdlLWhpZGRlblwiKX1lbHNle2UuaGlkZGVuPWZhbHNlO2UucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7ZS5jbGFzc0xpc3QucmVtb3ZlKFwiaW9uLXBhZ2UtaGlkZGVuXCIpfX07dmFyIHNldFpJbmRleD1mdW5jdGlvbihlLG4saSl7aWYoZSE9PXVuZGVmaW5lZCl7ZS5zdHlsZS56SW5kZXg9aT09PVwiYmFja1wiP1wiOTlcIjpcIjEwMVwifWlmKG4hPT11bmRlZmluZWQpe24uc3R5bGUuekluZGV4PVwiMTAwXCJ9fTt2YXIgZ2V0SW9uUGFnZUVsZW1lbnQ9ZnVuY3Rpb24oZSl7aWYoZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpb24tcGFnZVwiKSl7cmV0dXJuIGV9dmFyIG49ZS5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlID4gLmlvbi1wYWdlLCA6c2NvcGUgPiBpb24tbmF2LCA6c2NvcGUgPiBpb24tdGFic1wiKTtpZihuKXtyZXR1cm4gbn1yZXR1cm4gZX07ZXhwb3J0e0xJRkVDWUNMRV9XSUxMX0VOVEVSIGFzIEwsTElGRUNZQ0xFX0RJRF9FTlRFUiBhcyBhLExJRkVDWUNMRV9XSUxMX0xFQVZFIGFzIGIsTElGRUNZQ0xFX0RJRF9MRUFWRSBhcyBjLExJRkVDWUNMRV9XSUxMX1VOTE9BRCBhcyBkLGRlZXBSZWFkeSBhcyBlLGdldElvblBhZ2VFbGVtZW50IGFzIGcsbGlmZWN5Y2xlIGFzIGwsc2V0UGFnZUhpZGRlbiBhcyBzLHRyYW5zaXRpb24gYXMgdH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2032\n')},3774:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createAnimation": () => (/* reexport safe */ _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   "iosTransitionAnimation": () => (/* reexport safe */ _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__.iosTransitionAnimation),\n/* harmony export */   "mdTransitionAnimation": () => (/* reexport safe */ _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__.mdTransitionAnimation),\n/* harmony export */   "getTimeGivenProgression": () => (/* reexport safe */ _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__.g),\n/* harmony export */   "createGesture": () => (/* reexport safe */ _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__.createGesture),\n/* harmony export */   "getPlatforms": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.g),\n/* harmony export */   "initialize": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.i),\n/* harmony export */   "isPlatform": () => (/* reexport safe */ _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__.a),\n/* harmony export */   "componentOnReady": () => (/* reexport safe */ _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.c),\n/* harmony export */   "IonicSafeString": () => (/* reexport safe */ _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__.I),\n/* harmony export */   "LIFECYCLE_DID_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.a),\n/* harmony export */   "LIFECYCLE_DID_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.c),\n/* harmony export */   "LIFECYCLE_WILL_ENTER": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.L),\n/* harmony export */   "LIFECYCLE_WILL_LEAVE": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.b),\n/* harmony export */   "LIFECYCLE_WILL_UNLOAD": () => (/* reexport safe */ _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__.d),\n/* harmony export */   "menuController": () => (/* reexport safe */ _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__.m),\n/* harmony export */   "actionSheetController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.b),\n/* harmony export */   "alertController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.a),\n/* harmony export */   "loadingController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.l),\n/* harmony export */   "modalController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.m),\n/* harmony export */   "pickerController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.p),\n/* harmony export */   "popoverController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.c),\n/* harmony export */   "toastController": () => (/* reexport safe */ _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__.t),\n/* harmony export */   "IonicSlides": () => (/* binding */ IonicSlides),\n/* harmony export */   "IonicSwiper": () => (/* binding */ IonicSwiper),\n/* harmony export */   "getMode": () => (/* binding */ getMode),\n/* harmony export */   "setupConfig": () => (/* binding */ setupConfig)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7434);\n/* harmony import */ var _ios_transition_8b6a776a_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8360);\n/* harmony import */ var _md_transition_da866119_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2782);\n/* harmony import */ var _cubic_bezier_154a53a5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3544);\n/* harmony import */ var _index_41bf41f2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3876);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(882);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7504);\n/* harmony import */ var _index_c841c933_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8186);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2032);\n/* harmony import */ var _index_cdb1cf94_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(114);\n/* harmony import */ var _overlays_36d3475d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6250);\n/* harmony import */ var _gesture_controller_68c023a4_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4988);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar setupConfig=function(e){var i=window;var o=i.Ionic;if(o&&o.config&&o.config.constructor.name!=="Object"){return}i.Ionic=i.Ionic||{};i.Ionic.config=Object.assign(Object.assign({},i.Ionic.config),e);return i.Ionic.config};var getMode=function(){var e=window;var i=e&&e.Ionic&&e.Ionic.config;if(i){if(i.mode){return i.mode}else{return i.get("mode")}}return"md"};var setupSwiperInIonic=function(e,i){if(i===void 0){i=true}if(typeof window==="undefined"){return}var o=e.el;var t=o.closest(".ion-page");if(!t){if(i){var r=o.getRootNode();if(r.tagName==="DIV"){var a=new MutationObserver((function(i){var o=i[0];var t=o.oldValue===null;var s=r.classList.contains("ion-page");if(t&&s){a.disconnect();setupSwiperInIonic(e,false)}}));a.observe(r,{attributeFilter:["class"],attributeOldValue:true})}}return}var s=o.closest("ion-modal, ion-popover");if(s){var n=s.tagName==="ION-MODAL"?"ionModalWillPresent":"ionPopoverWillPresent";var l=function(){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.r)((function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(s,n,l)}))};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(s,n,l)}else{var c=new MutationObserver((function(e){var i;var r=e[0];var a=(i=r.oldValue)===null||i===void 0?void 0:i.includes("ion-page-invisible");var s=t.classList.contains("ion-page-invisible");if(!s&&s!==a){o.swiper.update()}}));c.observe(t,{attributeFilter:["class"],attributeOldValue:true})}var d=function(){o.swiper.update();(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.b)(window,"appload",d)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_6__.a)(window,"appload",d)};var IonicSwiper={name:"ionic",on:{afterInit:function(e){console.warn("[Deprecation Warning]: The IonicSwiper module has been deprecated in favor of the IonSlides module. This change was made to better support the Swiper 7 release. The IonicSwiper module will be removed in Ionic 7.0. See https://ionicframework.com/docs/api/slides#migration for revised migration steps.");setupSwiperInIonic(e)}}};var IonicSlides=function(e){var i=e.swiper,o=e.extendParams;var t={effect:undefined,direction:"horizontal",initialSlide:0,loop:false,parallax:false,slidesPerView:1,spaceBetween:0,speed:300,slidesPerColumn:1,slidesPerColumnFill:"column",slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0,touchEventsTarget:"container",autoplay:false,freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:false,freeModeMinimumVelocity:.02,autoHeight:false,setWrapperSize:false,zoom:{maxRatio:3,minRatio:1,toggle:false},touchRatio:1,touchAngle:45,simulateTouch:true,touchStartPreventDefault:false,shortSwipes:true,longSwipes:true,longSwipesRatio:.5,longSwipesMs:300,followFinger:true,threshold:0,touchMoveStopPropagation:true,touchReleaseOnEdges:false,iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20,resistance:true,resistanceRatio:.85,watchSlidesProgress:false,watchSlidesVisibility:false,preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false,loopAdditionalSlides:0,noSwiping:true,runCallbacksOnInit:true,coverflowEffect:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},flipEffect:{slideShadows:true,limitRotation:true},cubeEffect:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:.94},fadeEffect:{crossFade:false},a11y:{prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide"}};if(i.pagination){t.pagination={type:"bullets",clickable:false,hideOnClick:false}}if(i.scrollbar){t.scrollbar={hide:true}}o(t)};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzJsQyw0QkFBNEIsYUFBYSxjQUFjLHNEQUFzRCxPQUFPLG9CQUFvQiw2Q0FBNkMsb0JBQW9CLHVCQUF1Qix1QkFBdUIsYUFBYSxpQ0FBaUMsTUFBTSxXQUFXLGNBQWMsS0FBSyxzQkFBc0IsWUFBWSxxQ0FBcUMsZUFBZSxPQUFPLGdDQUFnQyxPQUFPLFdBQVcsNkJBQTZCLE9BQU8sTUFBTSxzQkFBc0Isc0JBQXNCLHdDQUF3QyxXQUFXLHdCQUF3Qix1Q0FBdUMsU0FBUyxlQUFlLDZCQUE2QixHQUFHLGFBQWEsaURBQWlELEdBQUcsT0FBTywwQ0FBMEMsTUFBTSw0RUFBNEUsaUJBQWlCLHVEQUFHLGFBQWEsa0JBQWtCLHVEQUFtQixRQUFRLElBQUksdURBQWdCLFFBQVEsS0FBSyx3Q0FBd0MsTUFBTSxXQUFXLGdGQUFnRixpREFBaUQsY0FBYyxtQkFBbUIsR0FBRyxhQUFhLGlEQUFpRCxFQUFFLGlCQUFpQixrQkFBa0IsdURBQW1CLHNCQUFzQix1REFBZ0Isc0JBQXNCLGlCQUFpQixpQkFBaUIsc0JBQXNCLDRUQUE0VCx5QkFBeUIsNEJBQTRCLGdDQUFnQyxPQUFPLHloQkFBeWhCLG1DQUFtQyxraEJBQWtoQiwyREFBMkQsYUFBYSxxQ0FBcUMsYUFBYSw4REFBOEQsYUFBYSxnQkFBZ0IsT0FBTyx3SkFBd0osaUJBQWlCLGNBQWMsa0RBQWtELGdCQUFnQixhQUFhLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtLWVzNS9pbmRleC5qcz82MjZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5leHBvcnR7YyBhcyBjcmVhdGVBbmltYXRpb259ZnJvbVwiLi9hbmltYXRpb24tMTlkYmY5YmYuanNcIjtleHBvcnR7aW9zVHJhbnNpdGlvbkFuaW1hdGlvbn1mcm9tXCIuL2lvcy50cmFuc2l0aW9uLThiNmE3NzZhLmpzXCI7ZXhwb3J0e21kVHJhbnNpdGlvbkFuaW1hdGlvbn1mcm9tXCIuL21kLnRyYW5zaXRpb24tZGE4NjYxMTkuanNcIjtleHBvcnR7ZyBhcyBnZXRUaW1lR2l2ZW5Qcm9ncmVzc2lvbn1mcm9tXCIuL2N1YmljLWJlemllci0xNTRhNTNhNS5qc1wiO2V4cG9ydHtjcmVhdGVHZXN0dXJlfWZyb21cIi4vaW5kZXgtNDFiZjQxZjIuanNcIjtleHBvcnR7ZyBhcyBnZXRQbGF0Zm9ybXMsaSBhcyBpbml0aWFsaXplLGEgYXMgaXNQbGF0Zm9ybX1mcm9tXCIuL2lvbmljLWdsb2JhbC0wZWJlMzIxYy5qc1wiO2ltcG9ydHthIGFzIGFkZEV2ZW50TGlzdGVuZXIsciBhcyByYWYsYiBhcyByZW1vdmVFdmVudExpc3RlbmVyfWZyb21cIi4vaGVscGVycy02ZTFlNWI2NS5qc1wiO2V4cG9ydHtjIGFzIGNvbXBvbmVudE9uUmVhZHl9ZnJvbVwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7ZXhwb3J0e0kgYXMgSW9uaWNTYWZlU3RyaW5nfWZyb21cIi4vaW5kZXgtYzg0MWM5MzMuanNcIjtleHBvcnR7YSBhcyBMSUZFQ1lDTEVfRElEX0VOVEVSLGMgYXMgTElGRUNZQ0xFX0RJRF9MRUFWRSxMIGFzIExJRkVDWUNMRV9XSUxMX0VOVEVSLGIgYXMgTElGRUNZQ0xFX1dJTExfTEVBVkUsZCBhcyBMSUZFQ1lDTEVfV0lMTF9VTkxPQUR9ZnJvbVwiLi9pbmRleC1lNmMyYzgyMi5qc1wiO2V4cG9ydHttIGFzIG1lbnVDb250cm9sbGVyfWZyb21cIi4vaW5kZXgtY2RiMWNmOTQuanNcIjtleHBvcnR7YiBhcyBhY3Rpb25TaGVldENvbnRyb2xsZXIsYSBhcyBhbGVydENvbnRyb2xsZXIsbCBhcyBsb2FkaW5nQ29udHJvbGxlcixtIGFzIG1vZGFsQ29udHJvbGxlcixwIGFzIHBpY2tlckNvbnRyb2xsZXIsYyBhcyBwb3BvdmVyQ29udHJvbGxlcix0IGFzIHRvYXN0Q29udHJvbGxlcn1mcm9tXCIuL292ZXJsYXlzLTM2ZDM0NzVkLmpzXCI7aW1wb3J0XCIuL2dlc3R1cmUtY29udHJvbGxlci02OGMwMjNhNC5qc1wiO2ltcG9ydFwiLi9pbmRleC1iM2VlY2IxNC5qc1wiO2ltcG9ydFwiLi9oYXJkd2FyZS1iYWNrLWJ1dHRvbi1hY2U2YTcxYi5qc1wiO3ZhciBzZXR1cENvbmZpZz1mdW5jdGlvbihlKXt2YXIgaT13aW5kb3c7dmFyIG89aS5Jb25pYztpZihvJiZvLmNvbmZpZyYmby5jb25maWcuY29uc3RydWN0b3IubmFtZSE9PVwiT2JqZWN0XCIpe3JldHVybn1pLklvbmljPWkuSW9uaWN8fHt9O2kuSW9uaWMuY29uZmlnPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpLklvbmljLmNvbmZpZyksZSk7cmV0dXJuIGkuSW9uaWMuY29uZmlnfTt2YXIgZ2V0TW9kZT1mdW5jdGlvbigpe3ZhciBlPXdpbmRvdzt2YXIgaT1lJiZlLklvbmljJiZlLklvbmljLmNvbmZpZztpZihpKXtpZihpLm1vZGUpe3JldHVybiBpLm1vZGV9ZWxzZXtyZXR1cm4gaS5nZXQoXCJtb2RlXCIpfX1yZXR1cm5cIm1kXCJ9O3ZhciBzZXR1cFN3aXBlckluSW9uaWM9ZnVuY3Rpb24oZSxpKXtpZihpPT09dm9pZCAwKXtpPXRydWV9aWYodHlwZW9mIHdpbmRvdz09PVwidW5kZWZpbmVkXCIpe3JldHVybn12YXIgbz1lLmVsO3ZhciB0PW8uY2xvc2VzdChcIi5pb24tcGFnZVwiKTtpZighdCl7aWYoaSl7dmFyIHI9by5nZXRSb290Tm9kZSgpO2lmKHIudGFnTmFtZT09PVwiRElWXCIpe3ZhciBhPW5ldyBNdXRhdGlvbk9ic2VydmVyKChmdW5jdGlvbihpKXt2YXIgbz1pWzBdO3ZhciB0PW8ub2xkVmFsdWU9PT1udWxsO3ZhciBzPXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaW9uLXBhZ2VcIik7aWYodCYmcyl7YS5kaXNjb25uZWN0KCk7c2V0dXBTd2lwZXJJbklvbmljKGUsZmFsc2UpfX0pKTthLm9ic2VydmUocix7YXR0cmlidXRlRmlsdGVyOltcImNsYXNzXCJdLGF0dHJpYnV0ZU9sZFZhbHVlOnRydWV9KX19cmV0dXJufXZhciBzPW8uY2xvc2VzdChcImlvbi1tb2RhbCwgaW9uLXBvcG92ZXJcIik7aWYocyl7dmFyIG49cy50YWdOYW1lPT09XCJJT04tTU9EQUxcIj9cImlvbk1vZGFsV2lsbFByZXNlbnRcIjpcImlvblBvcG92ZXJXaWxsUHJlc2VudFwiO3ZhciBsPWZ1bmN0aW9uKCl7cmFmKChmdW5jdGlvbigpe28uc3dpcGVyLnVwZGF0ZSgpO3JlbW92ZUV2ZW50TGlzdGVuZXIocyxuLGwpfSkpfTthZGRFdmVudExpc3RlbmVyKHMsbixsKX1lbHNle3ZhciBjPW5ldyBNdXRhdGlvbk9ic2VydmVyKChmdW5jdGlvbihlKXt2YXIgaTt2YXIgcj1lWzBdO3ZhciBhPShpPXIub2xkVmFsdWUpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5pbmNsdWRlcyhcImlvbi1wYWdlLWludmlzaWJsZVwiKTt2YXIgcz10LmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1wYWdlLWludmlzaWJsZVwiKTtpZighcyYmcyE9PWEpe28uc3dpcGVyLnVwZGF0ZSgpfX0pKTtjLm9ic2VydmUodCx7YXR0cmlidXRlRmlsdGVyOltcImNsYXNzXCJdLGF0dHJpYnV0ZU9sZFZhbHVlOnRydWV9KX12YXIgZD1mdW5jdGlvbigpe28uc3dpcGVyLnVwZGF0ZSgpO3JlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LFwiYXBwbG9hZFwiLGQpfTthZGRFdmVudExpc3RlbmVyKHdpbmRvdyxcImFwcGxvYWRcIixkKX07dmFyIElvbmljU3dpcGVyPXtuYW1lOlwiaW9uaWNcIixvbjp7YWZ0ZXJJbml0OmZ1bmN0aW9uKGUpe2NvbnNvbGUud2FybihcIltEZXByZWNhdGlvbiBXYXJuaW5nXTogVGhlIElvbmljU3dpcGVyIG1vZHVsZSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBJb25TbGlkZXMgbW9kdWxlLiBUaGlzIGNoYW5nZSB3YXMgbWFkZSB0byBiZXR0ZXIgc3VwcG9ydCB0aGUgU3dpcGVyIDcgcmVsZWFzZS4gVGhlIElvbmljU3dpcGVyIG1vZHVsZSB3aWxsIGJlIHJlbW92ZWQgaW4gSW9uaWMgNy4wLiBTZWUgaHR0cHM6Ly9pb25pY2ZyYW1ld29yay5jb20vZG9jcy9hcGkvc2xpZGVzI21pZ3JhdGlvbiBmb3IgcmV2aXNlZCBtaWdyYXRpb24gc3RlcHMuXCIpO3NldHVwU3dpcGVySW5Jb25pYyhlKX19fTt2YXIgSW9uaWNTbGlkZXM9ZnVuY3Rpb24oZSl7dmFyIGk9ZS5zd2lwZXIsbz1lLmV4dGVuZFBhcmFtczt2YXIgdD17ZWZmZWN0OnVuZGVmaW5lZCxkaXJlY3Rpb246XCJob3Jpem9udGFsXCIsaW5pdGlhbFNsaWRlOjAsbG9vcDpmYWxzZSxwYXJhbGxheDpmYWxzZSxzbGlkZXNQZXJWaWV3OjEsc3BhY2VCZXR3ZWVuOjAsc3BlZWQ6MzAwLHNsaWRlc1BlckNvbHVtbjoxLHNsaWRlc1BlckNvbHVtbkZpbGw6XCJjb2x1bW5cIixzbGlkZXNQZXJHcm91cDoxLGNlbnRlcmVkU2xpZGVzOmZhbHNlLHNsaWRlc09mZnNldEJlZm9yZTowLHNsaWRlc09mZnNldEFmdGVyOjAsdG91Y2hFdmVudHNUYXJnZXQ6XCJjb250YWluZXJcIixhdXRvcGxheTpmYWxzZSxmcmVlTW9kZTpmYWxzZSxmcmVlTW9kZU1vbWVudHVtOnRydWUsZnJlZU1vZGVNb21lbnR1bVJhdGlvOjEsZnJlZU1vZGVNb21lbnR1bUJvdW5jZTp0cnVlLGZyZWVNb2RlTW9tZW50dW1Cb3VuY2VSYXRpbzoxLGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOjEsZnJlZU1vZGVTdGlja3k6ZmFsc2UsZnJlZU1vZGVNaW5pbXVtVmVsb2NpdHk6LjAyLGF1dG9IZWlnaHQ6ZmFsc2Usc2V0V3JhcHBlclNpemU6ZmFsc2Usem9vbTp7bWF4UmF0aW86MyxtaW5SYXRpbzoxLHRvZ2dsZTpmYWxzZX0sdG91Y2hSYXRpbzoxLHRvdWNoQW5nbGU6NDUsc2ltdWxhdGVUb3VjaDp0cnVlLHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDpmYWxzZSxzaG9ydFN3aXBlczp0cnVlLGxvbmdTd2lwZXM6dHJ1ZSxsb25nU3dpcGVzUmF0aW86LjUsbG9uZ1N3aXBlc01zOjMwMCxmb2xsb3dGaW5nZXI6dHJ1ZSx0aHJlc2hvbGQ6MCx0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246dHJ1ZSx0b3VjaFJlbGVhc2VPbkVkZ2VzOmZhbHNlLGlPU0VkZ2VTd2lwZURldGVjdGlvbjpmYWxzZSxpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6MjAscmVzaXN0YW5jZTp0cnVlLHJlc2lzdGFuY2VSYXRpbzouODUsd2F0Y2hTbGlkZXNQcm9ncmVzczpmYWxzZSx3YXRjaFNsaWRlc1Zpc2liaWxpdHk6ZmFsc2UscHJldmVudENsaWNrczp0cnVlLHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjp0cnVlLHNsaWRlVG9DbGlja2VkU2xpZGU6ZmFsc2UsbG9vcEFkZGl0aW9uYWxTbGlkZXM6MCxub1N3aXBpbmc6dHJ1ZSxydW5DYWxsYmFja3NPbkluaXQ6dHJ1ZSxjb3ZlcmZsb3dFZmZlY3Q6e3JvdGF0ZTo1MCxzdHJldGNoOjAsZGVwdGg6MTAwLG1vZGlmaWVyOjEsc2xpZGVTaGFkb3dzOnRydWV9LGZsaXBFZmZlY3Q6e3NsaWRlU2hhZG93czp0cnVlLGxpbWl0Um90YXRpb246dHJ1ZX0sY3ViZUVmZmVjdDp7c2xpZGVTaGFkb3dzOnRydWUsc2hhZG93OnRydWUsc2hhZG93T2Zmc2V0OjIwLHNoYWRvd1NjYWxlOi45NH0sZmFkZUVmZmVjdDp7Y3Jvc3NGYWRlOmZhbHNlfSxhMTF5OntwcmV2U2xpZGVNZXNzYWdlOlwiUHJldmlvdXMgc2xpZGVcIixuZXh0U2xpZGVNZXNzYWdlOlwiTmV4dCBzbGlkZVwiLGZpcnN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGVcIixsYXN0U2xpZGVNZXNzYWdlOlwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwifX07aWYoaS5wYWdpbmF0aW9uKXt0LnBhZ2luYXRpb249e3R5cGU6XCJidWxsZXRzXCIsY2xpY2thYmxlOmZhbHNlLGhpZGVPbkNsaWNrOmZhbHNlfX1pZihpLnNjcm9sbGJhcil7dC5zY3JvbGxiYXI9e2hpZGU6dHJ1ZX19byh0KX07ZXhwb3J0e0lvbmljU2xpZGVzLElvbmljU3dpcGVyLGdldE1vZGUsc2V0dXBDb25maWd9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3774\n')},882:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "a": () => (/* binding */ isPlatform),\n/* harmony export */   "b": () => (/* binding */ getIonMode),\n/* harmony export */   "c": () => (/* binding */ config),\n/* harmony export */   "g": () => (/* binding */ getPlatforms),\n/* harmony export */   "i": () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar Config=function(){function e(){this.m=new Map}e.prototype.reset=function(e){this.m=new Map(Object.entries(e))};e.prototype.get=function(e,t){var n=this.m.get(e);return n!==undefined?n:t};e.prototype.getBoolean=function(e,t){if(t===void 0){t=false}var n=this.m.get(e);if(n===undefined){return t}if(typeof n==="string"){return n==="true"}return!!n};e.prototype.getNumber=function(e,t){var n=parseFloat(this.m.get(e));return isNaN(n)?t!==undefined?t:NaN:n};e.prototype.set=function(e,t){this.m.set(e,t)};return e}();var config=new Config;var configFromSession=function(e){try{var t=e.sessionStorage.getItem(IONIC_SESSION_KEY);return t!==null?JSON.parse(t):{}}catch(e){return{}}};var saveConfig=function(e,t){try{e.sessionStorage.setItem(IONIC_SESSION_KEY,JSON.stringify(t))}catch(e){return}};var configFromURL=function(e){var t={};e.location.search.slice(1).split("&").map((function(e){return e.split("=")})).map((function(e){var t=e[0],n=e[1];return[decodeURIComponent(t),decodeURIComponent(n)]})).filter((function(e){var t=e[0];return startsWith(t,IONIC_PREFIX)})).map((function(e){var t=e[0],n=e[1];return[t.slice(IONIC_PREFIX.length),n]})).forEach((function(e){var n=e[0],i=e[1];t[n]=i}));return t};var startsWith=function(e,t){return e.substr(0,t.length)===t};var IONIC_PREFIX="ionic:";var IONIC_SESSION_KEY="ionic-persist-config";var getPlatforms=function(e){return setupPlatforms(e)};var isPlatform=function(e,t){if(typeof e==="string"){t=e;e=undefined}return getPlatforms(e).includes(t)};var setupPlatforms=function(e){if(e===void 0){e=window}if(typeof e==="undefined"){return[]}e.Ionic=e.Ionic||{};var t=e.Ionic.platforms;if(t==null){t=e.Ionic.platforms=detectPlatforms(e);t.forEach((function(t){return e.document.documentElement.classList.add("plt-".concat(t))}))}return t};var detectPlatforms=function(e){var t=config.get("platform");return Object.keys(PLATFORMS_MAP).filter((function(n){var i=t&&t[n];return typeof i==="function"?i(e):PLATFORMS_MAP[n](e)}))};var isMobileWeb=function(e){return isMobile(e)&&!isHybrid(e)};var isIpad=function(e){if(testUserAgent(e,/iPad/i)){return true}if(testUserAgent(e,/Macintosh/i)&&isMobile(e)){return true}return false};var isIphone=function(e){return testUserAgent(e,/iPhone/i)};var isIOS=function(e){return testUserAgent(e,/iPhone|iPod/i)||isIpad(e)};var isAndroid=function(e){return testUserAgent(e,/android|sink/i)};var isAndroidTablet=function(e){return isAndroid(e)&&!testUserAgent(e,/mobile/i)};var isPhablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return i>390&&i<520&&(r>620&&r<800)};var isTablet=function(e){var t=e.innerWidth;var n=e.innerHeight;var i=Math.min(t,n);var r=Math.max(t,n);return isIpad(e)||isAndroidTablet(e)||i>460&&i<820&&(r>780&&r<1400)};var isMobile=function(e){return matchMedia(e,"(any-pointer:coarse)")};var isDesktop=function(e){return!isMobile(e)};var isHybrid=function(e){return isCordova(e)||isCapacitorNative(e)};var isCordova=function(e){return!!(e["cordova"]||e["phonegap"]||e["PhoneGap"])};var isCapacitorNative=function(e){var t=e["Capacitor"];return!!(t&&t.isNative)};var isElectron=function(e){return testUserAgent(e,/electron/i)};var isPWA=function(e){return!!(e.matchMedia&&e.matchMedia("(display-mode: standalone)").matches||e.navigator.standalone)};var testUserAgent=function(e,t){return t.test(e.navigator.userAgent)};var matchMedia=function(e,t){return e.matchMedia&&e.matchMedia(t).matches};var PLATFORMS_MAP={ipad:isIpad,iphone:isIphone,ios:isIOS,android:isAndroid,phablet:isPhablet,tablet:isTablet,cordova:isCordova,capacitor:isCapacitorNative,electron:isElectron,pwa:isPWA,mobile:isMobile,mobileweb:isMobileWeb,desktop:isDesktop,hybrid:isHybrid};var defaultMode;var getIonMode=function(e){return e&&(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.g)(e)||defaultMode};var initialize=function(e){if(e===void 0){e={}}if(typeof window==="undefined"){return}var t=window.document;var n=window;var i=n.Ionic=n.Ionic||{};var r={};if(e._ael){r.ael=e._ael}if(e._rel){r.rel=e._rel}if(e._ce){r.ce=e._ce}(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.s)(r);var o=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},configFromSession(n)),{persistConfig:false}),i.config),configFromURL(n)),e);config.reset(o);if(config.getBoolean("persistConfig")){saveConfig(n,o)}setupPlatforms(n);i.config=config;i.mode=defaultMode=config.get("mode",t.documentElement.getAttribute("mode")||(isPlatform(n,"ios")?"ios":"md"));config.set("mode",defaultMode);t.documentElement.setAttribute("mode",defaultMode);t.documentElement.classList.add(defaultMode);if(config.getBoolean("_testing")){config.set("animated",false)}var a=function(e){return e.tagName&&e.tagName.startsWith("ION-")};var s=function(e){return["ios","md"].includes(e)};(0,_index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_0__.a)((function(e){while(e){var t=e.mode||e.getAttribute("mode");if(t){if(s(t)){return t}else if(a(e)){console.warn(\'Invalid ionic mode: "\'+t+\'", expected: "ios" or "md"\')}}e=e.parentElement}return defaultMode}))};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNtRixzQkFBc0IsYUFBYSxlQUFlLDhCQUE4QixtQ0FBbUMsOEJBQThCLG9CQUFvQiwwQkFBMEIscUNBQXFDLGVBQWUsUUFBUSxvQkFBb0Isa0JBQWtCLFNBQVMsd0JBQXdCLGtCQUFrQixXQUFXLG9DQUFvQyxnQ0FBZ0MsdUNBQXVDLDhCQUE4QixpQkFBaUIsU0FBUyxHQUFHLHNCQUFzQixrQ0FBa0MsSUFBSSxrREFBa0QsaUNBQWlDLFNBQVMsV0FBVyw2QkFBNkIsSUFBSSw4REFBOEQsU0FBUyxTQUFTLDhCQUE4QixTQUFTLHVEQUF1RCxvQkFBb0Isb0JBQW9CLGtCQUFrQixvREFBb0QsdUJBQXVCLFdBQVcsa0NBQWtDLG9CQUFvQixrQkFBa0IsdUNBQXVDLHdCQUF3QixrQkFBa0IsT0FBTyxHQUFHLFVBQVUsNkJBQTZCLGlDQUFpQywwQkFBMEIsNkNBQTZDLDZCQUE2QiwwQkFBMEIsNkJBQTZCLHdCQUF3QixJQUFJLFlBQVksb0NBQW9DLCtCQUErQixlQUFlLFNBQVMsMkJBQTJCLFNBQVMsb0JBQW9CLHdCQUF3QixZQUFZLHVDQUF1Qyx1QkFBdUIsa0VBQWtFLEdBQUcsVUFBVSxnQ0FBZ0MsNkJBQTZCLHNEQUFzRCxjQUFjLHNEQUFzRCxJQUFJLDRCQUE0QixrQ0FBa0MsdUJBQXVCLDZCQUE2QixZQUFZLCtDQUErQyxZQUFZLGNBQWMseUJBQXlCLG1DQUFtQyxzQkFBc0IsbURBQW1ELDBCQUEwQix5Q0FBeUMsZ0NBQWdDLGtEQUFrRCwwQkFBMEIsbUJBQW1CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHFDQUFxQyx5QkFBeUIsbUJBQW1CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHFFQUFxRSx5QkFBeUIsNkNBQTZDLDBCQUEwQixvQkFBb0IseUJBQXlCLDJDQUEyQywwQkFBMEIsc0RBQXNELGtDQUFrQyxxQkFBcUIseUJBQXlCLDJCQUEyQixxQ0FBcUMsc0JBQXNCLG9HQUFvRyxnQ0FBZ0Msc0NBQXNDLDZCQUE2Qiw4Q0FBOEMsbUJBQW1CLCtPQUErTyxnQkFBZ0IsMkJBQTJCLFVBQVUscURBQU8sa0JBQWtCLDJCQUEyQixlQUFlLEtBQUssZ0NBQWdDLE9BQU8sc0JBQXNCLGFBQWEsMEJBQTBCLFNBQVMsV0FBVyxhQUFhLFdBQVcsYUFBYSxVQUFVLFdBQVcscURBQWtCLElBQUksOEVBQThFLHdCQUF3QixvQkFBb0IsaUNBQWlDLGdCQUFnQix1Q0FBdUMsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsK0dBQStHLCtCQUErQixtREFBbUQsNkNBQTZDLGtDQUFrQyw2QkFBNkIsa0JBQWtCLGdEQUFnRCxrQkFBa0IsZ0NBQWdDLHFEQUFPLGNBQWMsU0FBUyxxQ0FBcUMsTUFBTSxTQUFTLFNBQVMsY0FBYyxzRUFBc0Usa0JBQWtCLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L2lvbmljLWdsb2JhbC0wZWJlMzIxYy5qcz9hM2IzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnR7cyBhcyBzZXRQbGF0Zm9ybUhlbHBlcnMsZyBhcyBnZXRNb2RlLGEgYXMgc2V0TW9kZX1mcm9tXCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7dmFyIENvbmZpZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLm09bmV3IE1hcH1lLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbihlKXt0aGlzLm09bmV3IE1hcChPYmplY3QuZW50cmllcyhlKSl9O2UucHJvdG90eXBlLmdldD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubS5nZXQoZSk7cmV0dXJuIG4hPT11bmRlZmluZWQ/bjp0fTtlLnByb3RvdHlwZS5nZXRCb29sZWFuPWZ1bmN0aW9uKGUsdCl7aWYodD09PXZvaWQgMCl7dD1mYWxzZX12YXIgbj10aGlzLm0uZ2V0KGUpO2lmKG49PT11bmRlZmluZWQpe3JldHVybiB0fWlmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7cmV0dXJuIG49PT1cInRydWVcIn1yZXR1cm4hIW59O2UucHJvdG90eXBlLmdldE51bWJlcj1mdW5jdGlvbihlLHQpe3ZhciBuPXBhcnNlRmxvYXQodGhpcy5tLmdldChlKSk7cmV0dXJuIGlzTmFOKG4pP3QhPT11bmRlZmluZWQ/dDpOYU46bn07ZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUsdCl7dGhpcy5tLnNldChlLHQpfTtyZXR1cm4gZX0oKTt2YXIgY29uZmlnPW5ldyBDb25maWc7dmFyIGNvbmZpZ0Zyb21TZXNzaW9uPWZ1bmN0aW9uKGUpe3RyeXt2YXIgdD1lLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oSU9OSUNfU0VTU0lPTl9LRVkpO3JldHVybiB0IT09bnVsbD9KU09OLnBhcnNlKHQpOnt9fWNhdGNoKGUpe3JldHVybnt9fX07dmFyIHNhdmVDb25maWc9ZnVuY3Rpb24oZSx0KXt0cnl7ZS5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKElPTklDX1NFU1NJT05fS0VZLEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaChlKXtyZXR1cm59fTt2YXIgY29uZmlnRnJvbVVSTD1mdW5jdGlvbihlKXt2YXIgdD17fTtlLmxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdChcIiZcIikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIj1cIil9KSkubWFwKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdLG49ZVsxXTtyZXR1cm5bZGVjb2RlVVJJQ29tcG9uZW50KHQpLGRlY29kZVVSSUNvbXBvbmVudChuKV19KSkuZmlsdGVyKChmdW5jdGlvbihlKXt2YXIgdD1lWzBdO3JldHVybiBzdGFydHNXaXRoKHQsSU9OSUNfUFJFRklYKX0pKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sbj1lWzFdO3JldHVyblt0LnNsaWNlKElPTklDX1BSRUZJWC5sZW5ndGgpLG5dfSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0saT1lWzFdO3Rbbl09aX0pKTtyZXR1cm4gdH07dmFyIHN0YXJ0c1dpdGg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zdWJzdHIoMCx0Lmxlbmd0aCk9PT10fTt2YXIgSU9OSUNfUFJFRklYPVwiaW9uaWM6XCI7dmFyIElPTklDX1NFU1NJT05fS0VZPVwiaW9uaWMtcGVyc2lzdC1jb25maWdcIjt2YXIgZ2V0UGxhdGZvcm1zPWZ1bmN0aW9uKGUpe3JldHVybiBzZXR1cFBsYXRmb3JtcyhlKX07dmFyIGlzUGxhdGZvcm09ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3Q9ZTtlPXVuZGVmaW5lZH1yZXR1cm4gZ2V0UGxhdGZvcm1zKGUpLmluY2x1ZGVzKHQpfTt2YXIgc2V0dXBQbGF0Zm9ybXM9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT13aW5kb3d9aWYodHlwZW9mIGU9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm5bXX1lLklvbmljPWUuSW9uaWN8fHt9O3ZhciB0PWUuSW9uaWMucGxhdGZvcm1zO2lmKHQ9PW51bGwpe3Q9ZS5Jb25pYy5wbGF0Zm9ybXM9ZGV0ZWN0UGxhdGZvcm1zKGUpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwbHQtXCIuY29uY2F0KHQpKX0pKX1yZXR1cm4gdH07dmFyIGRldGVjdFBsYXRmb3Jtcz1mdW5jdGlvbihlKXt2YXIgdD1jb25maWcuZ2V0KFwicGxhdGZvcm1cIik7cmV0dXJuIE9iamVjdC5rZXlzKFBMQVRGT1JNU19NQVApLmZpbHRlcigoZnVuY3Rpb24obil7dmFyIGk9dCYmdFtuXTtyZXR1cm4gdHlwZW9mIGk9PT1cImZ1bmN0aW9uXCI/aShlKTpQTEFURk9STVNfTUFQW25dKGUpfSkpfTt2YXIgaXNNb2JpbGVXZWI9ZnVuY3Rpb24oZSl7cmV0dXJuIGlzTW9iaWxlKGUpJiYhaXNIeWJyaWQoZSl9O3ZhciBpc0lwYWQ9ZnVuY3Rpb24oZSl7aWYodGVzdFVzZXJBZ2VudChlLC9pUGFkL2kpKXtyZXR1cm4gdHJ1ZX1pZih0ZXN0VXNlckFnZW50KGUsL01hY2ludG9zaC9pKSYmaXNNb2JpbGUoZSkpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dmFyIGlzSXBob25lPWZ1bmN0aW9uKGUpe3JldHVybiB0ZXN0VXNlckFnZW50KGUsL2lQaG9uZS9pKX07dmFyIGlzSU9TPWZ1bmN0aW9uKGUpe3JldHVybiB0ZXN0VXNlckFnZW50KGUsL2lQaG9uZXxpUG9kL2kpfHxpc0lwYWQoZSl9O3ZhciBpc0FuZHJvaWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvYW5kcm9pZHxzaW5rL2kpfTt2YXIgaXNBbmRyb2lkVGFibGV0PWZ1bmN0aW9uKGUpe3JldHVybiBpc0FuZHJvaWQoZSkmJiF0ZXN0VXNlckFnZW50KGUsL21vYmlsZS9pKX07dmFyIGlzUGhhYmxldD1mdW5jdGlvbihlKXt2YXIgdD1lLmlubmVyV2lkdGg7dmFyIG49ZS5pbm5lckhlaWdodDt2YXIgaT1NYXRoLm1pbih0LG4pO3ZhciByPU1hdGgubWF4KHQsbik7cmV0dXJuIGk+MzkwJiZpPDUyMCYmKHI+NjIwJiZyPDgwMCl9O3ZhciBpc1RhYmxldD1mdW5jdGlvbihlKXt2YXIgdD1lLmlubmVyV2lkdGg7dmFyIG49ZS5pbm5lckhlaWdodDt2YXIgaT1NYXRoLm1pbih0LG4pO3ZhciByPU1hdGgubWF4KHQsbik7cmV0dXJuIGlzSXBhZChlKXx8aXNBbmRyb2lkVGFibGV0KGUpfHxpPjQ2MCYmaTw4MjAmJihyPjc4MCYmcjwxNDAwKX07dmFyIGlzTW9iaWxlPWZ1bmN0aW9uKGUpe3JldHVybiBtYXRjaE1lZGlhKGUsXCIoYW55LXBvaW50ZXI6Y29hcnNlKVwiKX07dmFyIGlzRGVza3RvcD1mdW5jdGlvbihlKXtyZXR1cm4haXNNb2JpbGUoZSl9O3ZhciBpc0h5YnJpZD1mdW5jdGlvbihlKXtyZXR1cm4gaXNDb3Jkb3ZhKGUpfHxpc0NhcGFjaXRvck5hdGl2ZShlKX07dmFyIGlzQ29yZG92YT1mdW5jdGlvbihlKXtyZXR1cm4hIShlW1wiY29yZG92YVwiXXx8ZVtcInBob25lZ2FwXCJdfHxlW1wiUGhvbmVHYXBcIl0pfTt2YXIgaXNDYXBhY2l0b3JOYXRpdmU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVtcIkNhcGFjaXRvclwiXTtyZXR1cm4hISh0JiZ0LmlzTmF0aXZlKX07dmFyIGlzRWxlY3Ryb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRlc3RVc2VyQWdlbnQoZSwvZWxlY3Ryb24vaSl9O3ZhciBpc1BXQT1mdW5jdGlvbihlKXtyZXR1cm4hIShlLm1hdGNoTWVkaWEmJmUubWF0Y2hNZWRpYShcIihkaXNwbGF5LW1vZGU6IHN0YW5kYWxvbmUpXCIpLm1hdGNoZXN8fGUubmF2aWdhdG9yLnN0YW5kYWxvbmUpfTt2YXIgdGVzdFVzZXJBZ2VudD1mdW5jdGlvbihlLHQpe3JldHVybiB0LnRlc3QoZS5uYXZpZ2F0b3IudXNlckFnZW50KX07dmFyIG1hdGNoTWVkaWE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5tYXRjaE1lZGlhJiZlLm1hdGNoTWVkaWEodCkubWF0Y2hlc307dmFyIFBMQVRGT1JNU19NQVA9e2lwYWQ6aXNJcGFkLGlwaG9uZTppc0lwaG9uZSxpb3M6aXNJT1MsYW5kcm9pZDppc0FuZHJvaWQscGhhYmxldDppc1BoYWJsZXQsdGFibGV0OmlzVGFibGV0LGNvcmRvdmE6aXNDb3Jkb3ZhLGNhcGFjaXRvcjppc0NhcGFjaXRvck5hdGl2ZSxlbGVjdHJvbjppc0VsZWN0cm9uLHB3YTppc1BXQSxtb2JpbGU6aXNNb2JpbGUsbW9iaWxld2ViOmlzTW9iaWxlV2ViLGRlc2t0b3A6aXNEZXNrdG9wLGh5YnJpZDppc0h5YnJpZH07dmFyIGRlZmF1bHRNb2RlO3ZhciBnZXRJb25Nb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZnZXRNb2RlKGUpfHxkZWZhdWx0TW9kZX07dmFyIGluaXRpYWxpemU9ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT17fX1pZih0eXBlb2Ygd2luZG93PT09XCJ1bmRlZmluZWRcIil7cmV0dXJufXZhciB0PXdpbmRvdy5kb2N1bWVudDt2YXIgbj13aW5kb3c7dmFyIGk9bi5Jb25pYz1uLklvbmljfHx7fTt2YXIgcj17fTtpZihlLl9hZWwpe3IuYWVsPWUuX2FlbH1pZihlLl9yZWwpe3IucmVsPWUuX3JlbH1pZihlLl9jZSl7ci5jZT1lLl9jZX1zZXRQbGF0Zm9ybUhlbHBlcnMocik7dmFyIG89T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGNvbmZpZ0Zyb21TZXNzaW9uKG4pKSx7cGVyc2lzdENvbmZpZzpmYWxzZX0pLGkuY29uZmlnKSxjb25maWdGcm9tVVJMKG4pKSxlKTtjb25maWcucmVzZXQobyk7aWYoY29uZmlnLmdldEJvb2xlYW4oXCJwZXJzaXN0Q29uZmlnXCIpKXtzYXZlQ29uZmlnKG4sbyl9c2V0dXBQbGF0Zm9ybXMobik7aS5jb25maWc9Y29uZmlnO2kubW9kZT1kZWZhdWx0TW9kZT1jb25maWcuZ2V0KFwibW9kZVwiLHQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcIm1vZGVcIil8fChpc1BsYXRmb3JtKG4sXCJpb3NcIik/XCJpb3NcIjpcIm1kXCIpKTtjb25maWcuc2V0KFwibW9kZVwiLGRlZmF1bHRNb2RlKTt0LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtb2RlXCIsZGVmYXVsdE1vZGUpO3QuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmYXVsdE1vZGUpO2lmKGNvbmZpZy5nZXRCb29sZWFuKFwiX3Rlc3RpbmdcIikpe2NvbmZpZy5zZXQoXCJhbmltYXRlZFwiLGZhbHNlKX12YXIgYT1mdW5jdGlvbihlKXtyZXR1cm4gZS50YWdOYW1lJiZlLnRhZ05hbWUuc3RhcnRzV2l0aChcIklPTi1cIil9O3ZhciBzPWZ1bmN0aW9uKGUpe3JldHVybltcImlvc1wiLFwibWRcIl0uaW5jbHVkZXMoZSl9O3NldE1vZGUoKGZ1bmN0aW9uKGUpe3doaWxlKGUpe3ZhciB0PWUubW9kZXx8ZS5nZXRBdHRyaWJ1dGUoXCJtb2RlXCIpO2lmKHQpe2lmKHModCkpe3JldHVybiB0fWVsc2UgaWYoYShlKSl7Y29uc29sZS53YXJuKCdJbnZhbGlkIGlvbmljIG1vZGU6IFwiJyt0KydcIiwgZXhwZWN0ZWQ6IFwiaW9zXCIgb3IgXCJtZFwiJyl9fWU9ZS5wYXJlbnRFbGVtZW50fXJldHVybiBkZWZhdWx0TW9kZX0pKX07ZXhwb3J0e2lzUGxhdGZvcm0gYXMgYSxnZXRJb25Nb2RlIGFzIGIsY29uZmlnIGFzIGMsZ2V0UGxhdGZvcm1zIGFzIGcsaW5pdGlhbGl6ZSBhcyBpfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///882\n')},8360:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "iosTransitionAnimation": () => (/* binding */ iosTransitionAnimation),\n/* harmony export */   "shadow": () => (/* binding */ shadow)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar DURATION=540;var getClonedElement=function(t){return document.querySelector("".concat(t,".ion-cloned-element"))};var shadow=function(t){return t.shadowRoot||t};var getLargeTitle=function(t){var e=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var a="ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large";if(e!=null){var o=e.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");return o!=null?o.querySelector(a):null}return t.querySelector(a)};var getBackButton=function(t,e){var a=t.tagName==="ION-TABS"?t:t.querySelector("ion-tabs");var o=[];if(a!=null){var r=a.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)");if(r!=null){o=r.querySelectorAll("ion-buttons")}}else{o=t.querySelectorAll("ion-buttons")}for(var n=0,i=o;n<i.length;n++){var l=i[n];var c=l.closest("ion-header");var s=c&&!c.classList.contains("header-collapse-condense-inactive");var f=l.querySelector("ion-back-button");var d=l.classList.contains("buttons-collapse");var m=l.slot==="start"||l.slot==="";if(f!==null&&m&&(d&&s&&e||!d)){return f}}return null};var createLargeTitleTransition=function(t,e,a,o,r){var n=getBackButton(o,a);var i=getLargeTitle(r);var l=getLargeTitle(o);var c=getBackButton(r,a);var s=n!==null&&i!==null&&!a;var f=l!==null&&c!==null&&a;if(s){var d=i.getBoundingClientRect();var m=n.getBoundingClientRect();animateLargeTitle(t,e,a,i,d,m);animateBackButton(t,e,a,n,d,m)}else if(f){var v=l.getBoundingClientRect();var p=c.getBoundingClientRect();animateLargeTitle(t,e,a,l,v,p);animateBackButton(t,e,a,c,v,p)}return{forward:s,backward:f}};var animateBackButton=function(t,e,a,o,r,n){var i=e?"calc(100% - ".concat(n.right+4,"px)"):"".concat(n.left-4,"px");var l=e?"7px":"-7px";var c=e?"-4px":"4px";var s=e?"-4px":"4px";var f=e?"right":"left";var d=e?"left":"right";var m=[{offset:0,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")},{offset:1,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")}];var v=[{offset:0,opacity:1,transform:"translate3d(".concat(c,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(l,", ").concat(r.top-40,"px, 0) scale(2.1)")}];var p=a?v:m;var y=[{offset:0,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")}];var u=[{offset:0,opacity:1,transform:"translate3d(".concat(s,", ").concat(n.top-46,"px, 0) scale(1)")},{offset:.2,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")},{offset:1,opacity:0,transform:"translate3d(".concat(s,", ").concat(n.top-41,"px, 0) scale(0.6)")}];var b=a?u:y;var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var S=getClonedElement("ion-back-button");var T=shadow(S).querySelector(".button-text");var h=shadow(S).querySelector("ion-icon");S.text=o.text;S.mode=o.mode;S.icon=o.icon;S.color=o.color;S.disabled=o.disabled;S.style.setProperty("display","block");S.style.setProperty("position","fixed");A.addElement(h);g.addElement(T);g.beforeStyles({"transform-origin":"".concat(f," center")}).beforeAddWrite((function(){o.style.setProperty("display","none");S.style.setProperty(f,i)})).afterAddWrite((function(){o.style.setProperty("display","");S.style.setProperty("display","none");S.style.removeProperty(f)})).keyframes(p);A.beforeStyles({"transform-origin":"".concat(d," center")}).keyframes(b);t.addAnimation([g,A])};var animateLargeTitle=function(t,e,a,o,r,n){var i;var l=e?"calc(100% - ".concat(r.right,"px)"):"".concat(r.left,"px");var c=e?"-18px":"18px";var s=e?"right":"left";var f=[{offset:0,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.49)")},{offset:.1,opacity:0},{offset:1,opacity:1,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")}];var d=[{offset:0,opacity:.99,transform:"translate3d(0, ".concat(r.top-2,"px, 0) scale(1)")},{offset:.6,opacity:0},{offset:1,opacity:0,transform:"translate3d(".concat(c,", ").concat(n.top-4,"px, 0) scale(0.5)")}];var m=a?f:d;var v=getClonedElement("ion-title");var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();v.innerText=o.innerText;v.size=o.size;v.color=o.color;p.addElement(v);p.beforeStyles((i={"transform-origin":"".concat(s," center"),height:"46px",display:"",position:"relative"},i[s]=l,i)).beforeAddWrite((function(){o.style.setProperty("display","none")})).afterAddWrite((function(){o.style.setProperty("display","");v.style.setProperty("display","none")})).keyframes(m);t.addAnimation(p)};var iosTransitionAnimation=function(t,e){try{var a="cubic-bezier(0.32,0.72,0,1)";var o="opacity";var r="transform";var n="0%";var i=.8;var l=t.ownerDocument.dir==="rtl";var c=l?"-99.5%":"99.5%";var s=l?"33%":"-33%";var f=e.enteringEl;var d=e.leavingEl;var m=e.direction==="back";var v=f.querySelector(":scope > ion-content");var p=f.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");var y=f.querySelectorAll(":scope > ion-header > ion-toolbar");var u=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();u.addElement(f).duration(e.duration||DURATION).easing(e.easing||a).fill("both").beforeRemoveClass("ion-page-invisible");if(d&&t){var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();g.addElement(t);u.addAnimation(g)}if(!v&&y.length===0&&p.length===0){b.addElement(f.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{b.addElement(v);b.addElement(p)}u.addAnimation(b);if(m){b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,i,1)}else{b.beforeClearStyles([o]).fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"))}if(v){var A=shadow(v).querySelector(".transition-effect");if(A){var S=A.querySelector(".transition-cover");var T=A.querySelector(".transition-shadow");var h=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var x=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var E=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();h.addElement(A).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});x.addElement(S).beforeClearStyles([o]).fromTo(o,0,.1);E.addElement(T).beforeClearStyles([o]).fromTo(o,.03,.7);h.addAnimation([x,E]);b.addAnimation([h])}}var q=f.querySelector("ion-header.header-collapse-condense");var X=createLargeTitleTransition(u,l,m,f,d),C=X.forward,k=X.backward;y.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);u.addAnimation(e);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var r=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var i=Array.from(t.querySelectorAll("ion-buttons,[menuToggle]"));var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v;if(m){v=i.filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}))}else{v=i.filter((function(t){return!t.classList.contains("buttons-collapse")}))}r.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();p.addElement(t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"));var y=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();y.addElement(shadow(t).querySelector(".toolbar-background"));var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var g=t.querySelector("ion-back-button");if(g){b.addElement(g)}e.addAnimation([a,r,p,y,b]);r.fromTo(o,.01,1);p.fromTo(o,.01,1);if(m){if(!d){a.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(s,")"),"translateX(".concat(n,")"));b.fromTo(o,.01,1)}else{if(!q){a.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")")).fromTo(o,.01,1)}p.fromTo("transform","translateX(".concat(c,")"),"translateX(".concat(n,")"));y.beforeClearStyles([o,"transform"]);var A=f===null||f===void 0?void 0:f.translucent;if(!A){y.fromTo(o,.01,"var(--opacity)")}else{y.fromTo("transform",l?"translateX(-100%)":"translateX(100%)","translateX(0px)")}if(!C){b.fromTo(o,.01,1)}if(g&&!C){var S=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();S.addElement(shadow(g).querySelector(".button-text")).fromTo("transform",l?"translateX(-100px)":"translateX(100px)","translateX(0px)");e.addAnimation(S)}}}));if(d){var w=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var B=d.querySelector(":scope > ion-content");var L=d.querySelectorAll(":scope > ion-header > ion-toolbar");var P=d.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *");if(!B&&L.length===0&&P.length===0){w.addElement(d.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs"))}else{w.addElement(B);w.addElement(P)}u.addAnimation(w);if(m){w.beforeClearStyles([o]).fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");var R=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(d);u.afterAddWrite((function(){if(u.getDirection()==="normal"){R.style.setProperty("display","none")}}))}else{w.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,1,i)}if(B){var I=shadow(B).querySelector(".transition-effect");if(I){var N=I.querySelector(".transition-cover");var W=I.querySelector(".transition-shadow");var j=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var D=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var O=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();j.addElement(I).beforeStyles({opacity:"1",display:"block"}).afterStyles({opacity:"",display:""});D.addElement(N).beforeClearStyles([o]).fromTo(o,.1,0);O.addElement(W).beforeClearStyles([o]).fromTo(o,.7,.03);j.addAnimation([D,O]);w.addAnimation([j])}}L.forEach((function(t){var e=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();e.addElement(t);var a=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();a.addElement(t.querySelector("ion-title"));var i=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var c=t.querySelectorAll("ion-buttons,[menuToggle]");var f=t.closest("ion-header");var d=f&&f.classList.contains("header-collapse-condense-inactive");var v=Array.from(c).filter((function(t){var e=t.classList.contains("buttons-collapse");return e&&!d||!e}));i.addElement(v);var p=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var y=t.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])");if(y.length>0){p.addElement(y)}var b=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();b.addElement(shadow(t).querySelector(".toolbar-background"));var g=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();var A=t.querySelector("ion-back-button");if(A){g.addElement(A)}e.addAnimation([a,i,p,g,b]);u.addAnimation(e);g.fromTo(o,.99,0);i.fromTo(o,.99,0);p.fromTo(o,.99,0);if(m){if(!d){a.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)").fromTo(o,.99,0)}p.fromTo("transform","translateX(".concat(n,")"),l?"translateX(-100%)":"translateX(100%)");b.beforeClearStyles([o,"transform"]);var S=f===null||f===void 0?void 0:f.translucent;if(!S){b.fromTo(o,"var(--opacity)",0)}else{b.fromTo("transform","translateX(0px)",l?"translateX(-100%)":"translateX(100%)")}if(A&&!k){var T=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();T.addElement(shadow(A).querySelector(".button-text")).fromTo("transform","translateX(".concat(n,")"),"translateX(".concat((l?-124:124)+"px",")"));e.addAnimation(T)}}else{if(!d){a.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).fromTo(o,.99,0).afterClearStyles([r,o])}p.fromTo("transform","translateX(".concat(n,")"),"translateX(".concat(s,")")).afterClearStyles([r,o]);g.afterClearStyles([o]);a.afterClearStyles([o]);i.afterClearStyles([o])}}))}return u}catch(t){throw t}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU8sa0JBQWtCLFVBQVUsTUFBTSx5REFBZSxHQUFHLHVJQUF1SSxvQkFBb0IsR0FBRyxNQUFNLE1BQU0seURBQWUsR0FBRyw4Q0FBOEMsOERBQThELDhGQUE4RixtQ0FBbUMseUZBQXlGLEtBQUssZ0JBQWdCLGdCQUFnQixrQkFBa0IsTUFBTSxrSEFBa0gsTUFBTSxxREFBaUIsSUFBSSw0QkFBNEIsZ0NBQWdDLHVDQUF1QyxHQUFHLEtBQUssNEZBQTRGLE1BQU0sb0RBQW9ELE1BQU0sMkNBQTJDLDRDQUE0QyxNQUFNLHlEQUFlLEdBQUcsTUFBTSx5REFBZSxHQUFHLE1BQU0seURBQWUsR0FBRyw4QkFBOEIsNEJBQTRCLGVBQWUsc0JBQXNCLEVBQUUsc0RBQXNELHdEQUF3RCxzQkFBc0IscUJBQXFCLHVCQUF1QixNQUFNLHlEQUFlLEdBQUcsZ0JBQWdCLE1BQU0seURBQWUsR0FBRywyQ0FBMkMsTUFBTSx5REFBZSxHQUFHLHFEQUFxRCw4QkFBOEIsbUVBQW1FLHdDQUF3QywrQ0FBK0MsaUJBQWlCLEdBQUcsZ0JBQWdCLE1BQU0seURBQWUsR0FBRyx5RkFBeUYsZUFBZSxnQkFBZ0IsTUFBTSx5REFBZSxHQUFHLDZEQUE2RCxNQUFNLHlEQUFlLEdBQUcseUNBQXlDLE1BQU0sZ0JBQWdCLDRCQUE0QixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0IsTUFBTSxPQUFPLDJHQUEyRywyRkFBMkYscUNBQXFDLGdEQUFnRCxPQUFPLCtCQUErQixLQUFLLGlGQUFpRixVQUFVLE1BQU0seURBQWUsR0FBRyxrSkFBa0osbUJBQW1CLEtBQUssT0FBTyxzSEFBc0gsc0dBQXNHLHdCQUF3Qix3QkFBd0IseUJBQXlCLEdBQUcsU0FBUyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvaW9zLnRyYW5zaXRpb24tOGI2YTc3NmEuanM/M2I5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0e2MgYXMgY3JlYXRlQW5pbWF0aW9ufWZyb21cIi4vYW5pbWF0aW9uLTE5ZGJmOWJmLmpzXCI7aW1wb3J0e2cgYXMgZ2V0SW9uUGFnZUVsZW1lbnR9ZnJvbVwiLi9pbmRleC1lNmMyYzgyMi5qc1wiO2ltcG9ydFwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7aW1wb3J0XCIuL2luZGV4LWIzZWVjYjE0LmpzXCI7dmFyIERVUkFUSU9OPTU0MDt2YXIgZ2V0Q2xvbmVkRWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIlwiLmNvbmNhdCh0LFwiLmlvbi1jbG9uZWQtZWxlbWVudFwiKSl9O3ZhciBzaGFkb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhZG93Um9vdHx8dH07dmFyIGdldExhcmdlVGl0bGU9ZnVuY3Rpb24odCl7dmFyIGU9dC50YWdOYW1lPT09XCJJT04tVEFCU1wiP3Q6dC5xdWVyeVNlbGVjdG9yKFwiaW9uLXRhYnNcIik7dmFyIGE9XCJpb24tY29udGVudCBpb24taGVhZGVyOm5vdCguaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlKSBpb24tdGl0bGUudGl0bGUtbGFyZ2VcIjtpZihlIT1udWxsKXt2YXIgbz1lLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFiOm5vdCgudGFiLWhpZGRlbiksIC5pb24tcGFnZTpub3QoLmlvbi1wYWdlLWhpZGRlbilcIik7cmV0dXJuIG8hPW51bGw/by5xdWVyeVNlbGVjdG9yKGEpOm51bGx9cmV0dXJuIHQucXVlcnlTZWxlY3RvcihhKX07dmFyIGdldEJhY2tCdXR0b249ZnVuY3Rpb24odCxlKXt2YXIgYT10LnRhZ05hbWU9PT1cIklPTi1UQUJTXCI/dDp0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFic1wiKTt2YXIgbz1bXTtpZihhIT1udWxsKXt2YXIgcj1hLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGFiOm5vdCgudGFiLWhpZGRlbiksIC5pb24tcGFnZTpub3QoLmlvbi1wYWdlLWhpZGRlbilcIik7aWYociE9bnVsbCl7bz1yLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpb24tYnV0dG9uc1wiKX19ZWxzZXtvPXQucXVlcnlTZWxlY3RvckFsbChcImlvbi1idXR0b25zXCIpfWZvcih2YXIgbj0wLGk9bztuPGkubGVuZ3RoO24rKyl7dmFyIGw9aVtuXTt2YXIgYz1sLmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBzPWMmJiFjLmNsYXNzTGlzdC5jb250YWlucyhcImhlYWRlci1jb2xsYXBzZS1jb25kZW5zZS1pbmFjdGl2ZVwiKTt2YXIgZj1sLnF1ZXJ5U2VsZWN0b3IoXCJpb24tYmFjay1idXR0b25cIik7dmFyIGQ9bC5jbGFzc0xpc3QuY29udGFpbnMoXCJidXR0b25zLWNvbGxhcHNlXCIpO3ZhciBtPWwuc2xvdD09PVwic3RhcnRcInx8bC5zbG90PT09XCJcIjtpZihmIT09bnVsbCYmbSYmKGQmJnMmJmV8fCFkKSl7cmV0dXJuIGZ9fXJldHVybiBudWxsfTt2YXIgY3JlYXRlTGFyZ2VUaXRsZVRyYW5zaXRpb249ZnVuY3Rpb24odCxlLGEsbyxyKXt2YXIgbj1nZXRCYWNrQnV0dG9uKG8sYSk7dmFyIGk9Z2V0TGFyZ2VUaXRsZShyKTt2YXIgbD1nZXRMYXJnZVRpdGxlKG8pO3ZhciBjPWdldEJhY2tCdXR0b24ocixhKTt2YXIgcz1uIT09bnVsbCYmaSE9PW51bGwmJiFhO3ZhciBmPWwhPT1udWxsJiZjIT09bnVsbCYmYTtpZihzKXt2YXIgZD1pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBtPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7YW5pbWF0ZUxhcmdlVGl0bGUodCxlLGEsaSxkLG0pO2FuaW1hdGVCYWNrQnV0dG9uKHQsZSxhLG4sZCxtKX1lbHNlIGlmKGYpe3ZhciB2PWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIHA9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTthbmltYXRlTGFyZ2VUaXRsZSh0LGUsYSxsLHYscCk7YW5pbWF0ZUJhY2tCdXR0b24odCxlLGEsYyx2LHApfXJldHVybntmb3J3YXJkOnMsYmFja3dhcmQ6Zn19O3ZhciBhbmltYXRlQmFja0J1dHRvbj1mdW5jdGlvbih0LGUsYSxvLHIsbil7dmFyIGk9ZT9cImNhbGMoMTAwJSAtIFwiLmNvbmNhdChuLnJpZ2h0KzQsXCJweClcIik6XCJcIi5jb25jYXQobi5sZWZ0LTQsXCJweFwiKTt2YXIgbD1lP1wiN3B4XCI6XCItN3B4XCI7dmFyIGM9ZT9cIi00cHhcIjpcIjRweFwiO3ZhciBzPWU/XCItNHB4XCI6XCI0cHhcIjt2YXIgZj1lP1wicmlnaHRcIjpcImxlZnRcIjt2YXIgZD1lP1wibGVmdFwiOlwicmlnaHRcIjt2YXIgbT1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQobCxcIiwgXCIpLmNvbmNhdChyLnRvcC00MCxcInB4LCAwKSBzY2FsZSgyLjEpXCIpfSx7b2Zmc2V0OjEsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChjLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfV07dmFyIHY9W3tvZmZzZXQ6MCxvcGFjaXR5OjEsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KGMsXCIsIFwiKS5jb25jYXQobi50b3AtNDYsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjYsb3BhY2l0eTowfSx7b2Zmc2V0OjEsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChsLFwiLCBcIikuY29uY2F0KHIudG9wLTQwLFwicHgsIDApIHNjYWxlKDIuMSlcIil9XTt2YXIgcD1hP3Y6bTt2YXIgeT1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQocyxcIiwgXCIpLmNvbmNhdChuLnRvcC00MSxcInB4LCAwKSBzY2FsZSgwLjYpXCIpfSx7b2Zmc2V0OjEsb3BhY2l0eToxLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQ2LFwicHgsIDApIHNjYWxlKDEpXCIpfV07dmFyIHU9W3tvZmZzZXQ6MCxvcGFjaXR5OjEsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHMsXCIsIFwiKS5jb25jYXQobi50b3AtNDYsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjIsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KG4udG9wLTQxLFwicHgsIDApIHNjYWxlKDAuNilcIil9LHtvZmZzZXQ6MSxvcGFjaXR5OjAsdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoXCIuY29uY2F0KHMsXCIsIFwiKS5jb25jYXQobi50b3AtNDEsXCJweCwgMCkgc2NhbGUoMC42KVwiKX1dO3ZhciBiPWE/dTp5O3ZhciBnPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBBPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBTPWdldENsb25lZEVsZW1lbnQoXCJpb24tYmFjay1idXR0b25cIik7dmFyIFQ9c2hhZG93KFMpLnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uLXRleHRcIik7dmFyIGg9c2hhZG93KFMpLnF1ZXJ5U2VsZWN0b3IoXCJpb24taWNvblwiKTtTLnRleHQ9by50ZXh0O1MubW9kZT1vLm1vZGU7Uy5pY29uPW8uaWNvbjtTLmNvbG9yPW8uY29sb3I7Uy5kaXNhYmxlZD1vLmRpc2FibGVkO1Muc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJibG9ja1wiKTtTLnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIixcImZpeGVkXCIpO0EuYWRkRWxlbWVudChoKTtnLmFkZEVsZW1lbnQoVCk7Zy5iZWZvcmVTdHlsZXMoe1widHJhbnNmb3JtLW9yaWdpblwiOlwiXCIuY29uY2F0KGYsXCIgY2VudGVyXCIpfSkuYmVmb3JlQWRkV3JpdGUoKGZ1bmN0aW9uKCl7by5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIik7Uy5zdHlsZS5zZXRQcm9wZXJ0eShmLGkpfSkpLmFmdGVyQWRkV3JpdGUoKGZ1bmN0aW9uKCl7by5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIlwiKTtTLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiKTtTLnN0eWxlLnJlbW92ZVByb3BlcnR5KGYpfSkpLmtleWZyYW1lcyhwKTtBLmJlZm9yZVN0eWxlcyh7XCJ0cmFuc2Zvcm0tb3JpZ2luXCI6XCJcIi5jb25jYXQoZCxcIiBjZW50ZXJcIil9KS5rZXlmcmFtZXMoYik7dC5hZGRBbmltYXRpb24oW2csQV0pfTt2YXIgYW5pbWF0ZUxhcmdlVGl0bGU9ZnVuY3Rpb24odCxlLGEsbyxyLG4pe3ZhciBpO3ZhciBsPWU/XCJjYWxjKDEwMCUgLSBcIi5jb25jYXQoci5yaWdodCxcInB4KVwiKTpcIlwiLmNvbmNhdChyLmxlZnQsXCJweFwiKTt2YXIgYz1lP1wiLTE4cHhcIjpcIjE4cHhcIjt2YXIgcz1lP1wicmlnaHRcIjpcImxlZnRcIjt2YXIgZj1be29mZnNldDowLG9wYWNpdHk6MCx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoYyxcIiwgXCIpLmNvbmNhdChuLnRvcC00LFwicHgsIDApIHNjYWxlKDAuNDkpXCIpfSx7b2Zmc2V0Oi4xLG9wYWNpdHk6MH0se29mZnNldDoxLG9wYWNpdHk6MSx0cmFuc2Zvcm06XCJ0cmFuc2xhdGUzZCgwLCBcIi5jb25jYXQoci50b3AtMixcInB4LCAwKSBzY2FsZSgxKVwiKX1dO3ZhciBkPVt7b2Zmc2V0OjAsb3BhY2l0eTouOTksdHJhbnNmb3JtOlwidHJhbnNsYXRlM2QoMCwgXCIuY29uY2F0KHIudG9wLTIsXCJweCwgMCkgc2NhbGUoMSlcIil9LHtvZmZzZXQ6LjYsb3BhY2l0eTowfSx7b2Zmc2V0OjEsb3BhY2l0eTowLHRyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChjLFwiLCBcIikuY29uY2F0KG4udG9wLTQsXCJweCwgMCkgc2NhbGUoMC41KVwiKX1dO3ZhciBtPWE/ZjpkO3ZhciB2PWdldENsb25lZEVsZW1lbnQoXCJpb24tdGl0bGVcIik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7di5pbm5lclRleHQ9by5pbm5lclRleHQ7di5zaXplPW8uc2l6ZTt2LmNvbG9yPW8uY29sb3I7cC5hZGRFbGVtZW50KHYpO3AuYmVmb3JlU3R5bGVzKChpPXtcInRyYW5zZm9ybS1vcmlnaW5cIjpcIlwiLmNvbmNhdChzLFwiIGNlbnRlclwiKSxoZWlnaHQ6XCI0NnB4XCIsZGlzcGxheTpcIlwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIn0saVtzXT1sLGkpKS5iZWZvcmVBZGRXcml0ZSgoZnVuY3Rpb24oKXtvLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiKX0pKS5hZnRlckFkZFdyaXRlKChmdW5jdGlvbigpe28uc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJcIik7di5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9KSkua2V5ZnJhbWVzKG0pO3QuYWRkQW5pbWF0aW9uKHApfTt2YXIgaW9zVHJhbnNpdGlvbkFuaW1hdGlvbj1mdW5jdGlvbih0LGUpe3RyeXt2YXIgYT1cImN1YmljLWJlemllcigwLjMyLDAuNzIsMCwxKVwiO3ZhciBvPVwib3BhY2l0eVwiO3ZhciByPVwidHJhbnNmb3JtXCI7dmFyIG49XCIwJVwiO3ZhciBpPS44O3ZhciBsPXQub3duZXJEb2N1bWVudC5kaXI9PT1cInJ0bFwiO3ZhciBjPWw/XCItOTkuNSVcIjpcIjk5LjUlXCI7dmFyIHM9bD9cIjMzJVwiOlwiLTMzJVwiO3ZhciBmPWUuZW50ZXJpbmdFbDt2YXIgZD1lLmxlYXZpbmdFbDt2YXIgbT1lLmRpcmVjdGlvbj09PVwiYmFja1wiO3ZhciB2PWYucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IGlvbi1jb250ZW50XCIpO3ZhciBwPWYucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiAqOm5vdChpb24tdG9vbGJhciksIDpzY29wZSA+IGlvbi1mb290ZXIgPiAqXCIpO3ZhciB5PWYucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiBpb24tdG9vbGJhclwiKTt2YXIgdT1jcmVhdGVBbmltYXRpb24oKTt2YXIgYj1jcmVhdGVBbmltYXRpb24oKTt1LmFkZEVsZW1lbnQoZikuZHVyYXRpb24oZS5kdXJhdGlvbnx8RFVSQVRJT04pLmVhc2luZyhlLmVhc2luZ3x8YSkuZmlsbChcImJvdGhcIikuYmVmb3JlUmVtb3ZlQ2xhc3MoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aWYoZCYmdCl7dmFyIGc9Y3JlYXRlQW5pbWF0aW9uKCk7Zy5hZGRFbGVtZW50KHQpO3UuYWRkQW5pbWF0aW9uKGcpfWlmKCF2JiZ5Lmxlbmd0aD09PTAmJnAubGVuZ3RoPT09MCl7Yi5hZGRFbGVtZW50KGYucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IC5pb24tcGFnZSwgOnNjb3BlID4gaW9uLW5hdiwgOnNjb3BlID4gaW9uLXRhYnNcIikpfWVsc2V7Yi5hZGRFbGVtZW50KHYpO2IuYWRkRWxlbWVudChwKX11LmFkZEFuaW1hdGlvbihiKTtpZihtKXtiLmJlZm9yZUNsZWFyU3R5bGVzKFtvXSkuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obyxpLDEpfWVsc2V7Yi5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQoYyxcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSl9aWYodil7dmFyIEE9c2hhZG93KHYpLnF1ZXJ5U2VsZWN0b3IoXCIudHJhbnNpdGlvbi1lZmZlY3RcIik7aWYoQSl7dmFyIFM9QS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tY292ZXJcIik7dmFyIFQ9QS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tc2hhZG93XCIpO3ZhciBoPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciB4PWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBFPWNyZWF0ZUFuaW1hdGlvbigpO2guYWRkRWxlbWVudChBKS5iZWZvcmVTdHlsZXMoe29wYWNpdHk6XCIxXCIsZGlzcGxheTpcImJsb2NrXCJ9KS5hZnRlclN0eWxlcyh7b3BhY2l0eTpcIlwiLGRpc3BsYXk6XCJcIn0pO3guYWRkRWxlbWVudChTKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLDAsLjEpO0UuYWRkRWxlbWVudChUKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC4wMywuNyk7aC5hZGRBbmltYXRpb24oW3gsRV0pO2IuYWRkQW5pbWF0aW9uKFtoXSl9fXZhciBxPWYucXVlcnlTZWxlY3RvcihcImlvbi1oZWFkZXIuaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlXCIpO3ZhciBYPWNyZWF0ZUxhcmdlVGl0bGVUcmFuc2l0aW9uKHUsbCxtLGYsZCksQz1YLmZvcndhcmQsaz1YLmJhY2t3YXJkO3kuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Y3JlYXRlQW5pbWF0aW9uKCk7ZS5hZGRFbGVtZW50KHQpO3UuYWRkQW5pbWF0aW9uKGUpO3ZhciBhPWNyZWF0ZUFuaW1hdGlvbigpO2EuYWRkRWxlbWVudCh0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGl0bGVcIikpO3ZhciByPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBpPUFycmF5LmZyb20odC5xdWVyeVNlbGVjdG9yQWxsKFwiaW9uLWJ1dHRvbnMsW21lbnVUb2dnbGVdXCIpKTt2YXIgZj10LmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBkPWYmJmYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlXCIpO3ZhciB2O2lmKG0pe3Y9aS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBlPXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYnV0dG9ucy1jb2xsYXBzZVwiKTtyZXR1cm4gZSYmIWR8fCFlfSkpfWVsc2V7dj1pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYnV0dG9ucy1jb2xsYXBzZVwiKX0pKX1yLmFkZEVsZW1lbnQodik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7cC5hZGRFbGVtZW50KHQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+ICo6bm90KGlvbi10aXRsZSk6bm90KGlvbi1idXR0b25zKTpub3QoW21lbnVUb2dnbGVdKVwiKSk7dmFyIHk9Y3JlYXRlQW5pbWF0aW9uKCk7eS5hZGRFbGVtZW50KHNoYWRvdyh0KS5xdWVyeVNlbGVjdG9yKFwiLnRvb2xiYXItYmFja2dyb3VuZFwiKSk7dmFyIGI9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIGc9dC5xdWVyeVNlbGVjdG9yKFwiaW9uLWJhY2stYnV0dG9uXCIpO2lmKGcpe2IuYWRkRWxlbWVudChnKX1lLmFkZEFuaW1hdGlvbihbYSxyLHAseSxiXSk7ci5mcm9tVG8obywuMDEsMSk7cC5mcm9tVG8obywuMDEsMSk7aWYobSl7aWYoIWQpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChzLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obywuMDEsMSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIikpO2IuZnJvbVRvKG8sLjAxLDEpfWVsc2V7aWYoIXEpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChjLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpKS5mcm9tVG8obywuMDEsMSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KGMsXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIikpO3kuYmVmb3JlQ2xlYXJTdHlsZXMoW28sXCJ0cmFuc2Zvcm1cIl0pO3ZhciBBPWY9PT1udWxsfHxmPT09dm9pZCAwP3ZvaWQgMDpmLnRyYW5zbHVjZW50O2lmKCFBKXt5LmZyb21UbyhvLC4wMSxcInZhcigtLW9wYWNpdHkpXCIpfWVsc2V7eS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixsP1widHJhbnNsYXRlWCgtMTAwJSlcIjpcInRyYW5zbGF0ZVgoMTAwJSlcIixcInRyYW5zbGF0ZVgoMHB4KVwiKX1pZighQyl7Yi5mcm9tVG8obywuMDEsMSl9aWYoZyYmIUMpe3ZhciBTPWNyZWF0ZUFuaW1hdGlvbigpO1MuYWRkRWxlbWVudChzaGFkb3coZykucXVlcnlTZWxlY3RvcihcIi5idXR0b24tdGV4dFwiKSkuZnJvbVRvKFwidHJhbnNmb3JtXCIsbD9cInRyYW5zbGF0ZVgoLTEwMHB4KVwiOlwidHJhbnNsYXRlWCgxMDBweClcIixcInRyYW5zbGF0ZVgoMHB4KVwiKTtlLmFkZEFuaW1hdGlvbihTKX19fSkpO2lmKGQpe3ZhciB3PWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBCPWQucXVlcnlTZWxlY3RvcihcIjpzY29wZSA+IGlvbi1jb250ZW50XCIpO3ZhciBMPWQucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGlvbi1oZWFkZXIgPiBpb24tdG9vbGJhclwiKTt2YXIgUD1kLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgPiBpb24taGVhZGVyID4gKjpub3QoaW9uLXRvb2xiYXIpLCA6c2NvcGUgPiBpb24tZm9vdGVyID4gKlwiKTtpZighQiYmTC5sZW5ndGg9PT0wJiZQLmxlbmd0aD09PTApe3cuYWRkRWxlbWVudChkLnF1ZXJ5U2VsZWN0b3IoXCI6c2NvcGUgPiAuaW9uLXBhZ2UsIDpzY29wZSA+IGlvbi1uYXYsIDpzY29wZSA+IGlvbi10YWJzXCIpKX1lbHNle3cuYWRkRWxlbWVudChCKTt3LmFkZEVsZW1lbnQoUCl9dS5hZGRBbmltYXRpb24odyk7aWYobSl7dy5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIiksbD9cInRyYW5zbGF0ZVgoLTEwMCUpXCI6XCJ0cmFuc2xhdGVYKDEwMCUpXCIpO3ZhciBSPWdldElvblBhZ2VFbGVtZW50KGQpO3UuYWZ0ZXJBZGRXcml0ZSgoZnVuY3Rpb24oKXtpZih1LmdldERpcmVjdGlvbigpPT09XCJub3JtYWxcIil7Ui5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9fSkpfWVsc2V7dy5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIikpLmZyb21UbyhvLDEsaSl9aWYoQil7dmFyIEk9c2hhZG93KEIpLnF1ZXJ5U2VsZWN0b3IoXCIudHJhbnNpdGlvbi1lZmZlY3RcIik7aWYoSSl7dmFyIE49SS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tY292ZXJcIik7dmFyIFc9SS5xdWVyeVNlbGVjdG9yKFwiLnRyYW5zaXRpb24tc2hhZG93XCIpO3ZhciBqPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBEPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBPPWNyZWF0ZUFuaW1hdGlvbigpO2ouYWRkRWxlbWVudChJKS5iZWZvcmVTdHlsZXMoe29wYWNpdHk6XCIxXCIsZGlzcGxheTpcImJsb2NrXCJ9KS5hZnRlclN0eWxlcyh7b3BhY2l0eTpcIlwiLGRpc3BsYXk6XCJcIn0pO0QuYWRkRWxlbWVudChOKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC4xLDApO08uYWRkRWxlbWVudChXKS5iZWZvcmVDbGVhclN0eWxlcyhbb10pLmZyb21UbyhvLC43LC4wMyk7ai5hZGRBbmltYXRpb24oW0QsT10pO3cuYWRkQW5pbWF0aW9uKFtqXSl9fUwuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9Y3JlYXRlQW5pbWF0aW9uKCk7ZS5hZGRFbGVtZW50KHQpO3ZhciBhPWNyZWF0ZUFuaW1hdGlvbigpO2EuYWRkRWxlbWVudCh0LnF1ZXJ5U2VsZWN0b3IoXCJpb24tdGl0bGVcIikpO3ZhciBpPWNyZWF0ZUFuaW1hdGlvbigpO3ZhciBjPXQucXVlcnlTZWxlY3RvckFsbChcImlvbi1idXR0b25zLFttZW51VG9nZ2xlXVwiKTt2YXIgZj10LmNsb3Nlc3QoXCJpb24taGVhZGVyXCIpO3ZhciBkPWYmJmYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGVhZGVyLWNvbGxhcHNlLWNvbmRlbnNlLWluYWN0aXZlXCIpO3ZhciB2PUFycmF5LmZyb20oYykuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZT10LmNsYXNzTGlzdC5jb250YWlucyhcImJ1dHRvbnMtY29sbGFwc2VcIik7cmV0dXJuIGUmJiFkfHwhZX0pKTtpLmFkZEVsZW1lbnQodik7dmFyIHA9Y3JlYXRlQW5pbWF0aW9uKCk7dmFyIHk9dC5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlID4gKjpub3QoaW9uLXRpdGxlKTpub3QoaW9uLWJ1dHRvbnMpOm5vdChbbWVudVRvZ2dsZV0pXCIpO2lmKHkubGVuZ3RoPjApe3AuYWRkRWxlbWVudCh5KX12YXIgYj1jcmVhdGVBbmltYXRpb24oKTtiLmFkZEVsZW1lbnQoc2hhZG93KHQpLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbGJhci1iYWNrZ3JvdW5kXCIpKTt2YXIgZz1jcmVhdGVBbmltYXRpb24oKTt2YXIgQT10LnF1ZXJ5U2VsZWN0b3IoXCJpb24tYmFjay1idXR0b25cIik7aWYoQSl7Zy5hZGRFbGVtZW50KEEpfWUuYWRkQW5pbWF0aW9uKFthLGkscCxnLGJdKTt1LmFkZEFuaW1hdGlvbihlKTtnLmZyb21UbyhvLC45OSwwKTtpLmZyb21UbyhvLC45OSwwKTtwLmZyb21UbyhvLC45OSwwKTtpZihtKXtpZighZCl7YS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKS5mcm9tVG8obywuOTksMCl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLGw/XCJ0cmFuc2xhdGVYKC0xMDAlKVwiOlwidHJhbnNsYXRlWCgxMDAlKVwiKTtiLmJlZm9yZUNsZWFyU3R5bGVzKFtvLFwidHJhbnNmb3JtXCJdKTt2YXIgUz1mPT09bnVsbHx8Zj09PXZvaWQgMD92b2lkIDA6Zi50cmFuc2x1Y2VudDtpZighUyl7Yi5mcm9tVG8obyxcInZhcigtLW9wYWNpdHkpXCIsMCl9ZWxzZXtiLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWCgwcHgpXCIsbD9cInRyYW5zbGF0ZVgoLTEwMCUpXCI6XCJ0cmFuc2xhdGVYKDEwMCUpXCIpfWlmKEEmJiFrKXt2YXIgVD1jcmVhdGVBbmltYXRpb24oKTtULmFkZEVsZW1lbnQoc2hhZG93KEEpLnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uLXRleHRcIikpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWChcIi5jb25jYXQobixcIilcIiksXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdCgobD8tMTI0OjEyNCkrXCJweFwiLFwiKVwiKSk7ZS5hZGRBbmltYXRpb24oVCl9fWVsc2V7aWYoIWQpe2EuZnJvbVRvKFwidHJhbnNmb3JtXCIsXCJ0cmFuc2xhdGVYKFwiLmNvbmNhdChuLFwiKVwiKSxcInRyYW5zbGF0ZVgoXCIuY29uY2F0KHMsXCIpXCIpKS5mcm9tVG8obywuOTksMCkuYWZ0ZXJDbGVhclN0eWxlcyhbcixvXSl9cC5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVgoXCIuY29uY2F0KG4sXCIpXCIpLFwidHJhbnNsYXRlWChcIi5jb25jYXQocyxcIilcIikpLmFmdGVyQ2xlYXJTdHlsZXMoW3Isb10pO2cuYWZ0ZXJDbGVhclN0eWxlcyhbb10pO2EuYWZ0ZXJDbGVhclN0eWxlcyhbb10pO2kuYWZ0ZXJDbGVhclN0eWxlcyhbb10pfX0pKX1yZXR1cm4gdX1jYXRjaCh0KXt0aHJvdyB0fX07ZXhwb3J0e2lvc1RyYW5zaXRpb25BbmltYXRpb24sc2hhZG93fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8360\n')},2782:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mdTransitionAnimation": () => (/* binding */ mdTransitionAnimation)\n/* harmony export */ });\n/* harmony import */ var _animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7434);\n/* harmony import */ var _index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2032);\n/* harmony import */ var _index_b3eecb14_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2896);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nvar mdTransitionAnimation=function(e,n){var a="40px";var t="0px";var i=n.direction==="back";var o=n.enteringEl;var r=n.leavingEl;var m=(0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(o);var c=m.querySelector("ion-toolbar");var s=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();s.addElement(m).fill("both").beforeRemoveClass("ion-page-invisible");if(i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)")}else{s.duration(n.duration||280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform","translateY(".concat(a,")"),"translateY(".concat(t,")")).fromTo("opacity",.01,1)}if(c){var l=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();l.addElement(c);s.addAnimation(l)}if(r&&i){s.duration(n.duration||200).easing("cubic-bezier(0.47,0,0.745,0.715)");var d=(0,_animation_19dbf9bf_js__WEBPACK_IMPORTED_MODULE_2__.c)();d.addElement((0,_index_e6c2c822_js__WEBPACK_IMPORTED_MODULE_0__.g)(r)).onFinish((function(e){if(e===1&&d.elements.length>0){d.elements[0].style.setProperty("display","none")}})).fromTo("transform","translateY(".concat(t,")"),"translateY(".concat(a,")")).fromTo("opacity",1,0);s.addAnimation(d)}return s};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQzRLLHdDQUF3QyxhQUFhLFlBQVksMkJBQTJCLG1CQUFtQixrQkFBa0IsTUFBTSxxREFBaUIsSUFBSSxxQ0FBcUMsTUFBTSx5REFBZSxHQUFHLHFFQUFxRSxNQUFNLHVFQUF1RSxLQUFLLHlLQUF5SyxNQUFNLE1BQU0seURBQWUsR0FBRyxnQkFBZ0Isa0JBQWtCLFNBQVMsdUVBQXVFLE1BQU0seURBQWUsR0FBRyxhQUFhLHFEQUFpQiwyQkFBMkIsK0JBQStCLG1EQUFtRCxxR0FBcUcsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS1lczUvbWQudHJhbnNpdGlvbi1kYTg2NjExOS5qcz85ZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnR7YyBhcyBjcmVhdGVBbmltYXRpb259ZnJvbVwiLi9hbmltYXRpb24tMTlkYmY5YmYuanNcIjtpbXBvcnR7ZyBhcyBnZXRJb25QYWdlRWxlbWVudH1mcm9tXCIuL2luZGV4LWU2YzJjODIyLmpzXCI7aW1wb3J0XCIuL2hlbHBlcnMtNmUxZTViNjUuanNcIjtpbXBvcnRcIi4vaW5kZXgtYjNlZWNiMTQuanNcIjt2YXIgbWRUcmFuc2l0aW9uQW5pbWF0aW9uPWZ1bmN0aW9uKGUsbil7dmFyIGE9XCI0MHB4XCI7dmFyIHQ9XCIwcHhcIjt2YXIgaT1uLmRpcmVjdGlvbj09PVwiYmFja1wiO3ZhciBvPW4uZW50ZXJpbmdFbDt2YXIgcj1uLmxlYXZpbmdFbDt2YXIgbT1nZXRJb25QYWdlRWxlbWVudChvKTt2YXIgYz1tLnF1ZXJ5U2VsZWN0b3IoXCJpb24tdG9vbGJhclwiKTt2YXIgcz1jcmVhdGVBbmltYXRpb24oKTtzLmFkZEVsZW1lbnQobSkuZmlsbChcImJvdGhcIikuYmVmb3JlUmVtb3ZlQ2xhc3MoXCJpb24tcGFnZS1pbnZpc2libGVcIik7aWYoaSl7cy5kdXJhdGlvbihuLmR1cmF0aW9ufHwyMDApLmVhc2luZyhcImN1YmljLWJlemllcigwLjQ3LDAsMC43NDUsMC43MTUpXCIpfWVsc2V7cy5kdXJhdGlvbihuLmR1cmF0aW9ufHwyODApLmVhc2luZyhcImN1YmljLWJlemllcigwLjM2LDAuNjYsMC4wNCwxKVwiKS5mcm9tVG8oXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZVkoXCIuY29uY2F0KGEsXCIpXCIpLFwidHJhbnNsYXRlWShcIi5jb25jYXQodCxcIilcIikpLmZyb21UbyhcIm9wYWNpdHlcIiwuMDEsMSl9aWYoYyl7dmFyIGw9Y3JlYXRlQW5pbWF0aW9uKCk7bC5hZGRFbGVtZW50KGMpO3MuYWRkQW5pbWF0aW9uKGwpfWlmKHImJmkpe3MuZHVyYXRpb24obi5kdXJhdGlvbnx8MjAwKS5lYXNpbmcoXCJjdWJpYy1iZXppZXIoMC40NywwLDAuNzQ1LDAuNzE1KVwiKTt2YXIgZD1jcmVhdGVBbmltYXRpb24oKTtkLmFkZEVsZW1lbnQoZ2V0SW9uUGFnZUVsZW1lbnQocikpLm9uRmluaXNoKChmdW5jdGlvbihlKXtpZihlPT09MSYmZC5lbGVtZW50cy5sZW5ndGg+MCl7ZC5lbGVtZW50c1swXS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcIm5vbmVcIil9fSkpLmZyb21UbyhcInRyYW5zZm9ybVwiLFwidHJhbnNsYXRlWShcIi5jb25jYXQodCxcIilcIiksXCJ0cmFuc2xhdGVZKFwiLmNvbmNhdChhLFwiKVwiKSkuZnJvbVRvKFwib3BhY2l0eVwiLDEsMCk7cy5hZGRBbmltYXRpb24oZCl9cmV0dXJuIHN9O2V4cG9ydHttZFRyYW5zaXRpb25BbmltYXRpb259OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2782\n')},6250:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "B": () => (/* binding */ BACKDROP),\n/* harmony export */   "a": () => (/* binding */ alertController),\n/* harmony export */   "b": () => (/* binding */ actionSheetController),\n/* harmony export */   "c": () => (/* binding */ popoverController),\n/* harmony export */   "d": () => (/* binding */ present),\n/* harmony export */   "e": () => (/* binding */ prepareOverlay),\n/* harmony export */   "f": () => (/* binding */ dismiss),\n/* harmony export */   "g": () => (/* binding */ eventMethod),\n/* harmony export */   "h": () => (/* binding */ activeAnimations),\n/* harmony export */   "i": () => (/* binding */ isCancel),\n/* harmony export */   "j": () => (/* binding */ focusFirstDescendant),\n/* harmony export */   "k": () => (/* binding */ getOverlay),\n/* harmony export */   "l": () => (/* binding */ loadingController),\n/* harmony export */   "m": () => (/* binding */ modalController),\n/* harmony export */   "p": () => (/* binding */ pickerController),\n/* harmony export */   "s": () => (/* binding */ safeCall),\n/* harmony export */   "t": () => (/* binding */ toastController)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(655);\n/* harmony import */ var _ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(882);\n/* harmony import */ var _hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7292);\n/* harmony import */ var _helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7504);\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */var lastId=0;var activeAnimations=new WeakMap;var createController=function(e){return{create:function(t){return createOverlay(e,t)},dismiss:function(t,n,r){return dismissOverlay(document,t,n,e,r)},getTop:function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(this,void 0,void 0,(function(){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(t){return[2,getOverlay(document,e)]}))}))}}};var alertController=createController("ion-alert");var actionSheetController=createController("ion-action-sheet");var loadingController=createController("ion-loading");var modalController=createController("ion-modal");var pickerController=createController("ion-picker");var popoverController=createController("ion-popover");var toastController=createController("ion-toast");var prepareOverlay=function(e){if(typeof document!=="undefined"){connectListeners(document)}var t=lastId++;e.overlayIndex=t;if(!e.hasAttribute("id")){e.id="ion-overlay-".concat(t)}};var createOverlay=function(e,t){if(typeof window!=="undefined"&&typeof window.customElements!=="undefined"){return window.customElements.whenDefined(e).then((function(){var n=document.createElement(e);n.classList.add("overlay-hidden");Object.assign(n,Object.assign(Object.assign({},t),{hasController:true}));getAppRoot(document).appendChild(n);return new Promise((function(e){return (0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.c)(n,e)}))}))}return Promise.resolve()};var focusableQueryString=\'[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])\';var innerFocusableQueryString="input:not([type=hidden]), textarea, button, select";var focusFirstDescendant=function(e,t){var n=e.querySelector(focusableQueryString);var r=n&&n.shadowRoot;if(r){n=r.querySelector(innerFocusableQueryString)||n}if(n){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.f)(n)}else{t.focus()}};var isOverlayHidden=function(e){return e.classList.contains("overlay-hidden")};var focusLastDescendant=function(e,t){var n=Array.from(e.querySelectorAll(focusableQueryString));var r=n.length>0?n[n.length-1]:null;var o=r&&r.shadowRoot;if(o){r=o.querySelector(innerFocusableQueryString)||r}if(r){r.focus()}else{t.focus()}};var trapKeyboardFocus=function(e,t){var n=getOverlay(t,"ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover");var r=e.target;if(!n||!r){return}if(n.classList.contains("ion-disable-focus-trap")){return}var o=function(){if(n===r){n.lastFocus=undefined}else{var e=(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.g)(n);if(!e.contains(r)){return}var o=e.querySelector(".ion-overlay-wrapper");if(!o){return}if(o.contains(r)){n.lastFocus=r}else{var i=n.lastFocus;focusFirstDescendant(o,n);if(i===t.activeElement){focusLastDescendant(o,n)}n.lastFocus=t.activeElement}}};var i=function(){if(n.contains(r)){n.lastFocus=r}else{var e=n.lastFocus;focusFirstDescendant(n,n);if(e===t.activeElement){focusLastDescendant(n,n)}n.lastFocus=t.activeElement}};if(n.shadowRoot){i()}else{o()}};var connectListeners=function(e){if(lastId===0){lastId=1;e.addEventListener("focus",(function(t){trapKeyboardFocus(t,e)}),true);e.addEventListener("ionBackButton",(function(t){var n=getOverlay(e);if(n&&n.backdropDismiss){t.detail.register(_hardware_back_button_ace6a71b_js__WEBPACK_IMPORTED_MODULE_3__.OVERLAY_BACK_BUTTON_PRIORITY,(function(){return n.dismiss(undefined,BACKDROP)}))}}));e.addEventListener("keyup",(function(t){if(t.key==="Escape"){var n=getOverlay(e);if(n&&n.backdropDismiss){n.dismiss(undefined,BACKDROP)}}}))}};var dismissOverlay=function(e,t,n,r,o){var i=getOverlay(e,r,o);if(!i){return Promise.reject("overlay does not exist")}return i.dismiss(t,n)};var getOverlays=function(e,t){if(t===undefined){t="ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast"}return Array.from(e.querySelectorAll(t)).filter((function(e){return e.overlayIndex>0}))};var getOverlay=function(e,t,n){var r=getOverlays(e,t).filter((function(e){return!isOverlayHidden(e)}));return n===undefined?r[r.length-1]:r.find((function(e){return e.id===n}))};var setRootAriaHidden=function(e){if(e===void 0){e=false}var t=getAppRoot(document);var n=t.querySelector("ion-router-outlet, ion-nav, #ion-view-container-root");if(!n){return}if(e){n.setAttribute("aria-hidden","true")}else{n.removeAttribute("aria-hidden")}};var present=function(e,t,n,r,o){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var i,a,s,l,c;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(u){switch(u.label){case 0:if(e.presented){return[2]}setRootAriaHidden(true);e.presented=true;e.willPresent.emit();(i=e.willPresentShorthand)===null||i===void 0?void 0:i.emit();s=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);l=e.enterAnimation?e.enterAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(t,s==="ios"?n:r);return[4,overlayAnimation(e,l,e.el,o)];case 1:c=u.sent();if(c){e.didPresent.emit();(a=e.didPresentShorthand)===null||a===void 0?void 0:a.emit()}if(e.el.tagName!=="ION-TOAST"){focusPreviousElementOnDismiss(e.el)}if(e.keyboardClose){e.el.focus()}return[2]}}))}))};var focusPreviousElementOnDismiss=function(e){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var t,n;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(r){switch(r.label){case 0:t=document.activeElement;if(!t){return[2]}n=t&&t.shadowRoot;if(n){t=n.querySelector(innerFocusableQueryString)||t}return[4,e.onDidDismiss()];case 1:r.sent();t.focus();return[2]}}))}))};var dismiss=function(e,t,n,r,o,i,a){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var s,l,c,u,d;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(v){switch(v.label){case 0:if(!e.presented){return[2,false]}setRootAriaHidden(false);e.presented=false;v.label=1;case 1:v.trys.push([1,4,,5]);e.el.style.setProperty("pointer-events","none");e.willDismiss.emit({data:t,role:n});(s=e.willDismissShorthand)===null||s===void 0?void 0:s.emit({data:t,role:n});c=(0,_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.b)(e);u=e.leaveAnimation?e.leaveAnimation:_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get(r,c==="ios"?o:i);if(!(n!=="gesture"))return[3,3];return[4,overlayAnimation(e,u,e.el,a)];case 2:v.sent();v.label=3;case 3:e.didDismiss.emit({data:t,role:n});(l=e.didDismissShorthand)===null||l===void 0?void 0:l.emit({data:t,role:n});activeAnimations.delete(e);e.el.classList.add("overlay-hidden");e.el.style.removeProperty("pointer-events");return[3,5];case 4:d=v.sent();console.error(d);return[3,5];case 5:e.el.remove();return[2,true]}}))}))};var getAppRoot=function(e){return e.querySelector("ion-app")||e.body};var overlayAnimation=function(e,t,n,r){return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__awaiter */ .mG)(void 0,void 0,void 0,(function(){var o,i,a;return (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__generator */ .Jh)(this,(function(s){switch(s.label){case 0:n.classList.remove("overlay-hidden");o=e.el;i=t(o,r);if(!e.animated||!_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.getBoolean("animated",true)){i.duration(0)}if(e.keyboardClose){i.beforeAddWrite((function(){var e=n.ownerDocument.activeElement;if(e&&e.matches("input,ion-input, ion-textarea")){e.blur()}}))}a=activeAnimations.get(e)||[];activeAnimations.set(e,(0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)((0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__spreadArray */ .ev)([],a,true),[i],false));return[4,i.play()];case 1:s.sent();return[2,true]}}))}))};var eventMethod=function(e,t){var n;var r=new Promise((function(e){return n=e}));onceEvent(e,t,(function(e){n(e.detail)}));return r};var onceEvent=function(e,t,n){var r=function(o){(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.b)(e,t,r);n(o)};(0,_helpers_6e1e5b65_js__WEBPACK_IMPORTED_MODULE_2__.a)(e,t,r)};var isCancel=function(e){return e==="cancel"||e===BACKDROP};var defaultGate=function(e){return e()};var safeCall=function(e,t){if(typeof e==="function"){var n=_ionic_global_0ebe321c_js__WEBPACK_IMPORTED_MODULE_0__.c.get("_zoneGate",defaultGate);return n((function(){try{return e(t)}catch(e){throw e}}))}return undefined};var BACKDROP="backdrop";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG1CQUFtQixnQkFBZ0IsNENBQTRDLE9BQU8sU0FBUyxpQkFBaUIsbUVBQWlCLG1CQUFtQixjQUFjLG9CQUFvQiw2QkFBNkIsb0NBQW9DLGtEQUFrRCxVQUFVLEdBQUcsOEJBQThCLHVCQUF1Qiw4REFBYSxDQUFDLDhEQUFhLHdCQUF3QixtQkFBbUIsZ0JBQWdCLGdCQUFnQixHQUFHLElBQUksOEJBQThCLE1BQU0sK0JBQStCLFdBQVcsR0FBRywyQkFBMkIsWUFBWSxHQUFHLFVBQVUsOEJBQThCLGtCQUFrQix1REFBbUIsUUFBUSxNQUFNLHVEQUFnQixTQUFTLHlCQUF5QixtQ0FBbUMsNEJBQTRCLFlBQVksMkJBQTJCLDBCQUEwQixNQUFNLDREQUFVLDBCQUEwQixxQkFBcUIsSUFBSSxZQUFZLFNBQVMsU0FBUyxHQUFHLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9lc20tZXM1L292ZXJsYXlzLTM2ZDM0NzVkLmpzPzRkMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e19fYXdhaXRlcixfX2dlbmVyYXRvcixfX3NwcmVhZEFycmF5fWZyb21cInRzbGliXCI7XG4vKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL2ltcG9ydHtiIGFzIGdldElvbk1vZGUsYyBhcyBjb25maWd9ZnJvbVwiLi9pb25pYy1nbG9iYWwtMGViZTMyMWMuanNcIjtpbXBvcnR7T1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWX1mcm9tXCIuL2hhcmR3YXJlLWJhY2stYnV0dG9uLWFjZTZhNzFiLmpzXCI7aW1wb3J0e2MgYXMgY29tcG9uZW50T25SZWFkeSxmIGFzIGZvY3VzRWxlbWVudCxhIGFzIGFkZEV2ZW50TGlzdGVuZXIsYiBhcyByZW1vdmVFdmVudExpc3RlbmVyLGcgYXMgZ2V0RWxlbWVudFJvb3R9ZnJvbVwiLi9oZWxwZXJzLTZlMWU1YjY1LmpzXCI7dmFyIGxhc3RJZD0wO3ZhciBhY3RpdmVBbmltYXRpb25zPW5ldyBXZWFrTWFwO3ZhciBjcmVhdGVDb250cm9sbGVyPWZ1bmN0aW9uKGUpe3JldHVybntjcmVhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIGNyZWF0ZU92ZXJsYXkoZSx0KX0sZGlzbWlzczpmdW5jdGlvbih0LG4scil7cmV0dXJuIGRpc21pc3NPdmVybGF5KGRvY3VtZW50LHQsbixlLHIpfSxnZXRUb3A6ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsZ2V0T3ZlcmxheShkb2N1bWVudCxlKV19KSl9KSl9fX07dmFyIGFsZXJ0Q29udHJvbGxlcj1jcmVhdGVDb250cm9sbGVyKFwiaW9uLWFsZXJ0XCIpO3ZhciBhY3Rpb25TaGVldENvbnRyb2xsZXI9Y3JlYXRlQ29udHJvbGxlcihcImlvbi1hY3Rpb24tc2hlZXRcIik7dmFyIGxvYWRpbmdDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tbG9hZGluZ1wiKTt2YXIgbW9kYWxDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tbW9kYWxcIik7dmFyIHBpY2tlckNvbnRyb2xsZXI9Y3JlYXRlQ29udHJvbGxlcihcImlvbi1waWNrZXJcIik7dmFyIHBvcG92ZXJDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tcG9wb3ZlclwiKTt2YXIgdG9hc3RDb250cm9sbGVyPWNyZWF0ZUNvbnRyb2xsZXIoXCJpb24tdG9hc3RcIik7dmFyIHByZXBhcmVPdmVybGF5PWZ1bmN0aW9uKGUpe2lmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCIpe2Nvbm5lY3RMaXN0ZW5lcnMoZG9jdW1lbnQpfXZhciB0PWxhc3RJZCsrO2Uub3ZlcmxheUluZGV4PXQ7aWYoIWUuaGFzQXR0cmlidXRlKFwiaWRcIikpe2UuaWQ9XCJpb24tb3ZlcmxheS1cIi5jb25jYXQodCl9fTt2YXIgY3JlYXRlT3ZlcmxheT1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2Ygd2luZG93LmN1c3RvbUVsZW1lbnRzIT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIHdpbmRvdy5jdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChlKS50aGVuKChmdW5jdGlvbigpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7bi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheS1oaWRkZW5cIik7T2JqZWN0LmFzc2lnbihuLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7aGFzQ29udHJvbGxlcjp0cnVlfSkpO2dldEFwcFJvb3QoZG9jdW1lbnQpLmFwcGVuZENoaWxkKG4pO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbXBvbmVudE9uUmVhZHkobixlKX0pKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9O3ZhciBmb2N1c2FibGVRdWVyeVN0cmluZz0nW3RhYmluZGV4XTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSk6bm90KFt0YWJpbmRleF49XCItXCJdKSwgdGV4dGFyZWE6bm90KFt0YWJpbmRleF49XCItXCJdKSwgYnV0dG9uOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIHNlbGVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCAuaW9uLWZvY3VzYWJsZTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pJzt2YXIgaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZz1cImlucHV0Om5vdChbdHlwZT1oaWRkZW5dKSwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XCI7dmFyIGZvY3VzRmlyc3REZXNjZW5kYW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5xdWVyeVNlbGVjdG9yKGZvY3VzYWJsZVF1ZXJ5U3RyaW5nKTt2YXIgcj1uJiZuLnNoYWRvd1Jvb3Q7aWYocil7bj1yLnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZyl8fG59aWYobil7Zm9jdXNFbGVtZW50KG4pfWVsc2V7dC5mb2N1cygpfX07dmFyIGlzT3ZlcmxheUhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMoXCJvdmVybGF5LWhpZGRlblwiKX07dmFyIGZvY3VzTGFzdERlc2NlbmRhbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1BcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVRdWVyeVN0cmluZykpO3ZhciByPW4ubGVuZ3RoPjA/bltuLmxlbmd0aC0xXTpudWxsO3ZhciBvPXImJnIuc2hhZG93Um9vdDtpZihvKXtyPW8ucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKXx8cn1pZihyKXtyLmZvY3VzKCl9ZWxzZXt0LmZvY3VzKCl9fTt2YXIgdHJhcEtleWJvYXJkRm9jdXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRPdmVybGF5KHQsXCJpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3ZlclwiKTt2YXIgcj1lLnRhcmdldDtpZighbnx8IXIpe3JldHVybn1pZihuLmNsYXNzTGlzdC5jb250YWlucyhcImlvbi1kaXNhYmxlLWZvY3VzLXRyYXBcIikpe3JldHVybn12YXIgbz1mdW5jdGlvbigpe2lmKG49PT1yKXtuLmxhc3RGb2N1cz11bmRlZmluZWR9ZWxzZXt2YXIgZT1nZXRFbGVtZW50Um9vdChuKTtpZighZS5jb250YWlucyhyKSl7cmV0dXJufXZhciBvPWUucXVlcnlTZWxlY3RvcihcIi5pb24tb3ZlcmxheS13cmFwcGVyXCIpO2lmKCFvKXtyZXR1cm59aWYoby5jb250YWlucyhyKSl7bi5sYXN0Rm9jdXM9cn1lbHNle3ZhciBpPW4ubGFzdEZvY3VzO2ZvY3VzRmlyc3REZXNjZW5kYW50KG8sbik7aWYoaT09PXQuYWN0aXZlRWxlbWVudCl7Zm9jdXNMYXN0RGVzY2VuZGFudChvLG4pfW4ubGFzdEZvY3VzPXQuYWN0aXZlRWxlbWVudH19fTt2YXIgaT1mdW5jdGlvbigpe2lmKG4uY29udGFpbnMocikpe24ubGFzdEZvY3VzPXJ9ZWxzZXt2YXIgZT1uLmxhc3RGb2N1cztmb2N1c0ZpcnN0RGVzY2VuZGFudChuLG4pO2lmKGU9PT10LmFjdGl2ZUVsZW1lbnQpe2ZvY3VzTGFzdERlc2NlbmRhbnQobixuKX1uLmxhc3RGb2N1cz10LmFjdGl2ZUVsZW1lbnR9fTtpZihuLnNoYWRvd1Jvb3Qpe2koKX1lbHNle28oKX19O3ZhciBjb25uZWN0TGlzdGVuZXJzPWZ1bmN0aW9uKGUpe2lmKGxhc3RJZD09PTApe2xhc3RJZD0xO2UuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsKGZ1bmN0aW9uKHQpe3RyYXBLZXlib2FyZEZvY3VzKHQsZSl9KSx0cnVlKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJpb25CYWNrQnV0dG9uXCIsKGZ1bmN0aW9uKHQpe3ZhciBuPWdldE92ZXJsYXkoZSk7aWYobiYmbi5iYWNrZHJvcERpc21pc3Mpe3QuZGV0YWlsLnJlZ2lzdGVyKE9WRVJMQVlfQkFDS19CVVRUT05fUFJJT1JJVFksKGZ1bmN0aW9uKCl7cmV0dXJuIG4uZGlzbWlzcyh1bmRlZmluZWQsQkFDS0RST1ApfSkpfX0pKTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLChmdW5jdGlvbih0KXtpZih0LmtleT09PVwiRXNjYXBlXCIpe3ZhciBuPWdldE92ZXJsYXkoZSk7aWYobiYmbi5iYWNrZHJvcERpc21pc3Mpe24uZGlzbWlzcyh1bmRlZmluZWQsQkFDS0RST1ApfX19KSl9fTt2YXIgZGlzbWlzc092ZXJsYXk9ZnVuY3Rpb24oZSx0LG4scixvKXt2YXIgaT1nZXRPdmVybGF5KGUscixvKTtpZighaSl7cmV0dXJuIFByb21pc2UucmVqZWN0KFwib3ZlcmxheSBkb2VzIG5vdCBleGlzdFwiKX1yZXR1cm4gaS5kaXNtaXNzKHQsbil9O3ZhciBnZXRPdmVybGF5cz1mdW5jdGlvbihlLHQpe2lmKHQ9PT11bmRlZmluZWQpe3Q9XCJpb24tYWxlcnQsaW9uLWFjdGlvbi1zaGVldCxpb24tbG9hZGluZyxpb24tbW9kYWwsaW9uLXBpY2tlcixpb24tcG9wb3Zlcixpb24tdG9hc3RcIn1yZXR1cm4gQXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUub3ZlcmxheUluZGV4PjB9KSl9O3ZhciBnZXRPdmVybGF5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1nZXRPdmVybGF5cyhlLHQpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIWlzT3ZlcmxheUhpZGRlbihlKX0pKTtyZXR1cm4gbj09PXVuZGVmaW5lZD9yW3IubGVuZ3RoLTFdOnIuZmluZCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1ufSkpfTt2YXIgc2V0Um9vdEFyaWFIaWRkZW49ZnVuY3Rpb24oZSl7aWYoZT09PXZvaWQgMCl7ZT1mYWxzZX12YXIgdD1nZXRBcHBSb290KGRvY3VtZW50KTt2YXIgbj10LnF1ZXJ5U2VsZWN0b3IoXCJpb24tcm91dGVyLW91dGxldCwgaW9uLW5hdiwgI2lvbi12aWV3LWNvbnRhaW5lci1yb290XCIpO2lmKCFuKXtyZXR1cm59aWYoZSl7bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKX1lbHNle24ucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIil9fTt2YXIgcHJlc2VudD1mdW5jdGlvbihlLHQsbixyLG8pe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGksYSxzLGwsYztyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDppZihlLnByZXNlbnRlZCl7cmV0dXJuWzJdfXNldFJvb3RBcmlhSGlkZGVuKHRydWUpO2UucHJlc2VudGVkPXRydWU7ZS53aWxsUHJlc2VudC5lbWl0KCk7KGk9ZS53aWxsUHJlc2VudFNob3J0aGFuZCk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLmVtaXQoKTtzPWdldElvbk1vZGUoZSk7bD1lLmVudGVyQW5pbWF0aW9uP2UuZW50ZXJBbmltYXRpb246Y29uZmlnLmdldCh0LHM9PT1cImlvc1wiP246cik7cmV0dXJuWzQsb3ZlcmxheUFuaW1hdGlvbihlLGwsZS5lbCxvKV07Y2FzZSAxOmM9dS5zZW50KCk7aWYoYyl7ZS5kaWRQcmVzZW50LmVtaXQoKTsoYT1lLmRpZFByZXNlbnRTaG9ydGhhbmQpPT09bnVsbHx8YT09PXZvaWQgMD92b2lkIDA6YS5lbWl0KCl9aWYoZS5lbC50YWdOYW1lIT09XCJJT04tVE9BU1RcIil7Zm9jdXNQcmV2aW91c0VsZW1lbnRPbkRpc21pc3MoZS5lbCl9aWYoZS5rZXlib2FyZENsb3NlKXtlLmVsLmZvY3VzKCl9cmV0dXJuWzJdfX0pKX0pKX07dmFyIGZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoIXQpe3JldHVyblsyXX1uPXQmJnQuc2hhZG93Um9vdDtpZihuKXt0PW4ucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKXx8dH1yZXR1cm5bNCxlLm9uRGlkRGlzbWlzcygpXTtjYXNlIDE6ci5zZW50KCk7dC5mb2N1cygpO3JldHVyblsyXX19KSl9KSl9O3ZhciBkaXNtaXNzPWZ1bmN0aW9uKGUsdCxuLHIsbyxpLGEpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHMsbCxjLHUsZDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcywoZnVuY3Rpb24odil7c3dpdGNoKHYubGFiZWwpe2Nhc2UgMDppZighZS5wcmVzZW50ZWQpe3JldHVyblsyLGZhbHNlXX1zZXRSb290QXJpYUhpZGRlbihmYWxzZSk7ZS5wcmVzZW50ZWQ9ZmFsc2U7di5sYWJlbD0xO2Nhc2UgMTp2LnRyeXMucHVzaChbMSw0LCw1XSk7ZS5lbC5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO2Uud2lsbERpc21pc3MuZW1pdCh7ZGF0YTp0LHJvbGU6bn0pOyhzPWUud2lsbERpc21pc3NTaG9ydGhhbmQpPT09bnVsbHx8cz09PXZvaWQgMD92b2lkIDA6cy5lbWl0KHtkYXRhOnQscm9sZTpufSk7Yz1nZXRJb25Nb2RlKGUpO3U9ZS5sZWF2ZUFuaW1hdGlvbj9lLmxlYXZlQW5pbWF0aW9uOmNvbmZpZy5nZXQocixjPT09XCJpb3NcIj9vOmkpO2lmKCEobiE9PVwiZ2VzdHVyZVwiKSlyZXR1cm5bMywzXTtyZXR1cm5bNCxvdmVybGF5QW5pbWF0aW9uKGUsdSxlLmVsLGEpXTtjYXNlIDI6di5zZW50KCk7di5sYWJlbD0zO2Nhc2UgMzplLmRpZERpc21pc3MuZW1pdCh7ZGF0YTp0LHJvbGU6bn0pOyhsPWUuZGlkRGlzbWlzc1Nob3J0aGFuZCk9PT1udWxsfHxsPT09dm9pZCAwP3ZvaWQgMDpsLmVtaXQoe2RhdGE6dCxyb2xlOm59KTthY3RpdmVBbmltYXRpb25zLmRlbGV0ZShlKTtlLmVsLmNsYXNzTGlzdC5hZGQoXCJvdmVybGF5LWhpZGRlblwiKTtlLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwicG9pbnRlci1ldmVudHNcIik7cmV0dXJuWzMsNV07Y2FzZSA0OmQ9di5zZW50KCk7Y29uc29sZS5lcnJvcihkKTtyZXR1cm5bMyw1XTtjYXNlIDU6ZS5lbC5yZW1vdmUoKTtyZXR1cm5bMix0cnVlXX19KSl9KSl9O3ZhciBnZXRBcHBSb290PWZ1bmN0aW9uKGUpe3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJpb24tYXBwXCIpfHxlLmJvZHl9O3ZhciBvdmVybGF5QW5pbWF0aW9uPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBfX2F3YWl0ZXIodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG8saSxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLChmdW5jdGlvbihzKXtzd2l0Y2gocy5sYWJlbCl7Y2FzZSAwOm4uY2xhc3NMaXN0LnJlbW92ZShcIm92ZXJsYXktaGlkZGVuXCIpO289ZS5lbDtpPXQobyxyKTtpZighZS5hbmltYXRlZHx8IWNvbmZpZy5nZXRCb29sZWFuKFwiYW5pbWF0ZWRcIix0cnVlKSl7aS5kdXJhdGlvbigwKX1pZihlLmtleWJvYXJkQ2xvc2Upe2kuYmVmb3JlQWRkV3JpdGUoKGZ1bmN0aW9uKCl7dmFyIGU9bi5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoZSYmZS5tYXRjaGVzKFwiaW5wdXQsaW9uLWlucHV0LCBpb24tdGV4dGFyZWFcIikpe2UuYmx1cigpfX0pKX1hPWFjdGl2ZUFuaW1hdGlvbnMuZ2V0KGUpfHxbXTthY3RpdmVBbmltYXRpb25zLnNldChlLF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSxhLHRydWUpLFtpXSxmYWxzZSkpO3JldHVybls0LGkucGxheSgpXTtjYXNlIDE6cy5zZW50KCk7cmV0dXJuWzIsdHJ1ZV19fSkpfSkpfTt2YXIgZXZlbnRNZXRob2Q9ZnVuY3Rpb24oZSx0KXt2YXIgbjt2YXIgcj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIG49ZX0pKTtvbmNlRXZlbnQoZSx0LChmdW5jdGlvbihlKXtuKGUuZGV0YWlsKX0pKTtyZXR1cm4gcn07dmFyIG9uY2VFdmVudD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZnVuY3Rpb24obyl7cmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQscik7bihvKX07YWRkRXZlbnRMaXN0ZW5lcihlLHQscil9O3ZhciBpc0NhbmNlbD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PVwiY2FuY2VsXCJ8fGU9PT1CQUNLRFJPUH07dmFyIGRlZmF1bHRHYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBlKCl9O3ZhciBzYWZlQ2FsbD1mdW5jdGlvbihlLHQpe2lmKHR5cGVvZiBlPT09XCJmdW5jdGlvblwiKXt2YXIgbj1jb25maWcuZ2V0KFwiX3pvbmVHYXRlXCIsZGVmYXVsdEdhdGUpO3JldHVybiBuKChmdW5jdGlvbigpe3RyeXtyZXR1cm4gZSh0KX1jYXRjaChlKXt0aHJvdyBlfX0pKX1yZXR1cm4gdW5kZWZpbmVkfTt2YXIgQkFDS0RST1A9XCJiYWNrZHJvcFwiO2V4cG9ydHtCQUNLRFJPUCBhcyBCLGFsZXJ0Q29udHJvbGxlciBhcyBhLGFjdGlvblNoZWV0Q29udHJvbGxlciBhcyBiLHBvcG92ZXJDb250cm9sbGVyIGFzIGMscHJlc2VudCBhcyBkLHByZXBhcmVPdmVybGF5IGFzIGUsZGlzbWlzcyBhcyBmLGV2ZW50TWV0aG9kIGFzIGcsYWN0aXZlQW5pbWF0aW9ucyBhcyBoLGlzQ2FuY2VsIGFzIGksZm9jdXNGaXJzdERlc2NlbmRhbnQgYXMgaixnZXRPdmVybGF5IGFzIGssbG9hZGluZ0NvbnRyb2xsZXIgYXMgbCxtb2RhbENvbnRyb2xsZXIgYXMgbSxwaWNrZXJDb250cm9sbGVyIGFzIHAsc2FmZUNhbGwgYXMgcyx0b2FzdENvbnRyb2xsZXIgYXMgdH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6250\n')},5087:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// UNUSED EXPORTS: CreateAnimation, DefaultIonLifeCycleContext, IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonLifeCycleContext, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRedirect, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRoute, IonRouterContext, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonTabsContext, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, IonicSafeString, IonicSlides, IonicSwiper, LocationHistory, NavContext, NavManager, RouteManagerContext, StackContext, ViewLifeCycleManager, ViewStacks, createAnimation, createGesture, generateId, getConfig, getPlatforms, getTimeGivenProgression, iosTransitionAnimation, isPlatform, mdTransitionAnimation, setupIonicReact, useIonActionSheet, useIonAlert, useIonLoading, useIonModal, useIonPicker, useIonPopover, useIonRouter, useIonToast, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./node_modules/@stencil/core/internal/client/index.js + 1 modules\nvar client = __webpack_require__(7210);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ionic-global.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nclass Config {\n  constructor() {\n    this.m = new Map();\n  }\n  reset(configObj) {\n    this.m = new Map(Object.entries(configObj));\n  }\n  get(key, fallback) {\n    const value = this.m.get(key);\n    return value !== undefined ? value : fallback;\n  }\n  getBoolean(key, fallback = false) {\n    const val = this.m.get(key);\n    if (val === undefined) {\n      return fallback;\n    }\n    if (typeof val === 'string') {\n      return val === 'true';\n    }\n    return !!val;\n  }\n  getNumber(key, fallback) {\n    const val = parseFloat(this.m.get(key));\n    return isNaN(val) ? (fallback !== undefined ? fallback : NaN) : val;\n  }\n  set(key, value) {\n    this.m.set(key, value);\n  }\n}\nconst ionic_global_config = /*@__PURE__*/ new Config();\nconst configFromSession = (win) => {\n  try {\n    const configStr = win.sessionStorage.getItem(IONIC_SESSION_KEY);\n    return configStr !== null ? JSON.parse(configStr) : {};\n  }\n  catch (e) {\n    return {};\n  }\n};\nconst saveConfig = (win, c) => {\n  try {\n    win.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c));\n  }\n  catch (e) {\n    return;\n  }\n};\nconst configFromURL = (win) => {\n  const configObj = {};\n  win.location.search\n    .slice(1)\n    .split('&')\n    .map(entry => entry.split('='))\n    .map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)])\n    .filter(([key]) => startsWith(key, IONIC_PREFIX))\n    .map(([key, value]) => [key.slice(IONIC_PREFIX.length), value])\n    .forEach(([key, value]) => {\n    configObj[key] = value;\n  });\n  return configObj;\n};\nconst startsWith = (input, search) => {\n  return input.substr(0, search.length) === search;\n};\nconst IONIC_PREFIX = 'ionic:';\nconst IONIC_SESSION_KEY = 'ionic-persist-config';\n\nconst getPlatforms = (win) => setupPlatforms(win);\nconst isPlatform = (winOrPlatform, platform) => {\n  if (typeof winOrPlatform === 'string') {\n    platform = winOrPlatform;\n    winOrPlatform = undefined;\n  }\n  return getPlatforms(winOrPlatform).includes(platform);\n};\nconst setupPlatforms = (win = window) => {\n  if (typeof win === 'undefined') {\n    return [];\n  }\n  win.Ionic = win.Ionic || {};\n  let platforms = win.Ionic.platforms;\n  if (platforms == null) {\n    platforms = win.Ionic.platforms = detectPlatforms(win);\n    platforms.forEach(p => win.document.documentElement.classList.add(`plt-${p}`));\n  }\n  return platforms;\n};\nconst detectPlatforms = (win) => {\n  const customPlatformMethods = ionic_global_config.get('platform');\n  return Object.keys(PLATFORMS_MAP).filter(p => {\n    const customMethod = customPlatformMethods && customPlatformMethods[p];\n    return typeof customMethod === 'function' ? customMethod(win) : PLATFORMS_MAP[p](win);\n  });\n};\nconst isMobileWeb = (win) => isMobile(win) && !isHybrid(win);\nconst isIpad = (win) => {\n  // iOS 12 and below\n  if (testUserAgent(win, /iPad/i)) {\n    return true;\n  }\n  // iOS 13+\n  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {\n    return true;\n  }\n  return false;\n};\nconst isIphone = (win) => testUserAgent(win, /iPhone/i);\nconst isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);\nconst isAndroid = (win) => testUserAgent(win, /android|sink/i);\nconst isAndroidTablet = (win) => {\n  return isAndroid(win) && !testUserAgent(win, /mobile/i);\n};\nconst isPhablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (smallest > 390 && smallest < 520) &&\n    (largest > 620 && largest < 800);\n};\nconst isTablet = (win) => {\n  const width = win.innerWidth;\n  const height = win.innerHeight;\n  const smallest = Math.min(width, height);\n  const largest = Math.max(width, height);\n  return (isIpad(win) ||\n    isAndroidTablet(win) ||\n    ((smallest > 460 && smallest < 820) &&\n      (largest > 780 && largest < 1400)));\n};\nconst isMobile = (win) => matchMedia(win, '(any-pointer:coarse)');\nconst isDesktop = (win) => !isMobile(win);\nconst isHybrid = (win) => isCordova(win) || isCapacitorNative(win);\nconst isCordova = (win) => !!(win['cordova'] || win['phonegap'] || win['PhoneGap']);\nconst isCapacitorNative = (win) => {\n  const capacitor = win['Capacitor'];\n  return !!(capacitor && capacitor.isNative);\n};\nconst isElectron = (win) => testUserAgent(win, /electron/i);\nconst isPWA = (win) => !!((win.matchMedia && win.matchMedia('(display-mode: standalone)').matches) || win.navigator.standalone);\nconst testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);\nconst matchMedia = (win, query) => win.matchMedia && win.matchMedia(query).matches;\nconst PLATFORMS_MAP = {\n  'ipad': isIpad,\n  'iphone': isIphone,\n  'ios': isIOS,\n  'android': isAndroid,\n  'phablet': isPhablet,\n  'tablet': isTablet,\n  'cordova': isCordova,\n  'capacitor': isCapacitorNative,\n  'electron': isElectron,\n  'pwa': isPWA,\n  'mobile': isMobile,\n  'mobileweb': isMobileWeb,\n  'desktop': isDesktop,\n  'hybrid': isHybrid\n};\n\nlet defaultMode;\nconst ionic_global_getIonMode = (ref) => {\n  return (ref && (0,client/* getMode */.iJ)(ref)) || defaultMode;\n};\nconst ionic_global_initialize = (userConfig = {}) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const doc = window.document;\n  const win = window;\n  Context.config = ionic_global_config;\n  const Ionic = win.Ionic = win.Ionic || {};\n  const platformHelpers = {};\n  if (userConfig._ael) {\n    platformHelpers.ael = userConfig._ael;\n  }\n  if (userConfig._rel) {\n    platformHelpers.rel = userConfig._rel;\n  }\n  if (userConfig._ce) {\n    platformHelpers.ce = userConfig._ce;\n  }\n  setPlatformHelpers(platformHelpers);\n  // create the Ionic.config from raw config object (if it exists)\n  // and convert Ionic.config into a ConfigApi that has a get() fn\n  const configObj = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win)), { persistConfig: false }), Ionic.config), configFromURL(win)), userConfig);\n  ionic_global_config.reset(configObj);\n  if (ionic_global_config.getBoolean('persistConfig')) {\n    saveConfig(win, configObj);\n  }\n  // Setup platforms\n  setupPlatforms(win);\n  // first see if the mode was set as an attribute on <html>\n  // which could have been set by the user, or by pre-rendering\n  // otherwise get the mode via config settings, and fallback to md\n  Ionic.config = ionic_global_config;\n  Ionic.mode = defaultMode = ionic_global_config.get('mode', (doc.documentElement.getAttribute('mode')) || (isPlatform(win, 'ios') ? 'ios' : 'md'));\n  ionic_global_config.set('mode', defaultMode);\n  doc.documentElement.setAttribute('mode', defaultMode);\n  doc.documentElement.classList.add(defaultMode);\n  if (ionic_global_config.getBoolean('_testing')) {\n    ionic_global_config.set('animated', false);\n  }\n  const isIonicElement = (elm) => elm.tagName && elm.tagName.startsWith('ION-');\n  const isAllowedIonicModeValue = (elmMode) => ['ios', 'md'].includes(elmMode);\n  setMode((elm) => {\n    while (elm) {\n      const elmMode = elm.mode || elm.getAttribute('mode');\n      if (elmMode) {\n        if (isAllowedIonicModeValue(elmMode)) {\n          return elmMode;\n        }\n        else if (isIonicElement(elm)) {\n          console.warn('Invalid ionic mode: \"' + elmMode + '\", expected: \"ios\" or \"md\"');\n        }\n      }\n      elm = elm.parentElement;\n    }\n    return defaultMode;\n  });\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/helpers.js\nvar helpers = __webpack_require__(6587);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/overlays.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getOverlay(document, tagName);\n    }\n  };\n};\nconst overlays_alertController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-alert')));\nconst actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nconst overlays_loadingController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-loading')));\nconst overlays_modalController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-modal')));\nconst overlays_pickerController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-picker')));\nconst overlays_popoverController = /*@__PURE__*/ (/* unused pure expression or super */ null && (createController('ion-popover')));\nconst toastController = /*@__PURE__*/ createController('ion-toast');\nconst prepareOverlay = (el) => {\n  /* tslint:disable-next-line */\n  if (typeof document !== 'undefined') {\n    connectListeners(document);\n  }\n  const overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${overlayIndex}`;\n  }\n};\nconst createOverlay = (tagName, opts) => {\n  /* tslint:disable-next-line */\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise(resolve => (0,helpers.c)(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]), input:not([type=hidden]):not([tabindex^=\"-\"]), textarea:not([tabindex^=\"-\"]), button:not([tabindex^=\"-\"]), select:not([tabindex^=\"-\"]), .ion-focusable:not([tabindex^=\"-\"])';\nconst innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';\nconst focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput && firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput && lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    }\n    else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      }\n      else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    }\n    else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  }\n  else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = (doc) => {\n  if (lastId === 0) {\n    lastId = 1;\n    doc.addEventListener('focus', (ev) => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', ev => {\n      const lastOverlay = getOverlay(doc);\n      if (lastOverlay && lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keyup', ev => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getOverlay(doc);\n        if (lastOverlay && lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\nconst getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector))\n    .filter(c => c.overlayIndex > 0);\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getOverlay = (doc, overlayTag, id) => {\n  const overlays = getOverlays(doc, overlayTag).filter(o => !isOverlayHidden(o));\n  return (id === undefined)\n    ? overlays[overlays.length - 1]\n    : overlays.find(o => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  }\n  else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = (overlay.enterAnimation)\n    ? overlay.enterAnimation\n    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  if (overlay.keyboardClose) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement && previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  setRootAriaHidden(false);\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({ data, role });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n    const mode = getIonMode(overlay);\n    const animationBuilder = (overlay.leaveAnimation)\n      ? overlay.leaveAnimation\n      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== 'gesture') {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({ data, role });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n  }\n  catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = (doc) => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement && activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nconst eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise(r => resolve = r);\n  onceEvent(element, eventName, (event) => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n  const handler = (ev) => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nconst isCancel = (role) => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      }\n      catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nconst BACKDROP = 'backdrop';\n\n\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(655);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(3935);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/cubic-bezier.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Based on:\n * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier\n * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves\n * TODO: Reduce rounding error\n */\n/**\n * EXPERIMENTAL\n * Given a cubic-bezier curve, get the x value (time) given\n * the y value (progression).\n * Ex: cubic-bezier(0.32, 0.72, 0, 1);\n * P0: (0, 0)\n * P1: (0.32, 0.72)\n * P2: (0, 1)\n * P3: (1, 1)\n *\n * If you give a cubic bezier curve that never reaches the\n * provided progression, this function will return an empty array.\n */\nconst getTimeGivenProgression = (p0, p1, p2, p3, progression) => {\n  return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {\n    return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);\n  });\n};\n/**\n * Solve a cubic equation in one dimension (time)\n */\nconst solveCubicParametricEquation = (p0, p1, p2, p3, t) => {\n  const partA = (3 * p1) * Math.pow(t - 1, 2);\n  const partB = (-3 * p2 * t) + (3 * p2) + (p3 * t);\n  const partC = p0 * Math.pow(t - 1, 3);\n  return t * (partA + (t * partB)) - partC;\n};\n/**\n * Find the `t` value for a cubic bezier using Cardano's formula\n */\nconst solveCubicBezier = (p0, p1, p2, p3, refPoint) => {\n  p0 -= refPoint;\n  p1 -= refPoint;\n  p2 -= refPoint;\n  p3 -= refPoint;\n  const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);\n  return roots.filter(root => root >= 0 && root <= 1);\n};\nconst solveQuadraticEquation = (a, b, c) => {\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant < 0) {\n    return [];\n  }\n  else {\n    return [\n      (-b + Math.sqrt(discriminant)) / (2 * a),\n      (-b - Math.sqrt(discriminant)) / (2 * a)\n    ];\n  }\n};\nconst solveCubicEquation = (a, b, c, d) => {\n  if (a === 0) {\n    return solveQuadraticEquation(b, c, d);\n  }\n  b /= a;\n  c /= a;\n  d /= a;\n  const p = (3 * c - b * b) / 3;\n  const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;\n  if (p === 0) {\n    return [Math.pow(-q, 1 / 3)];\n  }\n  else if (q === 0) {\n    return [Math.sqrt(-p), -Math.sqrt(-p)];\n  }\n  const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);\n  if (discriminant === 0) {\n    return [Math.pow(q / 2, 1 / 2) - b / 3];\n  }\n  else if (discriminant > 0) {\n    return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow((q / 2) + Math.sqrt(discriminant), 1 / 3) - b / 3];\n  }\n  const r = Math.sqrt(Math.pow(-(p / 3), 3));\n  const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));\n  const s = 2 * Math.pow(r, 1 / 3);\n  return [\n    s * Math.cos(phi / 3) - b / 3,\n    s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3,\n    s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3\n  ];\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/framework-delegate.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nconst attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {\n  if (delegate) {\n    return delegate.attachViewToDom(container, component, componentProps, cssClasses);\n  }\n  if (!inline && typeof component !== 'string' && !(component instanceof HTMLElement)) {\n    throw new Error('framework delegate is missing');\n  }\n  const el = (typeof component === 'string')\n    ? container.ownerDocument && container.ownerDocument.createElement(component)\n    : component;\n  if (cssClasses) {\n    cssClasses.forEach(c => el.classList.add(c));\n  }\n  if (componentProps) {\n    Object.assign(el, componentProps);\n  }\n  container.appendChild(el);\n  await new Promise(resolve => (0,helpers.c)(el, resolve));\n  return el;\n};\nconst detachComponent = (delegate, element) => {\n  if (element) {\n    if (delegate) {\n      const container = element.parentElement;\n      return delegate.removeViewFromDom(container, element);\n    }\n    element.remove();\n  }\n  return Promise.resolve();\n};\nconst CoreDelegate = () => {\n  let BaseComponent;\n  let Reference;\n  const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {\n    BaseComponent = parentElement;\n    /**\n     * If passing in a component via the `component` props\n     * we need to append it inside of our overlay component.\n     */\n    if (userComponent) {\n      /**\n       * If passing in the tag name, create\n       * the element otherwise just get a reference\n       * to the component.\n       */\n      const el = (typeof userComponent === 'string')\n        ? BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement(userComponent)\n        : userComponent;\n      /**\n       * Add any css classes passed in\n       * via the cssClasses prop on the overlay.\n       */\n      cssClasses.forEach(c => el.classList.add(c));\n      /**\n       * Add any props passed in\n       * via the componentProps prop on the overlay.\n       */\n      Object.assign(el, userComponentProps);\n      /**\n       * Finally, append the component\n       * inside of the overlay component.\n       */\n      BaseComponent.appendChild(el);\n      await new Promise(resolve => componentOnReady(el, resolve));\n    }\n    else if (BaseComponent.children.length > 0) {\n      // If there is no component, then we need to create a new parent\n      // element to apply the css classes to.\n      const el = BaseComponent.ownerDocument && BaseComponent.ownerDocument.createElement('div');\n      cssClasses.forEach(c => el.classList.add(c));\n      // Move each child from the original template to the new parent element.\n      el.append(...BaseComponent.children);\n      // Append the new parent element to the original parent element.\n      BaseComponent.appendChild(el);\n    }\n    /**\n     * Get the root of the app and\n     * add the overlay there.\n     */\n    const app = document.querySelector('ion-app') || document.body;\n    /**\n     * Create a placeholder comment so that\n     * we can return this component to where\n     * it was previously.\n     */\n    Reference = document.createComment('ionic teleport');\n    BaseComponent.parentNode.insertBefore(Reference, BaseComponent);\n    app.appendChild(BaseComponent);\n    return BaseComponent;\n  };\n  const removeViewFromDom = () => {\n    /**\n     * Return component to where it was previously in the DOM.\n     */\n    if (BaseComponent && Reference) {\n      Reference.parentNode.insertBefore(BaseComponent, Reference);\n      Reference.remove();\n    }\n    return Promise.resolve();\n  };\n  return { attachViewToDom, removeViewFromDom };\n};\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/index4.js\nvar index4 = __webpack_require__(5026);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-router-outlet.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\n\n\n\nconst routeOutletCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\n\nconst RouterOutlet = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionNavWillLoad = (0,client/* createEvent */.yM)(this, \"ionNavWillLoad\", 7);\n    this.ionNavWillChange = (0,client/* createEvent */.yM)(this, \"ionNavWillChange\", 3);\n    this.ionNavDidChange = (0,client/* createEvent */.yM)(this, \"ionNavDidChange\", 3);\n    this.gestureOrAnimationInProgress = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ionic_global_getIonMode(this);\n    /**\n     * If `true`, the router-outlet should animate the transition of components.\n     */\n    this.animated = true;\n  }\n  swipeHandlerChanged() {\n    if (this.gesture) {\n      this.gesture.enable(this.swipeHandler !== undefined);\n    }\n  }\n  async connectedCallback() {\n    const onStart = () => {\n      this.gestureOrAnimationInProgress = true;\n      if (this.swipeHandler) {\n        this.swipeHandler.onStart();\n      }\n    };\n    this.gesture = (await __webpack_require__.e(/* import() */ 6167).then(__webpack_require__.bind(__webpack_require__, 6167))).createSwipeBackGesture(this.el, () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(), () => onStart(), step => this.ani && this.ani.progressStep(step), (shouldComplete, step, dur) => {\n      if (this.ani) {\n        this.ani.onFinish(() => {\n          this.gestureOrAnimationInProgress = false;\n          if (this.swipeHandler) {\n            this.swipeHandler.onEnd(shouldComplete);\n          }\n        }, { oneTimeCallback: true });\n        // Account for rounding errors in JS\n        let newStepValue = (shouldComplete) ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n        }\n        else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n        }\n        this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n      else {\n        this.gestureOrAnimationInProgress = false;\n      }\n    });\n    this.swipeHandlerChanged();\n  }\n  componentWillLoad() {\n    this.ionNavWillLoad.emit();\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  /** @internal */\n  async commit(enteringEl, leavingEl, opts) {\n    const unlock = await this.lock();\n    let changed = false;\n    try {\n      changed = await this.transition(enteringEl, leavingEl, opts);\n    }\n    catch (e) {\n      console.error(e);\n    }\n    unlock();\n    return changed;\n  }\n  /** @internal */\n  async setRouteId(id, params, direction, animation) {\n    const changed = await this.setRoot(id, params, {\n      duration: direction === 'root' ? 0 : undefined,\n      direction: direction === 'back' ? 'back' : 'forward',\n      animationBuilder: animation\n    });\n    return {\n      changed,\n      element: this.activeEl\n    };\n  }\n  /** @internal */\n  async getRouteId() {\n    const active = this.activeEl;\n    return active ? {\n      id: active.tagName,\n      element: active,\n      params: this.activeParams,\n    } : undefined;\n  }\n  async setRoot(component, params, opts) {\n    if (this.activeComponent === component && (0,helpers.s)(params, this.activeParams)) {\n      return false;\n    }\n    // attach entering view to DOM\n    const leavingEl = this.activeEl;\n    const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);\n    this.activeComponent = component;\n    this.activeEl = enteringEl;\n    this.activeParams = params;\n    // commit animation\n    await this.commit(enteringEl, leavingEl, opts);\n    await detachComponent(this.delegate, leavingEl);\n    return true;\n  }\n  async transition(enteringEl, leavingEl, opts = {}) {\n    if (leavingEl === enteringEl) {\n      return false;\n    }\n    // emit nav will change event\n    this.ionNavWillChange.emit();\n    const { el, mode } = this;\n    const animated = this.animated && ionic_global_config.getBoolean('animated', true);\n    const animationBuilder = opts.animationBuilder || this.animation || ionic_global_config.get('navAnimation');\n    await (0,index4.t)(Object.assign(Object.assign({ mode,\n      animated,\n      enteringEl,\n      leavingEl, baseEl: el, progressCallback: (opts.progressAnimation\n        ? ani => {\n          /**\n           * Because this progress callback is called asynchronously\n           * it is possible for the gesture to start and end before\n           * the animation is ever set. In that scenario, we should\n           * immediately call progressEnd so that the transition promise\n           * resolves and the gesture does not get locked up.\n           */\n          if (ani !== undefined && !this.gestureOrAnimationInProgress) {\n            this.gestureOrAnimationInProgress = true;\n            ani.onFinish(() => {\n              this.gestureOrAnimationInProgress = false;\n              if (this.swipeHandler) {\n                this.swipeHandler.onEnd(false);\n              }\n            }, { oneTimeCallback: true });\n            /**\n             * Playing animation to beginning\n             * with a duration of 0 prevents\n             * any flickering when the animation\n             * is later cleaned up.\n             */\n            ani.progressEnd(0, 0, 0);\n          }\n          else {\n            this.ani = ani;\n          }\n        }\n        : undefined) }, opts), { animationBuilder }));\n    // emit nav changed event\n    this.ionNavDidChange.emit();\n    return true;\n  }\n  async lock() {\n    const p = this.waitPromise;\n    let resolve;\n    this.waitPromise = new Promise(r => resolve = r);\n    if (p !== undefined) {\n      await p;\n    }\n    return resolve;\n  }\n  render() {\n    return ((0,client.h)(\"slot\", null));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"swipeHandler\": [\"swipeHandlerChanged\"]\n  }; }\n  static get style() { return routeOutletCss; }\n}, [1, \"ion-router-outlet\", {\n    \"mode\": [1025],\n    \"delegate\": [16],\n    \"animated\": [4],\n    \"animation\": [16],\n    \"swipeHandler\": [16],\n    \"commit\": [64],\n    \"setRouteId\": [64],\n    \"getRouteId\": [64]\n  }]);\nfunction ion_router_outlet_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-router-outlet\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-router-outlet\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RouterOutlet);\n      }\n      break;\n  } });\n}\n\nconst IonRouterOutlet = (/* unused pure expression or super */ null && (RouterOutlet));\nconst defineCustomElement = ion_router_outlet_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/theme.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return (typeof color === 'string' && color.length > 0) ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter(c => c != null)\n      .map(c => c.trim())\n      .filter(c => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach(c => map[c] = true);\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-bar.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabBarIosCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-400, #999999));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}\";\n\nconst tabBarMdCss = \":host{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}\";\n\nconst TabBar = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabBarChanged = (0,client/* createEvent */.yM)(this, \"ionTabBarChanged\", 7);\n    this.keyboardVisible = false;\n    /**\n     * If `true`, the tab bar will be translucent.\n     * Only applies when the mode is `\"ios\"` and the device supports\n     * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).\n     */\n    this.translucent = false;\n  }\n  selectedTabChanged() {\n    if (this.selectedTab !== undefined) {\n      this.ionTabBarChanged.emit({\n        tab: this.selectedTab\n      });\n    }\n  }\n  componentWillLoad() {\n    this.selectedTabChanged();\n  }\n  connectedCallback() {\n    if (typeof window !== 'undefined') {\n      this.keyboardWillShowHandler = () => {\n        if (this.el.getAttribute('slot') !== 'top') {\n          this.keyboardVisible = true;\n        }\n      };\n      this.keyboardWillHideHandler = () => {\n        setTimeout(() => this.keyboardVisible = false, 50);\n      };\n      window.addEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.addEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n    }\n  }\n  disconnectedCallback() {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('keyboardWillShow', this.keyboardWillShowHandler);\n      window.removeEventListener('keyboardWillHide', this.keyboardWillHideHandler);\n      this.keyboardWillShowHandler = this.keyboardWillHideHandler = undefined;\n    }\n  }\n  render() {\n    const { color, translucent, keyboardVisible } = this;\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"tablist\", \"aria-hidden\": keyboardVisible ? 'true' : null, class: createColorClasses(color, {\n        [mode]: true,\n        'tab-bar-translucent': translucent,\n        'tab-bar-hidden': keyboardVisible,\n      }) }, (0,client.h)(\"slot\", null)));\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"selectedTab\": [\"selectedTabChanged\"]\n  }; }\n  static get style() { return {\n    ios: tabBarIosCss,\n    md: tabBarMdCss\n  }; }\n}, [33, \"ion-tab-bar\", {\n    \"color\": [513],\n    \"selectedTab\": [1, \"selected-tab\"],\n    \"translucent\": [4],\n    \"keyboardVisible\": [32]\n  }]);\nfunction ion_tab_bar_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-bar\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-bar\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabBar);\n      }\n      break;\n  } });\n}\n\nconst IonTabBar = (/* unused pure expression or super */ null && (TabBar));\nconst ion_tab_bar_defineCustomElement = ion_tab_bar_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ripple-effect.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst rippleEffectCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}\";\n\nconst RippleEffect = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    /**\n     * Sets the type of ripple-effect:\n     *\n     * - `bounded`: the ripple effect expands from the user's click position\n     * - `unbounded`: the ripple effect expands from the center of the button and overflows the container.\n     *\n     * NOTE: Surfaces for bounded ripples should have the overflow property set to hidden,\n     * while surfaces for unbounded ripples should have it set to visible.\n     */\n    this.type = 'bounded';\n  }\n  /**\n   * Adds the ripple effect to the parent element.\n   *\n   * @param x The horizontal coordinate of where the ripple should start.\n   * @param y The vertical coordinate of where the ripple should start.\n   */\n  async addRipple(x, y) {\n    return new Promise(resolve => {\n      (0,client/* readTask */.wj)(() => {\n        const rect = this.el.getBoundingClientRect();\n        const width = rect.width;\n        const height = rect.height;\n        const hypotenuse = Math.sqrt(width * width + height * height);\n        const maxDim = Math.max(height, width);\n        const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;\n        const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n        const finalScale = maxRadius / initialSize;\n        let posX = x - rect.left;\n        let posY = y - rect.top;\n        if (this.unbounded) {\n          posX = width * 0.5;\n          posY = height * 0.5;\n        }\n        const styleX = posX - initialSize * 0.5;\n        const styleY = posY - initialSize * 0.5;\n        const moveX = width * 0.5 - posX;\n        const moveY = height * 0.5 - posY;\n        (0,client/* writeTask */.Iu)(() => {\n          const div = document.createElement('div');\n          div.classList.add('ripple-effect');\n          const style = div.style;\n          style.top = styleY + 'px';\n          style.left = styleX + 'px';\n          style.width = style.height = initialSize + 'px';\n          style.setProperty('--final-scale', `${finalScale}`);\n          style.setProperty('--translate-end', `${moveX}px, ${moveY}px`);\n          const container = this.el.shadowRoot || this.el;\n          container.appendChild(div);\n          setTimeout(() => {\n            resolve(() => {\n              removeRipple(div);\n            });\n          }, 225 + 100);\n        });\n      });\n    });\n  }\n  get unbounded() {\n    return this.type === 'unbounded';\n  }\n  render() {\n    const mode = ionic_global_getIonMode(this);\n    return ((0,client.h)(client/* Host */.AA, { role: \"presentation\", class: {\n        [mode]: true,\n        'unbounded': this.unbounded\n      } }));\n  }\n  get el() { return this; }\n  static get style() { return rippleEffectCss; }\n}, [1, \"ion-ripple-effect\", {\n    \"type\": [1],\n    \"addRipple\": [64]\n  }]);\nconst removeRipple = (ripple) => {\n  ripple.classList.add('fade-out');\n  setTimeout(() => {\n    ripple.remove();\n  }, 200);\n};\nconst PADDING = 10;\nconst INITIAL_ORIGIN_SCALE = 0.5;\nfunction ripple_effect_defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, RippleEffect);\n      }\n      break;\n  } });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/ion-tab-button.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst tabButtonIosCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){padding-left:6px;padding-right:6px;padding-top:1px;padding-bottom:1px;left:calc(50% + 6px);top:4px;height:auto;font-size:12px;line-height:16px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px);top:10px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}\";\n\nconst tabButtonMdCss = \":host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.button-native{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:\\\"\\\";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}[dir=rtl] ::slotted(ion-icon),:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}::slotted(ion-badge){border-radius:8px;padding-left:2px;padding-right:2px;padding-top:3px;padding-bottom:2px;left:calc(50% + 6px);top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){::slotted(ion-badge){padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px}}[dir=rtl] ::slotted(ion-badge),:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%;top:8px}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-icon){margin-right:unset;-webkit-margin-end:6px;margin-inline-end:6px}}:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:6px}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host(.tab-layout-icon-end) ::slotted(ion-icon){margin-left:unset;-webkit-margin-start:6px;margin-inline-start:6px}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%;top:16px}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}\";\n\nconst TabButton = /*@__PURE__*/ (0,client/* proxyCustomElement */.GH)(class extends client/* HTMLElement */.mv {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.ionTabButtonClick = (0,client/* createEvent */.yM)(this, \"ionTabButtonClick\", 7);\n    /**\n     * If `true`, the user cannot interact with the tab button.\n     */\n    this.disabled = false;\n    /**\n     * The selected tab component\n     */\n    this.selected = false;\n    this.onKeyUp = (ev) => {\n      if (ev.key === 'Enter' || ev.key === ' ') {\n        this.selectTab(ev);\n      }\n    };\n    this.onClick = (ev) => {\n      this.selectTab(ev);\n    };\n  }\n  onTabBarChanged(ev) {\n    const dispatchedFrom = ev.target;\n    const parent = this.el.parentElement;\n    if ((ev.composedPath && ev.composedPath().includes(parent)) || (dispatchedFrom && dispatchedFrom.contains(this.el))) {\n      this.selected = this.tab === ev.detail.tab;\n    }\n  }\n  componentWillLoad() {\n    if (this.layout === undefined) {\n      this.layout = ionic_global_config.get('tabButtonLayout', 'icon-top');\n    }\n  }\n  selectTab(ev) {\n    if (this.tab !== undefined) {\n      if (!this.disabled) {\n        this.ionTabButtonClick.emit({\n          tab: this.tab,\n          href: this.href,\n          selected: this.selected\n        });\n      }\n      ev.preventDefault();\n    }\n  }\n  get hasLabel() {\n    return !!this.el.querySelector('ion-label');\n  }\n  get hasIcon() {\n    return !!this.el.querySelector('ion-icon');\n  }\n  get tabIndex() {\n    if (this.disabled) {\n      return -1;\n    }\n    const hasTabIndex = this.el.hasAttribute('tabindex');\n    if (hasTabIndex) {\n      return this.el.getAttribute('tabindex');\n    }\n    return 0;\n  }\n  render() {\n    const { disabled, hasIcon, hasLabel, tabIndex, href, rel, target, layout, selected, tab } = this;\n    const mode = ionic_global_getIonMode(this);\n    const attrs = {\n      download: this.download,\n      href,\n      rel,\n      target\n    };\n    return ((0,client.h)(client/* Host */.AA, { onClick: this.onClick, onKeyup: this.onKeyUp, role: \"tab\", tabindex: tabIndex, \"aria-selected\": selected ? 'true' : null, id: tab !== undefined ? `tab-button-${tab}` : null, class: {\n        [mode]: true,\n        'tab-selected': selected,\n        'tab-disabled': disabled,\n        'tab-has-label': hasLabel,\n        'tab-has-icon': hasIcon,\n        'tab-has-label-only': hasLabel && !hasIcon,\n        'tab-has-icon-only': hasIcon && !hasLabel,\n        [`tab-layout-${layout}`]: true,\n        'ion-activatable': true,\n        'ion-selectable': true,\n        'ion-focusable': true\n      } }, (0,client.h)(\"a\", Object.assign({}, attrs, { tabIndex: -1, class: \"button-native\", part: \"native\" }), (0,client.h)(\"span\", { class: \"button-inner\" }, (0,client.h)(\"slot\", null)), mode === 'md' && (0,client.h)(\"ion-ripple-effect\", { type: \"unbounded\" }))));\n  }\n  get el() { return this; }\n  static get style() { return {\n    ios: tabButtonIosCss,\n    md: tabButtonMdCss\n  }; }\n}, [33, \"ion-tab-button\", {\n    \"disabled\": [4],\n    \"download\": [1],\n    \"href\": [1],\n    \"rel\": [1],\n    \"layout\": [1025],\n    \"selected\": [1028],\n    \"tab\": [1],\n    \"target\": [1]\n  }, [[8, \"ionTabBarChanged\", \"onTabBarChanged\"]]]);\nfunction ion_tab_button_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-tab-button\", \"ion-ripple-effect\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-tab-button\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, TabButton);\n      }\n      break;\n    case \"ion-ripple-effect\":\n      if (!customElements.get(tagName)) {\n        ripple_effect_defineCustomElement();\n      }\n      break;\n  } });\n}\n\nconst IonTabButton = (/* unused pure expression or super */ null && (TabButton));\nconst ion_tab_button_defineCustomElement = ion_tab_button_defineCustomElement$1;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.12.1 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst client_setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst client_Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst client_setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => client_safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = client_safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = client_safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => client_safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        client_safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            client_safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            client_safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( _)\n    // ( _)>-\n    // (_)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst client_safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && newVal !== oldVal) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 5880).then(__webpack_require__.bind(__webpack_require__, 5880)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        client_safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            client_safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            client_safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst client_defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // \\_()_/\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in client_Context) {\n        return client_Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst client_Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(1875)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ (/* unused pure expression or super */ null && (queueTask(queueDomReads, false)));\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/utils.js\n\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  }\n  else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = (icons) => {\n  const map = getIconMap();\n  Object.keys(icons).forEach(name => map.set(name, icons[name]));\n};\nconst getUrl = (i) => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  return getAssetPath(`svg/${iconName}.svg`);\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  }\n  else if (md && mode === 'md') {\n    iconName = toLower(md);\n  }\n  else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = (src) => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/ionicons/components/ion-icon.js\n\n\n\nconst validateContent = (svgContent) => {\n  const div = document.createElement('div');\n  div.innerHTML = svgContent;\n  // setup this way to ensure it works on our buddy IE\n  for (let i = div.childNodes.length - 1; i >= 0; i--) {\n    if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n      div.removeChild(div.childNodes[i]);\n    }\n  }\n  // must only have 1 root element\n  const svgElm = div.firstElementChild;\n  if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n    const svgClass = svgElm.getAttribute('class') || '';\n    svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());\n    // root element must be an svg\n    // lets double check we've got valid elements\n    // do not allow scripts\n    if (isValid(svgElm)) {\n      return div.innerHTML;\n    }\n  }\n  return '';\n};\nconst isValid = (elm) => {\n  if (elm.nodeType === 1) {\n    if (elm.nodeName.toLowerCase() === 'script') {\n      return false;\n    }\n    for (let i = 0; i < elm.attributes.length; i++) {\n      const val = elm.attributes[i].value;\n      if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\n        return false;\n      }\n    }\n    for (let i = 0; i < elm.childNodes.length; i++) {\n      if (!isValid(elm.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconst ioniconContent = new Map();\nconst requests = new Map();\nconst getSvgContent = (url, sanitize) => {\n  // see if we already have a request for this url\n  let req = requests.get(url);\n  if (!req) {\n    if (typeof fetch !== 'undefined' && typeof document !== 'undefined') {\n      // we don't already have a request\n      req = fetch(url).then((rsp) => {\n        if (rsp.ok) {\n          return rsp.text().then((svgContent) => {\n            if (svgContent && sanitize !== false) {\n              svgContent = validateContent(svgContent);\n            }\n            ioniconContent.set(url, svgContent || '');\n          });\n        }\n        ioniconContent.set(url, '');\n      });\n      // cache for the same requests\n      requests.set(url, req);\n    }\n    else {\n      // set to empty for ssr scenarios and resolve promise\n      ioniconContent.set(url, '');\n      return Promise.resolve();\n    }\n  }\n  return req;\n};\n\nconst iconCss = \":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}\";\n\nlet Icon = class extends H {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.iconName = null;\n    this.inheritedAttributes = {};\n    this.isVisible = false;\n    /**\n     * The mode determines which platform styles to use.\n     */\n    this.mode = ion_icon_getIonMode();\n    /**\n     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\n     * Default, `false`.\n     */\n    this.lazy = false;\n    /**\n     * When set to `false`, SVG content that is HTTP fetched will not be checked\n     * if the response SVG content has any `<script>` elements, or any attributes\n     * that start with `on`, such as `onclick`.\n     * @default true\n     */\n    this.sanitize = true;\n    this.hasAriaHidden = () => {\n      const { el } = this;\n      return el.hasAttribute('aria-hidden') && el.getAttribute('aria-hidden') === 'true';\n    };\n  }\n  componentWillLoad() {\n    this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);\n  }\n  connectedCallback() {\n    // purposely do not return the promise here because loading\n    // the svg file should not hold up loading the app\n    // only load the svg if it's visible\n    this.waitUntilVisible(this.el, '50px', () => {\n      this.isVisible = true;\n      this.loadIcon();\n    });\n  }\n  disconnectedCallback() {\n    if (this.io) {\n      this.io.disconnect();\n      this.io = undefined;\n    }\n  }\n  waitUntilVisible(el, rootMargin, cb) {\n    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {\n      const io = (this.io = new window.IntersectionObserver((data) => {\n        if (data[0].isIntersecting) {\n          io.disconnect();\n          this.io = undefined;\n          cb();\n        }\n      }, { rootMargin }));\n      io.observe(el);\n    }\n    else {\n      // browser doesn't support IntersectionObserver\n      // so just fallback to always show it\n      cb();\n    }\n  }\n  loadIcon() {\n    if (Build.isBrowser && this.isVisible) {\n      const url = getUrl(this);\n      if (url) {\n        if (ioniconContent.has(url)) {\n          // sync if it's already loaded\n          this.svgContent = ioniconContent.get(url);\n        }\n        else {\n          // async if it hasn't been loaded\n          getSvgContent(url, this.sanitize).then(() => (this.svgContent = ioniconContent.get(url)));\n        }\n      }\n    }\n    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);\n    /**\n     * Come up with a default label\n     * in case user does not provide their own.\n     */\n    if (label) {\n      this.ariaLabel = label.replace(/\\-/g, ' ');\n    }\n  }\n  render() {\n    const { iconName, ariaLabel, inheritedAttributes } = this;\n    const mode = this.mode || 'md';\n    const flipRtl = this.flipRtl ||\n      (iconName &&\n        (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) &&\n        this.flipRtl !== false);\n    /**\n     * Only set the aria-label if a) we have generated\n     * one for the icon and if aria-hidden is not set to \"true\".\n     * If developer wants to set their own aria-label, then\n     * inheritedAttributes down below will override whatever\n     * default label we have set.\n     */\n    return (h(Host, Object.assign({ \"aria-label\": ariaLabel !== undefined && !this.hasAriaHidden() ? ariaLabel : null, role: \"img\", class: Object.assign(Object.assign({ [mode]: true }, ion_icon_createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, inheritedAttributes), Build.isBrowser && this.svgContent ? (h(\"div\", { class: \"icon-inner\", innerHTML: this.svgContent })) : (h(\"div\", { class: \"icon-inner\" }))));\n  }\n  static get assetsDirs() { return [\"svg\"]; }\n  get el() { return this; }\n  static get watchers() { return {\n    \"name\": [\"loadIcon\"],\n    \"src\": [\"loadIcon\"],\n    \"icon\": [\"loadIcon\"]\n  }; }\n  static get style() { return iconCss; }\n};\nconst ion_icon_getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';\nconst ion_icon_createColorClasses = (color) => {\n  return color\n    ? {\n      'ion-color': true,\n      [`ion-color-${color}`]: true,\n    }\n    : null;\n};\nIcon = /*@__PURE__*/ proxyCustomElement(Icon, [1, \"ion-icon\", {\n    \"mode\": [1025],\n    \"color\": [1],\n    \"ios\": [1],\n    \"md\": [1],\n    \"flipRtl\": [4, \"flip-rtl\"],\n    \"name\": [513],\n    \"src\": [1],\n    \"icon\": [8],\n    \"size\": [1],\n    \"lazy\": [4],\n    \"sanitize\": [4],\n    \"svgContent\": [32],\n    \"isVisible\": [32],\n    \"ariaLabel\": [32]\n  }]);\nfunction ion_icon_defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"ion-icon\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"ion-icon\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Icon);\n      }\n      break;\n  } });\n}\n\nconst IonIcon = (/* unused pure expression or super */ null && (Icon));\nconst ion_icon_defineCustomElement = ion_icon_defineCustomElement$1;\n\n\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/dist/esm-es5/index.js\nvar esm_es5 = __webpack_require__(3774);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/dist/index.js\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/react/dist/index.esm.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IonLifeCycleContext = /*@__PURE__*/ react.createContext({\n    onIonViewWillEnter: () => {\n        return;\n    },\n    ionViewWillEnter: () => {\n        return;\n    },\n    onIonViewDidEnter: () => {\n        return;\n    },\n    ionViewDidEnter: () => {\n        return;\n    },\n    onIonViewWillLeave: () => {\n        return;\n    },\n    ionViewWillLeave: () => {\n        return;\n    },\n    onIonViewDidLeave: () => {\n        return;\n    },\n    ionViewDidLeave: () => {\n        return;\n    },\n});\nconst DefaultIonLifeCycleContext = class {\n    constructor() {\n        this.ionViewWillEnterCallbacks = [];\n        this.ionViewDidEnterCallbacks = [];\n        this.ionViewWillLeaveCallbacks = [];\n        this.ionViewDidLeaveCallbacks = [];\n    }\n    onIonViewWillEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillEnterCallbacks.push(callback);\n        }\n    }\n    ionViewWillEnter() {\n        this.ionViewWillEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidEnter(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidEnterCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidEnterCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidEnterCallbacks.push(callback);\n        }\n    }\n    ionViewDidEnter() {\n        this.ionViewDidEnterCallbacks.forEach((cb) => cb());\n    }\n    onIonViewWillLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewWillLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewWillLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewWillLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewWillLeave() {\n        this.ionViewWillLeaveCallbacks.forEach((cb) => cb());\n    }\n    onIonViewDidLeave(callback) {\n        if (callback.id) {\n            const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);\n            if (index > -1) {\n                this.ionViewDidLeaveCallbacks[index] = callback;\n            }\n            else {\n                this.ionViewDidLeaveCallbacks.push(callback);\n            }\n        }\n        else {\n            this.ionViewDidLeaveCallbacks.push(callback);\n        }\n    }\n    ionViewDidLeave() {\n        this.ionViewDidLeaveCallbacks.forEach((cb) => cb());\n        this.componentCanBeDestroyed();\n    }\n    onComponentCanBeDestroyed(callback) {\n        this.componentCanBeDestroyedCallback = callback;\n    }\n    componentCanBeDestroyed() {\n        if (this.componentCanBeDestroyedCallback) {\n            this.componentCanBeDestroyedCallback();\n        }\n    }\n};\n\nconst withIonLifeCycle = (WrappedComponent) => {\n    return class IonLifeCycle extends React.Component {\n        constructor(props) {\n            super(props);\n            this.componentRef = React.createRef();\n        }\n        componentDidMount() {\n            const element = this.componentRef.current;\n            this.context.onIonViewWillEnter(() => {\n                if (element && element.ionViewWillEnter) {\n                    element.ionViewWillEnter();\n                }\n            });\n            this.context.onIonViewDidEnter(() => {\n                if (element && element.ionViewDidEnter) {\n                    element.ionViewDidEnter();\n                }\n            });\n            this.context.onIonViewWillLeave(() => {\n                if (element && element.ionViewWillLeave) {\n                    element.ionViewWillLeave();\n                }\n            });\n            this.context.onIonViewDidLeave(() => {\n                if (element && element.ionViewDidLeave) {\n                    element.ionViewDidLeave();\n                }\n            });\n        }\n        render() {\n            return (React.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n                this.context = context;\n                return React.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));\n            }));\n        }\n    };\n};\n\nconst useIonViewWillEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillEnter(callback);\n    }, deps);\n};\nconst useIonViewDidEnter = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidEnter(callback);\n    }, deps);\n};\nconst useIonViewWillLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewWillLeave(callback);\n    }, deps);\n};\nconst useIonViewDidLeave = (callback, deps = []) => {\n    const context = useContext(IonLifeCycleContext);\n    const id = useRef();\n    id.current = id.current || Math.floor(Math.random() * 1000000);\n    useEffect(() => {\n        callback.id = id.current;\n        context.onIonViewDidLeave(callback);\n    }, deps);\n};\n\nconst NavContext = /*@__PURE__*/ react.createContext({\n    getIonRedirect: () => undefined,\n    getIonRoute: () => undefined,\n    getPageManager: () => undefined,\n    getStackManager: () => undefined,\n    goBack: (route) => {\n        if (typeof window !== 'undefined') {\n            if (typeof route === 'string') {\n                window.location.pathname = route;\n            }\n            else {\n                window.history.back();\n            }\n        }\n    },\n    navigate: (path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    hasIonicRouter: () => false,\n    routeInfo: undefined,\n    setCurrentTab: () => undefined,\n    changeTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n    resetTab: (_tab, path) => {\n        if (typeof window !== 'undefined') {\n            window.location.pathname = path;\n        }\n    },\n});\n\nconst dashToPascalCase = (str) => str\n    .toLowerCase()\n    .split('-')\n    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))\n    .join('');\nconst camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);\n\nconst attachProps = (node, newProps, oldProps = {}) => {\n    // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n    if (node instanceof Element) {\n        // add any classes in className to the class list\n        const className = getClassName(node.classList, newProps, oldProps);\n        if (className !== '') {\n            node.className = className;\n        }\n        Object.keys(newProps).forEach((name) => {\n            if (name === 'children' ||\n                name === 'style' ||\n                name === 'ref' ||\n                name === 'class' ||\n                name === 'className' ||\n                name === 'forwardedRef') {\n                return;\n            }\n            if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                const eventName = name.substring(2);\n                const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n                if (!isCoveredByReact(eventNameLc)) {\n                    syncEvent(node, eventNameLc, newProps[name]);\n                }\n            }\n            else {\n                node[name] = newProps[name];\n                const propType = typeof newProps[name];\n                if (propType === 'string') {\n                    node.setAttribute(camelToDashCase(name), newProps[name]);\n                }\n            }\n        });\n    }\n};\nconst getClassName = (classList, newProps, oldProps) => {\n    const newClassProp = newProps.className || newProps.class;\n    const oldClassProp = oldProps.className || oldProps.class;\n    // map the classes to Maps for performance\n    const currentClasses = arrayToMap(classList);\n    const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n    const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n    const finalClassNames = [];\n    // loop through each of the current classes on the component\n    // to see if it should be a part of the classNames added\n    currentClasses.forEach((currentClass) => {\n        if (incomingPropClasses.has(currentClass)) {\n            // add it as its already included in classnames coming in from newProps\n            finalClassNames.push(currentClass);\n            incomingPropClasses.delete(currentClass);\n        }\n        else if (!oldPropClasses.has(currentClass)) {\n            // add it as it has NOT been removed by user\n            finalClassNames.push(currentClass);\n        }\n    });\n    incomingPropClasses.forEach((s) => finalClassNames.push(s));\n    return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nconst isCoveredByReact = (eventNameSuffix) => {\n    if (typeof document === 'undefined') {\n        return true;\n    }\n    else {\n        const eventName = 'on' + eventNameSuffix;\n        let isSupported = eventName in document;\n        if (!isSupported) {\n            const element = document.createElement('div');\n            element.setAttribute(eventName, 'return;');\n            isSupported = typeof element[eventName] === 'function';\n        }\n        return isSupported;\n    }\n};\nconst syncEvent = (node, eventName, newEventHandler) => {\n    const eventStore = node.__events || (node.__events = {});\n    const oldEventHandler = eventStore[eventName];\n    // Remove old listener so they don't double up.\n    if (oldEventHandler) {\n        node.removeEventListener(eventName, oldEventHandler);\n    }\n    // Bind new listener.\n    node.addEventListener(eventName, (eventStore[eventName] = function handler(e) {\n        if (newEventHandler) {\n            newEventHandler.call(this, e);\n        }\n    }));\n};\nconst arrayToMap = (arr) => {\n    const map = new Map();\n    arr.forEach((s) => map.set(s, s));\n    return map;\n};\n\nconst setRef = (ref, value) => {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref != null) {\n        // Cast as a MutableRef so we can assign current\n        ref.current = value;\n    }\n};\nconst mergeRefs = (...refs) => {\n    return (value) => {\n        refs.forEach(ref => {\n            setRef(ref, value);\n        });\n    };\n};\nconst createForwardRef$1 = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_defineCustomElement = (tagName, customElement) => {\n    if (customElement !== undefined &&\n        typeof customElements !== 'undefined' &&\n        !customElements.get(tagName)) {\n        customElements.define(tagName, customElement);\n    }\n};\n\nconst createReactComponent = (tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends react.Component {\n        constructor(props) {\n            super(props);\n            this.setComponentElRef = (element) => {\n                this.componentEl = element;\n            };\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            attachProps(this.componentEl, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            let propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else {\n                    acc[name] = cProps[name];\n                }\n                return acc;\n            }, {});\n            if (manipulatePropsFunction) {\n                propsToPass = manipulatePropsFunction(this.props, propsToPass);\n            }\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: mergeRefs(forwardedRef, this.setComponentElRef), style });\n            /**\n             * We use createElement here instead of\n             * React.createElement to work around a\n             * bug in Vite (https://github.com/vitejs/vite/issues/6104).\n             * React.createElement causes all elements to be rendered\n             * as <tagname> instead of the actual Web Component.\n             */\n            return (0,react.createElement)(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    // If context was passed to createReactComponent then conditionally add it to the Component Class\n    if (ReactComponentContext) {\n        ReactComponent.contextType = ReactComponentContext;\n    }\n    return createForwardRef$1(ReactComponent, displayName);\n};\n\n/* eslint-disable */\nconst IonAccordion = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion', undefined, undefined, defineCustomElement$1)));\nconst IonAccordionGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-accordion-group', undefined, undefined, defineCustomElement$2)));\nconst IonAvatar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-avatar', undefined, undefined, defineCustomElement$3)));\nconst IonBackdrop = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-backdrop', undefined, undefined, defineCustomElement$4)));\nconst IonBadge = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-badge', undefined, undefined, defineCustomElement$5)));\nconst IonBreadcrumbs = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-breadcrumbs', undefined, undefined, defineCustomElement$6)));\nconst IonButtons = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-buttons', undefined, undefined, defineCustomElement$7)));\nconst IonCardContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-content', undefined, undefined, defineCustomElement$8)));\nconst IonCardHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-header', undefined, undefined, defineCustomElement$9)));\nconst IonCardSubtitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-subtitle', undefined, undefined, defineCustomElement$a)));\nconst IonCardTitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-card-title', undefined, undefined, defineCustomElement$b)));\nconst IonCheckbox = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-checkbox', undefined, undefined, defineCustomElement$c)));\nconst IonChip = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-chip', undefined, undefined, defineCustomElement$d)));\nconst IonCol = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-col', undefined, undefined, defineCustomElement$e)));\nconst IonContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-content', undefined, undefined, defineCustomElement$f)));\nconst IonDatetime = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-datetime', undefined, undefined, defineCustomElement$g)));\nconst IonFab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab', undefined, undefined, defineCustomElement$h)));\nconst IonFabList = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-fab-list', undefined, undefined, defineCustomElement$i)));\nconst IonFooter = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-footer', undefined, undefined, defineCustomElement$j)));\nconst IonGrid = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-grid', undefined, undefined, defineCustomElement$k)));\nconst IonHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-header', undefined, undefined, defineCustomElement$l)));\nconst IonImg = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-img', undefined, undefined, defineCustomElement$m)));\nconst IonInfiniteScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll', undefined, undefined, defineCustomElement$n)));\nconst IonInfiniteScrollContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-infinite-scroll-content', undefined, undefined, defineCustomElement$o)));\nconst IonInput = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-input', undefined, undefined, defineCustomElement$p)));\nconst IonItemDivider = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-divider', undefined, undefined, defineCustomElement$q)));\nconst IonItemGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-group', undefined, undefined, defineCustomElement$r)));\nconst IonItemOptions = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-options', undefined, undefined, defineCustomElement$s)));\nconst IonItemSliding = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-item-sliding', undefined, undefined, defineCustomElement$t)));\nconst IonLabel = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-label', undefined, undefined, defineCustomElement$u)));\nconst IonList = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-list', undefined, undefined, defineCustomElement$v)));\nconst IonListHeader = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-list-header', undefined, undefined, defineCustomElement$w)));\nconst IonMenu = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu', undefined, undefined, defineCustomElement$x)));\nconst IonMenuButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-button', undefined, undefined, defineCustomElement$y)));\nconst IonMenuToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-menu-toggle', undefined, undefined, defineCustomElement$z)));\nconst IonNav = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav', undefined, undefined, defineCustomElement$A)));\nconst IonNavLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-nav-link', undefined, undefined, defineCustomElement$B)));\nconst IonNote = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-note', undefined, undefined, defineCustomElement$C)));\nconst IonProgressBar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-progress-bar', undefined, undefined, defineCustomElement$D)));\nconst IonRadio = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio', undefined, undefined, defineCustomElement$E)));\nconst IonRadioGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-radio-group', undefined, undefined, defineCustomElement$F)));\nconst IonRange = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-range', undefined, undefined, defineCustomElement$G)));\nconst IonRefresher = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher', undefined, undefined, defineCustomElement$H)));\nconst IonRefresherContent = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-refresher-content', undefined, undefined, defineCustomElement$I)));\nconst IonReorder = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder', undefined, undefined, defineCustomElement$J)));\nconst IonReorderGroup = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-reorder-group', undefined, undefined, defineCustomElement$K)));\nconst IonRippleEffect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-ripple-effect', undefined, undefined, defineCustomElement$L)));\nconst IonRow = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-row', undefined, undefined, defineCustomElement$M)));\nconst IonSearchbar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-searchbar', undefined, undefined, defineCustomElement$N)));\nconst IonSegment = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment', undefined, undefined, defineCustomElement$O)));\nconst IonSegmentButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-segment-button', undefined, undefined, defineCustomElement$P)));\nconst IonSelect = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select', undefined, undefined, defineCustomElement$Q)));\nconst IonSelectOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-select-option', undefined, undefined, defineCustomElement$R)));\nconst IonSkeletonText = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-skeleton-text', undefined, undefined, defineCustomElement$S)));\nconst IonSlide = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slide', undefined, undefined, defineCustomElement$T)));\nconst IonSlides = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-slides', undefined, undefined, defineCustomElement$U)));\nconst IonSpinner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-spinner', undefined, undefined, defineCustomElement$V)));\nconst IonSplitPane = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-split-pane', undefined, undefined, defineCustomElement$W)));\nconst IonTab = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-tab', undefined, undefined, defineCustomElement$X)));\nconst IonText = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-text', undefined, undefined, defineCustomElement$Y)));\nconst IonTextarea = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-textarea', undefined, undefined, defineCustomElement$Z)));\nconst IonThumbnail = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-thumbnail', undefined, undefined, defineCustomElement$_)));\nconst IonTitle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-title', undefined, undefined, defineCustomElement$$)));\nconst IonToggle = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-toggle', undefined, undefined, defineCustomElement$10)));\nconst IonToolbar = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-toolbar', undefined, undefined, defineCustomElement$11)));\nconst IonVirtualScroll = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-virtual-scroll', undefined, undefined, defineCustomElement$12)));\n\nconst createForwardRef = (ReactComponent, displayName) => {\n    const forwardRef = (props, ref) => {\n        return react.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));\n    };\n    forwardRef.displayName = displayName;\n    return react.forwardRef(forwardRef);\n};\nconst index_esm_isPlatform = (platform) => {\n    return isPlatform(window, platform);\n};\nconst index_esm_getPlatforms = () => {\n    return getPlatforms$1(window);\n};\nconst getConfig = () => {\n    if (typeof window !== 'undefined') {\n        const Ionic = window.Ionic;\n        if (Ionic && Ionic.config) {\n            return Ionic.config;\n        }\n    }\n    return null;\n};\n\nconst createRoutingComponent = (tagName, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends React.Component {\n        constructor(props) {\n            super(props);\n            this.handleClick = (e) => {\n                const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;\n                if (routerLink !== undefined) {\n                    e.preventDefault();\n                    this.context.navigate(routerLink, routerDirection, undefined, routerAnimation, routerOptions);\n                }\n            };\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = React.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n        }\n        componentDidMount() {\n            this.componentDidUpdate(this.props);\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            if (this.props.routerLink && !this.props.href) {\n                newProps.href = this.props.routerLink;\n            }\n            if (newProps.onClick) {\n                const oldClick = newProps.onClick;\n                newProps.onClick = (e) => {\n                    oldClick(e);\n                    if (!e.defaultPrevented) {\n                        this.handleClick(e);\n                    }\n                };\n            }\n            else {\n                newProps.onClick = this.handleClick;\n            }\n            return createElement(tagName, newProps, children);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        static get contextType() {\n            return NavContext;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonRouterLink = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-router-link', IonRouterLink$1)));\nconst IonButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-button', IonButton$1)));\nconst IonCard = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-card', IonCard$1)));\nconst IonFabButton = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-fab-button', IonFabButton$1)));\nconst IonItem = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-item', IonItem$1)));\nconst IonItemOption = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-item-option', IonItemOption$1)));\nconst IonBreadcrumb = /*@__PURE__*/ (/* unused pure expression or super */ null && (createRoutingComponent('ion-breadcrumb', IonBreadcrumb$1)));\n\nconst createControllerComponent = (tagName, controller, customElement) => {\n    index_esm_defineCustomElement(tagName, customElement);\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isUnmounted = false;\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        async componentDidMount() {\n            const { isOpen } = this.props;\n            if (isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            this.isUnmounted = true;\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        async componentDidUpdate(prevProps) {\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            this.overlay = await controller.create(Object.assign({}, cProps));\n            attachProps(this.overlay, {\n                [didDismissEventName]: this.handleDismiss,\n                [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),\n                [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),\n                [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e),\n            }, prevProps);\n            // Check isOpen again since the value could have changed during the async call to controller.create\n            // It's also possible for the component to have become unmounted.\n            if (this.props.isOpen === true && this.isUnmounted === false) {\n                setRef(this.props.forwardedRef, this.overlay);\n                await this.overlay.present();\n            }\n        }\n        render() {\n            return null;\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst IonAlert = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-alert', alertController, IonAlert$1)));\n\nconst IonLoading = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-loading', loadingController, IonLoading$1)));\n\nconst index_esm_toastController = {\n    create: (options) => toastController.create(options),\n    dismiss: (data, role, id) => toastController.dismiss(data, role, id),\n    getTop: () => toastController.getTop(),\n};\nconst IonToast = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-toast', index_esm_toastController, IonToast$1)));\n\nconst IonPicker = /*@__PURE__*/ (/* unused pure expression or super */ null && (createControllerComponent('ion-picker', pickerController, IonPicker$1)));\n\nconst createOverlayComponent = (tagName, controller, defineCustomElement) => {\n    if (defineCustomElement !== undefined) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const didDismissEventName = `on${displayName}DidDismiss`;\n    const didPresentEventName = `on${displayName}DidPresent`;\n    const willDismissEventName = `on${displayName}WillDismiss`;\n    const willPresentEventName = `on${displayName}WillPresent`;\n    class Overlay extends React.Component {\n        constructor(props) {\n            super(props);\n            this.isDismissing = false;\n            if (typeof document !== 'undefined') {\n                this.el = document.createElement('div');\n            }\n            this.handleDismiss = this.handleDismiss.bind(this);\n        }\n        static get displayName() {\n            return displayName;\n        }\n        componentDidMount() {\n            if (this.props.isOpen) {\n                this.present();\n            }\n        }\n        componentWillUnmount() {\n            if (this.overlay) {\n                this.overlay.dismiss();\n            }\n        }\n        handleDismiss(event) {\n            if (this.props.onDidDismiss) {\n                this.props.onDidDismiss(event);\n            }\n            setRef(this.props.forwardedRef, null);\n        }\n        shouldComponentUpdate(nextProps) {\n            // Check if the overlay component is about to dismiss\n            if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {\n                this.isDismissing = true;\n            }\n            return true;\n        }\n        async componentDidUpdate(prevProps) {\n            if (this.overlay) {\n                attachProps(this.overlay, this.props, prevProps);\n            }\n            if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                this.present(prevProps);\n            }\n            if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n                await this.overlay.dismiss();\n                this.isDismissing = false;\n                /**\n                 * Now that the overlay is dismissed\n                 * we need to render again so that any\n                 * inner components will be unmounted\n                 */\n                this.forceUpdate();\n            }\n        }\n        async present(prevProps) {\n            const _a = this.props, cProps = __rest(_a, [\"children\", \"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n            const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });\n            this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));\n            setRef(this.props.forwardedRef, this.overlay);\n            attachProps(this.overlay, elementProps, prevProps);\n            await this.overlay.present();\n        }\n        render() {\n            /**\n             * Continue to render the component even when\n             * overlay is dismissing otherwise component\n             * will be hidden before animation is done.\n             */\n            return ReactDOM.createPortal(this.props.isOpen || this.isDismissing ? this.props.children : null, this.el);\n        }\n    }\n    return React.forwardRef((props, ref) => {\n        return React.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));\n    });\n};\n\nconst index_esm_actionSheetController = {\n    create: (options) => actionSheetController.create(options),\n    dismiss: (data, role, id) => actionSheetController.dismiss(data, role, id),\n    getTop: () => actionSheetController.getTop(),\n};\nconst IonActionSheet = /*@__PURE__*/ (/* unused pure expression or super */ null && (createOverlayComponent('ion-action-sheet', index_esm_actionSheetController, defineCustomElement$13)));\n\nconst createInlineOverlayComponent = (tagName, defineCustomElement) => {\n    if (defineCustomElement) {\n        defineCustomElement();\n    }\n    const displayName = dashToPascalCase(tagName);\n    const ReactComponent = class extends React.Component {\n        constructor(props) {\n            super(props);\n            // Create a local ref to to attach props to the wrapped element.\n            this.ref = React.createRef();\n            // React refs must be stable (not created inline).\n            this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);\n            // Component is hidden by default\n            this.state = { isOpen: false };\n            // Create a local ref to the inner child element.\n            this.wrapperRef = React.createRef();\n        }\n        componentDidMount() {\n            var _a, _b;\n            this.componentDidUpdate(this.props);\n            /**\n             * Mount the inner component\n             * when overlay is about to open.\n             * Also manually call the onWillPresent\n             * handler if present as setState will\n             * cause the event handlers to be\n             * destroyed and re-created.\n             */\n            (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('willPresent', (evt) => {\n                this.setState({ isOpen: true });\n                this.props.onWillPresent && this.props.onWillPresent(evt);\n            });\n            /**\n             * Unmount the inner component.\n             * React will call Node.removeChild\n             * which expects the child to be\n             * a direct descendent of the parent\n             * but due to the presence of\n             * Web Component slots, this is not\n             * always the case. To work around this\n             * we move the inner component to the root\n             * of the Web Component so React can\n             * cleanup properly.\n             */\n            (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('didDismiss', (evt) => {\n                const wrapper = this.wrapperRef.current;\n                const el = this.ref.current;\n                /**\n                 * This component might be unmounted already, if the containing\n                 * element was removed while the popover was still open. (For\n                 * example, if an item contains an inline popover with a button\n                 * that removes the item.)\n                 */\n                if (wrapper && el) {\n                    el.append(wrapper);\n                    this.setState({ isOpen: false });\n                }\n                this.props.onDidDismiss && this.props.onDidDismiss(evt);\n            });\n        }\n        componentDidUpdate(prevProps) {\n            const node = this.ref.current;\n            attachProps(node, this.props, prevProps);\n        }\n        render() {\n            const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n            const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n                if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n                    const eventName = name.substring(2).toLowerCase();\n                    if (isCoveredByReact(eventName)) {\n                        acc[name] = cProps[name];\n                    }\n                }\n                else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n                    acc[camelToDashCase(name)] = cProps[name];\n                }\n                return acc;\n            }, {});\n            const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });\n            /**\n             * We only want the inner component\n             * to be mounted if the overlay is open,\n             * so conditionally render the component\n             * based on the isOpen state.\n             */\n            return createElement(tagName, newProps, (this.state.isOpen) ?\n                createElement('div', {\n                    id: 'ion-react-wrapper',\n                    ref: this.wrapperRef,\n                    style: {\n                        display: 'flex',\n                        flexDirection: 'column',\n                        height: '100%'\n                    }\n                }, children) :\n                null);\n        }\n        static get displayName() {\n            return displayName;\n        }\n    };\n    return createForwardRef(ReactComponent, displayName);\n};\n\nconst IonModal = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-modal', defineCustomElement$14)));\n\nconst IonPopover = /*@__PURE__*/ (/* unused pure expression or super */ null && (createInlineOverlayComponent('ion-popover', defineCustomElement$15)));\n\nconst IonContext = react.createContext({\n    addOverlay: () => {\n        return;\n    },\n    removeOverlay: () => {\n        return;\n    },\n});\n\n/**\n * Manages overlays that are added via the useOverlay hook.\n * This is a standalone component so changes to its children don't cause other descendant\n * components to re-render when overlays are added. However, we need to communicate with the IonContext\n * that is set up in <IonApp />, so we register callbacks so when overlays are added to IonContext,\n * they ultimately added here.\n */\nconst IonOverlayManager = ({ onAddOverlay, onRemoveOverlay, }) => {\n    /**\n     * Because of the way we're passing around the addOverlay and removeOverlay\n     * callbacks, by the time they finally get called, they use a stale reference\n     * to the state that only has the initial values. So if two overlays are opened\n     * at the same time, both using useIonModal or similar (such as through nesting),\n     * the second will erase the first from the overlays list. This causes the content\n     * of the first overlay to unmount.\n     *\n     * We wrap the state in useRef to ensure the two callbacks always use the most\n     * up-to-date version.\n     *\n     * Further reading: https://stackoverflow.com/a/56554056\n     */\n    const [overlays, setOverlays] = useState({});\n    const overlaysRef = useRef({});\n    overlaysRef.current = overlays;\n    useEffect(() => {\n        /* Setup the callbacks that get called from <IonApp /> */\n        onAddOverlay(addOverlay);\n        onRemoveOverlay(removeOverlay);\n    }, []);\n    const addOverlay = (id, component, containerElement) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        newOverlays[id] = { component, containerElement };\n        setOverlays(newOverlays);\n    };\n    const removeOverlay = (id) => {\n        const newOverlays = Object.assign({}, overlaysRef.current);\n        delete newOverlays[id];\n        setOverlays(newOverlays);\n    };\n    const overlayKeys = Object.keys(overlays);\n    return (React.createElement(React.Fragment, null, overlayKeys.map((key) => {\n        const overlay = overlays[key];\n        return ReactDOM.createPortal(overlay.component, overlay.containerElement, `overlay-${key}`);\n    })));\n};\n\nconst IonTabButtonInner = /*@__PURE__*/ createReactComponent('ion-tab-button', undefined, undefined, ion_tab_button_defineCustomElement);\nconst IonTabBarInner = /*@__PURE__*/ createReactComponent('ion-tab-bar', undefined, undefined, ion_tab_bar_defineCustomElement);\nconst IonBackButtonInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-back-button', undefined, undefined, defineCustomElement$18)));\nconst IonRouterOutletInner = /*@__PURE__*/ createReactComponent('ion-router-outlet', undefined, undefined, defineCustomElement);\nconst IonAppInner = /*@__PURE__*/ (/* unused pure expression or super */ null && (createReactComponent('ion-app', undefined, undefined, defineCustomElement$1a)));\n// ionicons\nconst IonIconInner = /*@__PURE__*/ createReactComponent('ion-icon', undefined, undefined, ion_icon_defineCustomElement);\n\nconst IonApp = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        /*\n          Wire up methods to call into IonOverlayManager\n        */\n        this.ionContext = {\n            addOverlay: (id, overlay, containerElement) => {\n                if (this.addOverlayCallback) {\n                    this.addOverlayCallback(id, overlay, containerElement);\n                }\n            },\n            removeOverlay: (id) => {\n                if (this.removeOverlayCallback) {\n                    this.removeOverlayCallback(id);\n                }\n            },\n        };\n    }\n    render() {\n        return (React.createElement(IonContext.Provider, { value: this.ionContext },\n            React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children),\n            React.createElement(IonOverlayManager, { onAddOverlay: (callback) => {\n                    this.addOverlayCallback = callback;\n                }, onRemoveOverlay: (callback) => {\n                    this.removeOverlayCallback = callback;\n                } })));\n    }\n    static get displayName() {\n        return 'IonApp';\n    }\n})()));\n\nconst StackContext = react.createContext({\n    registerIonPage: () => undefined,\n    isInOutlet: () => false,\n});\n\nclass PageManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.ionPageElementRef = react.createRef();\n        // React refs must be stable (not created inline).\n        this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);\n    }\n    componentDidMount() {\n        if (this.ionPageElementRef.current) {\n            if (this.context.isInOutlet()) {\n                this.ionPageElementRef.current.classList.add('ion-page-invisible');\n            }\n            this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);\n            this.ionPageElementRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionPageElementRef.current) {\n            this.ionPageElementRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionPageElementRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"routeInfo\", \"forwardedRef\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(\"div\", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonPageInternal extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const _a = this.props, { className, children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"className\", \"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (react.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo, forwardedRef: forwardedRef }, props), children)) : (react.createElement(\"div\", Object.assign({ className: className ? `ion-page ${className}` : 'ion-page', ref: forwardedRef }, props), children));\n    }\n    static get displayName() {\n        return 'IonPage';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonPage = createForwardRef(IonPageInternal, 'IonPage');\n\nconst IonTabsContext = react.createContext({\n    activeTab: undefined,\n    selectTab: () => false,\n});\n\nconst HTMLElementSSR = (typeof HTMLElement !== 'undefined'\n    ? HTMLElement\n    : class {\n    });\n\nclass OutletPageManager extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    componentDidMount() {\n        if (this.ionRouterOutlet) {\n            (0,esm_es5.componentOnReady)(this.ionRouterOutlet, () => {\n                this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);\n            });\n            this.ionRouterOutlet.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    componentWillUnmount() {\n        if (this.ionRouterOutlet) {\n            this.ionRouterOutlet.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n            this.ionRouterOutlet.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n        }\n    }\n    ionViewWillEnterHandler() {\n        this.ionLifeCycleContext.ionViewWillEnter();\n    }\n    ionViewDidEnterHandler() {\n        this.ionLifeCycleContext.ionViewDidEnter();\n    }\n    ionViewWillLeaveHandler() {\n        this.ionLifeCycleContext.ionViewWillLeave();\n    }\n    ionViewDidLeaveHandler() {\n        this.ionLifeCycleContext.ionViewDidLeave();\n    }\n    render() {\n        const _a = this.props, { StackManager, children, routeInfo } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"StackManager\", \"children\", \"routeInfo\"]);\n        return (react.createElement(IonLifeCycleContext.Consumer, null, (context) => {\n            this.ionLifeCycleContext = context;\n            return (react.createElement(StackManager, { routeInfo: routeInfo },\n                react.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => (this.ionRouterOutlet = val) }, props), children)));\n        }));\n    }\n    static get contextType() {\n        return StackContext;\n    }\n}\n\nclass IonRouterOutletContainer extends react.Component {\n    constructor(props) {\n        super(props);\n    }\n    render() {\n        const StackManager = this.context.getStackManager();\n        const _a = this.props, { children, forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"children\", \"forwardedRef\"]);\n        return this.context.hasIonicRouter() ? (props.ionPage ? (react.createElement(OutletPageManager, Object.assign({ StackManager: StackManager, routeInfo: this.context.routeInfo }, props), children)) : (react.createElement(StackManager, { routeInfo: this.context.routeInfo },\n            react.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef: forwardedRef }), children)))) : (react.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');\n\nconst index_esm_IonTabButton = /*@__PURE__*/ (() => class extends react.Component {\n    constructor(props) {\n        super(props);\n        this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);\n    }\n    handleIonTabButtonClick() {\n        if (this.props.onClick) {\n            this.props.onClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    tab: this.props.tab,\n                    href: this.props.href,\n                    routeOptions: this.props.routerOptions,\n                },\n            }));\n        }\n    }\n    render() {\n        const _a = this.props, rest = (0,tslib_es6/* __rest */._T)(_a, [\"onClick\"]);\n        return (react.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest)));\n    }\n    static get displayName() {\n        return 'IonTabButton';\n    }\n})();\n\nclass IonTabBarUnwrapped extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.setActiveTabOnContext = (_tab) => { };\n        const tabs = {};\n        react.Children.forEach(props.children, (child) => {\n            var _a, _b, _c, _d;\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                tabs[child.props.tab] = {\n                    originalHref: child.props.href,\n                    currentHref: child.props.href,\n                    originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname)\n                        ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : undefined,\n                    currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname)\n                        ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : undefined,\n                };\n            }\n        });\n        this.state = {\n            tabs,\n        };\n        this.onTabButtonClick = this.onTabButtonClick.bind(this);\n        this.renderTabButton = this.renderTabButton.bind(this);\n        this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);\n        this.selectTab = this.selectTab.bind(this);\n    }\n    componentDidMount() {\n        const tabs = this.state.tabs;\n        const tabKeys = Object.keys(tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = tabs[key].originalHref;\n            return this.props.routeInfo.pathname.startsWith(href);\n        });\n        if (activeTab) {\n            this.setState({\n                activeTab,\n            });\n        }\n    }\n    componentDidUpdate() {\n        if (this.state.activeTab) {\n            this.setActiveTabOnContext(this.state.activeTab);\n        }\n    }\n    selectTab(tab) {\n        const tabUrl = this.state.tabs[tab];\n        if (tabUrl) {\n            this.onTabButtonClick(new CustomEvent('ionTabButtonClick', {\n                detail: {\n                    href: tabUrl.currentHref,\n                    tab,\n                    selected: tab === this.state.activeTab,\n                    routeOptions: undefined,\n                },\n            }));\n            return true;\n        }\n        return false;\n    }\n    static getDerivedStateFromProps(props, state) {\n        var _a, _b, _c;\n        const tabs = Object.assign({}, state.tabs);\n        const tabKeys = Object.keys(state.tabs);\n        const activeTab = tabKeys.find((key) => {\n            const href = state.tabs[key].originalHref;\n            return props.routeInfo.pathname.startsWith(href);\n        });\n        // Check to see if the tab button href has changed, and if so, update it in the tabs state\n        react.Children.forEach(props.children, (child) => {\n            if (child != null &&\n                typeof child === 'object' &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const tab = tabs[child.props.tab];\n                if (!tab || tab.originalHref !== child.props.href) {\n                    tabs[child.props.tab] = {\n                        originalHref: child.props.href,\n                        currentHref: child.props.href,\n                        originalRouteOptions: child.props.routeOptions,\n                        currentRouteOptions: child.props.routeOptions,\n                    };\n                }\n            }\n        });\n        const { activeTab: prevActiveTab } = state;\n        if (activeTab && prevActiveTab) {\n            const prevHref = state.tabs[prevActiveTab].currentHref;\n            const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;\n            if (activeTab !== prevActiveTab ||\n                prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ||\n                prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {\n                tabs[activeTab] = {\n                    originalHref: tabs[activeTab].originalHref,\n                    currentHref: props.routeInfo.pathname + (props.routeInfo.search || ''),\n                    originalRouteOptions: tabs[activeTab].originalRouteOptions,\n                    currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions,\n                };\n                if (props.routeInfo.routeAction === 'pop' && activeTab !== prevActiveTab) {\n                    // If navigating back and the tabs change, set the prev tab back to its original href\n                    tabs[prevActiveTab] = {\n                        originalHref: tabs[prevActiveTab].originalHref,\n                        currentHref: tabs[prevActiveTab].originalHref,\n                        originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,\n                        currentRouteOptions: tabs[prevActiveTab].currentRouteOptions,\n                    };\n                }\n            }\n        }\n        activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);\n        return {\n            activeTab,\n            tabs,\n        };\n    }\n    onTabButtonClick(e) {\n        const tappedTab = this.state.tabs[e.detail.tab];\n        const originalHref = tappedTab.originalHref;\n        const currentHref = e.detail.href;\n        const { activeTab: prevActiveTab } = this.state;\n        // this.props.onSetCurrentTab(e.detail.tab, this.props.routeInfo);\n        // Clicking the current tab will bring you back to the original href\n        if (prevActiveTab === e.detail.tab) {\n            if (originalHref !== currentHref) {\n                this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);\n            }\n        }\n        else {\n            if (this.props.onIonTabsWillChange) {\n                this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', { detail: { tab: e.detail.tab } }));\n            }\n            if (this.props.onIonTabsDidChange) {\n                this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', { detail: { tab: e.detail.tab } }));\n            }\n            this.setActiveTabOnContext(e.detail.tab);\n            this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);\n        }\n    }\n    renderTabButton(activeTab) {\n        return (child) => {\n            var _a, _b;\n            if (child != null &&\n                child.props &&\n                (child.type === index_esm_IonTabButton || child.type.isTabButton)) {\n                const href = child.props.tab === activeTab\n                    ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;\n                const routeOptions = child.props.tab === activeTab\n                    ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;\n                return react.cloneElement(child, {\n                    href,\n                    routeOptions,\n                    onClick: this.onTabButtonClick,\n                });\n            }\n            return null;\n        };\n    }\n    render() {\n        const { activeTab } = this.state;\n        return (react.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), react.Children.map(this.props.children, this.renderTabButton(activeTab))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst IonTabBarContainer = react.memo((_a) => {\n    var { forwardedRef } = _a, props = (0,tslib_es6/* __rest */._T)(_a, [\"forwardedRef\"]);\n    const context = (0,react.useContext)(NavContext);\n    return (react.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children));\n});\nconst index_esm_IonTabBar = createForwardRef(IonTabBarContainer, 'IonTabBar');\n\nclass IonTabsElement extends HTMLElementSSR {\n    constructor() {\n        super();\n    }\n}\nif (typeof window !== 'undefined' && window.customElements) {\n    const element = window.customElements.get('ion-tabs');\n    if (!element) {\n        window.customElements.define('ion-tabs', IonTabsElement);\n    }\n}\nconst hostStyles = {\n    display: 'flex',\n    position: 'absolute',\n    top: '0',\n    left: '0',\n    right: '0',\n    bottom: '0',\n    flexDirection: 'column',\n    width: '100%',\n    height: '100%',\n    contain: 'layout size style',\n};\nconst tabsInner = {\n    position: 'relative',\n    flex: 1,\n    contain: 'layout size style',\n};\nconst IonTabs = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor(props) {\n        super(props);\n        this.routerOutletRef = React.createRef();\n        this.tabBarRef = React.createRef();\n        this.ionTabContextState = {\n            activeTab: undefined,\n            selectTab: () => false,\n        };\n    }\n    componentDidMount() {\n        if (this.tabBarRef.current) {\n            // Grab initial value\n            this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;\n            // Override method\n            this.tabBarRef.current.setActiveTabOnContext = (tab) => {\n                this.ionTabContextState.activeTab = tab;\n            };\n            this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;\n        }\n    }\n    render() {\n        let outlet;\n        let tabBar;\n        const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = __rest(_a, [\"className\", \"onIonTabsDidChange\", \"onIonTabsWillChange\"]);\n        const children = typeof this.props.children === 'function'\n            ? this.props.children(this.ionTabContextState)\n            : this.props.children;\n        React.Children.forEach(children, (child) => {\n            if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {\n                return;\n            }\n            if (child.type === index_esm_IonRouterOutlet || child.type.isRouterOutlet) {\n                outlet = React.cloneElement(child);\n            }\n            else if (child.type === Fragment && child.props.children[0].type === index_esm_IonRouterOutlet) {\n                outlet = child.props.children[0];\n            }\n            let childProps = {\n                ref: this.tabBarRef\n            };\n            /**\n             * Only pass these props\n             * down from IonTabs to IonTabBar\n             * if they are defined, otherwise\n             * if you have a handler set on\n             * IonTabBar it will be overridden.\n             */\n            if (onIonTabsDidChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });\n            }\n            if (onIonTabsWillChange !== undefined) {\n                childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });\n            }\n            if (child.type === index_esm_IonTabBar || child.type.isTabBar) {\n                tabBar = React.cloneElement(child, childProps);\n            }\n            else if (child.type === Fragment &&\n                (child.props.children[1].type === index_esm_IonTabBar || child.props.children[1].type.isTabBar)) {\n                tabBar = React.cloneElement(child.props.children[1], childProps);\n            }\n        });\n        if (!outlet) {\n            throw new Error('IonTabs must contain an IonRouterOutlet');\n        }\n        if (!tabBar) {\n            throw new Error('IonTabs needs a IonTabBar');\n        }\n        return (React.createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? (React.createElement(PageManager, Object.assign({ className: className ? `${className}` : '', routeInfo: this.context.routeInfo }, props),\n            React.createElement(\"ion-tabs\", { className: \"ion-tabs\", style: hostStyles },\n                tabBar.props.slot === 'top' ? tabBar : null,\n                React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n                tabBar.props.slot === 'bottom' ? tabBar : null))) : (React.createElement(\"div\", Object.assign({ className: className ? `${className}` : 'ion-tabs' }, props, { style: hostStyles }),\n            tabBar.props.slot === 'top' ? tabBar : null,\n            React.createElement(\"div\", { style: tabsInner, className: \"tabs-inner\" }, outlet),\n            tabBar.props.slot === 'bottom' ? tabBar : null))));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nconst IonBackButton = /*@__PURE__*/ (/* unused pure expression or super */ null && ((() => class extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.clickButton = (e) => {\n            const { defaultHref, routerAnimation } = this.props;\n            if (this.context.hasIonicRouter()) {\n                e.stopPropagation();\n                this.context.goBack(defaultHref, routerAnimation);\n            }\n            else if (defaultHref !== undefined) {\n                window.location.href = defaultHref;\n            }\n        };\n    }\n    render() {\n        return React.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));\n    }\n    static get displayName() {\n        return 'IonBackButton';\n    }\n    static get contextType() {\n        return NavContext;\n    }\n})()));\n\nclass IonIconContainer extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        if (this.props.name) {\n            console.warn('In Ionic React, you import icons from \"ionicons/icons\" and set the icon you imported to the \"icon\" property. Setting the \"name\" property has no effect.');\n        }\n    }\n    render() {\n        var _a, _b;\n        const _c = this.props, { icon, ios, md } = _c, rest = (0,tslib_es6/* __rest */._T)(_c, [\"icon\", \"ios\", \"md\"]);\n        let iconToUse;\n        if (ios || md) {\n            if (index_esm_isPlatform('ios')) {\n                iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n            }\n            else {\n                iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n            }\n        }\n        else {\n            iconToUse = icon;\n        }\n        return (react.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\nconst index_esm_IonIcon = createForwardRef(IonIconContainer, 'IonIcon');\n\nclass IonRoute extends react.PureComponent {\n    render() {\n        const IonRouteInner = this.context.getIonRoute();\n        if (!this.context.hasIonicRouter() || !IonRoute) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRoute>');\n            return null;\n        }\n        return React.createElement(IonRouteInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nclass IonRedirect extends react.PureComponent {\n    render() {\n        const IonRedirectInner = this.context.getIonRedirect();\n        if (!this.context.hasIonicRouter() || !IonRedirect) {\n            console.error('You either do not have an Ionic Router package, or your router does not support using <IonRedirect>');\n            return null;\n        }\n        return React.createElement(IonRedirectInner, Object.assign({}, this.props));\n    }\n    static get contextType() {\n        return NavContext;\n    }\n}\n\nconst IonRouterContext = react.createContext({\n    routeInfo: undefined,\n    push: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    back: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    canGoBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n    nativeBack: () => {\n        throw new Error('An Ionic Router is required for IonRouterContext');\n    },\n});\n/**\n * A hook for more direct control over routing in an Ionic React application. Allows you to pass additional meta-data to the router before the call to the native router.\n */\nfunction useIonRouter() {\n    const context = useContext(IonRouterContext);\n    return {\n        back: context.back,\n        push: context.push,\n        goBack: context.back,\n        canGoBack: context.canGoBack,\n        routeInfo: context.routeInfo,\n    };\n}\n\nclass CreateAnimation extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this.nodes = new Map();\n        this.animation = createAnimation(props.id);\n    }\n    setupAnimation(props) {\n        const animation = this.animation;\n        if (this.nodes.size > 0) {\n            animation.addElement(Array.from(this.nodes.values()));\n        }\n        checkConfig(animation, props);\n        checkPlayback(animation, props);\n    }\n    componentDidMount() {\n        const props = this.props;\n        this.setupAnimation(props);\n    }\n    componentDidUpdate(prevProps) {\n        const animation = this.animation;\n        const props = this.props;\n        checkConfig(animation, props, prevProps);\n        checkProgress(animation, props, prevProps);\n        checkPlayback(animation, props, prevProps);\n    }\n    render() {\n        const { children } = this.props;\n        return (React.createElement(React.Fragment, null, React.Children.map(children, (child, id) => React.cloneElement(child, { ref: (el) => this.nodes.set(id, el) }))));\n    }\n}\nconst checkConfig = (animation, currentProps = {}, prevProps = {}) => {\n    const reservedProps = [\n        'children',\n        'progressStart',\n        'progressStep',\n        'progressEnd',\n        'pause',\n        'stop',\n        'destroy',\n        'play',\n        'from',\n        'to',\n        'fromTo',\n        'onFinish',\n    ];\n    for (const key in currentProps) {\n        if (currentProps.hasOwnProperty(key) &&\n            !reservedProps.includes(key) &&\n            currentProps[key] !== prevProps[key]) {\n            animation[key](currentProps[key]);\n        }\n    }\n    const fromValues = currentProps.from;\n    if (fromValues && fromValues !== prevProps.from) {\n        const values = Array.isArray(fromValues) ? fromValues : [fromValues];\n        values.forEach((val) => animation.from(val.property, val.value));\n    }\n    const toValues = currentProps.to;\n    if (toValues && toValues !== prevProps.to) {\n        const values = Array.isArray(toValues) ? toValues : [toValues];\n        values.forEach((val) => animation.to(val.property, val.value));\n    }\n    const fromToValues = currentProps.fromTo;\n    if (fromToValues && fromToValues !== prevProps.fromTo) {\n        const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];\n        values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));\n    }\n    const onFinishValues = currentProps.onFinish;\n    if (onFinishValues && onFinishValues !== prevProps.onFinish) {\n        const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];\n        values.forEach((val) => animation.onFinish(val.callback, val.opts));\n    }\n};\nconst checkProgress = (animation, currentProps = {}, prevProps = {}) => {\n    var _a, _b, _c, _d, _e;\n    const { progressStart, progressStep, progressEnd } = currentProps;\n    if (progressStart &&\n        (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) ||\n            ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {\n        animation.progressStart(progressStart.forceLinearEasing, progressStart.step);\n    }\n    if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {\n        animation.progressStep(progressStep.step);\n    }\n    if (progressEnd &&\n        (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) ||\n            ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) ||\n            (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {\n        animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);\n    }\n};\nconst checkPlayback = (animation, currentProps = {}, prevProps = {}) => {\n    if (!prevProps.play && currentProps.play) {\n        animation.play();\n    }\n    if (!prevProps.pause && currentProps.pause) {\n        animation.pause();\n    }\n    if (!prevProps.stop && currentProps.stop) {\n        animation.stop();\n    }\n    if (!prevProps.destroy && currentProps.destroy) {\n        animation.destroy();\n    }\n};\n\nfunction useController(displayName, controller, defineCustomElement) {\n    const overlayRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    defineCustomElement();\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        const handleDismiss = (event) => {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n        };\n        overlayRef.current = await controller.create(Object.assign({}, rest));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n    }, [controller]);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonActionSheet component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonActionSheet() {\n    const controller = useController('IonActionSheet', actionSheetController$1, defineCustomElement$13);\n    const present = useCallback((buttonsOrOptions, header) => {\n        if (Array.isArray(buttonsOrOptions)) {\n            return controller.present({\n                buttons: buttonsOrOptions,\n                header,\n            });\n        }\n        else {\n            return controller.present(buttonsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonAlert component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonAlert() {\n    const controller = useController('IonAlert', alertController, defineCustomElement$1c);\n    const present = useCallback((messageOrOptions, buttons) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonToast component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonToast() {\n    const controller = useController('IonToast', toastController$1, defineCustomElement$1d);\n    const present = useCallback((messageOrOptions, duration) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\nconst ids = { main: 0 };\nconst generateId = (type = 'main') => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return id.toString();\n};\n\nfunction useOverlay(displayName, controller, defineCustomElement, component, componentProps) {\n    const overlayRef = useRef();\n    const containerElRef = useRef();\n    const didDismissEventName = useMemo(() => `on${displayName}DidDismiss`, [displayName]);\n    const didPresentEventName = useMemo(() => `on${displayName}DidPresent`, [displayName]);\n    const willDismissEventName = useMemo(() => `on${displayName}WillDismiss`, [displayName]);\n    const willPresentEventName = useMemo(() => `on${displayName}WillPresent`, [displayName]);\n    const [isOpen, setIsOpen] = useState(false);\n    const ionContext = useContext(IonContext);\n    const [overlayId] = useState(generateId('overlay'));\n    defineCustomElement();\n    useEffect(() => {\n        if (isOpen && component && containerElRef.current) {\n            if (React.isValidElement(component)) {\n                ionContext.addOverlay(overlayId, component, containerElRef.current);\n            }\n            else {\n                const element = createElement(component, componentProps);\n                ionContext.addOverlay(overlayId, element, containerElRef.current);\n            }\n        }\n    }, [component, containerElRef.current, isOpen, componentProps]);\n    const present = useCallback(async (options) => {\n        if (overlayRef.current) {\n            return;\n        }\n        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n        if (typeof document !== 'undefined') {\n            containerElRef.current = document.createElement('div');\n        }\n        overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));\n        attachProps(overlayRef.current, {\n            [didDismissEventName]: handleDismiss,\n            [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),\n            [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),\n            [willPresentEventName]: (e) => onWillPresent && onWillPresent(e),\n        });\n        overlayRef.current.present();\n        setIsOpen(true);\n        function handleDismiss(event) {\n            if (onDidDismiss) {\n                onDidDismiss(event);\n            }\n            overlayRef.current = undefined;\n            containerElRef.current = undefined;\n            setIsOpen(false);\n            ionContext.removeOverlay(overlayId);\n        }\n    }, []);\n    const dismiss = useCallback(async () => {\n        overlayRef.current && (await overlayRef.current.dismiss());\n        overlayRef.current = undefined;\n        containerElRef.current = undefined;\n    }, []);\n    return {\n        present,\n        dismiss,\n    };\n}\n\n/**\n * A hook for presenting/dismissing an IonModal component\n * @param component The component that the modal will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonModal(component, componentProps) {\n    const controller = useOverlay('IonModal', modalController, defineCustomElement$14, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @param component The component that the popover will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPopover(component, componentProps) {\n    const controller = useOverlay('IonPopover', popoverController, defineCustomElement$15, component, componentProps);\n    const present = useCallback((options = {}) => {\n        controller.present(options);\n    }, [controller.present]);\n    return [\n        present,\n        controller.dismiss\n    ];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPicker() {\n    const controller = useController('IonPicker', pickerController, defineCustomElement$1e);\n    const present = useCallback((columnsOrOptions, buttons) => {\n        if (Array.isArray(columnsOrOptions)) {\n            return controller.present({\n                columns: columnsOrOptions,\n                buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: 'Ok' }],\n            });\n        }\n        else {\n            return controller.present(columnsOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonLoading component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonLoading() {\n    const controller = useController('IonLoading', loadingController, defineCustomElement$1f);\n    const present = useCallback((messageOrOptions = '', duration, spinner) => {\n        if (typeof messageOrOptions === 'string') {\n            return controller.present({\n                message: messageOrOptions,\n                duration,\n                spinner: spinner !== null && spinner !== void 0 ? spinner : 'lines',\n            });\n        }\n        else {\n            return controller.present(messageOrOptions);\n        }\n    }, [controller.present]);\n    return [present, controller.dismiss];\n}\n\nconst setupIonicReact = (config = {}) => {\n    /**\n     * By default Ionic Framework hides elements that\n     * are not hydrated, but in the CE build there is no\n     * hydration.\n     * TODO: Remove when all integrations have been\n     * migrated to CE build.\n     */\n    if (typeof document !== 'undefined') {\n        document.documentElement.classList.add('ion-ce');\n    }\n    initialize(Object.assign({}, config));\n};\n\nconst RouteManagerContext = /*@__PURE__*/ react.createContext({\n    addViewItem: () => undefined,\n    canGoBack: () => undefined,\n    clearOutlet: () => undefined,\n    createViewItem: () => undefined,\n    findViewItemByPathname: () => undefined,\n    findLeavingViewItemByRouteInfo: () => undefined,\n    findViewItemByRouteInfo: () => undefined,\n    getChildrenToRender: () => undefined,\n    goBack: () => undefined,\n    unMountViewItem: () => undefined,\n});\n\nclass ViewLifeCycleManager extends react.Component {\n    constructor(props) {\n        super(props);\n        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();\n        this._isMounted = false;\n        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {\n            if (!this.props.mount) {\n                if (this._isMounted) {\n                    this.setState({\n                        show: false,\n                    }, () => this.props.removeView());\n                }\n            }\n        });\n        this.state = {\n            show: true,\n        };\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        this._isMounted = false;\n    }\n    render() {\n        const { show } = this.state;\n        return (React.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children));\n    }\n}\n\n// const RESTRICT_SIZE = 100;\nclass LocationHistory {\n    constructor() {\n        this.locationHistory = [];\n        this.tabHistory = {};\n    }\n    add(routeInfo) {\n        if (routeInfo.routeAction === 'push' || routeInfo.routeAction == null) {\n            this._add(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'pop') {\n            this._pop(routeInfo);\n        }\n        else if (routeInfo.routeAction === 'replace') {\n            this._replace(routeInfo);\n        }\n        if (routeInfo.routeDirection === 'root') {\n            this._clear();\n            this._add(routeInfo);\n        }\n    }\n    clearTabStack(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            routeInfos.forEach((ri) => {\n                this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);\n            });\n            this.tabHistory[tab] = [];\n        }\n    }\n    update(routeInfo) {\n        const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            this.locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = this.tabHistory[routeInfo.tab || ''];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            this.tabHistory[routeInfo.tab] = [routeInfo];\n        }\n    }\n    _add(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {\n                routeInfos.pop();\n            }\n            routeInfos.push(routeInfo);\n        }\n        this.locationHistory.push(routeInfo);\n    }\n    _areRoutesEqual(route1, route2) {\n        if (!route1 || !route2) {\n            return false;\n        }\n        return route1.pathname === route2.pathname && route1.search === route2.search;\n    }\n    _pop(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            // Pop the previous route\n            routeInfos.pop();\n            // Replace the current route with an updated version\n            routeInfos.pop();\n            routeInfos.push(routeInfo);\n        }\n        // Pop the previous route\n        this.locationHistory.pop();\n        // Replace the current route with an updated version\n        this.locationHistory.pop();\n        this.locationHistory.push(routeInfo);\n    }\n    _replace(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        routeInfos && routeInfos.pop();\n        this.locationHistory.pop();\n        this._add(routeInfo);\n    }\n    _clear() {\n        const keys = Object.keys(this.tabHistory);\n        keys.forEach((k) => (this.tabHistory[k] = []));\n        this.locationHistory = [];\n    }\n    _getRouteInfosByKey(key) {\n        let routeInfos;\n        if (key) {\n            routeInfos = this.tabHistory[key];\n            if (!routeInfos) {\n                routeInfos = this.tabHistory[key] = [];\n            }\n        }\n        return routeInfos;\n    }\n    getFirstRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[0];\n        }\n        return undefined;\n    }\n    getCurrentRouteInfoForTab(tab) {\n        const routeInfos = this._getRouteInfosByKey(tab);\n        if (routeInfos) {\n            return routeInfos[routeInfos.length - 1];\n        }\n        return undefined;\n    }\n    findLastLocation(routeInfo) {\n        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n        if (routeInfos) {\n            for (let i = routeInfos.length - 2; i >= 0; i--) {\n                const ri = routeInfos[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        for (let i = this.locationHistory.length - 2; i >= 0; i--) {\n            const ri = this.locationHistory[i];\n            if (ri) {\n                if (ri.pathname === routeInfo.pushedByRoute) {\n                    return ri;\n                }\n            }\n        }\n        return undefined;\n    }\n    previous() {\n        return (this.locationHistory[this.locationHistory.length - 2] ||\n            this.locationHistory[this.locationHistory.length - 1]);\n    }\n    current() {\n        return this.locationHistory[this.locationHistory.length - 1];\n    }\n    canGoBack() {\n        return this.locationHistory.length > 1;\n    }\n}\n\nclass NavManager extends react.PureComponent {\n    constructor(props) {\n        super(props);\n        this._isMounted = false;\n        this.ionRouterContextValue = {\n            push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {\n                this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);\n            },\n            back: (animationBuilder) => {\n                this.goBack(undefined, animationBuilder);\n            },\n            canGoBack: () => this.props.locationHistory.canGoBack(),\n            nativeBack: () => this.props.onNativeBack(),\n            routeInfo: this.props.routeInfo,\n        };\n        this.state = {\n            goBack: this.goBack.bind(this),\n            hasIonicRouter: () => true,\n            navigate: this.navigate.bind(this),\n            getIonRedirect: this.getIonRedirect.bind(this),\n            getIonRoute: this.getIonRoute.bind(this),\n            getStackManager: this.getStackManager.bind(this),\n            getPageManager: this.getPageManager.bind(this),\n            routeInfo: this.props.routeInfo,\n            setCurrentTab: this.props.onSetCurrentTab,\n            changeTab: this.props.onChangeTab,\n            resetTab: this.props.onResetTab,\n        };\n        if (typeof document !== 'undefined') {\n            this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);\n            document.addEventListener('ionBackButton', this.handleHardwareBackButton);\n        }\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener('ionBackButton', this.handleHardwareBackButton);\n            this._isMounted = false;\n        }\n    }\n    handleHardwareBackButton(e) {\n        e.detail.register(0, (processNextHandler) => {\n            if (this._isMounted) {\n                this.nativeGoBack();\n                processNextHandler();\n            }\n        });\n    }\n    goBack(route, animationBuilder) {\n        this.props.onNavigateBack(route, animationBuilder);\n    }\n    nativeGoBack() {\n        this.props.onNativeBack();\n    }\n    navigate(path, direction = 'forward', action = 'push', animationBuilder, options, tab) {\n        this.props.onNavigate(path, action, direction, animationBuilder, options, tab);\n    }\n    getPageManager() {\n        return PageManager;\n    }\n    getIonRedirect() {\n        return this.props.ionRedirect;\n    }\n    getIonRoute() {\n        return this.props.ionRoute;\n    }\n    getStackManager() {\n        return this.props.stackManager;\n    }\n    render() {\n        return (React.createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) },\n            React.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children)));\n    }\n}\n\nclass ViewStacks {\n    constructor() {\n        this.viewStacks = {};\n        this.add = this.add.bind(this);\n        this.clear = this.clear.bind(this);\n        this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);\n        this.remove = this.remove.bind(this);\n    }\n    add(viewItem) {\n        const { outletId } = viewItem;\n        if (!this.viewStacks[outletId]) {\n            this.viewStacks[outletId] = [viewItem];\n        }\n        else {\n            this.viewStacks[outletId].push(viewItem);\n        }\n    }\n    clear(outletId) {\n        // Give some time for the leaving views to transition before removing\n        setTimeout(() => {\n            // console.log('Removing viewstack for outletID ' + outletId);\n            delete this.viewStacks[outletId];\n        }, 500);\n    }\n    getViewItemsForOutlet(outletId) {\n        return this.viewStacks[outletId] || [];\n    }\n    remove(viewItem) {\n        const { outletId } = viewItem;\n        const viewStack = this.viewStacks[outletId];\n        if (viewStack) {\n            const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);\n            if (viewItemToRemove) {\n                viewItemToRemove.mount = false;\n                this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);\n            }\n        }\n    }\n    getStackIds() {\n        return Object.keys(this.viewStacks);\n    }\n    getAllViewItems() {\n        const keys = this.getStackIds();\n        const viewItems = [];\n        keys.forEach((k) => {\n            viewItems.push(...this.viewStacks[k]);\n        });\n        return viewItems;\n    }\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSwyREFBMkQsV0FBVyxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBLG9DQUFvQyxhQUFnQjtBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0MsdUZBQXVGLFlBQVk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLHNGQUFzRixZQUFZO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRWtXOzs7Ozs7O0FDNWVsVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQixlQUFlLGNBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSx3QkFBd0I7QUFDckcsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLG9FQUFvRSxpQ0FBaUM7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUNBQXFDLGlCQUFpQixpQ0FBaUMsR0FBRztBQUNySiw2REFBNkQscUNBQXFDLGlDQUFpQyxpQ0FBaUMsR0FBRztBQUN2SztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRSttRDtBQUMvbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uaWMtZ2xvYmFsLmpzP2Y4ZTciLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL292ZXJsYXlzLmpzP2UyZjkiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2N1YmljLWJlemllci5qcz9jNTEwIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9mcmFtZXdvcmstZGVsZWdhdGUuanM/YzEyMSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJvdXRlci1vdXRsZXQuanM/YmJhOSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvdGhlbWUuanM/NTRiZiIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXRhYi1iYXIuanM/ZmM2ZiIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvcmlwcGxlLWVmZmVjdC5qcz82MDViIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLWJ1dHRvbi5qcz84YzkwIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvaW9uaWNvbnMvbm9kZV9tb2R1bGVzL0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEvaW5kZXguanM/YTMwMCIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL2lvbmljb25zL25vZGVfbW9kdWxlcy9Ac3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcz84NDE5Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvaW9uaWNvbnMvY29tcG9uZW50cy91dGlscy5qcz85Njg4Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvaW9uaWNvbnMvY29tcG9uZW50cy9pb24taWNvbi5qcz84YTNjIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvZGlzdC9pbmRleC5qcz9mZTcwIiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL3JlYWN0L2Rpc3QvaW5kZXguZXNtLmpzPzc4ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IENvbnRleHQsIHNldFBsYXRmb3JtSGVscGVycywgc2V0TW9kZSwgZ2V0TW9kZSB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcblxuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tID0gbmV3IE1hcCgpO1xuICB9XG4gIHJlc2V0KGNvbmZpZ09iaikge1xuICAgIHRoaXMubSA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqKSk7XG4gIH1cbiAgZ2V0KGtleSwgZmFsbGJhY2spIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMubS5nZXQoa2V5KTtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogZmFsbGJhY2s7XG4gIH1cbiAgZ2V0Qm9vbGVhbihrZXksIGZhbGxiYWNrID0gZmFsc2UpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLm0uZ2V0KGtleSk7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gISF2YWw7XG4gIH1cbiAgZ2V0TnVtYmVyKGtleSwgZmFsbGJhY2spIHtcbiAgICBjb25zdCB2YWwgPSBwYXJzZUZsb2F0KHRoaXMubS5nZXQoa2V5KSk7XG4gICAgcmV0dXJuIGlzTmFOKHZhbCkgPyAoZmFsbGJhY2sgIT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrIDogTmFOKSA6IHZhbDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cbmNvbnN0IGNvbmZpZyA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbmZpZygpO1xuY29uc3QgY29uZmlnRnJvbVNlc3Npb24gPSAod2luKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29uZmlnU3RyID0gd2luLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oSU9OSUNfU0VTU0lPTl9LRVkpO1xuICAgIHJldHVybiBjb25maWdTdHIgIT09IG51bGwgPyBKU09OLnBhcnNlKGNvbmZpZ1N0cikgOiB7fTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufTtcbmNvbnN0IHNhdmVDb25maWcgPSAod2luLCBjKSA9PiB7XG4gIHRyeSB7XG4gICAgd2luLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oSU9OSUNfU0VTU0lPTl9LRVksIEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHJldHVybjtcbiAgfVxufTtcbmNvbnN0IGNvbmZpZ0Zyb21VUkwgPSAod2luKSA9PiB7XG4gIGNvbnN0IGNvbmZpZ09iaiA9IHt9O1xuICB3aW4ubG9jYXRpb24uc2VhcmNoXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcmJylcbiAgICAubWFwKGVudHJ5ID0+IGVudHJ5LnNwbGl0KCc9JykpXG4gICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbZGVjb2RlVVJJQ29tcG9uZW50KGtleSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldKVxuICAgIC5maWx0ZXIoKFtrZXldKSA9PiBzdGFydHNXaXRoKGtleSwgSU9OSUNfUFJFRklYKSlcbiAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXkuc2xpY2UoSU9OSUNfUFJFRklYLmxlbmd0aCksIHZhbHVlXSlcbiAgICAuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uZmlnT2JqW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBjb25maWdPYmo7XG59O1xuY29uc3Qgc3RhcnRzV2l0aCA9IChpbnB1dCwgc2VhcmNoKSA9PiB7XG4gIHJldHVybiBpbnB1dC5zdWJzdHIoMCwgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn07XG5jb25zdCBJT05JQ19QUkVGSVggPSAnaW9uaWM6JztcbmNvbnN0IElPTklDX1NFU1NJT05fS0VZID0gJ2lvbmljLXBlcnNpc3QtY29uZmlnJztcblxuY29uc3QgZ2V0UGxhdGZvcm1zID0gKHdpbikgPT4gc2V0dXBQbGF0Zm9ybXMod2luKTtcbmNvbnN0IGlzUGxhdGZvcm0gPSAod2luT3JQbGF0Zm9ybSwgcGxhdGZvcm0pID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5PclBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgIHBsYXRmb3JtID0gd2luT3JQbGF0Zm9ybTtcbiAgICB3aW5PclBsYXRmb3JtID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBnZXRQbGF0Zm9ybXMod2luT3JQbGF0Zm9ybSkuaW5jbHVkZXMocGxhdGZvcm0pO1xufTtcbmNvbnN0IHNldHVwUGxhdGZvcm1zID0gKHdpbiA9IHdpbmRvdykgPT4ge1xuICBpZiAodHlwZW9mIHdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgd2luLklvbmljID0gd2luLklvbmljIHx8IHt9O1xuICBsZXQgcGxhdGZvcm1zID0gd2luLklvbmljLnBsYXRmb3JtcztcbiAgaWYgKHBsYXRmb3JtcyA9PSBudWxsKSB7XG4gICAgcGxhdGZvcm1zID0gd2luLklvbmljLnBsYXRmb3JtcyA9IGRldGVjdFBsYXRmb3Jtcyh3aW4pO1xuICAgIHBsYXRmb3Jtcy5mb3JFYWNoKHAgPT4gd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKGBwbHQtJHtwfWApKTtcbiAgfVxuICByZXR1cm4gcGxhdGZvcm1zO1xufTtcbmNvbnN0IGRldGVjdFBsYXRmb3JtcyA9ICh3aW4pID0+IHtcbiAgY29uc3QgY3VzdG9tUGxhdGZvcm1NZXRob2RzID0gY29uZmlnLmdldCgncGxhdGZvcm0nKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKFBMQVRGT1JNU19NQVApLmZpbHRlcihwID0+IHtcbiAgICBjb25zdCBjdXN0b21NZXRob2QgPSBjdXN0b21QbGF0Zm9ybU1ldGhvZHMgJiYgY3VzdG9tUGxhdGZvcm1NZXRob2RzW3BdO1xuICAgIHJldHVybiB0eXBlb2YgY3VzdG9tTWV0aG9kID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWV0aG9kKHdpbikgOiBQTEFURk9STVNfTUFQW3BdKHdpbik7XG4gIH0pO1xufTtcbmNvbnN0IGlzTW9iaWxlV2ViID0gKHdpbikgPT4gaXNNb2JpbGUod2luKSAmJiAhaXNIeWJyaWQod2luKTtcbmNvbnN0IGlzSXBhZCA9ICh3aW4pID0+IHtcbiAgLy8gaU9TIDEyIGFuZCBiZWxvd1xuICBpZiAodGVzdFVzZXJBZ2VudCh3aW4sIC9pUGFkL2kpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gaU9TIDEzK1xuICBpZiAodGVzdFVzZXJBZ2VudCh3aW4sIC9NYWNpbnRvc2gvaSkgJiYgaXNNb2JpbGUod2luKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBpc0lwaG9uZSA9ICh3aW4pID0+IHRlc3RVc2VyQWdlbnQod2luLCAvaVBob25lL2kpO1xuY29uc3QgaXNJT1MgPSAod2luKSA9PiB0ZXN0VXNlckFnZW50KHdpbiwgL2lQaG9uZXxpUG9kL2kpIHx8IGlzSXBhZCh3aW4pO1xuY29uc3QgaXNBbmRyb2lkID0gKHdpbikgPT4gdGVzdFVzZXJBZ2VudCh3aW4sIC9hbmRyb2lkfHNpbmsvaSk7XG5jb25zdCBpc0FuZHJvaWRUYWJsZXQgPSAod2luKSA9PiB7XG4gIHJldHVybiBpc0FuZHJvaWQod2luKSAmJiAhdGVzdFVzZXJBZ2VudCh3aW4sIC9tb2JpbGUvaSk7XG59O1xuY29uc3QgaXNQaGFibGV0ID0gKHdpbikgPT4ge1xuICBjb25zdCB3aWR0aCA9IHdpbi5pbm5lcldpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQ7XG4gIGNvbnN0IHNtYWxsZXN0ID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIGNvbnN0IGxhcmdlc3QgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgcmV0dXJuIChzbWFsbGVzdCA+IDM5MCAmJiBzbWFsbGVzdCA8IDUyMCkgJiZcbiAgICAobGFyZ2VzdCA+IDYyMCAmJiBsYXJnZXN0IDwgODAwKTtcbn07XG5jb25zdCBpc1RhYmxldCA9ICh3aW4pID0+IHtcbiAgY29uc3Qgd2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luLmlubmVySGVpZ2h0O1xuICBjb25zdCBzbWFsbGVzdCA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBsYXJnZXN0ID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiAoaXNJcGFkKHdpbikgfHxcbiAgICBpc0FuZHJvaWRUYWJsZXQod2luKSB8fFxuICAgICgoc21hbGxlc3QgPiA0NjAgJiYgc21hbGxlc3QgPCA4MjApICYmXG4gICAgICAobGFyZ2VzdCA+IDc4MCAmJiBsYXJnZXN0IDwgMTQwMCkpKTtcbn07XG5jb25zdCBpc01vYmlsZSA9ICh3aW4pID0+IG1hdGNoTWVkaWEod2luLCAnKGFueS1wb2ludGVyOmNvYXJzZSknKTtcbmNvbnN0IGlzRGVza3RvcCA9ICh3aW4pID0+ICFpc01vYmlsZSh3aW4pO1xuY29uc3QgaXNIeWJyaWQgPSAod2luKSA9PiBpc0NvcmRvdmEod2luKSB8fCBpc0NhcGFjaXRvck5hdGl2ZSh3aW4pO1xuY29uc3QgaXNDb3Jkb3ZhID0gKHdpbikgPT4gISEod2luWydjb3Jkb3ZhJ10gfHwgd2luWydwaG9uZWdhcCddIHx8IHdpblsnUGhvbmVHYXAnXSk7XG5jb25zdCBpc0NhcGFjaXRvck5hdGl2ZSA9ICh3aW4pID0+IHtcbiAgY29uc3QgY2FwYWNpdG9yID0gd2luWydDYXBhY2l0b3InXTtcbiAgcmV0dXJuICEhKGNhcGFjaXRvciAmJiBjYXBhY2l0b3IuaXNOYXRpdmUpO1xufTtcbmNvbnN0IGlzRWxlY3Ryb24gPSAod2luKSA9PiB0ZXN0VXNlckFnZW50KHdpbiwgL2VsZWN0cm9uL2kpO1xuY29uc3QgaXNQV0EgPSAod2luKSA9PiAhISgod2luLm1hdGNoTWVkaWEgJiYgd2luLm1hdGNoTWVkaWEoJyhkaXNwbGF5LW1vZGU6IHN0YW5kYWxvbmUpJykubWF0Y2hlcykgfHwgd2luLm5hdmlnYXRvci5zdGFuZGFsb25lKTtcbmNvbnN0IHRlc3RVc2VyQWdlbnQgPSAod2luLCBleHByKSA9PiBleHByLnRlc3Qod2luLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgbWF0Y2hNZWRpYSA9ICh3aW4sIHF1ZXJ5KSA9PiB3aW4ubWF0Y2hNZWRpYSAmJiB3aW4ubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbmNvbnN0IFBMQVRGT1JNU19NQVAgPSB7XG4gICdpcGFkJzogaXNJcGFkLFxuICAnaXBob25lJzogaXNJcGhvbmUsXG4gICdpb3MnOiBpc0lPUyxcbiAgJ2FuZHJvaWQnOiBpc0FuZHJvaWQsXG4gICdwaGFibGV0JzogaXNQaGFibGV0LFxuICAndGFibGV0JzogaXNUYWJsZXQsXG4gICdjb3Jkb3ZhJzogaXNDb3Jkb3ZhLFxuICAnY2FwYWNpdG9yJzogaXNDYXBhY2l0b3JOYXRpdmUsXG4gICdlbGVjdHJvbic6IGlzRWxlY3Ryb24sXG4gICdwd2EnOiBpc1BXQSxcbiAgJ21vYmlsZSc6IGlzTW9iaWxlLFxuICAnbW9iaWxld2ViJzogaXNNb2JpbGVXZWIsXG4gICdkZXNrdG9wJzogaXNEZXNrdG9wLFxuICAnaHlicmlkJzogaXNIeWJyaWRcbn07XG5cbmxldCBkZWZhdWx0TW9kZTtcbmNvbnN0IGdldElvbk1vZGUgPSAocmVmKSA9PiB7XG4gIHJldHVybiAocmVmICYmIGdldE1vZGUocmVmKSkgfHwgZGVmYXVsdE1vZGU7XG59O1xuY29uc3QgaW5pdGlhbGl6ZSA9ICh1c2VyQ29uZmlnID0ge30pID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcbiAgY29uc3Qgd2luID0gd2luZG93O1xuICBDb250ZXh0LmNvbmZpZyA9IGNvbmZpZztcbiAgY29uc3QgSW9uaWMgPSB3aW4uSW9uaWMgPSB3aW4uSW9uaWMgfHwge307XG4gIGNvbnN0IHBsYXRmb3JtSGVscGVycyA9IHt9O1xuICBpZiAodXNlckNvbmZpZy5fYWVsKSB7XG4gICAgcGxhdGZvcm1IZWxwZXJzLmFlbCA9IHVzZXJDb25maWcuX2FlbDtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5fcmVsKSB7XG4gICAgcGxhdGZvcm1IZWxwZXJzLnJlbCA9IHVzZXJDb25maWcuX3JlbDtcbiAgfVxuICBpZiAodXNlckNvbmZpZy5fY2UpIHtcbiAgICBwbGF0Zm9ybUhlbHBlcnMuY2UgPSB1c2VyQ29uZmlnLl9jZTtcbiAgfVxuICBzZXRQbGF0Zm9ybUhlbHBlcnMocGxhdGZvcm1IZWxwZXJzKTtcbiAgLy8gY3JlYXRlIHRoZSBJb25pYy5jb25maWcgZnJvbSByYXcgY29uZmlnIG9iamVjdCAoaWYgaXQgZXhpc3RzKVxuICAvLyBhbmQgY29udmVydCBJb25pYy5jb25maWcgaW50byBhIENvbmZpZ0FwaSB0aGF0IGhhcyBhIGdldCgpIGZuXG4gIGNvbnN0IGNvbmZpZ09iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnRnJvbVNlc3Npb24od2luKSksIHsgcGVyc2lzdENvbmZpZzogZmFsc2UgfSksIElvbmljLmNvbmZpZyksIGNvbmZpZ0Zyb21VUkwod2luKSksIHVzZXJDb25maWcpO1xuICBjb25maWcucmVzZXQoY29uZmlnT2JqKTtcbiAgaWYgKGNvbmZpZy5nZXRCb29sZWFuKCdwZXJzaXN0Q29uZmlnJykpIHtcbiAgICBzYXZlQ29uZmlnKHdpbiwgY29uZmlnT2JqKTtcbiAgfVxuICAvLyBTZXR1cCBwbGF0Zm9ybXNcbiAgc2V0dXBQbGF0Zm9ybXMod2luKTtcbiAgLy8gZmlyc3Qgc2VlIGlmIHRoZSBtb2RlIHdhcyBzZXQgYXMgYW4gYXR0cmlidXRlIG9uIDxodG1sPlxuICAvLyB3aGljaCBjb3VsZCBoYXZlIGJlZW4gc2V0IGJ5IHRoZSB1c2VyLCBvciBieSBwcmUtcmVuZGVyaW5nXG4gIC8vIG90aGVyd2lzZSBnZXQgdGhlIG1vZGUgdmlhIGNvbmZpZyBzZXR0aW5ncywgYW5kIGZhbGxiYWNrIHRvIG1kXG4gIElvbmljLmNvbmZpZyA9IGNvbmZpZztcbiAgSW9uaWMubW9kZSA9IGRlZmF1bHRNb2RlID0gY29uZmlnLmdldCgnbW9kZScsIChkb2MuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kZScpKSB8fCAoaXNQbGF0Zm9ybSh3aW4sICdpb3MnKSA/ICdpb3MnIDogJ21kJykpO1xuICBjb25maWcuc2V0KCdtb2RlJywgZGVmYXVsdE1vZGUpO1xuICBkb2MuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kZScsIGRlZmF1bHRNb2RlKTtcbiAgZG9jLmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKGRlZmF1bHRNb2RlKTtcbiAgaWYgKGNvbmZpZy5nZXRCb29sZWFuKCdfdGVzdGluZycpKSB7XG4gICAgY29uZmlnLnNldCgnYW5pbWF0ZWQnLCBmYWxzZSk7XG4gIH1cbiAgY29uc3QgaXNJb25pY0VsZW1lbnQgPSAoZWxtKSA9PiBlbG0udGFnTmFtZSAmJiBlbG0udGFnTmFtZS5zdGFydHNXaXRoKCdJT04tJyk7XG4gIGNvbnN0IGlzQWxsb3dlZElvbmljTW9kZVZhbHVlID0gKGVsbU1vZGUpID0+IFsnaW9zJywgJ21kJ10uaW5jbHVkZXMoZWxtTW9kZSk7XG4gIHNldE1vZGUoKGVsbSkgPT4ge1xuICAgIHdoaWxlIChlbG0pIHtcbiAgICAgIGNvbnN0IGVsbU1vZGUgPSBlbG0ubW9kZSB8fCBlbG0uZ2V0QXR0cmlidXRlKCdtb2RlJyk7XG4gICAgICBpZiAoZWxtTW9kZSkge1xuICAgICAgICBpZiAoaXNBbGxvd2VkSW9uaWNNb2RlVmFsdWUoZWxtTW9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZWxtTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0lvbmljRWxlbWVudChlbG0pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGlvbmljIG1vZGU6IFwiJyArIGVsbU1vZGUgKyAnXCIsIGV4cGVjdGVkOiBcImlvc1wiIG9yIFwibWRcIicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbG0gPSBlbG0ucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRNb2RlO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGlzUGxhdGZvcm0gYXMgYSwgZ2V0SW9uTW9kZSBhcyBiLCBjb25maWcgYXMgYywgZ2V0UGxhdGZvcm1zIGFzIGcsIGluaXRpYWxpemUgYXMgaSB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSwgYyBhcyBjb25maWcgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5pbXBvcnQgeyBPVkVSTEFZX0JBQ0tfQlVUVE9OX1BSSU9SSVRZIH0gZnJvbSAnLi9oYXJkd2FyZS1iYWNrLWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbXBvbmVudE9uUmVhZHksIGYgYXMgZm9jdXNFbGVtZW50LCBhIGFzIGFkZEV2ZW50TGlzdGVuZXIsIGIgYXMgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZyBhcyBnZXRFbGVtZW50Um9vdCB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmxldCBsYXN0SWQgPSAwO1xuY29uc3QgYWN0aXZlQW5pbWF0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjcmVhdGVDb250cm9sbGVyID0gKHRhZ05hbWUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNyZWF0ZU92ZXJsYXkodGFnTmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBkaXNtaXNzKGRhdGEsIHJvbGUsIGlkKSB7XG4gICAgICByZXR1cm4gZGlzbWlzc092ZXJsYXkoZG9jdW1lbnQsIGRhdGEsIHJvbGUsIHRhZ05hbWUsIGlkKTtcbiAgICB9LFxuICAgIGFzeW5jIGdldFRvcCgpIHtcbiAgICAgIHJldHVybiBnZXRPdmVybGF5KGRvY3VtZW50LCB0YWdOYW1lKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgYWxlcnRDb250cm9sbGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyKCdpb24tYWxlcnQnKTtcbmNvbnN0IGFjdGlvblNoZWV0Q29udHJvbGxlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlcignaW9uLWFjdGlvbi1zaGVldCcpO1xuY29uc3QgbG9hZGluZ0NvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1sb2FkaW5nJyk7XG5jb25zdCBtb2RhbENvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1tb2RhbCcpO1xuY29uc3QgcGlja2VyQ29udHJvbGxlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlcignaW9uLXBpY2tlcicpO1xuY29uc3QgcG9wb3ZlckNvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi1wb3BvdmVyJyk7XG5jb25zdCB0b2FzdENvbnRyb2xsZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNvbnRyb2xsZXIoJ2lvbi10b2FzdCcpO1xuY29uc3QgcHJlcGFyZU92ZXJsYXkgPSAoZWwpID0+IHtcbiAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29ubmVjdExpc3RlbmVycyhkb2N1bWVudCk7XG4gIH1cbiAgY29uc3Qgb3ZlcmxheUluZGV4ID0gbGFzdElkKys7XG4gIGVsLm92ZXJsYXlJbmRleCA9IG92ZXJsYXlJbmRleDtcbiAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICBlbC5pZCA9IGBpb24tb3ZlcmxheS0ke292ZXJsYXlJbmRleH1gO1xuICB9XG59O1xuY29uc3QgY3JlYXRlT3ZlcmxheSA9ICh0YWdOYW1lLCBvcHRzKSA9PiB7XG4gIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5jdXN0b21FbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93LmN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKHRhZ05hbWUpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ292ZXJsYXktaGlkZGVuJyk7XG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnQgdGhlIHBhc3NlZCBpbiBvdmVybGF5IG9wdGlvbnMgaW50byBwcm9wc1xuICAgICAgICogdGhhdCBnZXQgcGFzc2VkIGRvd24gaW50byB0aGUgbmV3IG92ZXJsYXkuXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBoYXNDb250cm9sbGVyOiB0cnVlIH0pKTtcbiAgICAgIC8vIGFwcGVuZCB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBib2R5XG4gICAgICBnZXRBcHBSb290KGRvY3VtZW50KS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNvbXBvbmVudE9uUmVhZHkoZWxlbWVudCwgcmVzb2x2ZSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5jb25zdCBmb2N1c2FibGVRdWVyeVN0cmluZyA9ICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSksIGlucHV0Om5vdChbdHlwZT1oaWRkZW5dKTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCB0ZXh0YXJlYTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pLCBidXR0b246bm90KFt0YWJpbmRleF49XCItXCJdKSwgc2VsZWN0Om5vdChbdGFiaW5kZXhePVwiLVwiXSksIC5pb24tZm9jdXNhYmxlOm5vdChbdGFiaW5kZXhePVwiLVwiXSknO1xuY29uc3QgaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZyA9ICdpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdCc7XG5jb25zdCBmb2N1c0ZpcnN0RGVzY2VuZGFudCA9IChyZWYsIG92ZXJsYXkpID0+IHtcbiAgbGV0IGZpcnN0SW5wdXQgPSByZWYucXVlcnlTZWxlY3Rvcihmb2N1c2FibGVRdWVyeVN0cmluZyk7XG4gIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaXJzdElucHV0ICYmIGZpcnN0SW5wdXQuc2hhZG93Um9vdDtcbiAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaW5uZXIgZm9jdXNhYmxlIGVsZW1lbnRzLCBqdXN0IGZvY3VzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgZmlyc3RJbnB1dCA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKSB8fCBmaXJzdElucHV0O1xuICB9XG4gIGlmIChmaXJzdElucHV0KSB7XG4gICAgZm9jdXNFbGVtZW50KGZpcnN0SW5wdXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEZvY3VzIG92ZXJsYXkgaW5zdGVhZCBvZiBsZXR0aW5nIGZvY3VzIGVzY2FwZVxuICAgIG92ZXJsYXkuZm9jdXMoKTtcbiAgfVxufTtcbmNvbnN0IGlzT3ZlcmxheUhpZGRlbiA9IChvdmVybGF5KSA9PiBvdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnb3ZlcmxheS1oaWRkZW4nKTtcbmNvbnN0IGZvY3VzTGFzdERlc2NlbmRhbnQgPSAocmVmLCBvdmVybGF5KSA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20ocmVmLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlUXVlcnlTdHJpbmcpKTtcbiAgbGV0IGxhc3RJbnB1dCA9IGlucHV0cy5sZW5ndGggPiAwID8gaW5wdXRzW2lucHV0cy5sZW5ndGggLSAxXSA6IG51bGw7XG4gIGNvbnN0IHNoYWRvd1Jvb3QgPSBsYXN0SW5wdXQgJiYgbGFzdElucHV0LnNoYWRvd1Jvb3Q7XG4gIGlmIChzaGFkb3dSb290KSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGlubmVyIGZvY3VzYWJsZSBlbGVtZW50cywganVzdCBmb2N1cyB0aGUgaG9zdCBlbGVtZW50LlxuICAgIGxhc3RJbnB1dCA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcihpbm5lckZvY3VzYWJsZVF1ZXJ5U3RyaW5nKSB8fCBsYXN0SW5wdXQ7XG4gIH1cbiAgaWYgKGxhc3RJbnB1dCkge1xuICAgIGxhc3RJbnB1dC5mb2N1cygpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEZvY3VzIG92ZXJsYXkgaW5zdGVhZCBvZiBsZXR0aW5nIGZvY3VzIGVzY2FwZVxuICAgIG92ZXJsYXkuZm9jdXMoKTtcbiAgfVxufTtcbi8qKlxuICogVHJhcHMga2V5Ym9hcmQgZm9jdXMgaW5zaWRlIG9mIG92ZXJsYXkgY29tcG9uZW50cy5cbiAqIEJhc2VkIG9uIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9hcmlhLXByYWN0aWNlcy9leGFtcGxlcy9kaWFsb2ctbW9kYWwvYWxlcnRkaWFsb2cuaHRtbFxuICogVGhpcyBpbmNsdWRlcyB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6IEFjdGlvbiBTaGVldCwgQWxlcnQsIExvYWRpbmcsIE1vZGFsLFxuICogUGlja2VyLCBhbmQgUG9wb3Zlci5cbiAqIFNob3VsZCBOT1QgaW5jbHVkZTogVG9hc3RcbiAqL1xuY29uc3QgdHJhcEtleWJvYXJkRm9jdXMgPSAoZXYsIGRvYykgPT4ge1xuICBjb25zdCBsYXN0T3ZlcmxheSA9IGdldE92ZXJsYXkoZG9jLCAnaW9uLWFsZXJ0LGlvbi1hY3Rpb24tc2hlZXQsaW9uLWxvYWRpbmcsaW9uLW1vZGFsLGlvbi1waWNrZXIsaW9uLXBvcG92ZXInKTtcbiAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAvKipcbiAgICogSWYgbm8gYWN0aXZlIG92ZXJsYXksIGlnbm9yZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJZiB0aGlzIGNvbXBvbmVudCB1c2VzIHRoZSBzaGFkb3cgZG9tLFxuICAgKiB0aGlzIGdsb2JhbCBsaXN0ZW5lciBpcyBwb2ludGxlc3NcbiAgICogc2luY2UgaXQgd2lsbCBub3QgY2F0Y2ggdGhlIGZvY3VzXG4gICAqIHRyYXBzIGFzIHRoZXkgYXJlIGluc2lkZSB0aGUgc2hhZG93IHJvb3QuXG4gICAqIFdlIG5lZWQgdG8gYWRkIGEgbGlzdGVuZXIgdG8gdGhlIHNoYWRvdyByb290XG4gICAqIGl0c2VsZiB0byBlbnN1cmUgdGhlIGZvY3VzIHRyYXAgd29ya3MuXG4gICAqL1xuICBpZiAoIWxhc3RPdmVybGF5IHx8ICF0YXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIElmIHRoZSBpb24tZGlzYWJsZS1mb2N1cy10cmFwIGNsYXNzXG4gICAqIGlzIHByZXNlbnQgb24gYW4gb3ZlcmxheSwgdGhlbiB0aGlzIGNvbXBvbmVudFxuICAgKiBpbnN0YW5jZSBoYXMgb3B0ZWQgb3V0IG9mIGZvY3VzIHRyYXBwaW5nLlxuICAgKiBBbiBleGFtcGxlIG9mIHRoaXMgaXMgd2hlbiB0aGUgc2hlZXQgbW9kYWxcbiAgICogaGFzIGEgYmFja2Ryb3AgdGhhdCBpcyBkaXNhYmxlZC4gVGhlIGNvbnRlbnRcbiAgICogYmVoaW5kIHRoZSBzaGVldCBzaG91bGQgYmUgZm9jdXNhYmxlIHVudGlsXG4gICAqIHRoZSBiYWNrZHJvcCBpcyBlbmFibGVkLlxuICAgKi9cbiAgaWYgKGxhc3RPdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnaW9uLWRpc2FibGUtZm9jdXMtdHJhcCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRyYXBTY29wZWRGb2N1cyA9ICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgZm9jdXNpbmcgdGhlIG92ZXJsYXksIGNsZWFyXG4gICAgICogdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50IHNvIHRoYXQgaGl0dGluZ1xuICAgICAqIHRhYiBhY3RpdmF0ZXMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50XG4gICAgICogaW4gdGhlIG92ZXJsYXkgd3JhcHBlci5cbiAgICAgKi9cbiAgICBpZiAobGFzdE92ZXJsYXkgPT09IHRhcmdldCkge1xuICAgICAgbGFzdE92ZXJsYXkubGFzdEZvY3VzID0gdW5kZWZpbmVkO1xuICAgICAgLyoqXG4gICAgICAgKiBPdGhlcndpc2UsIHdlIG11c3QgYmUgZm9jdXNpbmcgYW4gZWxlbWVudFxuICAgICAgICogaW5zaWRlIG9mIHRoZSBvdmVybGF5LiBUaGUgdHdvIHBvc3NpYmxlIG9wdGlvbnNcbiAgICAgICAqIGhlcmUgYXJlIGFuIGlucHV0L2J1dHRvbi9ldGMgb3IgdGhlIGlvbi1mb2N1cy10cmFwXG4gICAgICAgKiBlbGVtZW50LiBUaGUgZm9jdXMgdHJhcCBlbGVtZW50IGlzIHVzZWQgdG8gcHJldmVudFxuICAgICAgICogdGhlIGtleWJvYXJkIGZvY3VzIGZyb20gbGVhdmluZyB0aGUgb3ZlcmxheSB3aGVuXG4gICAgICAgKiB1c2luZyBUYWIgb3Igc2NyZWVuIGFzc2lzdGFudHMuXG4gICAgICAgKi9cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIFdlIGRvIG5vdCB3YW50IHRvIGZvY3VzIHRoZSB0cmFwcywgc28gZ2V0IHRoZSBvdmVybGF5XG4gICAgICAgKiB3cmFwcGVyIGVsZW1lbnQgYXMgdGhlIHRyYXBzIGxpdmUgb3V0c2lkZSBvZiB0aGUgd3JhcHBlci5cbiAgICAgICAqL1xuICAgICAgY29uc3Qgb3ZlcmxheVJvb3QgPSBnZXRFbGVtZW50Um9vdChsYXN0T3ZlcmxheSk7XG4gICAgICBpZiAoIW92ZXJsYXlSb290LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxheVdyYXBwZXIgPSBvdmVybGF5Um9vdC5xdWVyeVNlbGVjdG9yKCcuaW9uLW92ZXJsYXktd3JhcHBlcicpO1xuICAgICAgaWYgKCFvdmVybGF5V3JhcHBlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSB0YXJnZXQgaXMgaW5zaWRlIHRoZSB3cmFwcGVyLCBsZXQgdGhlIGJyb3dzZXJcbiAgICAgICAqIGZvY3VzIGFzIG5vcm1hbCBhbmQga2VlcCBhIGxvZyBvZiB0aGUgbGFzdCBmb2N1c2VkIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIGlmIChvdmVybGF5V3JhcHBlci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogT3RoZXJ3aXNlLCB3ZSBtdXN0IGhhdmUgZm9jdXNlZCBvbmUgb2YgdGhlIGZvY3VzIHRyYXBzLlxuICAgICAgICAgKiBXZSBuZWVkIHRvIHdyYXAgdGhlIGZvY3VzIHRvIGVpdGhlciB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgKiBvciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uY2Ugd2UgY2FsbCBgZm9jdXNGaXJzdERlc2NlbmRhbnRgIGFuZCBmb2N1cyB0aGUgZmlyc3RcbiAgICAgICAgICogZGVzY2VuZGFudCwgYW5vdGhlciBmb2N1cyBldmVudCB3aWxsIGZpcmUgd2hpY2ggd2lsbFxuICAgICAgICAgKiBjYXVzZSBgbGFzdE92ZXJsYXkubGFzdEZvY3VzYCB0byBiZSB1cGRhdGVkIGJlZm9yZVxuICAgICAgICAgKiB3ZSBjYW4gcnVuIHRoZSBjb2RlIGFmdGVyIHRoYXQuIFdlIHdpbGwgY2FjaGUgdGhlIHZhbHVlXG4gICAgICAgICAqIGhlcmUgdG8gYXZvaWQgdGhhdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGxhc3RGb2N1cyA9IGxhc3RPdmVybGF5Lmxhc3RGb2N1cztcbiAgICAgICAgLy8gRm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIG92ZXJsYXkgd3JhcHBlclxuICAgICAgICBmb2N1c0ZpcnN0RGVzY2VuZGFudChvdmVybGF5V3JhcHBlciwgbGFzdE92ZXJsYXkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGNhY2hlZCBsYXN0IGZvY3VzZWQgZWxlbWVudCBpcyB0aGVcbiAgICAgICAgICogc2FtZSBhcyB0aGUgYWN0aXZlIGVsZW1lbnQsIHRoZW4gd2UgbmVlZFxuICAgICAgICAgKiB0byB3cmFwIGZvY3VzIHRvIHRoZSBsYXN0IGRlc2NlbmRhbnQuIFRoaXMgaGFwcGVuc1xuICAgICAgICAgKiB3aGVuIHRoZSBmaXJzdCBkZXNjZW5kYW50IGlzIGZvY3VzZWQsIGFuZCB0aGUgdXNlclxuICAgICAgICAgKiBwcmVzc2VzIFNoaWZ0ICsgVGFiLiBUaGUgcHJldmlvdXMgbGluZSB3aWxsIGZvY3VzXG4gICAgICAgICAqIHRoZSBzYW1lIGRlc2NlbmRhbnQgYWdhaW4gKHRoZSBmaXJzdCBvbmUpLCBjYXVzaW5nXG4gICAgICAgICAqIGxhc3QgZm9jdXMgdG8gZXF1YWwgdGhlIGFjdGl2ZSBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGxhc3RGb2N1cyA9PT0gZG9jLmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICBmb2N1c0xhc3REZXNjZW5kYW50KG92ZXJsYXlXcmFwcGVyLCBsYXN0T3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE92ZXJsYXkubGFzdEZvY3VzID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFwU2hhZG93Rm9jdXMgPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhcmdldCBpcyBpbnNpZGUgdGhlIHdyYXBwZXIsIGxldCB0aGUgYnJvd3NlclxuICAgICAqIGZvY3VzIGFzIG5vcm1hbCBhbmQga2VlcCBhIGxvZyBvZiB0aGUgbGFzdCBmb2N1c2VkIGVsZW1lbnQuXG4gICAgICovXG4gICAgaWYgKGxhc3RPdmVybGF5LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGxhc3RPdmVybGF5Lmxhc3RGb2N1cyA9IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIE90aGVyd2lzZSwgd2UgYXJlIGFib3V0IHRvIGhhdmUgZm9jdXNcbiAgICAgICAqIGdvIG91dCBvZiB0aGUgb3ZlcmxheS4gV2UgbmVlZCB0byB3cmFwXG4gICAgICAgKiB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgKiBvciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIE9uY2Ugd2UgY2FsbCBgZm9jdXNGaXJzdERlc2NlbmRhbnRgIGFuZCBmb2N1cyB0aGUgZmlyc3RcbiAgICAgICAqIGRlc2NlbmRhbnQsIGFub3RoZXIgZm9jdXMgZXZlbnQgd2lsbCBmaXJlIHdoaWNoIHdpbGxcbiAgICAgICAqIGNhdXNlIGBsYXN0T3ZlcmxheS5sYXN0Rm9jdXNgIHRvIGJlIHVwZGF0ZWQgYmVmb3JlXG4gICAgICAgKiB3ZSBjYW4gcnVuIHRoZSBjb2RlIGFmdGVyIHRoYXQuIFdlIHdpbGwgY2FjaGUgdGhlIHZhbHVlXG4gICAgICAgKiBoZXJlIHRvIGF2b2lkIHRoYXQuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGxhc3RGb2N1cyA9IGxhc3RPdmVybGF5Lmxhc3RGb2N1cztcbiAgICAgIC8vIEZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBvdmVybGF5IHdyYXBwZXJcbiAgICAgIGZvY3VzRmlyc3REZXNjZW5kYW50KGxhc3RPdmVybGF5LCBsYXN0T3ZlcmxheSk7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBjYWNoZWQgbGFzdCBmb2N1c2VkIGVsZW1lbnQgaXMgdGhlXG4gICAgICAgKiBzYW1lIGFzIHRoZSBhY3RpdmUgZWxlbWVudCwgdGhlbiB3ZSBuZWVkXG4gICAgICAgKiB0byB3cmFwIGZvY3VzIHRvIHRoZSBsYXN0IGRlc2NlbmRhbnQuIFRoaXMgaGFwcGVuc1xuICAgICAgICogd2hlbiB0aGUgZmlyc3QgZGVzY2VuZGFudCBpcyBmb2N1c2VkLCBhbmQgdGhlIHVzZXJcbiAgICAgICAqIHByZXNzZXMgU2hpZnQgKyBUYWIuIFRoZSBwcmV2aW91cyBsaW5lIHdpbGwgZm9jdXNcbiAgICAgICAqIHRoZSBzYW1lIGRlc2NlbmRhbnQgYWdhaW4gKHRoZSBmaXJzdCBvbmUpLCBjYXVzaW5nXG4gICAgICAgKiBsYXN0IGZvY3VzIHRvIGVxdWFsIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgaWYgKGxhc3RGb2N1cyA9PT0gZG9jLmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgZm9jdXNMYXN0RGVzY2VuZGFudChsYXN0T3ZlcmxheSwgbGFzdE92ZXJsYXkpO1xuICAgICAgfVxuICAgICAgbGFzdE92ZXJsYXkubGFzdEZvY3VzID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICB9O1xuICBpZiAobGFzdE92ZXJsYXkuc2hhZG93Um9vdCkge1xuICAgIHRyYXBTaGFkb3dGb2N1cygpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRyYXBTY29wZWRGb2N1cygpO1xuICB9XG59O1xuY29uc3QgY29ubmVjdExpc3RlbmVycyA9IChkb2MpID0+IHtcbiAgaWYgKGxhc3RJZCA9PT0gMCkge1xuICAgIGxhc3RJZCA9IDE7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKGV2KSA9PiB7XG4gICAgICB0cmFwS2V5Ym9hcmRGb2N1cyhldiwgZG9jKTtcbiAgICB9LCB0cnVlKTtcbiAgICAvLyBoYW5kbGUgYmFjay1idXR0b24gY2xpY2tcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uQmFja0J1dHRvbicsIGV2ID0+IHtcbiAgICAgIGNvbnN0IGxhc3RPdmVybGF5ID0gZ2V0T3ZlcmxheShkb2MpO1xuICAgICAgaWYgKGxhc3RPdmVybGF5ICYmIGxhc3RPdmVybGF5LmJhY2tkcm9wRGlzbWlzcykge1xuICAgICAgICBldi5kZXRhaWwucmVnaXN0ZXIoT1ZFUkxBWV9CQUNLX0JVVFRPTl9QUklPUklUWSwgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsYXN0T3ZlcmxheS5kaXNtaXNzKHVuZGVmaW5lZCwgQkFDS0RST1ApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBoYW5kbGUgRVNDIHRvIGNsb3NlIG92ZXJsYXlcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBldiA9PiB7XG4gICAgICBpZiAoZXYua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICBjb25zdCBsYXN0T3ZlcmxheSA9IGdldE92ZXJsYXkoZG9jKTtcbiAgICAgICAgaWYgKGxhc3RPdmVybGF5ICYmIGxhc3RPdmVybGF5LmJhY2tkcm9wRGlzbWlzcykge1xuICAgICAgICAgIGxhc3RPdmVybGF5LmRpc21pc3ModW5kZWZpbmVkLCBCQUNLRFJPUCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IGRpc21pc3NPdmVybGF5ID0gKGRvYywgZGF0YSwgcm9sZSwgb3ZlcmxheVRhZywgaWQpID0+IHtcbiAgY29uc3Qgb3ZlcmxheSA9IGdldE92ZXJsYXkoZG9jLCBvdmVybGF5VGFnLCBpZCk7XG4gIGlmICghb3ZlcmxheSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnb3ZlcmxheSBkb2VzIG5vdCBleGlzdCcpO1xuICB9XG4gIHJldHVybiBvdmVybGF5LmRpc21pc3MoZGF0YSwgcm9sZSk7XG59O1xuY29uc3QgZ2V0T3ZlcmxheXMgPSAoZG9jLCBzZWxlY3RvcikgPT4ge1xuICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHNlbGVjdG9yID0gJ2lvbi1hbGVydCxpb24tYWN0aW9uLXNoZWV0LGlvbi1sb2FkaW5nLGlvbi1tb2RhbCxpb24tcGlja2VyLGlvbi1wb3BvdmVyLGlvbi10b2FzdCc7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuICAgIC5maWx0ZXIoYyA9PiBjLm92ZXJsYXlJbmRleCA+IDApO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBvdmVybGF5IGVsZW1lbnRcbiAqIEBwYXJhbSBkb2MgVGhlIGRvY3VtZW50IHRvIGZpbmQgdGhlIGVsZW1lbnQgd2l0aGluLlxuICogQHBhcmFtIG92ZXJsYXlUYWcgVGhlIHNlbGVjdG9yIGZvciB0aGUgb3ZlcmxheSwgZGVmYXVsdHMgdG8gSW9uaWMgb3ZlcmxheSBjb21wb25lbnRzLlxuICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIG92ZXJsYXkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyBUaGUgb3ZlcmxheSBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIG5vIG92ZXJsYXkgZWxlbWVudCBpcyBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0T3ZlcmxheSA9IChkb2MsIG92ZXJsYXlUYWcsIGlkKSA9PiB7XG4gIGNvbnN0IG92ZXJsYXlzID0gZ2V0T3ZlcmxheXMoZG9jLCBvdmVybGF5VGFnKS5maWx0ZXIobyA9PiAhaXNPdmVybGF5SGlkZGVuKG8pKTtcbiAgcmV0dXJuIChpZCA9PT0gdW5kZWZpbmVkKVxuICAgID8gb3ZlcmxheXNbb3ZlcmxheXMubGVuZ3RoIC0gMV1cbiAgICA6IG92ZXJsYXlzLmZpbmQobyA9PiBvLmlkID09PSBpZCk7XG59O1xuLyoqXG4gKiBXaGVuIGFuIG92ZXJsYXkgaXMgcHJlc2VudGVkLCB0aGUgbWFpblxuICogZm9jdXMgaXMgdGhlIG92ZXJsYXkgbm90IHRoZSBwYWdlIGNvbnRlbnQuXG4gKiBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgcGFnZSBjb250ZW50IGZyb20gdGhlXG4gKiBhY2Nlc3NpYmlsaXR5IHRyZWUgb3RoZXJ3aXNlIHdoZW5cbiAqIHVzZXJzIHVzZSBcInJlYWQgc2NyZWVuIGZyb20gdG9wXCIgZ2VzdHVyZXMgd2l0aFxuICogVGFsa0JhY2sgYW5kIFZvaWNlT3ZlciwgdGhlIHNjcmVlbiByZWFkZXIgd2lsbCBiZWdpblxuICogdG8gcmVhZCB0aGUgY29udGVudCB1bmRlcm5lYXRoIHRoZSBvdmVybGF5LlxuICpcbiAqIFdlIG5lZWQgYSBjb250YWluZXIgd2hlcmUgYWxsIHBhZ2UgY29tcG9uZW50c1xuICogZXhpc3QgdGhhdCBpcyBzZXBhcmF0ZSBmcm9tIHdoZXJlIHRoZSBvdmVybGF5c1xuICogYXJlIGFkZGVkIGluIHRoZSBET00uIEZvciBtb3N0IGFwcHMsIHRoaXMgZWxlbWVudFxuICogaXMgdGhlIHRvcCBtb3N0IGlvbi1yb3V0ZXItb3V0bGV0LiBJbiB0aGUgZXZlbnRcbiAqIHRoYXQgZGV2cyBhcmUgbm90IHVzaW5nIGEgcm91dGVyLFxuICogdGhleSB3aWxsIG5lZWQgdG8gYWRkIHRoZSBcImlvbi12aWV3LWNvbnRhaW5lci1yb290XCJcbiAqIGlkIHRvIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZWlyIHZpZXdzLlxuICpcbiAqIFRPRE86IElmIEZyYW1ld29yayBzdXBwb3J0cyBoYXZpbmcgbXVsdGlwbGUgdG9wXG4gKiBsZXZlbCByb3V0ZXIgb3V0bGV0cyB3ZSB3b3VsZCBuZWVkIHRvIHVwZGF0ZSB0aGlzLlxuICogRXhhbXBsZTogT25lIG91dGxldCBmb3Igc2lkZSBtZW51IGFuZCBvbmUgb3V0bGV0XG4gKiBmb3IgbWFpbiBjb250ZW50LlxuICovXG5jb25zdCBzZXRSb290QXJpYUhpZGRlbiA9IChoaWRkZW4gPSBmYWxzZSkgPT4ge1xuICBjb25zdCByb290ID0gZ2V0QXBwUm9vdChkb2N1bWVudCk7XG4gIGNvbnN0IHZpZXdDb250YWluZXIgPSByb290LnF1ZXJ5U2VsZWN0b3IoJ2lvbi1yb3V0ZXItb3V0bGV0LCBpb24tbmF2LCAjaW9uLXZpZXctY29udGFpbmVyLXJvb3QnKTtcbiAgaWYgKCF2aWV3Q29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChoaWRkZW4pIHtcbiAgICB2aWV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZpZXdDb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICB9XG59O1xuY29uc3QgcHJlc2VudCA9IGFzeW5jIChvdmVybGF5LCBuYW1lLCBpb3NFbnRlckFuaW1hdGlvbiwgbWRFbnRlckFuaW1hdGlvbiwgb3B0cykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBpZiAob3ZlcmxheS5wcmVzZW50ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0Um9vdEFyaWFIaWRkZW4odHJ1ZSk7XG4gIG92ZXJsYXkucHJlc2VudGVkID0gdHJ1ZTtcbiAgb3ZlcmxheS53aWxsUHJlc2VudC5lbWl0KCk7XG4gIChfYSA9IG92ZXJsYXkud2lsbFByZXNlbnRTaG9ydGhhbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWl0KCk7XG4gIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKG92ZXJsYXkpO1xuICAvLyBnZXQgdGhlIHVzZXIncyBhbmltYXRpb24gZm4gaWYgb25lIHdhcyBwcm92aWRlZFxuICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gKG92ZXJsYXkuZW50ZXJBbmltYXRpb24pXG4gICAgPyBvdmVybGF5LmVudGVyQW5pbWF0aW9uXG4gICAgOiBjb25maWcuZ2V0KG5hbWUsIG1vZGUgPT09ICdpb3MnID8gaW9zRW50ZXJBbmltYXRpb24gOiBtZEVudGVyQW5pbWF0aW9uKTtcbiAgY29uc3QgY29tcGxldGVkID0gYXdhaXQgb3ZlcmxheUFuaW1hdGlvbihvdmVybGF5LCBhbmltYXRpb25CdWlsZGVyLCBvdmVybGF5LmVsLCBvcHRzKTtcbiAgaWYgKGNvbXBsZXRlZCkge1xuICAgIG92ZXJsYXkuZGlkUHJlc2VudC5lbWl0KCk7XG4gICAgKF9iID0gb3ZlcmxheS5kaWRQcmVzZW50U2hvcnRoYW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW1pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIGFuIG92ZXJsYXkgdGhhdCBzdGVhbHMgZm9jdXNcbiAgICogaXMgZGlzbWlzc2VkLCBmb2N1cyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICogdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZFxuICAgKiBwcmlvciB0byB0aGUgb3ZlcmxheSBvcGVuaW5nLiBUb2FzdFxuICAgKiBkb2VzIG5vdCBzdGVhbCBmb2N1cyBhbmQgaXMgZXhjbHVkZWRcbiAgICogZnJvbSByZXR1cm5pbmcgZm9jdXMgYXMgYSByZXN1bHQuXG4gICAqL1xuICBpZiAob3ZlcmxheS5lbC50YWdOYW1lICE9PSAnSU9OLVRPQVNUJykge1xuICAgIGZvY3VzUHJldmlvdXNFbGVtZW50T25EaXNtaXNzKG92ZXJsYXkuZWwpO1xuICB9XG4gIGlmIChvdmVybGF5LmtleWJvYXJkQ2xvc2UpIHtcbiAgICBvdmVybGF5LmVsLmZvY3VzKCk7XG4gIH1cbn07XG4vKipcbiAqIFdoZW4gYW4gb3ZlcmxheSBjb21wb25lbnQgaXMgZGlzbWlzc2VkLFxuICogZm9jdXMgc2hvdWxkIGJlIHJldHVybmVkIHRvIHRoZSBlbGVtZW50XG4gKiB0aGF0IHByZXNlbnRlZCB0aGUgb3ZlcmxheS4gT3RoZXJ3aXNlXG4gKiBmb2N1cyB3aWxsIGJlIHNldCBvbiB0aGUgYm9keSB3aGljaFxuICogbWVhbnMgdGhhdCBwZW9wbGUgdXNpbmcgc2NyZWVuIHJlYWRlcnNcbiAqIG9yIHRhYmJpbmcgd2lsbCBuZWVkIHRvIHJlLW5hdmlnYXRlXG4gKiB0byB3aGVyZSB0aGV5IHdlcmUgYmVmb3JlIHRoZXlcbiAqIG9wZW5lZCB0aGUgb3ZlcmxheS5cbiAqL1xuY29uc3QgZm9jdXNQcmV2aW91c0VsZW1lbnRPbkRpc21pc3MgPSBhc3luYyAob3ZlcmxheUVsKSA9PiB7XG4gIGxldCBwcmV2aW91c0VsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBpZiAoIXByZXZpb3VzRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaGFkb3dSb290ID0gcHJldmlvdXNFbGVtZW50ICYmIHByZXZpb3VzRWxlbWVudC5zaGFkb3dSb290O1xuICBpZiAoc2hhZG93Um9vdCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBpbm5lciBmb2N1c2FibGUgZWxlbWVudHMsIGp1c3QgZm9jdXMgdGhlIGhvc3QgZWxlbWVudC5cbiAgICBwcmV2aW91c0VsZW1lbnQgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaW5uZXJGb2N1c2FibGVRdWVyeVN0cmluZykgfHwgcHJldmlvdXNFbGVtZW50O1xuICB9XG4gIGF3YWl0IG92ZXJsYXlFbC5vbkRpZERpc21pc3MoKTtcbiAgcHJldmlvdXNFbGVtZW50LmZvY3VzKCk7XG59O1xuY29uc3QgZGlzbWlzcyA9IGFzeW5jIChvdmVybGF5LCBkYXRhLCByb2xlLCBuYW1lLCBpb3NMZWF2ZUFuaW1hdGlvbiwgbWRMZWF2ZUFuaW1hdGlvbiwgb3B0cykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoIW92ZXJsYXkucHJlc2VudGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldFJvb3RBcmlhSGlkZGVuKGZhbHNlKTtcbiAgb3ZlcmxheS5wcmVzZW50ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICAvLyBPdmVybGF5IGNvbnRlbnRzIHNob3VsZCBub3QgYmUgY2xpY2thYmxlIGR1cmluZyBkaXNtaXNzXG4gICAgb3ZlcmxheS5lbC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICAgIG92ZXJsYXkud2lsbERpc21pc3MuZW1pdCh7IGRhdGEsIHJvbGUgfSk7XG4gICAgKF9hID0gb3ZlcmxheS53aWxsRGlzbWlzc1Nob3J0aGFuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtaXQoeyBkYXRhLCByb2xlIH0pO1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKG92ZXJsYXkpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkJ1aWxkZXIgPSAob3ZlcmxheS5sZWF2ZUFuaW1hdGlvbilcbiAgICAgID8gb3ZlcmxheS5sZWF2ZUFuaW1hdGlvblxuICAgICAgOiBjb25maWcuZ2V0KG5hbWUsIG1vZGUgPT09ICdpb3MnID8gaW9zTGVhdmVBbmltYXRpb24gOiBtZExlYXZlQW5pbWF0aW9uKTtcbiAgICAvLyBJZiBkaXNtaXNzZWQgdmlhIGdlc3R1cmUsIG5vIG5lZWQgdG8gcGxheSBsZWF2aW5nIGFuaW1hdGlvbiBhZ2FpblxuICAgIGlmIChyb2xlICE9PSAnZ2VzdHVyZScpIHtcbiAgICAgIGF3YWl0IG92ZXJsYXlBbmltYXRpb24ob3ZlcmxheSwgYW5pbWF0aW9uQnVpbGRlciwgb3ZlcmxheS5lbCwgb3B0cyk7XG4gICAgfVxuICAgIG92ZXJsYXkuZGlkRGlzbWlzcy5lbWl0KHsgZGF0YSwgcm9sZSB9KTtcbiAgICAoX2IgPSBvdmVybGF5LmRpZERpc21pc3NTaG9ydGhhbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbWl0KHsgZGF0YSwgcm9sZSB9KTtcbiAgICBhY3RpdmVBbmltYXRpb25zLmRlbGV0ZShvdmVybGF5KTtcbiAgICAvKipcbiAgICAgKiBNYWtlIG92ZXJsYXkgaGlkZGVuIGFnYWluIGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkLlxuICAgICAqIFdlIGNhbiBzYWZlbHkgcmVtb3ZlIHBvaW50ZXItZXZlbnRzOiBub25lIGFzXG4gICAgICogb3ZlcmxheS1oaWRkZW4gd2lsbCBzZXQgZGlzcGxheTogbm9uZS5cbiAgICAgKi9cbiAgICBvdmVybGF5LmVsLmNsYXNzTGlzdC5hZGQoJ292ZXJsYXktaGlkZGVuJyk7XG4gICAgb3ZlcmxheS5lbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG4gIG92ZXJsYXkuZWwucmVtb3ZlKCk7XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGdldEFwcFJvb3QgPSAoZG9jKSA9PiB7XG4gIHJldHVybiBkb2MucXVlcnlTZWxlY3RvcignaW9uLWFwcCcpIHx8IGRvYy5ib2R5O1xufTtcbmNvbnN0IG92ZXJsYXlBbmltYXRpb24gPSBhc3luYyAob3ZlcmxheSwgYW5pbWF0aW9uQnVpbGRlciwgYmFzZUVsLCBvcHRzKSA9PiB7XG4gIC8vIE1ha2Ugb3ZlcmxheSB2aXNpYmxlIGluIGNhc2UgaXQncyBoaWRkZW5cbiAgYmFzZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJsYXktaGlkZGVuJyk7XG4gIGNvbnN0IGFuaVJvb3QgPSBvdmVybGF5LmVsO1xuICBjb25zdCBhbmltYXRpb24gPSBhbmltYXRpb25CdWlsZGVyKGFuaVJvb3QsIG9wdHMpO1xuICBpZiAoIW92ZXJsYXkuYW5pbWF0ZWQgfHwgIWNvbmZpZy5nZXRCb29sZWFuKCdhbmltYXRlZCcsIHRydWUpKSB7XG4gICAgYW5pbWF0aW9uLmR1cmF0aW9uKDApO1xuICB9XG4gIGlmIChvdmVybGF5LmtleWJvYXJkQ2xvc2UpIHtcbiAgICBhbmltYXRpb24uYmVmb3JlQWRkV3JpdGUoKCkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGJhc2VFbC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50Lm1hdGNoZXMoJ2lucHV0LGlvbi1pbnB1dCwgaW9uLXRleHRhcmVhJykpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYWN0aXZlQW5pID0gYWN0aXZlQW5pbWF0aW9ucy5nZXQob3ZlcmxheSkgfHwgW107XG4gIGFjdGl2ZUFuaW1hdGlvbnMuc2V0KG92ZXJsYXksIFsuLi5hY3RpdmVBbmksIGFuaW1hdGlvbl0pO1xuICBhd2FpdCBhbmltYXRpb24ucGxheSgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBldmVudE1ldGhvZCA9IChlbGVtZW50LCBldmVudE5hbWUpID0+IHtcbiAgbGV0IHJlc29sdmU7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgb25jZUV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgKGV2ZW50KSA9PiB7XG4gICAgcmVzb2x2ZShldmVudC5kZXRhaWwpO1xuICB9KTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuY29uc3Qgb25jZUV2ZW50ID0gKGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgaGFuZGxlciA9IChldikgPT4ge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICBjYWxsYmFjayhldik7XG4gIH07XG4gIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbn07XG5jb25zdCBpc0NhbmNlbCA9IChyb2xlKSA9PiB7XG4gIHJldHVybiByb2xlID09PSAnY2FuY2VsJyB8fCByb2xlID09PSBCQUNLRFJPUDtcbn07XG5jb25zdCBkZWZhdWx0R2F0ZSA9IChoKSA9PiBoKCk7XG4vKipcbiAqIENhbGxzIGEgZGV2ZWxvcGVyIHByb3ZpZGVkIG1ldGhvZCB3aGlsZSBhdm9pZGluZ1xuICogQW5ndWxhciBab25lcy4gU2luY2UgdGhlIGhhbmRsZXIgaXMgcHJvdmlkZWQgYnlcbiAqIHRoZSBkZXZlbG9wZXIsIHdlIHNob3VsZCB0aHJvdyBhbnkgZXJyb3JzXG4gKiByZWNlaXZlZCBzbyB0aGF0IGRldmVsb3Blci1wcm92aWRlZCBidWdcbiAqIHRyYWNraW5nIHNvZnR3YXJlIGNhbiBsb2cgaXQuXG4gKi9cbmNvbnN0IHNhZmVDYWxsID0gKGhhbmRsZXIsIGFyZykgPT4ge1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBqbXAgPSBjb25maWcuZ2V0KCdfem9uZUdhdGUnLCBkZWZhdWx0R2F0ZSk7XG4gICAgcmV0dXJuIGptcCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihhcmcpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IEJBQ0tEUk9QID0gJ2JhY2tkcm9wJztcblxuZXhwb3J0IHsgQkFDS0RST1AgYXMgQiwgYWxlcnRDb250cm9sbGVyIGFzIGEsIGFjdGlvblNoZWV0Q29udHJvbGxlciBhcyBiLCBwb3BvdmVyQ29udHJvbGxlciBhcyBjLCBwcmVzZW50IGFzIGQsIHByZXBhcmVPdmVybGF5IGFzIGUsIGRpc21pc3MgYXMgZiwgZXZlbnRNZXRob2QgYXMgZywgZm9jdXNGaXJzdERlc2NlbmRhbnQgYXMgaCwgaXNDYW5jZWwgYXMgaSwgZ2V0T3ZlcmxheSBhcyBqLCBhY3RpdmVBbmltYXRpb25zIGFzIGssIGxvYWRpbmdDb250cm9sbGVyIGFzIGwsIG1vZGFsQ29udHJvbGxlciBhcyBtLCBwaWNrZXJDb250cm9sbGVyIGFzIHAsIHNhZmVDYWxsIGFzIHMsIHRvYXN0Q29udHJvbGxlciBhcyB0IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuLyoqXG4gKiBCYXNlZCBvbjpcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNDgwMDkveS1jb29yZGluYXRlLWZvci1hLWdpdmVuLXgtY3ViaWMtYmV6aWVyXG4gKiBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzI2ODQ2L2lzLXRoZXJlLWFuLWV4cGxpY2l0LWZvcm0tZm9yLWN1YmljLWIlQzMlQTl6aWVyLWN1cnZlc1xuICogVE9ETzogUmVkdWNlIHJvdW5kaW5nIGVycm9yXG4gKi9cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKiBHaXZlbiBhIGN1YmljLWJlemllciBjdXJ2ZSwgZ2V0IHRoZSB4IHZhbHVlICh0aW1lKSBnaXZlblxuICogdGhlIHkgdmFsdWUgKHByb2dyZXNzaW9uKS5cbiAqIEV4OiBjdWJpYy1iZXppZXIoMC4zMiwgMC43MiwgMCwgMSk7XG4gKiBQMDogKDAsIDApXG4gKiBQMTogKDAuMzIsIDAuNzIpXG4gKiBQMjogKDAsIDEpXG4gKiBQMzogKDEsIDEpXG4gKlxuICogSWYgeW91IGdpdmUgYSBjdWJpYyBiZXppZXIgY3VydmUgdGhhdCBuZXZlciByZWFjaGVzIHRoZVxuICogcHJvdmlkZWQgcHJvZ3Jlc3Npb24sIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gKi9cbmNvbnN0IGdldFRpbWVHaXZlblByb2dyZXNzaW9uID0gKHAwLCBwMSwgcDIsIHAzLCBwcm9ncmVzc2lvbikgPT4ge1xuICByZXR1cm4gc29sdmVDdWJpY0JlemllcihwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgcHJvZ3Jlc3Npb24pLm1hcCh0VmFsdWUgPT4ge1xuICAgIHJldHVybiBzb2x2ZUN1YmljUGFyYW1ldHJpY0VxdWF0aW9uKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB0VmFsdWUpO1xuICB9KTtcbn07XG4vKipcbiAqIFNvbHZlIGEgY3ViaWMgZXF1YXRpb24gaW4gb25lIGRpbWVuc2lvbiAodGltZSlcbiAqL1xuY29uc3Qgc29sdmVDdWJpY1BhcmFtZXRyaWNFcXVhdGlvbiA9IChwMCwgcDEsIHAyLCBwMywgdCkgPT4ge1xuICBjb25zdCBwYXJ0QSA9ICgzICogcDEpICogTWF0aC5wb3codCAtIDEsIDIpO1xuICBjb25zdCBwYXJ0QiA9ICgtMyAqIHAyICogdCkgKyAoMyAqIHAyKSArIChwMyAqIHQpO1xuICBjb25zdCBwYXJ0QyA9IHAwICogTWF0aC5wb3codCAtIDEsIDMpO1xuICByZXR1cm4gdCAqIChwYXJ0QSArICh0ICogcGFydEIpKSAtIHBhcnRDO1xufTtcbi8qKlxuICogRmluZCB0aGUgYHRgIHZhbHVlIGZvciBhIGN1YmljIGJlemllciB1c2luZyBDYXJkYW5vJ3MgZm9ybXVsYVxuICovXG5jb25zdCBzb2x2ZUN1YmljQmV6aWVyID0gKHAwLCBwMSwgcDIsIHAzLCByZWZQb2ludCkgPT4ge1xuICBwMCAtPSByZWZQb2ludDtcbiAgcDEgLT0gcmVmUG9pbnQ7XG4gIHAyIC09IHJlZlBvaW50O1xuICBwMyAtPSByZWZQb2ludDtcbiAgY29uc3Qgcm9vdHMgPSBzb2x2ZUN1YmljRXF1YXRpb24ocDMgLSAzICogcDIgKyAzICogcDEgLSBwMCwgMyAqIHAyIC0gNiAqIHAxICsgMyAqIHAwLCAzICogcDEgLSAzICogcDAsIHAwKTtcbiAgcmV0dXJuIHJvb3RzLmZpbHRlcihyb290ID0+IHJvb3QgPj0gMCAmJiByb290IDw9IDEpO1xufTtcbmNvbnN0IHNvbHZlUXVhZHJhdGljRXF1YXRpb24gPSAoYSwgYiwgYykgPT4ge1xuICBjb25zdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSksXG4gICAgICAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpXG4gICAgXTtcbiAgfVxufTtcbmNvbnN0IHNvbHZlQ3ViaWNFcXVhdGlvbiA9IChhLCBiLCBjLCBkKSA9PiB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIHNvbHZlUXVhZHJhdGljRXF1YXRpb24oYiwgYywgZCk7XG4gIH1cbiAgYiAvPSBhO1xuICBjIC89IGE7XG4gIGQgLz0gYTtcbiAgY29uc3QgcCA9ICgzICogYyAtIGIgKiBiKSAvIDM7XG4gIGNvbnN0IHEgPSAoMiAqIGIgKiBiICogYiAtIDkgKiBiICogYyArIDI3ICogZCkgLyAyNztcbiAgaWYgKHAgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGgucG93KC1xLCAxIC8gMyldO1xuICB9XG4gIGVsc2UgaWYgKHEgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGguc3FydCgtcCksIC1NYXRoLnNxcnQoLXApXTtcbiAgfVxuICBjb25zdCBkaXNjcmltaW5hbnQgPSBNYXRoLnBvdyhxIC8gMiwgMikgKyBNYXRoLnBvdyhwIC8gMywgMyk7XG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByZXR1cm4gW01hdGgucG93KHEgLyAyLCAxIC8gMikgLSBiIC8gM107XG4gIH1cbiAgZWxzZSBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgIHJldHVybiBbTWF0aC5wb3coLShxIC8gMikgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSwgMSAvIDMpIC0gTWF0aC5wb3coKHEgLyAyKSArIE1hdGguc3FydChkaXNjcmltaW5hbnQpLCAxIC8gMykgLSBiIC8gM107XG4gIH1cbiAgY29uc3QgciA9IE1hdGguc3FydChNYXRoLnBvdygtKHAgLyAzKSwgMykpO1xuICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoLShxIC8gKDIgKiBNYXRoLnNxcnQoTWF0aC5wb3coLShwIC8gMyksIDMpKSkpKTtcbiAgY29uc3QgcyA9IDIgKiBNYXRoLnBvdyhyLCAxIC8gMyk7XG4gIHJldHVybiBbXG4gICAgcyAqIE1hdGguY29zKHBoaSAvIDMpIC0gYiAvIDMsXG4gICAgcyAqIE1hdGguY29zKChwaGkgKyAyICogTWF0aC5QSSkgLyAzKSAtIGIgLyAzLFxuICAgIHMgKiBNYXRoLmNvcygocGhpICsgNCAqIE1hdGguUEkpIC8gMykgLSBiIC8gM1xuICBdO1xufTtcblxuZXhwb3J0IHsgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gYXMgZyB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGMgYXMgY29tcG9uZW50T25SZWFkeSB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmNvbnN0IGF0dGFjaENvbXBvbmVudCA9IGFzeW5jIChkZWxlZ2F0ZSwgY29udGFpbmVyLCBjb21wb25lbnQsIGNzc0NsYXNzZXMsIGNvbXBvbmVudFByb3BzLCBpbmxpbmUpID0+IHtcbiAgaWYgKGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGRlbGVnYXRlLmF0dGFjaFZpZXdUb0RvbShjb250YWluZXIsIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMsIGNzc0NsYXNzZXMpO1xuICB9XG4gIGlmICghaW5saW5lICYmIHR5cGVvZiBjb21wb25lbnQgIT09ICdzdHJpbmcnICYmICEoY29tcG9uZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcmFtZXdvcmsgZGVsZWdhdGUgaXMgbWlzc2luZycpO1xuICB9XG4gIGNvbnN0IGVsID0gKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgJiYgY29udGFpbmVyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpXG4gICAgOiBjb21wb25lbnQ7XG4gIGlmIChjc3NDbGFzc2VzKSB7XG4gICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIH1cbiAgaWYgKGNvbXBvbmVudFByb3BzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbCwgY29tcG9uZW50UHJvcHMpO1xuICB9XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShlbCwgcmVzb2x2ZSkpO1xuICByZXR1cm4gZWw7XG59O1xuY29uc3QgZGV0YWNoQ29tcG9uZW50ID0gKGRlbGVnYXRlLCBlbGVtZW50KSA9PiB7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gZGVsZWdhdGUucmVtb3ZlVmlld0Zyb21Eb20oY29udGFpbmVyLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuY29uc3QgQ29yZURlbGVnYXRlID0gKCkgPT4ge1xuICBsZXQgQmFzZUNvbXBvbmVudDtcbiAgbGV0IFJlZmVyZW5jZTtcbiAgY29uc3QgYXR0YWNoVmlld1RvRG9tID0gYXN5bmMgKHBhcmVudEVsZW1lbnQsIHVzZXJDb21wb25lbnQsIHVzZXJDb21wb25lbnRQcm9wcyA9IHt9LCBjc3NDbGFzc2VzID0gW10pID0+IHtcbiAgICBCYXNlQ29tcG9uZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBJZiBwYXNzaW5nIGluIGEgY29tcG9uZW50IHZpYSB0aGUgYGNvbXBvbmVudGAgcHJvcHNcbiAgICAgKiB3ZSBuZWVkIHRvIGFwcGVuZCBpdCBpbnNpZGUgb2Ygb3VyIG92ZXJsYXkgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGlmICh1c2VyQ29tcG9uZW50KSB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHBhc3NpbmcgaW4gdGhlIHRhZyBuYW1lLCBjcmVhdGVcbiAgICAgICAqIHRoZSBlbGVtZW50IG90aGVyd2lzZSBqdXN0IGdldCBhIHJlZmVyZW5jZVxuICAgICAgICogdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZWwgPSAodHlwZW9mIHVzZXJDb21wb25lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICA/IEJhc2VDb21wb25lbnQub3duZXJEb2N1bWVudCAmJiBCYXNlQ29tcG9uZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh1c2VyQ29tcG9uZW50KVxuICAgICAgICA6IHVzZXJDb21wb25lbnQ7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbnkgY3NzIGNsYXNzZXMgcGFzc2VkIGluXG4gICAgICAgKiB2aWEgdGhlIGNzc0NsYXNzZXMgcHJvcCBvbiB0aGUgb3ZlcmxheS5cbiAgICAgICAqL1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbnkgcHJvcHMgcGFzc2VkIGluXG4gICAgICAgKiB2aWEgdGhlIGNvbXBvbmVudFByb3BzIHByb3Agb24gdGhlIG92ZXJsYXkuXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5hc3NpZ24oZWwsIHVzZXJDb21wb25lbnRQcm9wcyk7XG4gICAgICAvKipcbiAgICAgICAqIEZpbmFsbHksIGFwcGVuZCB0aGUgY29tcG9uZW50XG4gICAgICAgKiBpbnNpZGUgb2YgdGhlIG92ZXJsYXkgY29tcG9uZW50LlxuICAgICAgICovXG4gICAgICBCYXNlQ29tcG9uZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gY29tcG9uZW50T25SZWFkeShlbCwgcmVzb2x2ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCYXNlQ29tcG9uZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvbXBvbmVudCwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBwYXJlbnRcbiAgICAgIC8vIGVsZW1lbnQgdG8gYXBwbHkgdGhlIGNzcyBjbGFzc2VzIHRvLlxuICAgICAgY29uc3QgZWwgPSBCYXNlQ29tcG9uZW50Lm93bmVyRG9jdW1lbnQgJiYgQmFzZUNvbXBvbmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgICAvLyBNb3ZlIGVhY2ggY2hpbGQgZnJvbSB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdG8gdGhlIG5ldyBwYXJlbnQgZWxlbWVudC5cbiAgICAgIGVsLmFwcGVuZCguLi5CYXNlQ29tcG9uZW50LmNoaWxkcmVuKTtcbiAgICAgIC8vIEFwcGVuZCB0aGUgbmV3IHBhcmVudCBlbGVtZW50IHRvIHRoZSBvcmlnaW5hbCBwYXJlbnQgZWxlbWVudC5cbiAgICAgIEJhc2VDb21wb25lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvb3Qgb2YgdGhlIGFwcCBhbmRcbiAgICAgKiBhZGQgdGhlIG92ZXJsYXkgdGhlcmUuXG4gICAgICovXG4gICAgY29uc3QgYXBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLWFwcCcpIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGxhY2Vob2xkZXIgY29tbWVudCBzbyB0aGF0XG4gICAgICogd2UgY2FuIHJldHVybiB0aGlzIGNvbXBvbmVudCB0byB3aGVyZVxuICAgICAqIGl0IHdhcyBwcmV2aW91c2x5LlxuICAgICAqL1xuICAgIFJlZmVyZW5jZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ2lvbmljIHRlbGVwb3J0Jyk7XG4gICAgQmFzZUNvbXBvbmVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShSZWZlcmVuY2UsIEJhc2VDb21wb25lbnQpO1xuICAgIGFwcC5hcHBlbmRDaGlsZChCYXNlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFzZUNvbXBvbmVudDtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlVmlld0Zyb21Eb20gPSAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGNvbXBvbmVudCB0byB3aGVyZSBpdCB3YXMgcHJldmlvdXNseSBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIGlmIChCYXNlQ29tcG9uZW50ICYmIFJlZmVyZW5jZSkge1xuICAgICAgUmVmZXJlbmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKEJhc2VDb21wb25lbnQsIFJlZmVyZW5jZSk7XG4gICAgICBSZWZlcmVuY2UucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcmV0dXJuIHsgYXR0YWNoVmlld1RvRG9tLCByZW1vdmVWaWV3RnJvbURvbSB9O1xufTtcblxuZXhwb3J0IHsgQ29yZURlbGVnYXRlIGFzIEMsIGF0dGFjaENvbXBvbmVudCBhcyBhLCBkZXRhY2hDb21wb25lbnQgYXMgZCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuaW1wb3J0IHsgYiBhcyBnZXRJb25Nb2RlLCBjIGFzIGNvbmZpZyB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24gfSBmcm9tICcuL2N1YmljLWJlemllci5qcyc7XG5pbXBvcnQgeyBhIGFzIGF0dGFjaENvbXBvbmVudCwgZCBhcyBkZXRhY2hDb21wb25lbnQgfSBmcm9tICcuL2ZyYW1ld29yay1kZWxlZ2F0ZS5qcyc7XG5pbXBvcnQgeyBzIGFzIHNoYWxsb3dFcXVhbFN0cmluZ01hcCB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyB0IGFzIHRyYW5zaXRpb24gfSBmcm9tICcuL2luZGV4NC5qcyc7XG5cbmNvbnN0IHJvdXRlT3V0bGV0Q3NzID0gXCI6aG9zdHtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTtjb250YWluOmxheW91dCBzaXplIHN0eWxlO292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjB9XCI7XG5cbmNvbnN0IFJvdXRlck91dGxldCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pb25OYXZXaWxsTG9hZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uTmF2V2lsbExvYWRcIiwgNyk7XG4gICAgdGhpcy5pb25OYXZXaWxsQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25OYXZXaWxsQ2hhbmdlXCIsIDMpO1xuICAgIHRoaXMuaW9uTmF2RGlkQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25OYXZEaWRDaGFuZ2VcIiwgMyk7XG4gICAgdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGUgZGV0ZXJtaW5lcyB3aGljaCBwbGF0Zm9ybSBzdHlsZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgcm91dGVyLW91dGxldCBzaG91bGQgYW5pbWF0ZSB0aGUgdHJhbnNpdGlvbiBvZiBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICB9XG4gIHN3aXBlSGFuZGxlckNoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuZ2VzdHVyZSkge1xuICAgICAgdGhpcy5nZXN0dXJlLmVuYWJsZSh0aGlzLnN3aXBlSGFuZGxlciAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3Qgb25TdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zd2lwZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5zd2lwZUhhbmRsZXIub25TdGFydCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXN0dXJlID0gKGF3YWl0IGltcG9ydCgnLi9zd2lwZS1iYWNrLmpzJykpLmNyZWF0ZVN3aXBlQmFja0dlc3R1cmUodGhpcy5lbCwgKCkgPT4gIXRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyAmJiAhIXRoaXMuc3dpcGVIYW5kbGVyICYmIHRoaXMuc3dpcGVIYW5kbGVyLmNhblN0YXJ0KCksICgpID0+IG9uU3RhcnQoKSwgc3RlcCA9PiB0aGlzLmFuaSAmJiB0aGlzLmFuaS5wcm9ncmVzc1N0ZXAoc3RlcCksIChzaG91bGRDb21wbGV0ZSwgc3RlcCwgZHVyKSA9PiB7XG4gICAgICBpZiAodGhpcy5hbmkpIHtcbiAgICAgICAgdGhpcy5hbmkub25GaW5pc2goKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0aGlzLnN3aXBlSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zd2lwZUhhbmRsZXIub25FbmQoc2hvdWxkQ29tcGxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBvbmVUaW1lQ2FsbGJhY2s6IHRydWUgfSk7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHJvdW5kaW5nIGVycm9ycyBpbiBKU1xuICAgICAgICBsZXQgbmV3U3RlcFZhbHVlID0gKHNob3VsZENvbXBsZXRlKSA/IC0wLjAwMSA6IDAuMDAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW5pbWF0aW9uIHdpbGwgYmUgcmV2ZXJzZWQgaGVyZSwgc28gbmVlZCB0b1xuICAgICAgICAgKiByZXZlcnNlIHRoZSBlYXNpbmcgY3VydmUgYXMgd2VsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBBZGRpdGlvbmFsbHksIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHRpbWUgcmVsYXRpdmVcbiAgICAgICAgICogdG8gdGhlIG5ldyBlYXNpbmcgY3VydmUsIGFzIGBzdGVwVmFsdWVgIGlzIGdvaW5nIHRvIGJlIGdpdmVuXG4gICAgICAgICAqIGluIHRlcm1zIG9mIGEgbGluZWFyIGN1cnZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgIHRoaXMuYW5pLmVhc2luZygnY3ViaWMtYmV6aWVyKDEsIDAsIDAuNjgsIDAuMjgpJyk7XG4gICAgICAgICAgbmV3U3RlcFZhbHVlICs9IGdldFRpbWVHaXZlblByb2dyZXNzaW9uKFswLCAwXSwgWzEsIDBdLCBbMC42OCwgMC4yOF0sIFsxLCAxXSwgc3RlcClbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3U3RlcFZhbHVlICs9IGdldFRpbWVHaXZlblByb2dyZXNzaW9uKFswLCAwXSwgWzAuMzIsIDAuNzJdLCBbMCwgMV0sIFsxLCAxXSwgc3RlcClbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmkucHJvZ3Jlc3NFbmQoc2hvdWxkQ29tcGxldGUgPyAxIDogMCwgbmV3U3RlcFZhbHVlLCBkdXIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZ2VzdHVyZU9yQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3dpcGVIYW5kbGVyQ2hhbmdlZCgpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMuaW9uTmF2V2lsbExvYWQuZW1pdCgpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmdlc3R1cmUpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmdlc3R1cmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgY29tbWl0KGVudGVyaW5nRWwsIGxlYXZpbmdFbCwgb3B0cykge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubG9jaygpO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNoYW5nZWQgPSBhd2FpdCB0aGlzLnRyYW5zaXRpb24oZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHVubG9jaygpO1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgc2V0Um91dGVJZChpZCwgcGFyYW1zLCBkaXJlY3Rpb24sIGFuaW1hdGlvbikge1xuICAgIGNvbnN0IGNoYW5nZWQgPSBhd2FpdCB0aGlzLnNldFJvb3QoaWQsIHBhcmFtcywge1xuICAgICAgZHVyYXRpb246IGRpcmVjdGlvbiA9PT0gJ3Jvb3QnID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uID09PSAnYmFjaycgPyAnYmFjaycgOiAnZm9yd2FyZCcsXG4gICAgICBhbmltYXRpb25CdWlsZGVyOiBhbmltYXRpb25cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZCxcbiAgICAgIGVsZW1lbnQ6IHRoaXMuYWN0aXZlRWxcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgZ2V0Um91dGVJZCgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmFjdGl2ZUVsO1xuICAgIHJldHVybiBhY3RpdmUgPyB7XG4gICAgICBpZDogYWN0aXZlLnRhZ05hbWUsXG4gICAgICBlbGVtZW50OiBhY3RpdmUsXG4gICAgICBwYXJhbXM6IHRoaXMuYWN0aXZlUGFyYW1zLFxuICAgIH0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgc2V0Um9vdChjb21wb25lbnQsIHBhcmFtcywgb3B0cykge1xuICAgIGlmICh0aGlzLmFjdGl2ZUNvbXBvbmVudCA9PT0gY29tcG9uZW50ICYmIHNoYWxsb3dFcXVhbFN0cmluZ01hcChwYXJhbXMsIHRoaXMuYWN0aXZlUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhdHRhY2ggZW50ZXJpbmcgdmlldyB0byBET01cbiAgICBjb25zdCBsZWF2aW5nRWwgPSB0aGlzLmFjdGl2ZUVsO1xuICAgIGNvbnN0IGVudGVyaW5nRWwgPSBhd2FpdCBhdHRhY2hDb21wb25lbnQodGhpcy5kZWxlZ2F0ZSwgdGhpcy5lbCwgY29tcG9uZW50LCBbJ2lvbi1wYWdlJywgJ2lvbi1wYWdlLWludmlzaWJsZSddLCBwYXJhbXMpO1xuICAgIHRoaXMuYWN0aXZlQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMuYWN0aXZlRWwgPSBlbnRlcmluZ0VsO1xuICAgIHRoaXMuYWN0aXZlUGFyYW1zID0gcGFyYW1zO1xuICAgIC8vIGNvbW1pdCBhbmltYXRpb25cbiAgICBhd2FpdCB0aGlzLmNvbW1pdChlbnRlcmluZ0VsLCBsZWF2aW5nRWwsIG9wdHMpO1xuICAgIGF3YWl0IGRldGFjaENvbXBvbmVudCh0aGlzLmRlbGVnYXRlLCBsZWF2aW5nRWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIHRyYW5zaXRpb24oZW50ZXJpbmdFbCwgbGVhdmluZ0VsLCBvcHRzID0ge30pIHtcbiAgICBpZiAobGVhdmluZ0VsID09PSBlbnRlcmluZ0VsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVtaXQgbmF2IHdpbGwgY2hhbmdlIGV2ZW50XG4gICAgdGhpcy5pb25OYXZXaWxsQ2hhbmdlLmVtaXQoKTtcbiAgICBjb25zdCB7IGVsLCBtb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFuaW1hdGVkID0gdGhpcy5hbmltYXRlZCAmJiBjb25maWcuZ2V0Qm9vbGVhbignYW5pbWF0ZWQnLCB0cnVlKTtcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gb3B0cy5hbmltYXRpb25CdWlsZGVyIHx8IHRoaXMuYW5pbWF0aW9uIHx8IGNvbmZpZy5nZXQoJ25hdkFuaW1hdGlvbicpO1xuICAgIGF3YWl0IHRyYW5zaXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbW9kZSxcbiAgICAgIGFuaW1hdGVkLFxuICAgICAgZW50ZXJpbmdFbCxcbiAgICAgIGxlYXZpbmdFbCwgYmFzZUVsOiBlbCwgcHJvZ3Jlc3NDYWxsYmFjazogKG9wdHMucHJvZ3Jlc3NBbmltYXRpb25cbiAgICAgICAgPyBhbmkgPT4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJlY2F1c2UgdGhpcyBwcm9ncmVzcyBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgKiBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGdlc3R1cmUgdG8gc3RhcnQgYW5kIGVuZCBiZWZvcmVcbiAgICAgICAgICAgKiB0aGUgYW5pbWF0aW9uIGlzIGV2ZXIgc2V0LiBJbiB0aGF0IHNjZW5hcmlvLCB3ZSBzaG91bGRcbiAgICAgICAgICAgKiBpbW1lZGlhdGVseSBjYWxsIHByb2dyZXNzRW5kIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gcHJvbWlzZVxuICAgICAgICAgICAqIHJlc29sdmVzIGFuZCB0aGUgZ2VzdHVyZSBkb2VzIG5vdCBnZXQgbG9ja2VkIHVwLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChhbmkgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVPckFuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgYW5pLm9uRmluaXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5nZXN0dXJlT3JBbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN3aXBlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpcGVIYW5kbGVyLm9uRW5kKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyBvbmVUaW1lQ2FsbGJhY2s6IHRydWUgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBsYXlpbmcgYW5pbWF0aW9uIHRvIGJlZ2lubmluZ1xuICAgICAgICAgICAgICogd2l0aCBhIGR1cmF0aW9uIG9mIDAgcHJldmVudHNcbiAgICAgICAgICAgICAqIGFueSBmbGlja2VyaW5nIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICogaXMgbGF0ZXIgY2xlYW5lZCB1cC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW5pLnByb2dyZXNzRW5kKDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5pID0gYW5pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCkgfSwgb3B0cyksIHsgYW5pbWF0aW9uQnVpbGRlciB9KSk7XG4gICAgLy8gZW1pdCBuYXYgY2hhbmdlZCBldmVudFxuICAgIHRoaXMuaW9uTmF2RGlkQ2hhbmdlLmVtaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyBsb2NrKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLndhaXRQcm9taXNlO1xuICAgIGxldCByZXNvbHZlO1xuICAgIHRoaXMud2FpdFByb21pc2UgPSBuZXcgUHJvbWlzZShyID0+IHJlc29sdmUgPSByKTtcbiAgICBpZiAocCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhd2FpdCBwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChoKFwic2xvdFwiLCBudWxsKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwic3dpcGVIYW5kbGVyXCI6IFtcInN3aXBlSGFuZGxlckNoYW5nZWRcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gcm91dGVPdXRsZXRDc3M7IH1cbn0sIFsxLCBcImlvbi1yb3V0ZXItb3V0bGV0XCIsIHtcbiAgICBcIm1vZGVcIjogWzEwMjVdLFxuICAgIFwiZGVsZWdhdGVcIjogWzE2XSxcbiAgICBcImFuaW1hdGVkXCI6IFs0XSxcbiAgICBcImFuaW1hdGlvblwiOiBbMTZdLFxuICAgIFwic3dpcGVIYW5kbGVyXCI6IFsxNl0sXG4gICAgXCJjb21taXRcIjogWzY0XSxcbiAgICBcInNldFJvdXRlSWRcIjogWzY0XSxcbiAgICBcImdldFJvdXRlSWRcIjogWzY0XVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImlvbi1yb3V0ZXItb3V0bGV0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tcm91dGVyLW91dGxldFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFJvdXRlck91dGxldCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cblxuY29uc3QgSW9uUm91dGVyT3V0bGV0ID0gUm91dGVyT3V0bGV0O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQkMTtcblxuZXhwb3J0IHsgSW9uUm91dGVyT3V0bGV0LCBkZWZpbmVDdXN0b21FbGVtZW50IH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgaG9zdENvbnRleHQgPSAoc2VsZWN0b3IsIGVsKSA9PiB7XG4gIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKSAhPT0gbnVsbDtcbn07XG4vKipcbiAqIENyZWF0ZSB0aGUgbW9kZSBhbmQgY29sb3IgY2xhc3NlcyBmb3IgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgY2xhc3NlcyBwYXNzZWQgaW5cbiAqL1xuY29uc3QgY3JlYXRlQ29sb3JDbGFzc2VzID0gKGNvbG9yLCBjc3NDbGFzc01hcCkgPT4ge1xuICByZXR1cm4gKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgY29sb3IubGVuZ3RoID4gMCkgPyBPYmplY3QuYXNzaWduKHsgJ2lvbi1jb2xvcic6IHRydWUsIFtgaW9uLWNvbG9yLSR7Y29sb3J9YF06IHRydWUgfSwgY3NzQ2xhc3NNYXApIDogY3NzQ2xhc3NNYXA7XG59O1xuY29uc3QgZ2V0Q2xhc3NMaXN0ID0gKGNsYXNzZXMpID0+IHtcbiAgaWYgKGNsYXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIGFycmF5XG4gICAgICAuZmlsdGVyKGMgPT4gYyAhPSBudWxsKVxuICAgICAgLm1hcChjID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcihjID0+IGMgIT09ICcnKTtcbiAgfVxuICByZXR1cm4gW107XG59O1xuY29uc3QgZ2V0Q2xhc3NNYXAgPSAoY2xhc3NlcykgPT4ge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZ2V0Q2xhc3NMaXN0KGNsYXNzZXMpLmZvckVhY2goYyA9PiBtYXBbY10gPSB0cnVlKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBwcm94eUN1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50LCBjcmVhdGVFdmVudCwgaCwgSG9zdCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50JztcbmltcG9ydCB7IGIgYXMgZ2V0SW9uTW9kZSB9IGZyb20gJy4vaW9uaWMtZ2xvYmFsLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29sb3JDbGFzc2VzIH0gZnJvbSAnLi90aGVtZS5qcyc7XG5cbmNvbnN0IHRhYkJhcklvc0NzcyA9IFwiOmhvc3R7cGFkZGluZy1sZWZ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7cGFkZGluZy1yaWdodDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KTtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6YXV0bztwYWRkaW5nLWJvdHRvbTp2YXIoLS1pb24tc2FmZS1hcmVhLWJvdHRvbSwgMCk7Ym9yZGVyLXRvcDp2YXIoLS1ib3JkZXIpO2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZCk7Y29sb3I6dmFyKC0tY29sb3IpO3RleHQtYWxpZ246Y2VudGVyO2NvbnRhaW46c3RyaWN0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt6LWluZGV4OjEwOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveCAhaW1wb3J0YW50O2JveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0e3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpO3BhZGRpbmctaW5saW5lLXN0YXJ0OnZhcigtLWlvbi1zYWZlLWFyZWEtbGVmdCk7LXdlYmtpdC1wYWRkaW5nLWVuZDp2YXIoLS1pb24tc2FmZS1hcmVhLXJpZ2h0KTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCl9fTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dmFyKC0taW9uLWNvbG9yLXNoYWRlKTstLWNvbG9yLXNlbGVjdGVkOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKC50YWItc2VsZWN0ZWQpe2NvbG9yOnZhcigtLWlvbi1jb2xvci1jb250cmFzdCl9Omhvc3QoLmlvbi1jb2xvciksOmhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uKXtjb2xvcjpyZ2JhKHZhcigtLWlvbi1jb2xvci1jb250cmFzdC1yZ2IpLCAwLjcpfTpob3N0KC5pb24tY29sb3IpLDpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7YmFja2dyb3VuZDp2YXIoLS1pb24tY29sb3ItYmFzZSl9Omhvc3QoLmlvbi1jb2xvcikgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uLmlvbi1mb2N1c2VkKSw6aG9zdCgudGFiLWJhci10cmFuc2x1Y2VudCkgOjpzbG90dGVkKGlvbi10YWItYnV0dG9uLmlvbi1mb2N1c2VkKXtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQtZm9jdXNlZCl9Omhvc3QoLnRhYi1iYXItdHJhbnNsdWNlbnQpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7YmFja2dyb3VuZDp0cmFuc3BhcmVudH06aG9zdChbc2xvdD10b3BdKXtwYWRkaW5nLXRvcDp2YXIoLS1pb24tc2FmZS1hcmVhLXRvcCwgMCk7cGFkZGluZy1ib3R0b206MDtib3JkZXItdG9wOjA7Ym9yZGVyLWJvdHRvbTp2YXIoLS1ib3JkZXIpfTpob3N0KC50YWItYmFyLWhpZGRlbil7ZGlzcGxheTpub25lICFpbXBvcnRhbnR9Omhvc3R7LS1iYWNrZ3JvdW5kOnZhcigtLWlvbi10YWItYmFyLWJhY2tncm91bmQsIHZhcigtLWlvbi1jb2xvci1zdGVwLTUwLCAjZjdmN2Y3KSk7LS1iYWNrZ3JvdW5kLWZvY3VzZWQ6dmFyKC0taW9uLXRhYi1iYXItYmFja2dyb3VuZC1mb2N1c2VkLCAjZTBlMGUwKTstLWJvcmRlcjowLjU1cHggc29saWQgdmFyKC0taW9uLXRhYi1iYXItYm9yZGVyLWNvbG9yLCB2YXIoLS1pb24tYm9yZGVyLWNvbG9yLCB2YXIoLS1pb24tY29sb3Itc3RlcC0xNTAsIHJnYmEoMCwgMCwgMCwgMC4yKSkpKTstLWNvbG9yOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLCB2YXIoLS1pb24tY29sb3Itc3RlcC00MDAsICM5OTk5OTkpKTstLWNvbG9yLXNlbGVjdGVkOnZhcigtLWlvbi10YWItYmFyLWNvbG9yLXNlbGVjdGVkLCB2YXIoLS1pb24tY29sb3ItcHJpbWFyeSwgIzM4ODBmZikpO2hlaWdodDo1MHB4fUBzdXBwb3J0cyAoKC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDApKSBvciAoYmFja2Ryb3AtZmlsdGVyOiBibHVyKDApKSl7Omhvc3QoLnRhYi1iYXItdHJhbnNsdWNlbnQpey0tYmFja2dyb3VuZDpyZ2JhKHZhcigtLWlvbi1iYWNrZ3JvdW5kLWNvbG9yLXJnYiwgMjU1LCAyNTUsIDI1NSksIDAuOCk7LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6c2F0dXJhdGUoMjEwJSkgYmx1cigyMHB4KTtiYWNrZHJvcC1maWx0ZXI6c2F0dXJhdGUoMjEwJSkgYmx1cigyMHB4KX06aG9zdCguaW9uLWNvbG9yLnRhYi1iYXItdHJhbnNsdWNlbnQpe2JhY2tncm91bmQ6cmdiYSh2YXIoLS1pb24tY29sb3ItYmFzZS1yZ2IpLCAwLjgpfTpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24uaW9uLWZvY3VzZWQpe2JhY2tncm91bmQ6cmdiYSh2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvci1yZ2IsIDI1NSwgMjU1LCAyNTUpLCAwLjYpfX1cIjtcblxuY29uc3QgdGFiQmFyTWRDc3MgPSBcIjpob3N0e3BhZGRpbmctbGVmdDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpO3BhZGRpbmctcmlnaHQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOmF1dG87cGFkZGluZy1ib3R0b206dmFyKC0taW9uLXNhZmUtYXJlYS1ib3R0b20sIDApO2JvcmRlci10b3A6dmFyKC0tYm9yZGVyKTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNvbG9yKTt0ZXh0LWFsaWduOmNlbnRlcjtjb250YWluOnN0cmljdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7ei1pbmRleDoxMDstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudDtib3gtc2l6aW5nOmNvbnRlbnQtYm94ICFpbXBvcnRhbnR9QHN1cHBvcnRzICgoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApIG9yIChtYXJnaW4taW5saW5lLXN0YXJ0OiAwKSkgb3IgKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKXs6aG9zdHtwYWRkaW5nLWxlZnQ6dW5zZXQ7cGFkZGluZy1yaWdodDp1bnNldDstd2Via2l0LXBhZGRpbmctc3RhcnQ6dmFyKC0taW9uLXNhZmUtYXJlYS1sZWZ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1pb24tc2FmZS1hcmVhLWxlZnQpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0taW9uLXNhZmUtYXJlYS1yaWdodCk7cGFkZGluZy1pbmxpbmUtZW5kOnZhcigtLWlvbi1zYWZlLWFyZWEtcmlnaHQpfX06aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pey0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi1jb2xvci1zaGFkZSk7LS1jb2xvci1zZWxlY3RlZDp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1pb24tY29sb3ItY29udHJhc3QpfTpob3N0KC5pb24tY29sb3IpLDpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbil7Y29sb3I6cmdiYSh2YXIoLS1pb24tY29sb3ItY29udHJhc3QtcmdiKSwgMC43KX06aG9zdCguaW9uLWNvbG9yKSw6aG9zdCguaW9uLWNvbG9yKSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dmFyKC0taW9uLWNvbG9yLWJhc2UpfTpob3N0KC5pb24tY29sb3IpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCksOmhvc3QoLnRhYi1iYXItdHJhbnNsdWNlbnQpIDo6c2xvdHRlZChpb24tdGFiLWJ1dHRvbi5pb24tZm9jdXNlZCl7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQpfTpob3N0KC50YWItYmFyLXRyYW5zbHVjZW50KSA6OnNsb3R0ZWQoaW9uLXRhYi1idXR0b24pe2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9Omhvc3QoW3Nsb3Q9dG9wXSl7cGFkZGluZy10b3A6dmFyKC0taW9uLXNhZmUtYXJlYS10b3AsIDApO3BhZGRpbmctYm90dG9tOjA7Ym9yZGVyLXRvcDowO2JvcmRlci1ib3R0b206dmFyKC0tYm9yZGVyKX06aG9zdCgudGFiLWJhci1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0ey0tYmFja2dyb3VuZDp2YXIoLS1pb24tdGFiLWJhci1iYWNrZ3JvdW5kLCB2YXIoLS1pb24tYmFja2dyb3VuZC1jb2xvciwgI2ZmZikpOy0tYmFja2dyb3VuZC1mb2N1c2VkOnZhcigtLWlvbi10YWItYmFyLWJhY2tncm91bmQtZm9jdXNlZCwgI2UwZTBlMCk7LS1ib3JkZXI6MXB4IHNvbGlkIHZhcigtLWlvbi10YWItYmFyLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWJvcmRlci1jb2xvciwgdmFyKC0taW9uLWNvbG9yLXN0ZXAtMTUwLCByZ2JhKDAsIDAsIDAsIDAuMDcpKSkpOy0tY29sb3I6dmFyKC0taW9uLXRhYi1iYXItY29sb3IsIHZhcigtLWlvbi1jb2xvci1zdGVwLTYwMCwgIzY2NjY2NikpOy0tY29sb3Itc2VsZWN0ZWQ6dmFyKC0taW9uLXRhYi1iYXItY29sb3Itc2VsZWN0ZWQsIHZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKSk7aGVpZ2h0OjU2cHh9XCI7XG5cbmNvbnN0IFRhYkJhciA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pb25UYWJCYXJDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJpb25UYWJCYXJDaGFuZ2VkXCIsIDcpO1xuICAgIHRoaXMua2V5Ym9hcmRWaXNpYmxlID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgdGFiIGJhciB3aWxsIGJlIHRyYW5zbHVjZW50LlxuICAgICAqIE9ubHkgYXBwbGllcyB3aGVuIHRoZSBtb2RlIGlzIGBcImlvc1wiYCBhbmQgdGhlIGRldmljZSBzdXBwb3J0c1xuICAgICAqIFtgYmFja2Ryb3AtZmlsdGVyYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2JhY2tkcm9wLWZpbHRlciNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICAgICAqL1xuICAgIHRoaXMudHJhbnNsdWNlbnQgPSBmYWxzZTtcbiAgfVxuICBzZWxlY3RlZFRhYkNoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRUYWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pb25UYWJCYXJDaGFuZ2VkLmVtaXQoe1xuICAgICAgICB0YWI6IHRoaXMuc2VsZWN0ZWRUYWJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLnNlbGVjdGVkVGFiQ2hhbmdlZCgpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5rZXlib2FyZFdpbGxTaG93SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZWwuZ2V0QXR0cmlidXRlKCdzbG90JykgIT09ICd0b3AnKSB7XG4gICAgICAgICAgdGhpcy5rZXlib2FyZFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5rZXlib2FyZFdpbGxIaWRlSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmtleWJvYXJkVmlzaWJsZSA9IGZhbHNlLCA1MCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWJvYXJkV2lsbFNob3cnLCB0aGlzLmtleWJvYXJkV2lsbFNob3dIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxIaWRlJywgdGhpcy5rZXlib2FyZFdpbGxIaWRlSGFuZGxlcik7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWJvYXJkV2lsbFNob3cnLCB0aGlzLmtleWJvYXJkV2lsbFNob3dIYW5kbGVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlib2FyZFdpbGxIaWRlJywgdGhpcy5rZXlib2FyZFdpbGxIaWRlSGFuZGxlcik7XG4gICAgICB0aGlzLmtleWJvYXJkV2lsbFNob3dIYW5kbGVyID0gdGhpcy5rZXlib2FyZFdpbGxIaWRlSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY29sb3IsIHRyYW5zbHVjZW50LCBrZXlib2FyZFZpc2libGUgfSA9IHRoaXM7XG4gICAgY29uc3QgbW9kZSA9IGdldElvbk1vZGUodGhpcyk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgcm9sZTogXCJ0YWJsaXN0XCIsIFwiYXJpYS1oaWRkZW5cIjoga2V5Ym9hcmRWaXNpYmxlID8gJ3RydWUnIDogbnVsbCwgY2xhc3M6IGNyZWF0ZUNvbG9yQ2xhc3Nlcyhjb2xvciwge1xuICAgICAgICBbbW9kZV06IHRydWUsXG4gICAgICAgICd0YWItYmFyLXRyYW5zbHVjZW50JzogdHJhbnNsdWNlbnQsXG4gICAgICAgICd0YWItYmFyLWhpZGRlbic6IGtleWJvYXJkVmlzaWJsZSxcbiAgICAgIH0pIH0sIGgoXCJzbG90XCIsIG51bGwpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwic2VsZWN0ZWRUYWJcIjogW1wic2VsZWN0ZWRUYWJDaGFuZ2VkXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHtcbiAgICBpb3M6IHRhYkJhcklvc0NzcyxcbiAgICBtZDogdGFiQmFyTWRDc3NcbiAgfTsgfVxufSwgWzMzLCBcImlvbi10YWItYmFyXCIsIHtcbiAgICBcImNvbG9yXCI6IFs1MTNdLFxuICAgIFwic2VsZWN0ZWRUYWJcIjogWzEsIFwic2VsZWN0ZWQtdGFiXCJdLFxuICAgIFwidHJhbnNsdWNlbnRcIjogWzRdLFxuICAgIFwia2V5Ym9hcmRWaXNpYmxlXCI6IFszMl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tdGFiLWJhclwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLXRhYi1iYXJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUYWJCYXIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvblRhYkJhciA9IFRhYkJhcjtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvblRhYkJhciwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIHJlYWRUYXNrLCB3cml0ZVRhc2ssIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBiIGFzIGdldElvbk1vZGUgfSBmcm9tICcuL2lvbmljLWdsb2JhbC5qcyc7XG5cbmNvbnN0IHJpcHBsZUVmZmVjdENzcyA9IFwiOmhvc3R7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGFpbjpzdHJpY3Q7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdCgudW5ib3VuZGVkKXtjb250YWluOmxheW91dCBzaXplIHN0eWxlfS5yaXBwbGUtZWZmZWN0e2JvcmRlci1yYWRpdXM6NTAlO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6Y3VycmVudENvbG9yO2NvbG9yOmluaGVyaXQ7Y29udGFpbjpzdHJpY3Q7b3BhY2l0eTowOy13ZWJraXQtYW5pbWF0aW9uOjIyNW1zIHJpcHBsZUFuaW1hdGlvbiBmb3J3YXJkcywgNzVtcyBmYWRlSW5BbmltYXRpb24gZm9yd2FyZHM7YW5pbWF0aW9uOjIyNW1zIHJpcHBsZUFuaW1hdGlvbiBmb3J3YXJkcywgNzVtcyBmYWRlSW5BbmltYXRpb24gZm9yd2FyZHM7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtLCBvcGFjaXR5O3BvaW50ZXItZXZlbnRzOm5vbmV9LmZhZGUtb3V0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKTt0cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpOy13ZWJraXQtYW5pbWF0aW9uOjE1MG1zIGZhZGVPdXRBbmltYXRpb24gZm9yd2FyZHM7YW5pbWF0aW9uOjE1MG1zIGZhZGVPdXRBbmltYXRpb24gZm9yd2FyZHN9QC13ZWJraXQta2V5ZnJhbWVzIHJpcHBsZUFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKTt0cmFuc2Zvcm06c2NhbGUoMSl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKHZhcigtLXRyYW5zbGF0ZS1lbmQpKSBzY2FsZSh2YXIoLS1maW5hbC1zY2FsZSwgMSkpO3RyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSl9fUBrZXlmcmFtZXMgcmlwcGxlQW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpO3RyYW5zZm9ybTpzY2FsZSgxKX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUodmFyKC0tdHJhbnNsYXRlLWVuZCkpIHNjYWxlKHZhcigtLWZpbmFsLXNjYWxlLCAxKSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSh2YXIoLS10cmFuc2xhdGUtZW5kKSkgc2NhbGUodmFyKC0tZmluYWwtc2NhbGUsIDEpKX19QC13ZWJraXQta2V5ZnJhbWVzIGZhZGVJbkFuaW1hdGlvbntmcm9tey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eTowfXRve29wYWNpdHk6MC4xNn19QGtleWZyYW1lcyBmYWRlSW5BbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MH10b3tvcGFjaXR5OjAuMTZ9fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0QW5pbWF0aW9ue2Zyb217LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjtvcGFjaXR5OjAuMTZ9dG97b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIGZhZGVPdXRBbmltYXRpb257ZnJvbXstd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MC4xNn10b3tvcGFjaXR5OjB9fVwiO1xuXG5jb25zdCBSaXBwbGVFZmZlY3QgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHR5cGUgb2YgcmlwcGxlLWVmZmVjdDpcbiAgICAgKlxuICAgICAqIC0gYGJvdW5kZWRgOiB0aGUgcmlwcGxlIGVmZmVjdCBleHBhbmRzIGZyb20gdGhlIHVzZXIncyBjbGljayBwb3NpdGlvblxuICAgICAqIC0gYHVuYm91bmRlZGA6IHRoZSByaXBwbGUgZWZmZWN0IGV4cGFuZHMgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBidXR0b24gYW5kIG92ZXJmbG93cyB0aGUgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogTk9URTogU3VyZmFjZXMgZm9yIGJvdW5kZWQgcmlwcGxlcyBzaG91bGQgaGF2ZSB0aGUgb3ZlcmZsb3cgcHJvcGVydHkgc2V0IHRvIGhpZGRlbixcbiAgICAgKiB3aGlsZSBzdXJmYWNlcyBmb3IgdW5ib3VuZGVkIHJpcHBsZXMgc2hvdWxkIGhhdmUgaXQgc2V0IHRvIHZpc2libGUuXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gJ2JvdW5kZWQnO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHRoZSByaXBwbGUgZWZmZWN0IHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB3aGVyZSB0aGUgcmlwcGxlIHNob3VsZCBzdGFydC5cbiAgICogQHBhcmFtIHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2Ygd2hlcmUgdGhlIHJpcHBsZSBzaG91bGQgc3RhcnQuXG4gICAqL1xuICBhc3luYyBhZGRSaXBwbGUoeCwgeSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlYWRUYXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGh5cG90ZW51c2UgPSBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IG1heERpbSA9IE1hdGgubWF4KGhlaWdodCwgd2lkdGgpO1xuICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSB0aGlzLnVuYm91bmRlZCA/IG1heERpbSA6IGh5cG90ZW51c2UgKyBQQURESU5HO1xuICAgICAgICBjb25zdCBpbml0aWFsU2l6ZSA9IE1hdGguZmxvb3IobWF4RGltICogSU5JVElBTF9PUklHSU5fU0NBTEUpO1xuICAgICAgICBjb25zdCBmaW5hbFNjYWxlID0gbWF4UmFkaXVzIC8gaW5pdGlhbFNpemU7XG4gICAgICAgIGxldCBwb3NYID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgbGV0IHBvc1kgPSB5IC0gcmVjdC50b3A7XG4gICAgICAgIGlmICh0aGlzLnVuYm91bmRlZCkge1xuICAgICAgICAgIHBvc1ggPSB3aWR0aCAqIDAuNTtcbiAgICAgICAgICBwb3NZID0gaGVpZ2h0ICogMC41O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlWCA9IHBvc1ggLSBpbml0aWFsU2l6ZSAqIDAuNTtcbiAgICAgICAgY29uc3Qgc3R5bGVZID0gcG9zWSAtIGluaXRpYWxTaXplICogMC41O1xuICAgICAgICBjb25zdCBtb3ZlWCA9IHdpZHRoICogMC41IC0gcG9zWDtcbiAgICAgICAgY29uc3QgbW92ZVkgPSBoZWlnaHQgKiAwLjUgLSBwb3NZO1xuICAgICAgICB3cml0ZVRhc2soKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdyaXBwbGUtZWZmZWN0Jyk7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgICAgICAgc3R5bGUudG9wID0gc3R5bGVZICsgJ3B4JztcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gc3R5bGVYICsgJ3B4JztcbiAgICAgICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IGluaXRpYWxTaXplICsgJ3B4JztcbiAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnLS1maW5hbC1zY2FsZScsIGAke2ZpbmFsU2NhbGV9YCk7XG4gICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoJy0tdHJhbnNsYXRlLWVuZCcsIGAke21vdmVYfXB4LCAke21vdmVZfXB4YCk7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbC5zaGFkb3dSb290IHx8IHRoaXMuZWw7XG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVtb3ZlUmlwcGxlKGRpdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAyMjUgKyAxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCB1bmJvdW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3VuYm91bmRlZCc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRJb25Nb2RlKHRoaXMpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzOiB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgJ3VuYm91bmRlZCc6IHRoaXMudW5ib3VuZGVkXG4gICAgICB9IH0pKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiByaXBwbGVFZmZlY3RDc3M7IH1cbn0sIFsxLCBcImlvbi1yaXBwbGUtZWZmZWN0XCIsIHtcbiAgICBcInR5cGVcIjogWzFdLFxuICAgIFwiYWRkUmlwcGxlXCI6IFs2NF1cbiAgfV0pO1xuY29uc3QgcmVtb3ZlUmlwcGxlID0gKHJpcHBsZSkgPT4ge1xuICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnZmFkZS1vdXQnKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgcmlwcGxlLnJlbW92ZSgpO1xuICB9LCAyMDApO1xufTtcbmNvbnN0IFBBRERJTkcgPSAxMDtcbmNvbnN0IElOSVRJQUxfT1JJR0lOX1NDQUxFID0gMC41O1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiaW9uLXJpcHBsZS1lZmZlY3RcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImlvbi1yaXBwbGUtZWZmZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgUmlwcGxlRWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5leHBvcnQgeyBSaXBwbGVFZmZlY3QgYXMgUiwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgY3JlYXRlRXZlbnQsIGgsIEhvc3QgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBjIGFzIGNvbmZpZywgYiBhcyBnZXRJb25Nb2RlIH0gZnJvbSAnLi9pb25pYy1nbG9iYWwuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDIgfSBmcm9tICcuL3JpcHBsZS1lZmZlY3QuanMnO1xuXG5jb25zdCB0YWJCdXR0b25Jb3NDc3MgPSBcIjpob3N0ey0tcmlwcGxlLWNvbG9yOnZhcigtLWNvbG9yLXNlbGVjdGVkKTstLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5OjE7LW1zLWZsZXg6MTtmbGV4OjE7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2hlaWdodDoxMDAlO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnZhcigtLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNvbG9yKX0uYnV0dG9uLW5hdGl2ZXtib3JkZXItcmFkaXVzOmluaGVyaXQ7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctbGVmdDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLXJpZ2h0OnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLXRvcDp2YXIoLS1wYWRkaW5nLXRvcCk7cGFkZGluZy1ib3R0b206dmFyKC0tcGFkZGluZy1ib3R0b20pO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXQ7bGV0dGVyLXNwYWNpbmc6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LWluZGVudDppbmhlcml0O3RleHQtb3ZlcmZsb3c6aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O3RleHQtYWxpZ246aW5oZXJpdDt3aGl0ZS1zcGFjZTppbmhlcml0O2NvbG9yOmluaGVyaXQ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7LW1zLWZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC1kaXJlY3Rpb246aW5oZXJpdDstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtcGFjazppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7Ym9yZGVyOjA7b3V0bGluZTpub25lO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y3Vyc29yOnBvaW50ZXI7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LXVzZXItZHJhZzpub25lfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7LmJ1dHRvbi1uYXRpdmV7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OnZhcigtLXBhZGRpbmctc3RhcnQpO3BhZGRpbmctaW5saW5lLXN0YXJ0OnZhcigtLXBhZGRpbmctc3RhcnQpOy13ZWJraXQtcGFkZGluZy1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpO3BhZGRpbmctaW5saW5lLWVuZDp2YXIoLS1wYWRkaW5nLWVuZCl9fS5idXR0b24tbmF0aXZlOjphZnRlcntsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OlxcXCJcXFwiO29wYWNpdHk6MH0uYnV0dG9uLWlubmVye2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWZsb3c6aW5oZXJpdDtmbGV4LWZsb3c6aW5oZXJpdDstbXMtZmxleC1hbGlnbjppbmhlcml0O2FsaWduLWl0ZW1zOmluaGVyaXQ7LW1zLWZsZXgtcGFjazppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ei1pbmRleDoxfTpob3N0KC5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmV7Y29sb3I6dmFyKC0tY29sb3ItZm9jdXNlZCl9Omhvc3QoLmlvbi1mb2N1c2VkKSAuYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kLWZvY3VzZWQpO29wYWNpdHk6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkLW9wYWNpdHkpfUBtZWRpYSAoYW55LWhvdmVyOiBob3Zlcil7YTpob3Zlcntjb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCl9fTpob3N0KC50YWItc2VsZWN0ZWQpe2NvbG9yOnZhcigtLWNvbG9yLXNlbGVjdGVkKX06aG9zdCgudGFiLWhpZGRlbil7ZGlzcGxheTpub25lICFpbXBvcnRhbnR9Omhvc3QoLnRhYi1kaXNhYmxlZCl7cG9pbnRlci1ldmVudHM6bm9uZTtvcGFjaXR5OjAuNH06OnNsb3R0ZWQoaW9uLWxhYmVsKSw6OnNsb3R0ZWQoaW9uLWljb24pe2Rpc3BsYXk6YmxvY2s7LW1zLWZsZXgtaXRlbS1hbGlnbjpjZW50ZXI7YWxpZ24tc2VsZjpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH06OnNsb3R0ZWQoaW9uLWxhYmVsKXstbXMtZmxleC1vcmRlcjowO29yZGVyOjB9OjpzbG90dGVkKGlvbi1pY29uKXstbXMtZmxleC1vcmRlcjotMTtvcmRlcjotMTtoZWlnaHQ6MWVtfTpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tbGFiZWwpe3doaXRlLXNwYWNlOm5vcm1hbH06OnNsb3R0ZWQoaW9uLWJhZGdlKXstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxfTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpey1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93fTpob3N0KC50YWItbGF5b3V0LWljb24tZW5kKXstbXMtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pey1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZTtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX06aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24taWNvbil7ZGlzcGxheTpub25lfTpob3N0KC50YWItbGF5b3V0LWxhYmVsLWhpZGUpIDo6c2xvdHRlZChpb24tbGFiZWwpe2Rpc3BsYXk6bm9uZX1pb24tcmlwcGxlLWVmZmVjdHtjb2xvcjp2YXIoLS1yaXBwbGUtY29sb3IpfTpob3N0ey0tcGFkZGluZy10b3A6MDstLXBhZGRpbmctZW5kOjJweDstLXBhZGRpbmctYm90dG9tOjA7LS1wYWRkaW5nLXN0YXJ0OjJweDttYXgtd2lkdGg6MjQwcHg7Zm9udC1zaXplOjEwcHh9OjpzbG90dGVkKGlvbi1iYWRnZSl7cGFkZGluZy1sZWZ0OjZweDtwYWRkaW5nLXJpZ2h0OjZweDtwYWRkaW5nLXRvcDoxcHg7cGFkZGluZy1ib3R0b206MXB4O2xlZnQ6Y2FsYyg1MCUgKyA2cHgpO3RvcDo0cHg7aGVpZ2h0OmF1dG87Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MTZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezo6c2xvdHRlZChpb24tYmFkZ2Upe3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDo2cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6NnB4Oy13ZWJraXQtcGFkZGluZy1lbmQ6NnB4O3BhZGRpbmctaW5saW5lLWVuZDo2cHh9fVtkaXI9cnRsXSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDpjYWxjKDUwJSArIDZweCl9OjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjJweDttYXJnaW4tYm90dG9tOjJweDtmb250LXNpemU6MzBweH06OnNsb3R0ZWQoaW9uLWljb246OmJlZm9yZSl7dmVydGljYWwtYWxpZ246dG9wfTo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjFweDttaW4taGVpZ2h0OjExcHg7Zm9udC13ZWlnaHQ6NTAwfTpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWJvdHRvbToycHg7Zm9udC1zaXplOjEycHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS4xfTpob3N0KC50YWItbGF5b3V0LWljb24tZW5kKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKSw6aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKSw6aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuMX06aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1pY29uKSw6aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KSA6OnNsb3R0ZWQoaW9uLWljb24pe21pbi13aWR0aDoyNHB4O2hlaWdodDoyNnB4O21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MXB4O2ZvbnQtc2l6ZToyNHB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OmNhbGMoNTAlICsgMTJweCl9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24tYm90dG9tIDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6Y2FsYyg1MCUgKyAxMnB4KX06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToxcHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6NHB4fTpob3N0KC50YWItbGF5b3V0LWljb24tc3RhcnQpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0KC50YWItbGF5b3V0LWljb24tZW5kKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OmNhbGMoNTAlICsgMzVweCk7dG9wOjEwcHh9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1zdGFydCA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1lbmQgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDpjYWxjKDUwJSArIDM1cHgpfTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDpjYWxjKDUwJSArIDMwcHgpO3RvcDoxMHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1oaWRlIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItaGFzLWxhYmVsLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItaGFzLWxhYmVsLW9ubHkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDpjYWxjKDUwJSArIDMwcHgpfTpob3N0KC50YWItbGF5b3V0LWxhYmVsLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0KC50YWItaGFzLWljb24tb25seSkgOjpzbG90dGVkKGlvbi1iYWRnZSl7dG9wOjEwcHh9Omhvc3QoLnRhYi1sYXlvdXQtbGFiZWwtaGlkZSkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjB9XCI7XG5cbmNvbnN0IHRhYkJ1dHRvbk1kQ3NzID0gXCI6aG9zdHstLXJpcHBsZS1jb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCk7LS1iYWNrZ3JvdW5kLWZvY3VzZWQtb3BhY2l0eToxOy1tcy1mbGV4OjE7ZmxleDoxOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1uOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtoZWlnaHQ6MTAwJTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZDp2YXIoLS1iYWNrZ3JvdW5kKTtjb2xvcjp2YXIoLS1jb2xvcil9LmJ1dHRvbi1uYXRpdmV7Ym9yZGVyLXJhZGl1czppbmhlcml0O21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtwYWRkaW5nLWxlZnQ6dmFyKC0tcGFkZGluZy1zdGFydCk7cGFkZGluZy1yaWdodDp2YXIoLS1wYWRkaW5nLWVuZCk7cGFkZGluZy10b3A6dmFyKC0tcGFkZGluZy10b3ApO3BhZGRpbmctYm90dG9tOnZhcigtLXBhZGRpbmctYm90dG9tKTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtc3R5bGU6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7dGV4dC1pbmRlbnQ6aW5oZXJpdDt0ZXh0LW92ZXJmbG93OmluaGVyaXQ7dGV4dC10cmFuc2Zvcm06aW5oZXJpdDt0ZXh0LWFsaWduOmluaGVyaXQ7d2hpdGUtc3BhY2U6aW5oZXJpdDtjb2xvcjppbmhlcml0O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy1tcy1mbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlcjowO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O3RleHQtZGVjb3JhdGlvbjpub25lO2N1cnNvcjpwb2ludGVyO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApey5idXR0b24tbmF0aXZle3BhZGRpbmctbGVmdDp1bnNldDtwYWRkaW5nLXJpZ2h0OnVuc2V0Oy13ZWJraXQtcGFkZGluZy1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTtwYWRkaW5nLWlubGluZS1zdGFydDp2YXIoLS1wYWRkaW5nLXN0YXJ0KTstd2Via2l0LXBhZGRpbmctZW5kOnZhcigtLXBhZGRpbmctZW5kKTtwYWRkaW5nLWlubGluZS1lbmQ6dmFyKC0tcGFkZGluZy1lbmQpfX0uYnV0dG9uLW5hdGl2ZTo6YWZ0ZXJ7bGVmdDowO3JpZ2h0OjA7dG9wOjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDpcXFwiXFxcIjtvcGFjaXR5OjB9LmJ1dHRvbi1pbm5lcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtZmxleC1mbG93OmluaGVyaXQ7ZmxleC1mbG93OmluaGVyaXQ7LW1zLWZsZXgtYWxpZ246aW5oZXJpdDthbGlnbi1pdGVtczppbmhlcml0Oy1tcy1mbGV4LXBhY2s6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6aW5oZXJpdDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MX06aG9zdCguaW9uLWZvY3VzZWQpIC5idXR0b24tbmF0aXZle2NvbG9yOnZhcigtLWNvbG9yLWZvY3VzZWQpfTpob3N0KC5pb24tZm9jdXNlZCkgLmJ1dHRvbi1uYXRpdmU6OmFmdGVye2JhY2tncm91bmQ6dmFyKC0tYmFja2dyb3VuZC1mb2N1c2VkKTtvcGFjaXR5OnZhcigtLWJhY2tncm91bmQtZm9jdXNlZC1vcGFjaXR5KX1AbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpe2E6aG92ZXJ7Y29sb3I6dmFyKC0tY29sb3Itc2VsZWN0ZWQpfX06aG9zdCgudGFiLXNlbGVjdGVkKXtjb2xvcjp2YXIoLS1jb2xvci1zZWxlY3RlZCl9Omhvc3QoLnRhYi1oaWRkZW4pe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fTpob3N0KC50YWItZGlzYWJsZWQpe3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowLjR9OjpzbG90dGVkKGlvbi1sYWJlbCksOjpzbG90dGVkKGlvbi1pY29uKXtkaXNwbGF5OmJsb2NrOy1tcy1mbGV4LWl0ZW0tYWxpZ246Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO21heC13aWR0aDoxMDAlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9OjpzbG90dGVkKGlvbi1sYWJlbCl7LW1zLWZsZXgtb3JkZXI6MDtvcmRlcjowfTo6c2xvdHRlZChpb24taWNvbil7LW1zLWZsZXgtb3JkZXI6LTE7b3JkZXI6LTE7aGVpZ2h0OjFlbX06aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXt3aGl0ZS1zcGFjZTpub3JtYWx9OjpzbG90dGVkKGlvbi1iYWRnZSl7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MX06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KXstbXMtZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtZGlyZWN0aW9uOnJvd306aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCl7LW1zLWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKXstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2U7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWljb24pe2Rpc3BsYXk6bm9uZX06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWxhYmVsKXtkaXNwbGF5Om5vbmV9aW9uLXJpcHBsZS1lZmZlY3R7Y29sb3I6dmFyKC0tcmlwcGxlLWNvbG9yKX06aG9zdHstLXBhZGRpbmctdG9wOjA7LS1wYWRkaW5nLWVuZDoxMnB4Oy0tcGFkZGluZy1ib3R0b206MDstLXBhZGRpbmctc3RhcnQ6MTJweDttYXgtd2lkdGg6MTY4cHg7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6bm9ybWFsO2xldHRlci1zcGFjaW5nOjAuMDNlbX06OnNsb3R0ZWQoaW9uLWxhYmVsKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MnB4O21hcmdpbi1ib3R0b206MnB4O3RleHQtdHJhbnNmb3JtOm5vbmV9OjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO21hcmdpbi10b3A6MTZweDttYXJnaW4tYm90dG9tOjE2cHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgY2VudGVyO2ZvbnQtc2l6ZToyMnB4fVtkaXI9cnRsXSA6OnNsb3R0ZWQoaW9uLWljb24pLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKSA6OnNsb3R0ZWQoaW9uLWljb24pey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpjYWxjKDEwMCUgLSBjZW50ZXIpIGNlbnRlcjt0cmFuc2Zvcm0tb3JpZ2luOmNhbGMoMTAwJSAtIGNlbnRlcikgY2VudGVyfTo6c2xvdHRlZChpb24tYmFkZ2Upe2JvcmRlci1yYWRpdXM6OHB4O3BhZGRpbmctbGVmdDoycHg7cGFkZGluZy1yaWdodDoycHg7cGFkZGluZy10b3A6M3B4O3BhZGRpbmctYm90dG9tOjJweDtsZWZ0OmNhbGMoNTAlICsgNnB4KTt0b3A6OHB4O21pbi13aWR0aDoxMnB4O2ZvbnQtc2l6ZTo4cHg7Zm9udC13ZWlnaHQ6bm9ybWFsfUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7OjpzbG90dGVkKGlvbi1iYWRnZSl7cGFkZGluZy1sZWZ0OnVuc2V0O3BhZGRpbmctcmlnaHQ6dW5zZXQ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjJweDtwYWRkaW5nLWlubGluZS1zdGFydDoycHg7LXdlYmtpdC1wYWRkaW5nLWVuZDoycHg7cGFkZGluZy1pbmxpbmUtZW5kOjJweH19W2Rpcj1ydGxdIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OmNhbGMoNTAlICsgNnB4KX06OnNsb3R0ZWQoaW9uLWJhZGdlOmVtcHR5KXtkaXNwbGF5OmJsb2NrO21pbi13aWR0aDo4cHg7aGVpZ2h0OjhweH06aG9zdCgudGFiLWxheW91dC1pY29uLXRvcCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjZweDttYXJnaW4tYm90dG9tOjJweH06aG9zdCgudGFiLWxheW91dC1pY29uLXRvcCkgOjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206NnB4fTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OjcwJTt0b3A6OHB4fTpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKTpob3N0KC50YWItbGF5b3V0LWljb24tYm90dG9tKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWxheW91dC1pY29uLWJvdHRvbSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OnVuc2V0O3JpZ2h0OnVuc2V0O3JpZ2h0OjcwJX06aG9zdCgudGFiLWxheW91dC1pY29uLWJvdHRvbSkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTo2cHh9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1ib3R0b20pIDo6c2xvdHRlZChpb24tbGFiZWwpe21hcmdpbi10b3A6NnB4O21hcmdpbi1ib3R0b206MH06aG9zdCgudGFiLWxheW91dC1pY29uLXN0YXJ0KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDo4MCU7dG9wOjE2cHh9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pOmhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1zdGFydCA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWVuZCkgOjpzbG90dGVkKGlvbi1iYWRnZSksOmhvc3QtY29udGV4dChbZGlyPXJ0bF0pLnRhYi1sYXlvdXQtaWNvbi1lbmQgOjpzbG90dGVkKGlvbi1iYWRnZSl7bGVmdDp1bnNldDtyaWdodDp1bnNldDtyaWdodDo4MCV9Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tcmlnaHQ6NnB4fUBzdXBwb3J0cyAoKC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwKSBvciAobWFyZ2luLWlubGluZS1zdGFydDogMCkpIG9yICgtd2Via2l0LW1hcmdpbi1zdGFydDogMCl7Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1zdGFydCkgOjpzbG90dGVkKGlvbi1pY29uKXttYXJnaW4tcmlnaHQ6dW5zZXQ7LXdlYmtpdC1tYXJnaW4tZW5kOjZweDttYXJnaW4taW5saW5lLWVuZDo2cHh9fTpob3N0KC50YWItbGF5b3V0LWljb24tZW5kKSA6OnNsb3R0ZWQoaW9uLWljb24pe21hcmdpbi1sZWZ0OjZweH1Ac3VwcG9ydHMgKCgtd2Via2l0LW1hcmdpbi1zdGFydDogMCkgb3IgKG1hcmdpbi1pbmxpbmUtc3RhcnQ6IDApKSBvciAoLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDApezpob3N0KC50YWItbGF5b3V0LWljb24tZW5kKSA6OnNsb3R0ZWQoaW9uLWljb24pe21hcmdpbi1sZWZ0OnVuc2V0Oy13ZWJraXQtbWFyZ2luLXN0YXJ0OjZweDttYXJnaW4taW5saW5lLXN0YXJ0OjZweH19Omhvc3QoLnRhYi1sYXlvdXQtaWNvbi1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKXtsZWZ0OjcwJTt0b3A6MTZweH06aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWxheW91dC1pY29uLWhpZGUpIDo6c2xvdHRlZChpb24tYmFkZ2UpLDpob3N0LWNvbnRleHQoW2Rpcj1ydGxdKS50YWItbGF5b3V0LWljb24taGlkZSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSk6aG9zdCgudGFiLWhhcy1sYWJlbC1vbmx5KSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdC1jb250ZXh0KFtkaXI9cnRsXSkudGFiLWhhcy1sYWJlbC1vbmx5IDo6c2xvdHRlZChpb24tYmFkZ2Upe2xlZnQ6dW5zZXQ7cmlnaHQ6dW5zZXQ7cmlnaHQ6NzAlfTpob3N0KC50YWItbGF5b3V0LWljb24taGlkZSkgOjpzbG90dGVkKGlvbi1sYWJlbCksOmhvc3QoLnRhYi1oYXMtbGFiZWwtb25seSkgOjpzbG90dGVkKGlvbi1sYWJlbCl7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MH06aG9zdCgudGFiLWxheW91dC1sYWJlbC1oaWRlKSA6OnNsb3R0ZWQoaW9uLWJhZGdlKSw6aG9zdCgudGFiLWhhcy1pY29uLW9ubHkpIDo6c2xvdHRlZChpb24tYmFkZ2Upe3RvcDoxNnB4fTpob3N0KC50YWItbGF5b3V0LWxhYmVsLWhpZGUpIDo6c2xvdHRlZChpb24taWNvbiksOmhvc3QoLnRhYi1oYXMtaWNvbi1vbmx5KSA6OnNsb3R0ZWQoaW9uLWljb24pe21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7Zm9udC1zaXplOjI0cHh9XCI7XG5cbmNvbnN0IFRhYkJ1dHRvbiA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pb25UYWJCdXR0b25DbGljayA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiaW9uVGFiQnV0dG9uQ2xpY2tcIiwgNyk7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGUgdGFiIGJ1dHRvbi5cbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIHRhYiBjb21wb25lbnRcbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vbktleVVwID0gKGV2KSA9PiB7XG4gICAgICBpZiAoZXYua2V5ID09PSAnRW50ZXInIHx8IGV2LmtleSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0VGFiKGV2KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25DbGljayA9IChldikgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RUYWIoZXYpO1xuICAgIH07XG4gIH1cbiAgb25UYWJCYXJDaGFuZ2VkKGV2KSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlZEZyb20gPSBldi50YXJnZXQ7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50O1xuICAgIGlmICgoZXYuY29tcG9zZWRQYXRoICYmIGV2LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHBhcmVudCkpIHx8IChkaXNwYXRjaGVkRnJvbSAmJiBkaXNwYXRjaGVkRnJvbS5jb250YWlucyh0aGlzLmVsKSkpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnRhYiA9PT0gZXYuZGV0YWlsLnRhYjtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGF5b3V0ID0gY29uZmlnLmdldCgndGFiQnV0dG9uTGF5b3V0JywgJ2ljb24tdG9wJyk7XG4gICAgfVxuICB9XG4gIHNlbGVjdFRhYihldikge1xuICAgIGlmICh0aGlzLnRhYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pb25UYWJCdXR0b25DbGljay5lbWl0KHtcbiAgICAgICAgICB0YWI6IHRoaXMudGFiLFxuICAgICAgICAgIGhyZWY6IHRoaXMuaHJlZixcbiAgICAgICAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGdldCBoYXNMYWJlbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lvbi1sYWJlbCcpO1xuICB9XG4gIGdldCBoYXNJY29uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZWwucXVlcnlTZWxlY3RvcignaW9uLWljb24nKTtcbiAgfVxuICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgY29uc3QgaGFzVGFiSW5kZXggPSB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICBpZiAoaGFzVGFiSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQsIGhhc0ljb24sIGhhc0xhYmVsLCB0YWJJbmRleCwgaHJlZiwgcmVsLCB0YXJnZXQsIGxheW91dCwgc2VsZWN0ZWQsIHRhYiB9ID0gdGhpcztcbiAgICBjb25zdCBtb2RlID0gZ2V0SW9uTW9kZSh0aGlzKTtcbiAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgIGRvd25sb2FkOiB0aGlzLmRvd25sb2FkLFxuICAgICAgaHJlZixcbiAgICAgIHJlbCxcbiAgICAgIHRhcmdldFxuICAgIH07XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgb25DbGljazogdGhpcy5vbkNsaWNrLCBvbktleXVwOiB0aGlzLm9uS2V5VXAsIHJvbGU6IFwidGFiXCIsIHRhYmluZGV4OiB0YWJJbmRleCwgXCJhcmlhLXNlbGVjdGVkXCI6IHNlbGVjdGVkID8gJ3RydWUnIDogbnVsbCwgaWQ6IHRhYiAhPT0gdW5kZWZpbmVkID8gYHRhYi1idXR0b24tJHt0YWJ9YCA6IG51bGwsIGNsYXNzOiB7XG4gICAgICAgIFttb2RlXTogdHJ1ZSxcbiAgICAgICAgJ3RhYi1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAndGFiLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgICAgICd0YWItaGFzLWxhYmVsJzogaGFzTGFiZWwsXG4gICAgICAgICd0YWItaGFzLWljb24nOiBoYXNJY29uLFxuICAgICAgICAndGFiLWhhcy1sYWJlbC1vbmx5JzogaGFzTGFiZWwgJiYgIWhhc0ljb24sXG4gICAgICAgICd0YWItaGFzLWljb24tb25seSc6IGhhc0ljb24gJiYgIWhhc0xhYmVsLFxuICAgICAgICBbYHRhYi1sYXlvdXQtJHtsYXlvdXR9YF06IHRydWUsXG4gICAgICAgICdpb24tYWN0aXZhdGFibGUnOiB0cnVlLFxuICAgICAgICAnaW9uLXNlbGVjdGFibGUnOiB0cnVlLFxuICAgICAgICAnaW9uLWZvY3VzYWJsZSc6IHRydWVcbiAgICAgIH0gfSwgaChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cnMsIHsgdGFiSW5kZXg6IC0xLCBjbGFzczogXCJidXR0b24tbmF0aXZlXCIsIHBhcnQ6IFwibmF0aXZlXCIgfSksIGgoXCJzcGFuXCIsIHsgY2xhc3M6IFwiYnV0dG9uLWlubmVyXCIgfSwgaChcInNsb3RcIiwgbnVsbCkpLCBtb2RlID09PSAnbWQnICYmIGgoXCJpb24tcmlwcGxlLWVmZmVjdFwiLCB7IHR5cGU6IFwidW5ib3VuZGVkXCIgfSkpKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4ge1xuICAgIGlvczogdGFiQnV0dG9uSW9zQ3NzLFxuICAgIG1kOiB0YWJCdXR0b25NZENzc1xuICB9OyB9XG59LCBbMzMsIFwiaW9uLXRhYi1idXR0b25cIiwge1xuICAgIFwiZGlzYWJsZWRcIjogWzRdLFxuICAgIFwiZG93bmxvYWRcIjogWzFdLFxuICAgIFwiaHJlZlwiOiBbMV0sXG4gICAgXCJyZWxcIjogWzFdLFxuICAgIFwibGF5b3V0XCI6IFsxMDI1XSxcbiAgICBcInNlbGVjdGVkXCI6IFsxMDI4XSxcbiAgICBcInRhYlwiOiBbMV0sXG4gICAgXCJ0YXJnZXRcIjogWzFdXG4gIH0sIFtbOCwgXCJpb25UYWJCYXJDaGFuZ2VkXCIsIFwib25UYWJCYXJDaGFuZ2VkXCJdXV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24tdGFiLWJ1dHRvblwiLCBcImlvbi1yaXBwbGUtZWZmZWN0XCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJpb24tdGFiLWJ1dHRvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFRhYkJ1dHRvbik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW9uLXJpcHBsZS1lZmZlY3RcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkMigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5cbmNvbnN0IElvblRhYkJ1dHRvbiA9IFRhYkJ1dHRvbjtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvblRhYkJ1dHRvbiwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiY29uc3QgQlVJTEQgPSB7XG4gICAgYWxsUmVuZGVyRm46IGZhbHNlLFxuICAgIGNtcERpZExvYWQ6IHRydWUsXG4gICAgY21wRGlkVW5sb2FkOiBmYWxzZSxcbiAgICBjbXBEaWRVcGRhdGU6IHRydWUsXG4gICAgY21wRGlkUmVuZGVyOiB0cnVlLFxuICAgIGNtcFdpbGxMb2FkOiB0cnVlLFxuICAgIGNtcFdpbGxVcGRhdGU6IHRydWUsXG4gICAgY21wV2lsbFJlbmRlcjogdHJ1ZSxcbiAgICBjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBlbGVtZW50OiB0cnVlLFxuICAgIGV2ZW50OiB0cnVlLFxuICAgIGhhc1JlbmRlckZuOiB0cnVlLFxuICAgIGxpZmVjeWNsZTogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXI6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldEJvZHk6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50OiBmYWxzZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXQ6IHRydWUsXG4gICAgbWVtYmVyOiB0cnVlLFxuICAgIG1ldGhvZDogdHJ1ZSxcbiAgICBtb2RlOiB0cnVlLFxuICAgIG9ic2VydmVBdHRyaWJ1dGU6IHRydWUsXG4gICAgcHJvcDogdHJ1ZSxcbiAgICBwcm9wTXV0YWJsZTogdHJ1ZSxcbiAgICByZWZsZWN0OiB0cnVlLFxuICAgIHNjb3BlZDogdHJ1ZSxcbiAgICBzaGFkb3dEb206IHRydWUsXG4gICAgc2xvdDogdHJ1ZSxcbiAgICBjc3NBbm5vdGF0aW9uczogdHJ1ZSxcbiAgICBzdGF0ZTogdHJ1ZSxcbiAgICBzdHlsZTogdHJ1ZSxcbiAgICBzdmc6IHRydWUsXG4gICAgdXBkYXRhYmxlOiB0cnVlLFxuICAgIHZkb21BdHRyaWJ1dGU6IHRydWUsXG4gICAgdmRvbVhsaW5rOiB0cnVlLFxuICAgIHZkb21DbGFzczogdHJ1ZSxcbiAgICB2ZG9tRnVuY3Rpb25hbDogdHJ1ZSxcbiAgICB2ZG9tS2V5OiB0cnVlLFxuICAgIHZkb21MaXN0ZW5lcjogdHJ1ZSxcbiAgICB2ZG9tUmVmOiB0cnVlLFxuICAgIHZkb21Qcm9wT3JBdHRyOiB0cnVlLFxuICAgIHZkb21SZW5kZXI6IHRydWUsXG4gICAgdmRvbVN0eWxlOiB0cnVlLFxuICAgIHZkb21UZXh0OiB0cnVlLFxuICAgIHdhdGNoQ2FsbGJhY2s6IHRydWUsXG4gICAgdGFza1F1ZXVlOiB0cnVlLFxuICAgIGhvdE1vZHVsZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgICBpc0RlYnVnOiBmYWxzZSxcbiAgICBpc0RldjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBmYWxzZSxcbiAgICBoeWRyYXRlU2VydmVyU2lkZTogZmFsc2UsXG4gICAgaHlkcmF0ZUNsaWVudFNpZGU6IGZhbHNlLFxuICAgIGxpZmVjeWNsZURPTUV2ZW50czogZmFsc2UsXG4gICAgbGF6eUxvYWQ6IGZhbHNlLFxuICAgIHByb2ZpbGU6IGZhbHNlLFxuICAgIHNsb3RSZWxvY2F0aW9uOiB0cnVlLFxuICAgIGFwcGVuZENoaWxkU2xvdEZpeDogZmFsc2UsXG4gICAgY2xvbmVOb2RlRml4OiBmYWxzZSxcbiAgICBoeWRyYXRlZEF0dHJpYnV0ZTogZmFsc2UsXG4gICAgaHlkcmF0ZWRDbGFzczogdHJ1ZSxcbiAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgc2NyaXB0RGF0YU9wdHM6IGZhbHNlLFxuICAgIHNjb3BlZFNsb3RUZXh0Q29udGVudEZpeDogZmFsc2UsXG4gICAgc2hhZG93RG9tU2hpbTogZmFsc2UsXG4gICAgc2xvdENoaWxkTm9kZXNGaXg6IGZhbHNlLFxuICAgIGludmlzaWJsZVByZWh5ZHJhdGlvbjogdHJ1ZSxcbiAgICBwcm9wQm9vbGVhbjogdHJ1ZSxcbiAgICBwcm9wTnVtYmVyOiB0cnVlLFxuICAgIHByb3BTdHJpbmc6IHRydWUsXG4gICAgY3NzVmFyU2hpbTogZmFsc2UsXG4gICAgY29uc3RydWN0YWJsZUNTUzogdHJ1ZSxcbiAgICBjbXBTaG91bGRVcGRhdGU6IHRydWUsXG4gICAgZGV2VG9vbHM6IGZhbHNlLFxuICAgIGR5bmFtaWNJbXBvcnRTaGltOiBmYWxzZSxcbiAgICBzaGFkb3dEZWxlZ2F0ZXNGb2N1czogdHJ1ZSxcbiAgICBpbml0aWFsaXplTmV4dFRpY2s6IGZhbHNlLFxuICAgIGFzeW5jTG9hZGluZzogZmFsc2UsXG4gICAgYXN5bmNRdWV1ZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gICAgYXR0YWNoU3R5bGVzOiB0cnVlLFxufTtcbmNvbnN0IEVudiA9IHt9O1xuY29uc3QgTkFNRVNQQUNFID0gLyogZGVmYXVsdCAqLyAnYXBwJztcblxuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH07XG4iLCJsZXQgc2NvcGVJZDtcbmxldCBjb250ZW50UmVmO1xubGV0IGhvc3RUYWdOYW1lO1xubGV0IGN1c3RvbUVycm9yO1xubGV0IGkgPSAwO1xubGV0IHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdFJlbG9jYXRlID0gZmFsc2U7XG5sZXQgaXNTdmdNb2RlID0gZmFsc2U7XG5sZXQgcmVuZGVyaW5nUmVmID0gbnVsbDtcbmxldCBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xubGV0IHF1ZXVlUGVuZGluZyA9IGZhbHNlO1xuLypcbiBTdGVuY2lsIENsaWVudCBQbGF0Zm9ybSB2Mi4xMi4xIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXG4gKi9cbmltcG9ydCB7IEJVSUxELCBOQU1FU1BBQ0UgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhJztcbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG5jb25zdCBDU1MgPSBCVUlMRC5jc3NWYXJTaGltID8gd2luLkNTUyA6IG51bGw7XG5jb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQgfHwgeyBoZWFkOiB7fSB9O1xuY29uc3QgSCA9ICh3aW4uSFRNTEVsZW1lbnQgfHwgY2xhc3Mge1xufSk7XG5jb25zdCBwbHQgPSB7XG4gICAgJGZsYWdzJDogMCxcbiAgICAkcmVzb3VyY2VzVXJsJDogJycsXG4gICAgam1wOiAoaCkgPT4gaCgpLFxuICAgIHJhZjogKGgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShoKSxcbiAgICBhZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICByZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICBjZTogKGV2ZW50TmFtZSwgb3B0cykgPT4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgb3B0cyksXG59O1xuY29uc3Qgc2V0UGxhdGZvcm1IZWxwZXJzID0gKGhlbHBlcnMpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgaGVscGVycyk7XG59O1xuY29uc3Qgc3VwcG9ydHNTaGFkb3cgPSBCVUlMRC5zaGFkb3dEb21TaGltICYmIEJVSUxELnNoYWRvd0RvbVxuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4gKGRvYy5oZWFkLmF0dGFjaFNoYWRvdyArICcnKS5pbmRleE9mKCdbbmF0aXZlJykgPiAtMSkoKVxuICAgIDogdHJ1ZTtcbmNvbnN0IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zID0gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgIGxldCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnM7XG59KSgpO1xuY29uc3QgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuY29uc3Qgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgPSBCVUlMRC5jb25zdHJ1Y3RhYmxlQ1NTXG4gICAgPyAvKkBfX1BVUkVfXyovICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuZXcgQ1NTU3R5bGVTaGVldCgpLnJlcGxhY2UgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoKVxuICAgIDogZmFsc2U7XG5jb25zdCBDb250ZXh0ID0ge307XG5jb25zdCBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMgPSAoZWxtLCBob3N0UmVmLCBsaXN0ZW5lcnMsIGF0dGFjaFBhcmVudExpc3RlbmVycykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIgJiYgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IHdpdGhpbiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGluaXRpYWxpemUgb3VyIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgIC8vIHdlIGRvIHRoaXMgbm93IHNvIHRoYXQgd2UgY2FuIGxpc3RlbiB0byBldmVudHMgdGhhdCBtYXlcbiAgICAgICAgLy8gaGF2ZSBmaXJlZCBldmVuIGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgcmVhZHlcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgbWF5IGhhdmUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGlmIChhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBpbXBvcnRhbnQgc28gdGhhdCB3ZSBrbm93IHRoZSBob3N0IGVsZW1lbnQgYWN0dWFsbHkgaGFzIGEgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoZSBsaXN0ZW5lcnMgdG8gb25seSBoYXZlIHRoZSBvbmVzIHRoYXQgQVJFIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBCVVQgdGhlIHBhcmVudCBlbGVtZW50IGxpc3RlbmVycyBzaG91bGQgYmUgYXR0YWNoZWQgYXQgdGhpcyB0aW1lXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRoYXQgYXJlIE5PVCBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gIShmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5tYXAoKFtmbGFncywgbmFtZSwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0ID8gZ2V0SG9zdExpc3RlbmVyVGFyZ2V0KGVsbSwgZmxhZ3MpIDogZWxtO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhvc3RMaXN0ZW5lclByb3h5KGhvc3RSZWYsIG1ldGhvZCk7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gaG9zdExpc3RlbmVyT3B0cyhmbGFncyk7XG4gICAgICAgICAgICBwbHQuYWVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cyk7XG4gICAgICAgICAgICAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gaG9zdFJlZi4kcm1MaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKCgpID0+IHBsdC5yZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBob3N0TGlzdGVuZXJQcm94eSA9IChob3N0UmVmLCBtZXRob2ROYW1lKSA9PiAoZXYpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LCBsZXQncyBjYWxsIGl0J3MgbWVtYmVyIG1ldGhvZCBmb3IgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGxhenlJbnN0YW5jZSRbbWV0aG9kTmFtZV0oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKFttZXRob2ROYW1lLCBldl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdFJlZi4kaG9zdEVsZW1lbnQkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEhvc3RMaXN0ZW5lclRhcmdldCA9IChlbG0sIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50ICYmIGZsYWdzICYgNCAvKiBUYXJnZXREb2N1bWVudCAqLylcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93ICYmIGZsYWdzICYgOCAvKiBUYXJnZXRXaW5kb3cgKi8pXG4gICAgICAgIHJldHVybiB3aW47XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldEJvZHkgJiYgZmxhZ3MgJiAxNiAvKiBUYXJnZXRCb2R5ICovKVxuICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCAmJiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLylcbiAgICAgICAgcmV0dXJuIGVsbS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBlbG07XG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBob3N0TGlzdGVuZXJPcHRzID0gKGZsYWdzKSA9PiBzdXBwb3J0c0xpc3RlbmVyT3B0aW9uc1xuICAgID8gKHtcbiAgICAgICAgcGFzc2l2ZTogKGZsYWdzICYgMSAvKiBQYXNzaXZlICovKSAhPT0gMCxcbiAgICAgICAgY2FwdHVyZTogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMCxcbiAgICB9KVxuICAgIDogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMDtcbmNvbnN0IENPTlRFTlRfUkVGX0lEID0gJ3InO1xuY29uc3QgT1JHX0xPQ0FUSU9OX0lEID0gJ28nO1xuY29uc3QgU0xPVF9OT0RFX0lEID0gJ3MnO1xuY29uc3QgVEVYVF9OT0RFX0lEID0gJ3QnO1xuY29uc3QgSFlEUkFURV9JRCA9ICdzLWlkJztcbmNvbnN0IEhZRFJBVEVEX1NUWUxFX0lEID0gJ3N0eS1pZCc7XG5jb25zdCBIWURSQVRFX0NISUxEX0lEID0gJ2MtaWQnO1xuY29uc3QgSFlEUkFURURfQ1NTID0gJ3t2aXNpYmlsaXR5OmhpZGRlbn0uaHlkcmF0ZWR7dmlzaWJpbGl0eTppbmhlcml0fSc7XG5jb25zdCBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IGNyZWF0ZVRpbWUgPSAoZm5OYW1lLCB0YWdOYW1lID0gJycpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGBzdDoke2ZuTmFtZX06JHt0YWdOYW1lfToke2krK31gO1xuICAgICAgICAvLyBTdGFydFxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIC8vIEVuZFxuICAgICAgICByZXR1cm4gKCkgPT4gcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7Zm5OYW1lfSgpIDwke3RhZ05hbWV9PmAsIGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCB1bmlxdWVUaW1lID0gKGtleSwgbWVhc3VyZVRleHQpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKGtleSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKG1lYXN1cmVUZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVUZXh0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGlmICghaG9zdFJlZikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJDb3VudDogaG9zdFJlZi4kcmVuZGVyQ291bnQkLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgaGFzUmVuZGVyZWQ6ICEhKGZsYWdzICYgMiAvKiBoYXNSZW5kZXJlZCAqLyksXG4gICAgICAgICAgICBoYXNDb25uZWN0ZWQ6ICEhKGZsYWdzICYgMSAvKiBoYXNDb25uZWN0ZWQgKi8pLFxuICAgICAgICAgICAgaXNXYWl0aW5nRm9yQ2hpbGRyZW46ICEhKGZsYWdzICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyksXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGluZ0luc3RhbmNlOiAhIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLyksXG4gICAgICAgICAgICBpc1F1ZXVlZEZvclVwZGF0ZTogISEoZmxhZ3MgJiAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLyksXG4gICAgICAgICAgICBoYXNJbml0aWFsaXplZENvbXBvbmVudDogISEoZmxhZ3MgJiAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBoYXNMb2FkZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgNjQgLyogaGFzTG9hZGVkQ29tcG9uZW50ICovKSxcbiAgICAgICAgICAgIGlzV2F0Y2hSZWFkeTogISEoZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSxcbiAgICAgICAgICAgIGlzTGlzdGVuUmVhZHk6ICEhKGZsYWdzICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pLFxuICAgICAgICAgICAgbmVlZHNSZXJlbmRlcjogISEoZmxhZ3MgJiA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyksXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlVmFsdWVzOiBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQsXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50OiBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQsXG4gICAgICAgIGhvc3RFbGVtZW50LFxuICAgICAgICBsYXp5SW5zdGFuY2U6IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQsXG4gICAgICAgIHZub2RlOiBob3N0UmVmLiR2bm9kZSQsXG4gICAgICAgIG1vZGVOYW1lOiBob3N0UmVmLiRtb2RlTmFtZSQsXG4gICAgICAgIG9uUmVhZHlQcm9taXNlOiBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQsXG4gICAgICAgIG9uUmVhZHlSZXNvbHZlOiBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQsXG4gICAgICAgIG9uSW5zdGFuY2VQcm9taXNlOiBob3N0UmVmLiRvbkluc3RhbmNlUHJvbWlzZSQsXG4gICAgICAgIG9uSW5zdGFuY2VSZXNvbHZlOiBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQsXG4gICAgICAgIG9uUmVuZGVyUmVzb2x2ZTogaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCxcbiAgICAgICAgcXVldWVkTGlzdGVuZXJzOiBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLFxuICAgICAgICBybUxpc3RlbmVyczogaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLFxuICAgICAgICBbJ3MtaWQnXTogaG9zdEVsZW1lbnRbJ3MtaWQnXSxcbiAgICAgICAgWydzLWNyJ106IGhvc3RFbGVtZW50WydzLWNyJ10sXG4gICAgICAgIFsncy1sciddOiBob3N0RWxlbWVudFsncy1sciddLFxuICAgICAgICBbJ3MtcCddOiBob3N0RWxlbWVudFsncy1wJ10sXG4gICAgICAgIFsncy1yYyddOiBob3N0RWxlbWVudFsncy1yYyddLFxuICAgICAgICBbJ3Mtc2MnXTogaG9zdEVsZW1lbnRbJ3Mtc2MnXSxcbiAgICB9O1xufTtcbmNvbnN0IGluc3RhbGxEZXZUb29scyA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuZGV2VG9vbHMpIHtcbiAgICAgICAgY29uc3Qgc3RlbmNpbCA9ICh3aW4uc3RlbmNpbCA9IHdpbi5zdGVuY2lsIHx8IHt9KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbnNwZWN0ID0gc3RlbmNpbC5pbnNwZWN0O1xuICAgICAgICBzdGVuY2lsLmluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIG9yaWdpbmFsSW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsSW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3Qgcm9vdEFwcGxpZWRTdHlsZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJTdHlsZSA9IChzY29wZUlkLCBjc3NUZXh0LCBhbGxvd0NTKSA9PiB7XG4gICAgbGV0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICBpZiAoc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgJiYgYWxsb3dDUykge1xuICAgICAgICBzdHlsZSA9IChzdHlsZSB8fCBuZXcgQ1NTU3R5bGVTaGVldCgpKTtcbiAgICAgICAgc3R5bGUucmVwbGFjZShjc3NUZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gY3NzVGV4dDtcbiAgICB9XG4gICAgc3R5bGVzLnNldChzY29wZUlkLCBzdHlsZSk7XG59O1xuY29uc3QgYWRkU3R5bGUgPSAoc3R5bGVDb250YWluZXJOb2RlLCBjbXBNZXRhLCBtb2RlLCBob3N0RWxtKSA9PiB7XG4gICAgbGV0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIG1vZGUpO1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKCFCVUlMRC5hdHRhY2hTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlSWQ7XG4gICAgfVxuICAgIC8vIGlmIGFuIGVsZW1lbnQgaXMgTk9UIGNvbm5lY3RlZCB0aGVuIGdldFJvb3ROb2RlKCkgd2lsbCByZXR1cm4gdGhlIHdyb25nIHJvb3Qgbm9kZVxuICAgIC8vIHNvIHRoZSBmYWxsYmFjayBpcyB0byBhbHdheXMgdXNlIHRoZSBkb2N1bWVudCBmb3IgdGhlIHJvb3Qgbm9kZSBpbiB0aG9zZSBjYXNlc1xuICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLyA/IHN0eWxlQ29udGFpbmVyTm9kZSA6IGRvYztcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5oZWFkIHx8IHN0eWxlQ29udGFpbmVyTm9kZTtcbiAgICAgICAgICAgIGxldCBhcHBsaWVkU3R5bGVzID0gcm9vdEFwcGxpZWRTdHlsZXMuZ2V0KHN0eWxlQ29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgICBsZXQgc3R5bGVFbG07XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByb290QXBwbGllZFN0eWxlcy5zZXQoc3R5bGVDb250YWluZXJOb2RlLCAoYXBwbGllZFN0eWxlcyA9IG5ldyBTZXQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaG9zdCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGVFbG0gPSBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcihgWyR7SFlEUkFURURfU1RZTEVfSUR9PVwiJHtzY29wZUlkfVwiXWApKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgaGFwcGVuaW5nIG9uIG5hdGl2ZSBzaGFkb3ctZG9tLCBkbyBub3QgbmVlZHMgQ1NTIHZhciBzaGltXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmNzc1ZhclNoaW0gJiYgcGx0LiRjc3NTaGltJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBwbHQuJGNzc1NoaW0kLmNyZWF0ZUhvc3RTdHlsZShob3N0RWxtLCBzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTY29wZUlkID0gc3R5bGVFbG1bJ3Mtc2MnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVJZCA9IG5ld1Njb3BlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhZGQgdGhpcyBzdHlsZUlEIHRvIHRoZSBhcHBsaWVkU3R5bGVzIFNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjc3NWYXJTaGltIG1pZ2h0IG5lZWQgdG8gYXBwbHkgc2V2ZXJhbCBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXNoZWV0cyBmb3IgdGhlIHNhbWUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQsIHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKCdsaW5rJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkU3R5bGVzLmFkZChzY29wZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQuY29uc3RydWN0YWJsZUNTUyAmJiAhc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZUlkO1xufTtcbmNvbnN0IGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKCdhdHRhY2hTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IGFkZFN0eWxlKEJVSUxELnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBlbG0uc2hhZG93Um9vdCA/IGVsbS5zaGFkb3dSb290IDogZWxtLmdldFJvb3ROb2RlKCksIGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCwgZWxtKTtcbiAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIEJVSUxELmNzc0Fubm90YXRpb25zICYmIGZsYWdzICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAgICAgLy8gYW5kIHRoaXMgaG9zdCBlbGVtZW50IHdhcyBOT1QgY3JlYXRlZCB3aXRoIFNTUlxuICAgICAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBjb250ZW50IHdhcyBmaXJzdCBwbGFjZWQsIHdoaWNoIGlzIHVzZWZ1bCBsYXRlciBvblxuICAgICAgICAvLyBET00gV1JJVEUhIVxuICAgICAgICBlbG1bJ3Mtc2MnXSA9IHNjb3BlSWQ7XG4gICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLWgnKTtcbiAgICAgICAgaWYgKEJVSUxELnNjb3BlZCAmJiBmbGFncyAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCArICctcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbmNvbnN0IGdldFNjb3BlSWQgPSAoY21wLCBtb2RlKSA9PiAnc2MtJyArIChCVUlMRC5tb2RlICYmIG1vZGUgJiYgY21wLiRmbGFncyQgJiAzMiAvKiBoYXNNb2RlICovID8gY21wLiR0YWdOYW1lJCArICctJyArIG1vZGUgOiBjbXAuJHRhZ05hbWUkKTtcbmNvbnN0IGNvbnZlcnRTY29wZWRUb1NoYWRvdyA9IChjc3MpID0+IGNzcy5yZXBsYWNlKC9cXC9cXCohQChbXlxcL10rKVxcKlxcL1teXFx7XStcXHsvZywgJyQxeycpO1xuLy8gUHJpdmF0ZVxuY29uc3QgY29tcHV0ZU1vZGUgPSAoZWxtKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLm1hcCgoaCkgPT4gaChlbG0pKS5maW5kKChtKSA9PiAhIW0pO1xuLy8gUHVibGljXG5jb25zdCBzZXRNb2RlID0gKGhhbmRsZXIpID0+IG1vZGVSZXNvbHV0aW9uQ2hhaW4ucHVzaChoYW5kbGVyKTtcbmNvbnN0IGdldE1vZGUgPSAocmVmKSA9PiBnZXRIb3N0UmVmKHJlZikuJG1vZGVOYW1lJDtcbi8qKlxuICogRGVmYXVsdCBzdHlsZSBtb2RlIGlkXG4gKi9cbi8qKlxuICogUmV1c2FibGUgZW1wdHkgb2JqL2FycmF5XG4gKiBEb24ndCBhZGQgdmFsdWVzIHRvIHRoZXNlISFcbiAqL1xuY29uc3QgRU1QVFlfT0JKID0ge307XG4vKipcbiAqIE5hbWVzcGFjZXNcbiAqL1xuY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBpc0RlZiA9ICh2KSA9PiB2ICE9IG51bGw7XG5jb25zdCBpc0NvbXBsZXhUeXBlID0gKG8pID0+IHtcbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdHlwZW9mLWZuLW9iamVjdC81XG4gICAgbyA9IHR5cGVvZiBvO1xuICAgIHJldHVybiBvID09PSAnb2JqZWN0JyB8fCBvID09PSAnZnVuY3Rpb24nO1xufTtcbi8qKlxuICogUHJvZHVjdGlvbiBoKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbi8vIGNvbnN0IHN0YWNrOiBhbnlbXSA9IFtdO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgY2hpbGQ/OiBkLkNoaWxkVHlwZSk6IGQuVk5vZGU7XG4vLyBleHBvcnQgZnVuY3Rpb24gaChub2RlTmFtZTogc3RyaW5nIHwgZC5GdW5jdGlvbmFsQ29tcG9uZW50LCB2bm9kZURhdGE6IGQuUHJvcHNUeXBlLCAuLi5jaGlsZHJlbjogZC5DaGlsZFR5cGVbXSk6IGQuVk5vZGU7XG5jb25zdCBoID0gKG5vZGVOYW1lLCB2bm9kZURhdGEsIC4uLmNoaWxkcmVuKSA9PiB7XG4gICAgbGV0IGNoaWxkID0gbnVsbDtcbiAgICBsZXQga2V5ID0gbnVsbDtcbiAgICBsZXQgc2xvdE5hbWUgPSBudWxsO1xuICAgIGxldCBzaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgbGFzdFNpbXBsZSA9IGZhbHNlO1xuICAgIGxldCB2Tm9kZUNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgd2FsayA9IChjKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIHR5cGVvZiBjaGlsZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgIWlzQ29tcGxleFR5cGUoY2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBub2RlTmFtZSAhPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC4kZmxhZ3MkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZURldkVycm9yKGB2Tm9kZSBwYXNzZWQgYXMgY2hpbGRyZW4gaGFzIHVuZXhwZWN0ZWQgdHlwZS5cbk1ha2Ugc3VyZSBpdCdzIHVzaW5nIHRoZSBjb3JyZWN0IGgoKSBmdW5jdGlvbi5cbkVtcHR5IG9iamVjdHMgY2FuIGFsc28gYmUgdGhlIGNhdXNlLCBsb29rIGZvciBKU1ggY29tbWVudHMgdGhhdCBiZWNhbWUgb2JqZWN0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGlsZCB3YXMgc2ltcGxlIChzdHJpbmcpLCB3ZSBtZXJnZSBib3RoXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlQ2hpbGRyZW5bdk5vZGVDaGlsZHJlbi5sZW5ndGggLSAxXS4kdGV4dCQgKz0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYSBuZXcgdk5vZGUsIGlmIGl0J3MgdGV4dCwgd2UgY3JlYXRlIGEgdGV4dCB2Tm9kZVxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuLnB1c2goc2ltcGxlID8gbmV3Vk5vZGUobnVsbCwgY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB3YWxrKGNoaWxkcmVuKTtcbiAgICBpZiAodm5vZGVEYXRhKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiBub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXModm5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemUgY2xhc3MgLyBjbGFzc25hbWUgYXR0cmlidXRlc1xuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSAmJiB2bm9kZURhdGEua2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB2bm9kZURhdGEua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiB2bm9kZURhdGEubmFtZSkge1xuICAgICAgICAgICAgc2xvdE5hbWUgPSB2bm9kZURhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0RhdGEgPSB2bm9kZURhdGEuY2xhc3NOYW1lIHx8IHZub2RlRGF0YS5jbGFzcztcbiAgICAgICAgICAgIGlmIChjbGFzc0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZURhdGEuY2xhc3MgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2xhc3NEYXRhICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGFzc0RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXMoY2xhc3NEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGNsYXNzRGF0YVtrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiB2Tm9kZUNoaWxkcmVuLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LiBNYWtlIHN1cmU6XG4tIFlvdSBhcmUgTk9UIHVzaW5nIGhvc3REYXRhKCkgYW5kIDxIb3N0PiBpbiB0aGUgc2FtZSBjb21wb25lbnQuXG4tIDxIb3N0PiBpcyB1c2VkIG9uY2UsIGFuZCBpdCdzIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQgb2YgdGhlIHJlbmRlcigpIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUZ1bmN0aW9uYWwgJiYgdHlwZW9mIG5vZGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vZGVOYW1lIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIG5vZGVOYW1lKHZub2RlRGF0YSA9PT0gbnVsbCA/IHt9IDogdm5vZGVEYXRhLCB2Tm9kZUNoaWxkcmVuLCB2ZG9tRm5VdGlscyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZU5hbWUsIG51bGwpO1xuICAgIHZub2RlLiRhdHRycyQgPSB2bm9kZURhdGE7XG4gICAgaWYgKHZOb2RlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2bm9kZS4kY2hpbGRyZW4kID0gdk5vZGVDaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgdm5vZGUuJGtleSQgPSBrZXk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBzbG90TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IG5ld1ZOb2RlID0gKHRhZywgdGV4dCkgPT4ge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkdGFnJDogdGFnLFxuICAgICAgICAkdGV4dCQ6IHRleHQsXG4gICAgICAgICRlbG0kOiBudWxsLFxuICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgIH07XG4gICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgdm5vZGUuJGF0dHJzJCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIHZub2RlLiRuYW1lJCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBIb3N0ID0ge307XG5jb25zdCBpc0hvc3QgPSAobm9kZSkgPT4gbm9kZSAmJiBub2RlLiR0YWckID09PSBIb3N0O1xuY29uc3QgdmRvbUZuVXRpbHMgPSB7XG4gICAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gICAgbWFwOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5tYXAoY2IpLm1hcChjb252ZXJ0VG9Qcml2YXRlKSxcbn07XG5jb25zdCBjb252ZXJ0VG9QdWJsaWMgPSAobm9kZSkgPT4gKHtcbiAgICB2YXR0cnM6IG5vZGUuJGF0dHJzJCxcbiAgICB2Y2hpbGRyZW46IG5vZGUuJGNoaWxkcmVuJCxcbiAgICB2a2V5OiBub2RlLiRrZXkkLFxuICAgIHZuYW1lOiBub2RlLiRuYW1lJCxcbiAgICB2dGFnOiBub2RlLiR0YWckLFxuICAgIHZ0ZXh0OiBub2RlLiR0ZXh0JCxcbn0pO1xuY29uc3QgY29udmVydFRvUHJpdmF0ZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlLnZ0YWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZS52YXR0cnMpO1xuICAgICAgICBpZiAobm9kZS52a2V5KSB7XG4gICAgICAgICAgICB2bm9kZURhdGEua2V5ID0gbm9kZS52a2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnZuYW1lKSB7XG4gICAgICAgICAgICB2bm9kZURhdGEubmFtZSA9IG5vZGUudm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgobm9kZS52dGFnLCB2bm9kZURhdGEsIC4uLihub2RlLnZjaGlsZHJlbiB8fCBbXSkpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGUudnRhZywgbm9kZS52dGV4dCk7XG4gICAgdm5vZGUuJGF0dHJzJCA9IG5vZGUudmF0dHJzO1xuICAgIHZub2RlLiRjaGlsZHJlbiQgPSBub2RlLnZjaGlsZHJlbjtcbiAgICB2bm9kZS4ka2V5JCA9IG5vZGUudmtleTtcbiAgICB2bm9kZS4kbmFtZSQgPSBub2RlLnZuYW1lO1xuICAgIHJldHVybiB2bm9kZTtcbn07XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgb3JkZXJpbmcgb2YgYXR0cmlidXRlcyBvbiBhbiBpbnB1dCBlbGVtZW50XG4gKiBAcGFyYW0gaW5wdXRFbG0gdGhlIGVsZW1lbnQgdG8gdmFsaWRhdGVcbiAqL1xuY29uc3QgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXMgPSAoaW5wdXRFbG0pID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGlucHV0RWxtKTtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzLmluZGV4T2YoJ3ZhbHVlJyk7XG4gICAgaWYgKHZhbHVlID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGVJbmRleCA9IHByb3BzLmluZGV4T2YoJ3R5cGUnKTtcbiAgICBjb25zdCBtaW5JbmRleCA9IHByb3BzLmluZGV4T2YoJ21pbicpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gcHJvcHMuaW5kZXhPZignbWF4Jyk7XG4gICAgY29uc3Qgc3RlcEluZGV4ID0gcHJvcHMuaW5kZXhPZignc3RlcCcpO1xuICAgIGlmICh2YWx1ZSA8IHR5cGVJbmRleCB8fCB2YWx1ZSA8IG1pbkluZGV4IHx8IHZhbHVlIDwgbWF4SW5kZXggfHwgdmFsdWUgPCBzdGVwSW5kZXgpIHtcbiAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcInZhbHVlXCIgcHJvcCBvZiA8aW5wdXQ+IHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJtaW5cIiwgXCJtYXhcIiwgXCJ0eXBlXCIgYW5kIFwic3RlcFwiYCk7XG4gICAgfVxufTtcbi8qKlxuICogUHJvZHVjdGlvbiBzZXRBY2Nlc3NvcigpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG5jb25zdCBzZXRBY2Nlc3NvciA9IChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgaXNTdmcsIGZsYWdzKSA9PiB7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgaXNQcm9wID0gaXNNZW1iZXJJbkVsZW1lbnQoZWxtLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgbGV0IGxuID0gbWVtYmVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzICYmIG1lbWJlck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsbS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICBjb25zdCBvbGRDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3Qob2xkVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW5ld0NsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW9sZENsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tU3R5bGUgJiYgbWVtYmVyTmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHN0eWxlIGF0dHJpYnV0ZSwgY3NzIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgICAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8IG5ld1ZhbHVlW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgcHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFZhbHVlIHx8IG5ld1ZhbHVlW3Byb3BdICE9PSBvbGRWYWx1ZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIG5ld1ZhbHVlW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IG5ld1ZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21LZXkgJiYgbWVtYmVyTmFtZSA9PT0gJ2tleScpXG4gICAgICAgICAgICA7XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21SZWYgJiYgbWVtYmVyTmFtZSA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIC8vIG1pbmlmaWVyIHdpbGwgY2xlYW4gdGhpcyB1cFxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tTGlzdGVuZXIgJiZcbiAgICAgICAgICAgIChCVUlMRC5sYXp5TG9hZCA/ICFpc1Byb3AgOiAhZWxtLl9fbG9va3VwU2V0dGVyX18obWVtYmVyTmFtZSkpICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzBdID09PSAnbycgJiZcbiAgICAgICAgICAgIG1lbWJlck5hbWVbMV0gPT09ICduJykge1xuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxlcnNcbiAgICAgICAgICAgIC8vIHNvIGlmIHRoZSBtZW1iZXIgbmFtZSBzdGFydHMgd2l0aCBcIm9uXCIgYW5kIHRoZSAzcmQgY2hhcmFjdGVycyBpc1xuICAgICAgICAgICAgLy8gYSBjYXBpdGFsIGxldHRlciwgYW5kIGl0J3Mgbm90IGFscmVhZHkgYSBtZW1iZXIgb24gdGhlIGVsZW1lbnQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlJ3JlIGFzc3VtaW5nIGl0J3MgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmIChtZW1iZXJOYW1lWzJdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAvLyBvbi0gcHJlZml4ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRvIGJlIGV4cGxpY2l0IGFib3V0IHRoZSBkb20gZXZlbnQgdG8gbGlzdGVuIHdpdGhvdXQgYW55IG1hZ2ljXG4gICAgICAgICAgICAgICAgLy8gdW5kZXIgdGhlIGhvb2Q6XG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1jbGljaz4gLy8gbGlzdGVucyBmb3IgXCJjbGlja1wiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1DbGljaz4gLy8gbGlzdGVucyBmb3IgXCJDbGlja1wiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1pb25DaGFuZ2U+IC8vIGxpc3RlbnMgZm9yIFwiaW9uQ2hhbmdlXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLUVWRU5UUz4gLy8gbGlzdGVucyBmb3IgXCJFVkVOVFNcIlxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNNZW1iZXJJbkVsZW1lbnQod2luLCBsbikpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSBKU1ggYXR0cmlidXRlIGNvdWxkIGhhdmUgYmVlbiBcIm9uTW91c2VPdmVyXCIgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1lbWJlciBuYW1lIFwib25tb3VzZW92ZXJcIiBpcyBvbiB0aGUgd2luZG93J3MgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgYWRkIHRoZSBsaXN0ZW5lciBcIm1vdXNlb3ZlclwiLCB3aGljaCBpcyBhbGwgbG93ZXJjYXNlZFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbi5zbGljZSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSBKU1ggYXR0cmlidXRlIGNvdWxkIGhhdmUgYmVlbiBcIm9uTXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgdHJpbSBvZmYgdGhlIFwib25cIiBwcmVmaXggYW5kIGxvd2VyY2FzZSB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgbGlzdGVuZXIgXCJteUN1c3RvbUV2ZW50XCJcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIHdlIGtlZXAgdGhlIGV2ZW50IG5hbWUgY2FzZVxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsblsyXSArIG1lbWJlck5hbWUuc2xpY2UoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQucmVsKGVsbSwgbWVtYmVyTmFtZSwgb2xkVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5hZWwoZWxtLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21Qcm9wT3JBdHRyKSB7XG4gICAgICAgICAgICAvLyBTZXQgcHJvcGVydHkgaWYgaXQgZXhpc3RzIGFuZCBpdCdzIG5vdCBhIFNWR1xuICAgICAgICAgICAgY29uc3QgaXNDb21wbGV4ID0gaXNDb21wbGV4VHlwZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoKGlzUHJvcCB8fCAoaXNDb21wbGV4ICYmIG5ld1ZhbHVlICE9PSBudWxsKSkgJiYgIWlzU3ZnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbG0udGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IG5ld1ZhbHVlID09IG51bGwgPyAnJyA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgU2FmYXJpLCBtb3ZpbmcgdGhlIDxpbnB1dD4gY2FyZXQgd2hlbiByZS1hc3NpZ25pbmcgdGhlIHNhbWUgdmFsdWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyTmFtZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZSA9PSBudWxsIHx8IGVsbVttZW1iZXJOYW1lXSAhPSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmVlZCB0byBtYW51YWxseSB1cGRhdGUgYXR0cmlidXRlIGlmOlxuICAgICAgICAgICAgICogLSBtZW1iZXJOYW1lIGlzIG5vdCBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIC0gaWYgd2UgYXJlIHJlbmRlcmluZyB0aGUgaG9zdCBlbGVtZW50IGluIG9yZGVyIHRvIHJlZmxlY3QgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIGl0J3MgYSBTVkcsIHNpbmNlIHByb3BlcnRpZXMgbWlnaHQgbm90IHdvcmsgaW4gPHN2Zz5cbiAgICAgICAgICAgICAqIC0gaWYgdGhlIG5ld1ZhbHVlIGlzIG51bGwvdW5kZWZpbmVkIG9yICdmYWxzZScuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCB4bGluayA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluaykge1xuICAgICAgICAgICAgICAgIGlmIChsbiAhPT0gKGxuID0gbG4ucmVwbGFjZSgvXnhsaW5rXFw6Py8sICcnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuO1xuICAgICAgICAgICAgICAgICAgICB4bGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmYWxzZSB8fCBlbG0uZ2V0QXR0cmlidXRlKG1lbWJlck5hbWUpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQudmRvbVhsaW5rICYmIHhsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghaXNQcm9wIHx8IGZsYWdzICYgNCAvKiBpc0hvc3QgKi8gfHwgaXNTdmcpICYmICFpc0NvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB0cnVlID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQudmRvbVhsaW5rICYmIHhsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgbWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShtZW1iZXJOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlQ2xhc3NMaXN0UmVnZXggPSAvXFxzLztcbmNvbnN0IHBhcnNlQ2xhc3NMaXN0ID0gKHZhbHVlKSA9PiAoIXZhbHVlID8gW10gOiB2YWx1ZS5zcGxpdChwYXJzZUNsYXNzTGlzdFJlZ2V4KSk7XG5jb25zdCB1cGRhdGVFbGVtZW50ID0gKG9sZFZub2RlLCBuZXdWbm9kZSwgaXNTdmdNb2RlLCBtZW1iZXJOYW1lKSA9PiB7XG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgcGFzc2VkIGluIGlzIGEgc2hhZG93IHJvb3QsIHdoaWNoIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAvLyB0aGVuIHdlIHdhbnQgdG8gYmUgYWRkaW5nIGF0dHJzL3Byb3BzIHRvIHRoZSBzaGFkb3cgcm9vdCdzIFwiaG9zdFwiIGVsZW1lbnRcbiAgICAvLyBpZiBpdCdzIG5vdCBhIHNoYWRvdyByb290LCB0aGVuIHdlIGFkZCBhdHRycy9wcm9wcyB0byB0aGUgc2FtZSBlbGVtZW50XG4gICAgY29uc3QgZWxtID0gbmV3Vm5vZGUuJGVsbSQubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gJiYgbmV3Vm5vZGUuJGVsbSQuaG9zdFxuICAgICAgICA/IG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgOiBuZXdWbm9kZS4kZWxtJDtcbiAgICBjb25zdCBvbGRWbm9kZUF0dHJzID0gKG9sZFZub2RlICYmIG9sZFZub2RlLiRhdHRycyQpIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdWbm9kZUF0dHJzID0gbmV3Vm5vZGUuJGF0dHJzJCB8fCBFTVBUWV9PQko7XG4gICAgaWYgKEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICAvLyByZW1vdmUgYXR0cmlidXRlcyBubyBsb25nZXIgcHJlc2VudCBvbiB0aGUgdm5vZGUgYnkgc2V0dGluZyB0aGVtIHRvIHVuZGVmaW5lZFxuICAgICAgICBmb3IgKG1lbWJlck5hbWUgaW4gb2xkVm5vZGVBdHRycykge1xuICAgICAgICAgICAgaWYgKCEobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSkge1xuICAgICAgICAgICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgdW5kZWZpbmVkLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBuZXcgJiB1cGRhdGUgY2hhbmdlZCBhdHRyaWJ1dGVzXG4gICAgZm9yIChtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpIHtcbiAgICAgICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBuZXdWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgIH1cbn07XG5jb25zdCBjcmVhdGVFbG0gPSAob2xkUGFyZW50Vk5vZGUsIG5ld1BhcmVudFZOb2RlLCBjaGlsZEluZGV4LCBwYXJlbnRFbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBuZXdWTm9kZSA9IG5ld1BhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRJbmRleF07XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBlbG07XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgb2xkVk5vZGU7XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmICF1c2VOYXRpdmVTaGFkb3dEb20pIHtcbiAgICAgICAgLy8gcmVtZW1iZXIgZm9yIGxhdGVyIHdlIG5lZWQgdG8gY2hlY2sgdG8gcmVsb2NhdGUgbm9kZXNcbiAgICAgICAgY2hlY2tTbG90UmVsb2NhdGUgPSB0cnVlO1xuICAgICAgICBpZiAobmV3Vk5vZGUuJHRhZyQgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzY29wZWQgY3NzIG5lZWRzIHRvIGFkZCBpdHMgc2NvcGVkIGlkIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgIHBhcmVudEVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZOb2RlLiRmbGFncyQgfD0gbmV3Vk5vZGUuJGNoaWxkcmVuJFxuICAgICAgICAgICAgICAgID8gLy8gc2xvdCBlbGVtZW50IGhhcyBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA6IC8vIHNsb3QgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGZhbGxiYWNrIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIG5ld1ZOb2RlLiRlbG0kKSB7XG4gICAgICAgIGNvbnNvbGVEZXZFcnJvcihgVGhlIEpTWCAke25ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCA/IGBcIiR7bmV3Vk5vZGUuJHRleHQkfVwiIHRleHRgIDogYFwiJHtuZXdWTm9kZS4kdGFnJH1cIiBlbGVtZW50YH0gbm9kZSBzaG91bGQgbm90IGJlIHNoYXJlZCB3aXRoaW4gdGhlIHNhbWUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjYWNoZXMgZWxlbWVudCBsb29rdXBzIGluIG9yZGVyIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuIEhvd2V2ZXIsIGEgc2lkZSBlZmZlY3QgZnJvbSB0aGlzIGlzIHRoYXQgdGhlIGV4YWN0IHNhbWUgSlNYIG5vZGUgc2hvdWxkIG5vdCBiZSByZXVzZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvdGVtcGxhdGluZy1qc3gjYXZvaWQtc2hhcmVkLWpzeC1ub2Rlc2ApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbVRleHQgJiYgbmV3Vk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcbiAgICAgICAgZWxtID0gbmV3Vk5vZGUuJGVsbSQgPSBkb2MuY3JlYXRlVGV4dE5vZGUobmV3Vk5vZGUuJHRleHQkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDEgLyogaXNTbG90UmVmZXJlbmNlICovKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHNsb3QgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgZWxtID0gbmV3Vk5vZGUuJGVsbSQgPVxuICAgICAgICAgICAgQlVJTEQuaXNEZWJ1ZyB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUobmV3Vk5vZGUpIDogZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgIWlzU3ZnTW9kZSkge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbmV3Vk5vZGUuJHRhZyQgPT09ICdzdmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gKEJVSUxELnN2Z1xuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKGlzU3ZnTW9kZSA/IFNWR19OUyA6IEhUTUxfTlMsIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgPyAnc2xvdC1mYidcbiAgICAgICAgICAgICAgICA6IG5ld1ZOb2RlLiR0YWckKVxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJCkpO1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiBuZXdWTm9kZS4kdGFnJCA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY3NzIGNsYXNzZXMsIGF0dHJzLCBwcm9wcywgbGlzdGVuZXJzLCBldGMuXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVFbGVtZW50KG51bGwsIG5ld1ZOb2RlLCBpc1N2Z01vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoQlVJTEQuc2hhZG93RG9tIHx8IEJVSUxELnNjb3BlZCkgJiYgaXNEZWYoc2NvcGVJZCkgJiYgZWxtWydzLXNpJ10gIT09IHNjb3BlSWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2NvcGVJZCBhbmQgdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0J3MgYWRkIHRoZSBzY29wZUlkIGFzIGEgY3NzIGNsYXNzXG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZCgoZWxtWydzLXNpJ10gPSBzY29wZUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdWTm9kZS4kY2hpbGRyZW4kLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY3JlYXRlRWxtKG9sZFBhcmVudFZOb2RlLCBuZXdWTm9kZSwgaSwgZWxtKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbm9kZSBjb3VsZCBoYXZlIGJlZW4gbnVsbFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIG91ciBuZXcgbm9kZVxuICAgICAgICAgICAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnN2Zykge1xuICAgICAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIFNWRyBjb250ZXh0IHdoZW4gd2UncmUgZXhpdGluZyA8c3ZnPiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbG0udGFnTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVlbnRlciBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPGZvcmVpZ25PYmplY3Q+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpc1N2Z01vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBlbG1bJ3MtaG4nXSA9IGhvc3RUYWdOYW1lO1xuICAgICAgICBpZiAobmV3Vk5vZGUuJGZsYWdzJCAmICgyIC8qIGlzU2xvdEZhbGxiYWNrICovIHwgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi8pKSB7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudFxuICAgICAgICAgICAgZWxtWydzLXNyJ10gPSB0cnVlO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1jciddID0gY29udGVudFJlZjtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBzbG90IG5hbWUsIG9yIGVtcHR5IHN0cmluZyBmb3IgZGVmYXVsdCBzbG90XG4gICAgICAgICAgICBlbG1bJ3Mtc24nXSA9IG5ld1ZOb2RlLiRuYW1lJCB8fCAnJztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlJ3ZlIGdvdCBhbiBvbGQgdm5vZGUgZm9yIHRoaXMgc2xvdFxuICAgICAgICAgICAgb2xkVk5vZGUgPSBvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kICYmIG9sZFBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRJbmRleF07XG4gICAgICAgICAgICBpZiAob2xkVk5vZGUgJiYgb2xkVk5vZGUuJHRhZyQgPT09IG5ld1ZOb2RlLiR0YWckICYmIG9sZFBhcmVudFZOb2RlLiRlbG0kKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgZ290IGFuIG9sZCBzbG90IHZub2RlIGFuZCB0aGUgd3JhcHBlciBpcyBiZWluZyByZXBsYWNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIG1vdmUgdGhlIG9sZCBzbG90IGNvbnRlbnQgYmFjayB0byBpdCdzIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRQYXJlbnRWTm9kZS4kZWxtJCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbG07XG59O1xuY29uc3QgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbiA9IChwYXJlbnRFbG0sIHJlY3Vyc2l2ZSkgPT4ge1xuICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgY29uc3Qgb2xkU2xvdENoaWxkTm9kZXMgPSBwYXJlbnRFbG0uY2hpbGROb2RlcztcbiAgICBmb3IgKGxldCBpID0gb2xkU2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gb2xkU2xvdENoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3MtaG4nXSAhPT0gaG9zdFRhZ05hbWUgJiYgY2hpbGROb2RlWydzLW9sJ10pIHtcbiAgICAgICAgICAgIC8vIC8vIHRoaXMgY2hpbGQgbm9kZSBpbiB0aGUgb2xkIGVsZW1lbnQgaXMgZnJvbSBhbm90aGVyIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gLy8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHRoZSBvbGQgc2xvdCdzIHBhcmVudFxuICAgICAgICAgICAgLy8gY2hpbGROb2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gYW5kIHJlbG9jYXRlIGl0IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShjaGlsZE5vZGUpLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9sZCBvcmlnaW5hbCBsb2NhdGlvbiBjb21tZW50IGVudGlyZWx5XG4gICAgICAgICAgICAvLyBsYXRlciBvbiB0aGUgcGF0Y2ggZnVuY3Rpb24gd2lsbCBrbm93IHdoYXQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuZCBtb3ZlIHRoaXMgdG8gdGhlIGNvcnJlY3Qgc3BvdCBpbiBuZWVkIGJlXG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNoaWxkTm9kZVsncy1vbCddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2hlY2tTbG90UmVsb2NhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oY2hpbGROb2RlLCByZWN1cnNpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsdC4kZmxhZ3MkICY9IH4xIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xufTtcbmNvbnN0IGFkZFZub2RlcyA9IChwYXJlbnRFbG0sIGJlZm9yZSwgcGFyZW50Vk5vZGUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkgPT4ge1xuICAgIGxldCBjb250YWluZXJFbG0gPSAoKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHBhcmVudEVsbVsncy1jciddICYmIHBhcmVudEVsbVsncy1jciddLnBhcmVudE5vZGUpIHx8IHBhcmVudEVsbSk7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIGNvbnRhaW5lckVsbS5zaGFkb3dSb290ICYmIGNvbnRhaW5lckVsbS50YWdOYW1lID09PSBob3N0VGFnTmFtZSkge1xuICAgICAgICBjb250YWluZXJFbG0gPSBjb250YWluZXJFbG0uc2hhZG93Um9vdDtcbiAgICB9XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICBpZiAodm5vZGVzW3N0YXJ0SWR4XSkge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY3JlYXRlRWxtKG51bGwsIHBhcmVudFZOb2RlLCBzdGFydElkeCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bm9kZXNbc3RhcnRJZHhdLiRlbG0kID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsbS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBCVUlMRC5zbG90UmVsb2NhdGlvbiA/IHJlZmVyZW5jZU5vZGUoYmVmb3JlKSA6IGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVtb3ZlVm5vZGVzID0gKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgdm5vZGUsIGVsbSkgPT4ge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKCh2bm9kZSA9IHZub2Rlc1tzdGFydElkeF0pKSB7XG4gICAgICAgICAgICBlbG0gPSB2bm9kZS4kZWxtJDtcbiAgICAgICAgICAgIGNhbGxOb2RlUmVmcyh2bm9kZSk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZW1vdmluZyB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG8gc2hvdyBzbG90IGZhbGxiYWNrIGNvbnRlbnQgbm93XG4gICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGVsbVsncy1vbCddLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IGNoaWxkIG5vZGVzIG9mIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQncyBiZWluZyByZW1vdmVkIGFyZSBzbG90IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oZWxtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHZub2RlJ3MgZWxlbWVudCBmcm9tIHRoZSBkb21cbiAgICAgICAgICAgIGVsbS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB1cGRhdGVDaGlsZHJlbiA9IChwYXJlbnRFbG0sIG9sZENoLCBuZXdWTm9kZSwgbmV3Q2gpID0+IHtcbiAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgIGxldCBuZXdTdGFydElkeCA9IDA7XG4gICAgbGV0IGlkeEluT2xkID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZWxtVG9Nb3ZlO1xuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkRW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3RW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnIHx8IG5ld0VuZFZub2RlLiR0YWckID09PSAnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkU3RhcnRWbm9kZS4kZWxtJCwgb2xkRW5kVm5vZGUuJGVsbSQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkRW5kVm5vZGUuJGVsbSQucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRFbmRWbm9kZS4kZWxtJCwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZUtleVRvT2xkSWR4XG4gICAgICAgICAgICBpZHhJbk9sZCA9IC0xO1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBvbGRTdGFydElkeDsgaSA8PSBvbGRFbmRJZHg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ2hbaV0gJiYgb2xkQ2hbaV0uJGtleSQgIT09IG51bGwgJiYgb2xkQ2hbaV0uJGtleSQgPT09IG5ld1N0YXJ0Vm5vZGUuJGtleSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgaWR4SW5PbGQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLiR0YWckICE9PSBuZXdTdGFydFZub2RlLiR0YWckKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgaWR4SW5PbGQsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbG1Ub01vdmUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlLCBuZXdTdGFydElkeCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpLmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUuJGVsbSQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLiRlbG0kLCBuZXdWTm9kZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC51cGRhdGFibGUgJiYgbmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG59O1xuY29uc3QgaXNTYW1lVm5vZGUgPSAodm5vZGUxLCB2bm9kZTIpID0+IHtcbiAgICAvLyBjb21wYXJlIGlmIHR3byB2bm9kZSB0byBzZWUgaWYgdGhleSdyZSBcInRlY2huaWNhbGx5XCIgdGhlIHNhbWVcbiAgICAvLyBuZWVkIHRvIGhhdmUgdGhlIHNhbWUgZWxlbWVudCB0YWcsIGFuZCBzYW1lIGtleSB0byBiZSB0aGUgc2FtZVxuICAgIGlmICh2bm9kZTEuJHRhZyQgPT09IHZub2RlMi4kdGFnJCkge1xuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGUxLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTEuJG5hbWUkID09PSB2bm9kZTIuJG5hbWUkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRrZXkkID09PSB2bm9kZTIuJGtleSQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCByZWZlcmVuY2VOb2RlID0gKG5vZGUpID0+IHtcbiAgICAvLyB0aGlzIG5vZGUgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBsb2NhdGlvbiBpbiB0aGUgZG9tXG4gICAgLy8gYmVjYXVzZSBvZiBzb21lIG90aGVyIGNvbXBvbmVudCdzIHNsb3RcbiAgICAvLyBidXQgd2Ugc3RpbGwgaGF2ZSBhbiBodG1sIGNvbW1lbnQgaW4gcGxhY2Ugb2Ygd2hlcmVcbiAgICAvLyBpdCdzIG9yaWdpbmFsIGxvY2F0aW9uIHdhcyBhY2NvcmRpbmcgdG8gaXQncyBvcmlnaW5hbCB2ZG9tXG4gICAgcmV0dXJuIChub2RlICYmIG5vZGVbJ3Mtb2wnXSkgfHwgbm9kZTtcbn07XG5jb25zdCBwYXJlbnRSZWZlcmVuY2VOb2RlID0gKG5vZGUpID0+IChub2RlWydzLW9sJ10gPyBub2RlWydzLW9sJ10gOiBub2RlKS5wYXJlbnROb2RlO1xuY29uc3QgcGF0Y2ggPSAob2xkVk5vZGUsIG5ld1ZOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxtID0gKG5ld1ZOb2RlLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQpO1xuICAgIGNvbnN0IG9sZENoaWxkcmVuID0gb2xkVk5vZGUuJGNoaWxkcmVuJDtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld1ZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgdGFnID0gbmV3Vk5vZGUuJHRhZyQ7XG4gICAgY29uc3QgdGV4dCA9IG5ld1ZOb2RlLiR0ZXh0JDtcbiAgICBsZXQgZGVmYXVsdEhvbGRlcjtcbiAgICBpZiAoIUJVSUxELnZkb21UZXh0IHx8IHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKEJVSUxELnN2Zykge1xuICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZW5kZXJpbmcgYW4gc3ZnIGVsZW1lbnQsIG9yIHN0aWxsIHJlbmRlcmluZyBub2RlcyBpbnNpZGUgb2Ygb25lXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGlzIHRvIHRoZSB3aGVuIHRoZSBjb21waWxlciBzZWVzIHdlJ3JlIHVzaW5nIGFuIHN2ZyBzb21ld2hlcmVcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRhZyA9PT0gJ3N2ZycgPyB0cnVlIDogdGFnID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbGVtZW50IG5vZGVcbiAgICAgICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUgfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3QgJiYgdGFnID09PSAnc2xvdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBvZiBhbiBlbGVtZW50IE9SIGl0J3MgYW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gQU5EIHdlIGFscmVhZHkga25vdyBpdCdzIHBvc3NpYmxlIGl0IGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgZWxlbWVudCdzIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQob2xkVk5vZGUsIG5ld1ZOb2RlLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgb2xkQ2hpbGRyZW4gIT09IG51bGwgJiYgbmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhlcmUncyBjaGlsZCB2bm9kZXMgZm9yIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZub2Rlc1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaGlsZHJlbiwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gb2xkIGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBuZXcgY2hpbGQgdm5vZGVzIHRvIGFkZFxuICAgICAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZub2RlIHdhcyB0ZXh0LCBzbyBiZSBzdXJlIHRvIGNsZWFyIGl0IG91dFxuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgdm5vZGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbiwgMCwgbmV3Q2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBuZXcgY2hpbGQgdm5vZGVzLCBidXQgdGhlcmUgYXJlIG9sZCBjaGlsZCB2bm9kZXMgdG8gcmVtb3ZlXG4gICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2hpbGRyZW4sIDAsIG9sZENoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgaXNTdmdNb2RlICYmIHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChkZWZhdWx0SG9sZGVyID0gZWxtWydzLWNyJ10pKSB7XG4gICAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgc2xvdHRlZCBjb250ZW50XG4gICAgICAgIGRlZmF1bHRIb2xkZXIucGFyZW50Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIG9sZFZOb2RlLiR0ZXh0JCAhPT0gdGV4dCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIHRleHQgb25seSB2bm9kZVxuICAgICAgICAvLyBhbmQgYWxzbyBvbmx5IGlmIHRoZSB0ZXh0IGlzIGRpZmZlcmVudCB0aGFuIGJlZm9yZVxuICAgICAgICBlbG0uZGF0YSA9IHRleHQ7XG4gICAgfVxufTtcbmNvbnN0IHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkgPSAoZWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgY2hpbGROb2RlcyA9IGVsbS5jaGlsZE5vZGVzO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IGk7XG4gICAgbGV0IGlsZW47XG4gICAgbGV0IGo7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgbm9kZVR5cGU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG90IGZhbGxiYWNrIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNsb3QgbmFtZSBmb3IgdGhpcyBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgc2xvdE5hbWVBdHRyID0gY2hpbGROb2RlWydzLXNuJ107XG4gICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbHdheXMgc2hvdyBhIGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaGlkZSBpdCBpZiB0aGVyZSBhcmUgb3RoZXIgc2xvdHMgaW4gdGhlIGxpZ2h0IGRvbVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaWxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gY2hpbGROb2Rlc1tqXS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal1bJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10gfHwgc2xvdE5hbWVBdHRyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzaWJsaW5nIG5vZGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgT1IgaXMgYSBuYW1lZCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyAmJiBzbG90TmFtZUF0dHIgPT09IGNoaWxkTm9kZXNbal0uZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkZWZhdWx0IGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IGVsZW1lbnQgb3IgdGV4dCBub2RlICh3aXRoIGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgaGlkZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLyAmJiBjaGlsZE5vZGVzW2pdLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWVwIGRyaWxsaW5nIGRvd25cbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZWxvY2F0ZU5vZGVzID0gW107XG5jb25zdCByZWxvY2F0ZVNsb3RDb250ZW50ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgaG9zdENvbnRlbnROb2RlcztcbiAgICBsZXQgc2xvdE5hbWVBdHRyO1xuICAgIGxldCByZWxvY2F0ZU5vZGVEYXRhO1xuICAgIGxldCBqO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlcyA9IGVsbS5jaGlsZE5vZGVzO1xuICAgIGxldCBpbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVsncy1zciddICYmIChub2RlID0gY2hpbGROb2RlWydzLWNyJ10pICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgZ290IHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50IG5vZGVcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZ290IGl0J3MgcGFyZW50LCB3aGljaCBpcyB3aGVyZSBhbGwgdGhlIGhvc3QgY29udGVudCBpcyBpbiBub3dcbiAgICAgICAgICAgIGhvc3RDb250ZW50Tm9kZXMgPSBub2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgZm9yIChqID0gaG9zdENvbnRlbnROb2Rlcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBob3N0Q29udGVudE5vZGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVsncy1jbiddICYmICFub2RlWydzLW5yJ10gJiYgbm9kZVsncy1obiddICE9PSBjaGlsZE5vZGVbJ3MtaG4nXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBkbyBzb21lIHJlbG9jYXRpbmcgdG8gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBuZXZlciByZWxvY2F0ZSBhIGNvbnRlbnQgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBpcyBzdXBwb3NlIHRvIGFsd2F5cyByZXByZXNlbnQgdGhlIG9yaWdpbmFsIGNvbnRlbnQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZUxvY2F0ZWRJblNsb3Qobm9kZSwgc2xvdE5hbWVBdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB3ZSd2ZSBhbHJlYWR5IGRlY2lkZWQgdG8gcmVsb2NhdGUgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFkZSBzb21lIGNoYW5nZXMgdG8gc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB3ZSBhbHNvIGRvdWJsZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2tzIGFyZSBjb3JyZWN0bHkgaGlkZGVuIG9yIHNob3duXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gbm9kZVsncy1zbiddIHx8IHNsb3ROYW1lQXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNseSB3ZSBuZXZlciBmb3VuZCBhIHNsb3QgaG9tZSBmb3IgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHR1cm5zIG91dCB3ZSBkaWQsIHNvIGxldCdzIHJlbWVtYmVyIGl0IG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZURhdGEuJHNsb3RSZWZOb2RlJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byBvdXIgbGlzdCBvZiBub2RlcyB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzbG90UmVmTm9kZSQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLm1hcCgocmVsb2NhdGVOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KHJlbG9jYXRlTm9kZS4kbm9kZVRvUmVsb2NhdGUkLCBub2RlWydzLXNuJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbG9jYXRlTm9kZURhdGEgJiYgIXJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlLiRzbG90UmVmTm9kZSQgPSByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVsb2NhdGVOb2Rlcy5zb21lKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmYXIgdGhpcyBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBzbG90IGhvbWUsIG5vdCBzZXR0aW5nIHNsb3RSZWZOb2RlIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIG5ldmVyIGZpbmQgYSBob21lIGZvciB0aGlzIGVsZW1lbnQgdGhlbiB3ZSdsbCBuZWVkIHRvIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIHJlbG9jYXRlU2xvdENvbnRlbnQoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpc05vZGVMb2NhdGVkSW5TbG90ID0gKG5vZGVUb1JlbG9jYXRlLCBzbG90TmFtZUF0dHIpID0+IHtcbiAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLmdldEF0dHJpYnV0ZSgnc2xvdCcpID09PSBudWxsICYmIHNsb3ROYW1lQXR0ciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlVG9SZWxvY2F0ZVsncy1zbiddID09PSBzbG90TmFtZUF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90TmFtZUF0dHIgPT09ICcnO1xufTtcbmNvbnN0IGNhbGxOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICAgIGlmIChCVUlMRC52ZG9tUmVmKSB7XG4gICAgICAgIHZOb2RlLiRhdHRycyQgJiYgdk5vZGUuJGF0dHJzJC5yZWYgJiYgdk5vZGUuJGF0dHJzJC5yZWYobnVsbCk7XG4gICAgICAgIHZOb2RlLiRjaGlsZHJlbiQgJiYgdk5vZGUuJGNoaWxkcmVuJC5tYXAoY2FsbE5vZGVSZWZzKTtcbiAgICB9XG59O1xuY29uc3QgcmVuZGVyVmRvbSA9IChob3N0UmVmLCByZW5kZXJGblJlc3VsdHMpID0+IHtcbiAgICBjb25zdCBob3N0RWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBvbGRWTm9kZSA9IGhvc3RSZWYuJHZub2RlJCB8fCBuZXdWTm9kZShudWxsLCBudWxsKTtcbiAgICBjb25zdCByb290Vm5vZGUgPSBpc0hvc3QocmVuZGVyRm5SZXN1bHRzKSA/IHJlbmRlckZuUmVzdWx0cyA6IGgobnVsbCwgbnVsbCwgcmVuZGVyRm5SZXN1bHRzKTtcbiAgICBob3N0VGFnTmFtZSA9IGhvc3RFbG0udGFnTmFtZTtcbiAgICAvLyA8SG9zdD4gcnVudGltZSBjaGVja1xuICAgIGlmIChCVUlMRC5pc0RldiAmJiBBcnJheS5pc0FycmF5KHJlbmRlckZuUmVzdWx0cykgJiYgcmVuZGVyRm5SZXN1bHRzLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LlxuTG9va3MgbGlrZSB0aGUgcmVuZGVyKCkgZnVuY3Rpb24gb2YgXCIke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9XCIgaXMgcmV0dXJuaW5nIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIDxIb3N0Pi5cblxuVGhlIHJlbmRlcigpIGZ1bmN0aW9uIHNob3VsZCBsb29rIGxpa2UgdGhpcyBpbnN0ZWFkOlxuXG5yZW5kZXIoKSB7XG4gIC8vIERvIG5vdCByZXR1cm4gYW4gYXJyYXlcbiAgcmV0dXJuIChcbiAgICA8SG9zdD57Y29udGVudH08L0hvc3Q+XG4gICk7XG59XG4gIGApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCAmJiBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQpIHtcbiAgICAgICAgcm9vdFZub2RlLiRhdHRycyQgPSByb290Vm5vZGUuJGF0dHJzJCB8fCB7fTtcbiAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLm1hcCgoW3Byb3BOYW1lLCBhdHRyaWJ1dGVdKSA9PiAocm9vdFZub2RlLiRhdHRycyRbYXR0cmlidXRlXSA9IGhvc3RFbG1bcHJvcE5hbWVdKSk7XG4gICAgfVxuICAgIHJvb3RWbm9kZS4kdGFnJCA9IG51bGw7XG4gICAgcm9vdFZub2RlLiRmbGFncyQgfD0gNCAvKiBpc0hvc3QgKi87XG4gICAgaG9zdFJlZi4kdm5vZGUkID0gcm9vdFZub2RlO1xuICAgIHJvb3RWbm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kID0gKEJVSUxELnNoYWRvd0RvbSA/IGhvc3RFbG0uc2hhZG93Um9vdCB8fCBob3N0RWxtIDogaG9zdEVsbSk7XG4gICAgaWYgKEJVSUxELnNjb3BlZCB8fCBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgc2NvcGVJZCA9IGhvc3RFbG1bJ3Mtc2MnXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnRlbnRSZWYgPSBob3N0RWxtWydzLWNyJ107XG4gICAgICAgIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IHN1cHBvcnRzU2hhZG93ICYmIChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pICE9PSAwO1xuICAgICAgICAvLyBhbHdheXMgcmVzZXRcbiAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHN5bmNocm9ub3VzIHBhdGNoXG4gICAgcGF0Y2gob2xkVk5vZGUsIHJvb3RWbm9kZSk7XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIC8vIHdoaWxlIHdlJ3JlIG1vdmluZyBub2RlcyBhcm91bmQgZXhpc3Rpbmcgbm9kZXMsIHRlbXBvcmFyaWx5IGRpc2FibGVcbiAgICAgICAgLy8gdGhlIGRpc2Nvbm5lY3RDYWxsYmFjayBmcm9tIHdvcmtpbmdcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgaWYgKGNoZWNrU2xvdFJlbG9jYXRlKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBsZXQgcmVsb2NhdGVEYXRhO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgbGV0IG9yZ0xvY2F0aW9uTm9kZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlUmVmO1xuICAgICAgICAgICAgbGV0IGluc2VydEJlZm9yZU5vZGU7XG4gICAgICAgICAgICBsZXQgcmVmTm9kZTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgcmVmZXJlbmNlIG5vZGUgbWFya2luZyB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBmb3IgbGF0ZXIgbG9va3Vwc1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgQlVJTEQuaXNEZWJ1ZyB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZShub2RlVG9SZWxvY2F0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZVsncy1uciddID0gbm9kZVRvUmVsb2NhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKChub2RlVG9SZWxvY2F0ZVsncy1vbCddID0gb3JnTG9jYXRpb25Ob2RlKSwgbm9kZVRvUmVsb2NhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWxvY2F0ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVsb2NhdGVEYXRhID0gcmVsb2NhdGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlJ3JlIGp1c3QgZ29pbmcgdG8gaW5zZXJ0IGl0IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGVSZWYgPSByZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgob3JnTG9jYXRpb25Ob2RlID0gb3JnTG9jYXRpb25Ob2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZOb2RlICYmIHJlZk5vZGVbJ3Mtc24nXSA9PT0gbm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSAmJiBwYXJlbnROb2RlUmVmID09PSByZWZOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gcmVmTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZk5vZGUgfHwgIXJlZk5vZGVbJ3MtbnInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVmTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWluc2VydEJlZm9yZU5vZGUgJiYgcGFyZW50Tm9kZVJlZiAhPT0gbm9kZVRvUmVsb2NhdGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLm5leHRTaWJsaW5nICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBjaGVja2VkIHRoYXQgaXQncyB3b3J0aCB3aGlsZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhhdCB0aGUgbm9kZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IG5leHQgc2libGluZyBvciBwYXJlbnQgcmVsb2NhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUgIT09IGluc2VydEJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLWhuJ10gJiYgbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhIGNvbXBvbmVudCBpbiB0aGUgaW5kZXguaHRtbCB0aGF0IGRvZXNuJ3QgaGF2ZSBpdCdzIGhvc3RuYW1lIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZVsncy1obiddID0gbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXS5wYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXQgYmFjayB0byB0aGUgZG9tIGJ1dCBpbiBpdHMgbmV3IGhvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmLmluc2VydEJlZm9yZShub2RlVG9SZWxvY2F0ZSwgaW5zZXJ0QmVmb3JlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2Vzbid0IGhhdmUgYSBzbG90IGhvbWUgdG8gZ28gdG8sIHNvIGxldCdzIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb25lIG1vdmluZyBub2RlcyBhcm91bmRcbiAgICAgICAgLy8gYWxsb3cgdGhlIGRpc2Nvbm5lY3QgY2FsbGJhY2sgdG8gd29yayBhZ2FpblxuICAgICAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIHJlbG9jYXRlTm9kZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuLy8gc2xvdCBjb21tZW50IGRlYnVnIG5vZGVzIG9ubHkgY3JlYXRlZCB3aXRoIHRoZSBgLS1kZWJ1Z2AgZmxhZ1xuLy8gb3RoZXJ3aXNlIHRoZXNlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzIHcvb3V0IGNvbnRlbnRcbmNvbnN0IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUgPSAoc2xvdFZOb2RlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgPHNsb3Qke3Nsb3RWTm9kZS4kbmFtZSQgPyAnIG5hbWU9XCInICsgc2xvdFZOb2RlLiRuYW1lJCArICdcIicgOiAnJ30+IChob3N0PSR7aG9zdFRhZ05hbWUudG9Mb3dlckNhc2UoKX0pYCk7XG5jb25zdCBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlID0gKG5vZGVUb1JlbG9jYXRlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgb3JnLWxvY2F0aW9uIGZvciBgICtcbiAgICAobm9kZVRvUmVsb2NhdGUubG9jYWxOYW1lXG4gICAgICAgID8gYDwke25vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZX0+IChob3N0PSR7bm9kZVRvUmVsb2NhdGVbJ3MtaG4nXX0pYFxuICAgICAgICA6IGBbJHtub2RlVG9SZWxvY2F0ZS50ZXh0Q29udGVudH1dYCkpO1xuY29uc3QgZ2V0RWxlbWVudCA9IChyZWYpID0+IChCVUlMRC5sYXp5TG9hZCA/IGdldEhvc3RSZWYocmVmKS4kaG9zdEVsZW1lbnQkIDogcmVmKTtcbmNvbnN0IGNyZWF0ZUV2ZW50ID0gKHJlZiwgbmFtZSwgZmxhZ3MpID0+IHtcbiAgICBjb25zdCBlbG0gPSBnZXRFbGVtZW50KHJlZik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1pdDogKGRldGFpbCkgPT4ge1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2ICYmICFlbG0uaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIFwiJHtuYW1lfVwiIGV2ZW50IHdhcyBlbWl0dGVkLCBidXQgdGhlIGRpc3BhdGNoZXIgbm9kZSBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBkb20uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW1pdEV2ZW50KGVsbSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEhKGZsYWdzICYgNCAvKiBCdWJibGVzICovKSxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogISEoZmxhZ3MgJiAyIC8qIENvbXBvc2VkICovKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhIShmbGFncyAmIDEgLyogQ2FuY2VsbGFibGUgKi8pLFxuICAgICAgICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlICYgZGlzcGF0Y2ggYSBjdXN0b20gRXZlbnQgb24gYSBwcm92aWRlZCB0YXJnZXRcbiAqIEBwYXJhbSBlbG0gdGhlIHRhcmdldCBvZiB0aGUgRXZlbnRcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIHRvIGdpdmUgdGhlIGN1c3RvbSBFdmVudFxuICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgYSBjdXN0b20gRXZlbnRcbiAqIEByZXR1cm5zIHRoZSBjdXN0b20gRXZlbnRcbiAqL1xuY29uc3QgZW1pdEV2ZW50ID0gKGVsbSwgbmFtZSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IGV2ID0gcGx0LmNlKG5hbWUsIG9wdHMpO1xuICAgIGVsbS5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICByZXR1cm4gZXY7XG59O1xuY29uc3QgYXR0YWNoVG9BbmNlc3RvciA9IChob3N0UmVmLCBhbmNlc3RvckNvbXBvbmVudCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgYW5jZXN0b3JDb21wb25lbnQgJiYgIWhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXS5wdXNoKG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHIpKSk7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVkdWxlVXBkYXRlID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBpZiAoQlVJTEQudGFza1F1ZXVlICYmIEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgaG9zdFJlZi4kZmxhZ3MkICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLykge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi87XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQpO1xuICAgIC8vIHRoZXJlIGlzIG5vIGFuY2VzdG9yIGNvbXBvbmVudCBvciB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgLy8gaGFzIGFscmVhZHkgZmlyZWQgb2ZmIGl0cyBsaWZlY3ljbGUgdXBkYXRlIHRoZW5cbiAgICAvLyBmaXJlIG9mZiB0aGUgaW5pdGlhbCB1cGRhdGVcbiAgICBjb25zdCBkaXNwYXRjaCA9ICgpID0+IGRpc3BhdGNoSG9va3MoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCk7XG4gICAgcmV0dXJuIEJVSUxELnRhc2tRdWV1ZSA/IHdyaXRlVGFzayhkaXNwYXRjaCkgOiBkaXNwYXRjaCgpO1xufTtcbmNvbnN0IGRpc3BhdGNoSG9va3MgPSAoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoJ3NjaGVkdWxlVXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi87XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQubWFwKChbbWV0aG9kTmFtZSwgZXZlbnRdKSA9PiBzYWZlQ2FsbChpbnN0YW5jZSwgbWV0aG9kTmFtZSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxMb2FkKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsTG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICBpZiAoQlVJTEQuY21wV2lsbFVwZGF0ZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsUmVuZGVyJyk7XG4gICAgaWYgKEJVSUxELmNtcFdpbGxSZW5kZXIpIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoZW4ocHJvbWlzZSwgKCkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsUmVuZGVyJykpO1xuICAgIH1cbiAgICBlbmRTY2hlZHVsZSgpO1xuICAgIHJldHVybiB0aGVuKHByb21pc2UsICgpID0+IHVwZGF0ZUNvbXBvbmVudChob3N0UmVmLCBpbnN0YW5jZSwgaXNJbml0aWFsTG9hZCkpO1xufTtcbmNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IGFzeW5jIChob3N0UmVmLCBpbnN0YW5jZSwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRVcGRhdGUgPSBjcmVhdGVUaW1lKCd1cGRhdGUnLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHJjID0gZWxtWydzLXJjJ107XG4gICAgaWYgKEJVSUxELnN0eWxlICYmIGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgfVxuICAgIGNvbnN0IGVuZFJlbmRlciA9IGNyZWF0ZVRpbWUoJ3JlbmRlcicsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgYXdhaXQgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSwgZWxtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgcGx0LiRjc3NTaGltJC51cGRhdGVIb3N0KGVsbSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQrKztcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG1hbnVhbGx5IGNvbm5lY3RlZCBjaGlsZCBjb21wb25lbnRzIGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGVsbSk7XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICAgICAgICAgIC8vIHVzaW5nIG9ubHkgZHVyaW5nIHNlcnZlci1zaWRlIGh5ZHJhdGVcbiAgICAgICAgICAgICAgICBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChob3N0UmVmLiRjbXBNZXRhJC4kZmxhZ3MkICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbVsncy1lbiddID0gJ2MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiByYykge1xuICAgICAgICAvLyBvaywgc28gdHVybnMgb3V0IHRoZXJlIGFyZSBzb21lIGNoaWxkIGhvc3QgZWxlbWVudHNcbiAgICAgICAgLy8gd2FpdGluZyBvbiB0aGlzIHBhcmVudCBlbGVtZW50IHRvIGxvYWRcbiAgICAgICAgLy8gbGV0J3MgZmlyZSBvZmYgYWxsIHVwZGF0ZSBjYWxsYmFja3Mgd2FpdGluZ1xuICAgICAgICByYy5tYXAoKGNiKSA9PiBjYigpKTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZFJlbmRlcigpO1xuICAgIGVuZFVwZGF0ZSgpO1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Qcm9taXNlcyA9IGVsbVsncy1wJ107XG4gICAgICAgIGNvbnN0IHBvc3RVcGRhdGUgPSAoKSA9PiBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgICAgICBpZiAoY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBvc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuUHJvbWlzZXMpLnRoZW4ocG9zdFVwZGF0ZSk7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLztcbiAgICAgICAgICAgIGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICB9XG59O1xuY29uc3QgY2FsbFJlbmRlciA9IChob3N0UmVmLCBpbnN0YW5jZSwgZWxtKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgZm9yIGJ1bmRsZXJzIHRvIGNvcnJlY3RseSB0cmVlc2hha2UgdGhlIEJVSUxEIG9iamVjdFxuICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIEJVSUxEIGlzIG5vdCBkZW9wdGltaXplZCB3aXRoaW4gYSB0cnkvY2F0Y2hcbiAgICAvLyBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jdHJlZXNoYWtlIHRyeUNhdGNoRGVvcHRpbWl6YXRpb25cbiAgICBjb25zdCBhbGxSZW5kZXJGbiA9IEJVSUxELmFsbFJlbmRlckZuID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IGxhenlMb2FkID0gQlVJTEQubGF6eUxvYWQgPyB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgdGFza1F1ZXVlID0gQlVJTEQudGFza1F1ZXVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHVwZGF0YWJsZSA9IEJVSUxELnVwZGF0YWJsZSA/IHRydWUgOiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICByZW5kZXJpbmdSZWYgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UgPSBhbGxSZW5kZXJGbiA/IGluc3RhbmNlLnJlbmRlcigpIDogaW5zdGFuY2UucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICBpZiAodXBkYXRhYmxlICYmIHRhc2tRdWV1ZSkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRhYmxlIHx8IGxhenlMb2FkKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMiAvKiBoYXNSZW5kZXJlZCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuaGFzUmVuZGVyRm4gfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21SZW5kZXIgfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2Ugd2UndmUgZ290IGNoaWxkIG5vZGVzIHRvIHJlbmRlciBpbnRvIHRoaXMgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2UgbmVlZCB0byB1cGRhdGUgdGhlIGNzcyBjbGFzcy9hdHRycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKS50aGVuKCh2YWx1ZSkgPT4gcmVuZGVyVmRvbShob3N0UmVmLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVmRvbShob3N0UmVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUsIGhvc3RSZWYuJGhvc3RFbGVtZW50JCk7XG4gICAgfVxuICAgIHJlbmRlcmluZ1JlZiA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0UmVuZGVyaW5nUmVmID0gKCkgPT4gcmVuZGVyaW5nUmVmO1xuY29uc3QgcG9zdFVwZGF0ZUNvbXBvbmVudCA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kUG9zdFVwZGF0ZSA9IGNyZWF0ZVRpbWUoJ3Bvc3RVcGRhdGUnLCB0YWdOYW1lKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JDtcbiAgICBpZiAoQlVJTEQuY21wRGlkUmVuZGVyKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFJlbmRlcicpO1xuICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLykpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLztcbiAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgYWRkSHlkcmF0ZWRGbGFnKGVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmNtcERpZExvYWQpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4yMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJChlbG0pO1xuICAgICAgICAgICAgaWYgKCFhbmNlc3RvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGFwcERpZExvYWQodGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgbG9hZGVkIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiB0aGUgdXNlcidzIGNvbXBvbmVudERpZFVwZGF0ZSBtZXRob2QgKGlmIG9uZSB3YXMgcHJvdmlkZWQpXG4gICAgICAgICAgICAvLyBjb21wb25lbnREaWRVcGRhdGUgcnVucyBBRlRFUiByZW5kZXIoKSBoYXMgYmVlbiBjYWxsZWRcbiAgICAgICAgICAgIC8vIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICBlbG1bJ3MtaG1yLWxvYWQnXSAmJiBlbG1bJ3MtaG1yLWxvYWQnXSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJChlbG0pO1xuICAgIH1cbiAgICAvLyBsb2FkIGV2ZW50cyBmaXJlIGZyb20gYm90dG9tIHRvIHRvcFxuICAgIC8vIHRoZSBkZWVwZXN0IGVsZW1lbnRzIGxvYWQgZmlyc3QgdGhlbiBidWJibGVzIHVwXG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBpZiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCgpO1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4oNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyB8IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKTtcbiAgICB9XG4gICAgLy8gKCDigKJf4oCiKVxuICAgIC8vICgg4oCiX+KAoik+4oyQ4pagLeKWoFxuICAgIC8vICjijJDilqBf4pagKVxufTtcbmNvbnN0IGZvcmNlVXBkYXRlID0gKHJlZikgPT4ge1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQuaXNDb25uZWN0ZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCAmJlxuICAgICAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmICgyIC8qIGhhc1JlbmRlcmVkICovIHwgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pKSA9PT0gMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgXCJ0cnVlXCIgd2hlbiB0aGUgZm9yY2VkIHVwZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICAgIC8vIG9uIGFwcGxvYWRcbiAgICAvLyB3ZSBoYXZlIGZpbmlzaCB0aGUgZmlyc3QgYmlnIGluaXRpYWwgcmVuZGVyXG4gICAgaWYgKEJVSUxELmNzc0Fubm90YXRpb25zKSB7XG4gICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sICdhcHBsb2FkJywgeyBkZXRhaWw6IHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0UgfSB9KSk7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWVhc3VyZSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtOQU1FU1BBQ0V9IGluaXRpYWwgbG9hZCAoYnkgJHt3aG99KWAsICdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG59O1xuY29uc3Qgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlW21ldGhvZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHRoZW4gPSAocHJvbWlzZSwgdGhlbkZuKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuID8gcHJvbWlzZS50aGVuKHRoZW5GbikgOiB0aGVuRm4oKTtcbn07XG5jb25zdCBlbWl0TGlmZWN5Y2xlRXZlbnQgPSAoZWxtLCBsaWZlY3ljbGVOYW1lKSA9PiB7XG4gICAgaWYgKEJVSUxELmxpZmVjeWNsZURPTUV2ZW50cykge1xuICAgICAgICBlbWl0RXZlbnQoZWxtLCAnc3RlbmNpbF8nICsgbGlmZWN5Y2xlTmFtZSwge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBOQU1FU1BBQ0UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgYWRkSHlkcmF0ZWRGbGFnID0gKGVsbSkgPT4gQlVJTEQuaHlkcmF0ZWRDbGFzc1xuICAgID8gZWxtLmNsYXNzTGlzdC5hZGQoJ2h5ZHJhdGVkJylcbiAgICA6IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlXG4gICAgICAgID8gZWxtLnNldEF0dHJpYnV0ZSgnaHlkcmF0ZWQnLCAnJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5jb25zdCBzZXJ2ZXJTaWRlQ29ubmVjdGVkID0gKGVsbSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxtLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFbG0uY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGluaXRpYWxpemVDbGllbnRIeWRyYXRlID0gKGhvc3RFbG0sIHRhZ05hbWUsIGhvc3RJZCwgaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGVuZEh5ZHJhdGUgPSBjcmVhdGVUaW1lKCdoeWRyYXRlQ2xpZW50JywgdGFnTmFtZSk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IGhvc3RFbG0uc2hhZG93Um9vdDtcbiAgICBjb25zdCBjaGlsZFJlbmRlck5vZGVzID0gW107XG4gICAgY29uc3Qgc2xvdE5vZGVzID0gW107XG4gICAgY29uc3Qgc2hhZG93Um9vdE5vZGVzID0gQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QgPyBbXSA6IG51bGw7XG4gICAgY29uc3Qgdm5vZGUgPSAoaG9zdFJlZi4kdm5vZGUkID0gbmV3Vk5vZGUodGFnTmFtZSwgbnVsbCkpO1xuICAgIGlmICghcGx0LiRvcmdMb2NOb2RlcyQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShkb2MuYm9keSwgKHBsdC4kb3JnTG9jTm9kZXMkID0gbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIGhvc3RFbG1bSFlEUkFURV9JRF0gPSBob3N0SWQ7XG4gICAgaG9zdEVsbS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgY2xpZW50SHlkcmF0ZSh2bm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIGhvc3RFbG0sIGhvc3RJZCk7XG4gICAgY2hpbGRSZW5kZXJOb2Rlcy5tYXAoKGMpID0+IHtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25JZCA9IGMuJGhvc3RJZCQgKyAnLicgKyBjLiRub2RlSWQkO1xuICAgICAgICBjb25zdCBvcmdMb2NhdGlvbk5vZGUgPSBwbHQuJG9yZ0xvY05vZGVzJC5nZXQob3JnTG9jYXRpb25JZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjLiRlbG0kO1xuICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlICYmIHN1cHBvcnRzU2hhZG93ICYmIG9yZ0xvY2F0aW9uTm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9yZ0xvY2F0aW9uTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgICAgICBub2RlWydzLWhuJ10gPSB0YWdOYW1lO1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZTtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ11bJ3MtbnInXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGx0LiRvcmdMb2NOb2RlcyQuZGVsZXRlKG9yZ0xvY2F0aW9uSWQpO1xuICAgIH0pO1xuICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdCkge1xuICAgICAgICBzaGFkb3dSb290Tm9kZXMubWFwKChzaGFkb3dSb290Tm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzaGFkb3dSb290Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRIeWRyYXRlKCk7XG59O1xuY29uc3QgY2xpZW50SHlkcmF0ZSA9IChwYXJlbnRWTm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIG5vZGUsIGhvc3RJZCkgPT4ge1xuICAgIGxldCBjaGlsZE5vZGVUeXBlO1xuICAgIGxldCBjaGlsZElkU3BsdDtcbiAgICBsZXQgY2hpbGRWTm9kZTtcbiAgICBsZXQgaTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBjaGlsZE5vZGVUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgIGlmIChjaGlsZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAvLyBnb3QgdGhlIG5vZGUgZGF0YSBmcm9tIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgICAgIGNoaWxkSWRTcGx0ID0gY2hpbGROb2RlVHlwZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzBdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMF0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFswXSxcbiAgICAgICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAgICAgICAgICAgICAkZGVwdGgkOiBjaGlsZElkU3BsdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgICAgICR0YWckOiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICR0ZXh0JDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGNoaWxkIHZub2RlXG4gICAgICAgICAgICAgICAgLy8gc28gZW5zdXJlIGl0cyBwYXJlbnQgdm5vZGUgaGFzIHRoZSB2Y2hpbGRyZW4gYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgb3VyIGNoaWxkIHZub2RlIHRvIGEgc3BlY2lmaWMgaW5kZXggb2YgdGhlIHZub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm93IHRoZSBuZXcgcGFyZW50IHZub2RlIGZvciBhbGwgdGhlIG5leHQgY2hpbGQgY2hlY2tzXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUgPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBkcmlsbCBkb3duLCBlbmQgdG8gc3RhcnQgc28gd2UgY2FuIHJlbW92ZSBub2Rlc1xuICAgICAgICBmb3IgKGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duIHRocm91Z2ggdGhlIHNoYWRvdyByb290IG5vZGVzXG4gICAgICAgICAgICBmb3IgKGkgPSBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgaG9zdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIC8vIGAke0NPTU1FTlRfVFlQRX0uJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMV0gPT09IGhvc3RJZCB8fCBjaGlsZElkU3BsdFsxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAvLyBjb21tZW50IG5vZGUgZm9yIGVpdGhlciB0aGUgaG9zdCBpZCBvciBhIDAgaG9zdCBpZFxuICAgICAgICAgICAgY2hpbGROb2RlVHlwZSA9IGNoaWxkSWRTcGx0WzBdO1xuICAgICAgICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbNF0sXG4gICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgJGF0dHJzJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICRuYW1lJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGFnJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFRFWFRfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRlbG0kICYmIGNoaWxkVk5vZGUuJGVsbSQubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGV4dCQgPSBjaGlsZFZOb2RlLiRlbG0kLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdGV4dCBjb21tZW50IHNpbmNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZFZOb2RlLiRob3N0SWQkID09PSBob3N0SWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbW1lbnQgbm9kZSBpcyBzcGVjaWZjYWxseSBmb3IgdGhpcyBob3N0IGlkXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFNMT1RfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtTTE9UX05PREVfSUR9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiR0YWckID0gJ3Nsb3QnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJZFNwbHRbNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IGNoaWxkVk5vZGUuJG5hbWUkID0gY2hpbGRJZFNwbHRbNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNyJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciBzdXBwb3J0IHNoYWRvd1Jvb3QgYW5kIHRoaXMgaXMgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFjdHVhbCBzbG90IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBkb2MuY3JlYXRlRWxlbWVudChjaGlsZFZOb2RlLiR0YWckKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRuYW1lJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgc2xvdCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQuc2V0QXR0cmlidXRlKCduYW1lJywgY2hpbGRWTm9kZS4kbmFtZSQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBuZXcgc2xvdCBlbGVtZW50IGJlZm9yZSB0aGUgc2xvdCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkVk5vZGUuJGVsbSQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzbG90IGNvbW1lbnQgc2luY2UgaXQncyBub3QgbmVlZGVkIGZvciBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkTm9kZVR5cGUgPT09IENPTlRFTlRfUkVGX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50IHJlZiBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxtWydzLWNyJ10gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1jbiddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnRWTm9kZSAmJiBwYXJlbnRWTm9kZS4kdGFnJCA9PT0gJ3N0eWxlJykge1xuICAgICAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG51bGwsIG5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICB2bm9kZS4kZWxtJCA9IG5vZGU7XG4gICAgICAgIHZub2RlLiRpbmRleCQgPSAnMCc7XG4gICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbdm5vZGVdO1xuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlID0gKG5vZGUsIG9yZ0xvY05vZGVzKSA9PiB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLmNoaWxkTm9kZXNbaV0sIG9yZ0xvY05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZElkU3BsdCA9IG5vZGUubm9kZVZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gT1JHX0xPQ0FUSU9OX0lEKSB7XG4gICAgICAgICAgICBvcmdMb2NOb2Rlcy5zZXQoY2hpbGRJZFNwbHRbMV0gKyAnLicgKyBjaGlsZElkU3BsdFsyXSwgbm9kZSk7XG4gICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgLy8gdXNlZnVsIHRvIGtub3cgaWYgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGlzXG4gICAgICAgICAgICAvLyB0aGUgcm9vdCBsaWdodC1kb20gb2YgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgbm9kZVsncy1lbiddID0gY2hpbGRJZFNwbHRbM107XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcGFyc2VQcm9wZXJ0eVZhbHVlID0gKHByb3BWYWx1ZSwgcHJvcFR5cGUpID0+IHtcbiAgICAvLyBlbnN1cmUgdGhpcyB2YWx1ZSBpcyBvZiB0aGUgY29ycmVjdCBwcm9wIHR5cGVcbiAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgIWlzQ29tcGxleFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICBpZiAoQlVJTEQucHJvcEJvb2xlYW4gJiYgcHJvcFR5cGUgJiA0IC8qIEJvb2xlYW4gKi8pIHtcbiAgICAgICAgICAgIC8vIHBlciB0aGUgSFRNTCBzcGVjLCBhbnkgc3RyaW5nIHZhbHVlIG1lYW5zIGl0IGlzIGEgYm9vbGVhbiB0cnVlIHZhbHVlXG4gICAgICAgICAgICAvLyBidXQgd2UnbGwgY2hlYXQgaGVyZSBhbmQgc2F5IHRoYXQgdGhlIHN0cmluZyBcImZhbHNlXCIgaXMgdGhlIGJvb2xlYW4gZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHByb3BWYWx1ZSA9PT0gJycgfHwgISFwcm9wVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BOdW1iZXIgJiYgcHJvcFR5cGUgJiAyIC8qIE51bWJlciAqLykge1xuICAgICAgICAgICAgLy8gZm9yY2UgaXQgdG8gYmUgYSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BTdHJpbmcgJiYgcHJvcFR5cGUgJiAxIC8qIFN0cmluZyAqLykge1xuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBiZWVuIHBhc3NlZCBhcyBhIG51bWJlciBvciBib29sZWFuXG4gICAgICAgICAgICAvLyBidXQgd2Ugc3RpbGwgd2FudCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVuZGFudCByZXR1cm4gaGVyZSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvblxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH1cbiAgICAvLyBub3Qgc3VyZSBleGFjdGx5IHdoYXQgdHlwZSB3ZSB3YW50XG4gICAgLy8gc28gbm8gbmVlZCB0byBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgIHJldHVybiBwcm9wVmFsdWU7XG59O1xuY29uc3QgZ2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSkgPT4gZ2V0SG9zdFJlZihyZWYpLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbmNvbnN0IHNldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUsIG5ld1ZhbCwgY21wTWV0YSkgPT4ge1xuICAgIC8vIGNoZWNrIG91ciBuZXcgcHJvcGVydHkgdmFsdWUgYWdhaW5zdCBvdXIgaW50ZXJuYWwgdmFsdWVcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGNvbnN0IGVsbSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kaG9zdEVsZW1lbnQkIDogcmVmO1xuICAgIGNvbnN0IG9sZFZhbCA9IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuICAgIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgIG5ld1ZhbCA9IHBhcnNlUHJvcGVydHlWYWx1ZShuZXdWYWwsIGNtcE1ldGEuJG1lbWJlcnMkW3Byb3BOYW1lXVswXSk7XG4gICAgaWYgKCghQlVJTEQubGF6eUxvYWQgfHwgIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB1bmRlZmluZWQpICYmIG5ld1ZhbCAhPT0gb2xkVmFsKSB7XG4gICAgICAgIC8vIGdhZHpvb2tzISB0aGUgcHJvcGVydHkncyB2YWx1ZSBoYXMgY2hhbmdlZCEhXG4gICAgICAgIC8vIHNldCBvdXIgbmV3IHZhbHVlIVxuICAgICAgICBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHByb3BOYW1lLCBuZXdWYWwpO1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAxMDI0IC8qIGRldk9uUmVuZGVyICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyByZW5kZXJpbmcuIFRoaXMgY2FuIHBvdGVudGlhbGx5IGxlYWQgdG8gaW5maW5pdGUtbG9vcHMgYW5kIG90aGVyIGJ1Z3MuYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjA0OCAvKiBkZXZPbkRpZExvYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIHN0YXRlL3Byb3AgXCIke3Byb3BOYW1lfVwiIGNoYW5nZWQgZHVyaW5nIFwiY29tcG9uZW50RGlkTG9hZCgpXCIsIHRoaXMgdHJpZ2dlcnMgZXh0cmEgcmUtcmVuZGVycywgdHJ5IHRvIHNldHVwIG9uIFwiY29tcG9uZW50V2lsbExvYWQoKVwiYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghQlVJTEQubGF6eUxvYWQgfHwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBtZXRob2QgbmFtZXMgb2Ygd2F0Y2ggZnVuY3Rpb25zIHRvIGNhbGxcbiAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIGNtcE1ldGEuJHdhdGNoZXJzJCAmJiBmbGFncyAmIDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbnN0YW5jZSBpcyB3YXRjaGluZyBmb3Igd2hlbiB0aGlzIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCgod2F0Y2hNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGVhY2ggb2YgdGhlIHdhdGNoIG1ldGhvZHMgdGhhdCBhcmUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiZcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuY21wU2hvdWxkVXBkYXRlICYmIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGlzIHZhbHVlIGFjdHVhbGx5IGNoYW5nZWQsIHNvIHdlJ3ZlIGdvdCB3b3JrIHRvIGRvIVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBvbmx5IGlmIHdlJ3ZlIGFscmVhZHkgcmVuZGVyZWQsIG90aGVyd2lzZSBqdXN0IGNoaWxsIG91dFxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHRoYXQgd2UgbmVlZCB0byBkbyBhbiB1cGRhdGUsIGJ1dCBkb24ndCB3b3JyeSBhYm91dCBxdWV1aW5nXG4gICAgICAgICAgICAgICAgLy8gdXAgbWlsbGlvbnMgY3V6IHRoaXMgZnVuY3Rpb24gZW5zdXJlcyBpdCBvbmx5IHJ1bnMgb25jZVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwcm94eUNvbXBvbmVudCA9IChDc3RyLCBjbXBNZXRhLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5tZW1iZXIgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2sgJiYgQ3N0ci53YXRjaGVycykge1xuICAgICAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci53YXRjaGVycztcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBoYXZlIGEgY29uc3QgdGhhbiB0d28gT2JqZWN0LmVudHJpZXMoKVxuICAgICAgICBjb25zdCBtZW1iZXJzID0gT2JqZWN0LmVudHJpZXMoY21wTWV0YS4kbWVtYmVycyQpO1xuICAgICAgICBjb25zdCBwcm90b3R5cGUgPSBDc3RyLnByb3RvdHlwZTtcbiAgICAgICAgbWVtYmVycy5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgICAgaWYgKChCVUlMRC5wcm9wIHx8IEJVSUxELnN0YXRlKSAmJlxuICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgKCghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAyIC8qIHByb3h5U3RhdGUgKi8pICYmIG1lbWJlckZsYWdzICYgMzIgLyogU3RhdGUgKi8pKSkge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gcHJvcFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIGdldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZHVyaW5nIGRldiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcHJveHlpbmcgdGhlIGluc3RhbmNlIChub3QgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBub3QgY29uc3RydWN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYuJGZsYWdzJCAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBhIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLykgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBub3QgbXV0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAxMDI0IC8qIE11dGFibGUgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBAUHJvcCgpIFwiJHttZW1iZXJOYW1lfVwiIG9uIDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gaXMgaW1tdXRhYmxlIGJ1dCB3YXMgbW9kaWZpZWQgZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudC5cXG5Nb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9wcm9wZXJ0aWVzI3Byb3AtbXV0YWJpbGl0eWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQubGF6eUxvYWQgJiZcbiAgICAgICAgICAgICAgICBCVUlMRC5tZXRob2QgJiZcbiAgICAgICAgICAgICAgICBmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gJiZcbiAgICAgICAgICAgICAgICBtZW1iZXJGbGFncyAmIDY0IC8qIE1ldGhvZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gbWV0aG9kXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZi4kb25JbnN0YW5jZVByb21pc2UkLnRoZW4oKCkgPT4gcmVmLiRsYXp5SW5zdGFuY2UkW21lbWJlck5hbWVdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChCVUlMRC5vYnNlcnZlQXR0cmlidXRlICYmICghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSkge1xuICAgICAgICAgICAgY29uc3QgYXR0ck5hbWVUb1Byb3BOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGF0dHJOYW1lVG9Qcm9wTmFtZS5nZXQoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gYSB3ZWIgY29tcG9uZW50IGxpZmVjeWNsZSB0aGUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHJ1bnMgcHJpb3IgdG8gY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gIGluIHRoZSBjYXNlIHdoZXJlIGFuIGF0dHJpYnV0ZSB3YXMgc2V0IGlubGluZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPG15LWNvbXBvbmVudCBzb21lLWF0dHJpYnV0ZT1cInNvbWUtdmFsdWVcIj48L215LWNvbXBvbmVudD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlcmUgaXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgZGV2ZWxvcGVyIHNldHMgdGhlIGF0dHJpYnV0ZSBpbmxpbmUgb24gYSBjdXN0b20gZWxlbWVudCBhbmQgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyAgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIGl0IGJlZm9yZSBpdCBoYXMgYmVlbiB1cGdyYWRlZCBhcyBzaG93biBiZWxvdzpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPCEtLSB0aGlzIGNvbXBvbmVudCBoYXMgX25vdF8gYmVlbiB1cGdyYWRlZCB5ZXQgLS0+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgaWQ9XCJ0ZXN0XCIgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgLy8gZ3JhYiBub24tdXBncmFkZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Rlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwuc29tZUF0dHJpYnV0ZSA9IFwiYW5vdGhlci12YWx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIHVwZ3JhZGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgYGBgXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbiB0aGlzIGNhc2UgaWYgd2UgZG8gbm90IHVuc2hhZG93IGhlcmUgYW5kIHVzZSB0aGUgdmFsdWUgb2YgdGhlIHNoYWRvd2luZyBwcm9wZXJ0eSwgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICB3aWxsIGJlIGNhbGxlZCB3aXRoIGBuZXdWYWx1ZSA9IFwic29tZS12YWx1ZVwiYCBhbmQgd2lsbCBzZXQgdGhlIHNoYWRvd2VkIHByb3BlcnR5ICh0aGlzLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gIHRvIHRoZSB2YWx1ZSB0aGF0IHdhcyBzZXQgaW5saW5lIGkuZS4gXCJzb21lLXZhbHVlXCIgZnJvbSBhYm92ZSBleGFtcGxlLiBXaGVuXG4gICAgICAgICAgICAgICAgICAgIC8vICB0aGUgY29ubmVjdGVkQ2FsbGJhY2sgYXR0ZW1wdHMgdG8gdW5zaGFkb3cgaXQgd2lsbCB1c2UgXCJzb21lLXZhbHVlXCIgYXMgdGhlIGluaXRpYWwgdmFsdWUgcmF0aGVyIHRoYW4gXCJhbm90aGVyLXZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZSBjYXNlIHdoZXJlIHRoZSBhdHRyaWJ1dGUgd2FzIE5PVCBzZXQgaW5saW5lIGJ1dCB3YXMgbm90IHNldCBwcm9ncmFtbWF0aWNhbGx5IHNoYWxsIGJlIGhhbmRsZWQvdW5zaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgYnkgY29ubmVjdGVkQ2FsbGJhY2sgYXMgdGhpcyBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgd2lsbCBub3QgZmlyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUT0RPKFNURU5DSUwtMTYpIHdlIHNob3VsZCB0aGluayBhYm91dCB3aGV0aGVyIG9yIG5vdCB3ZSBhY3R1YWxseSB3YW50IHRvIGJlIHJlZmxlY3RpbmcgdGhlIGF0dHJpYnV0ZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb3BlcnRpZXMgaGVyZSBnaXZlbiB0aGF0IHRoaXMgZ29lcyBhZ2FpbnN0IGJlc3QgcHJhY3RpY2VzIG91dGxpbmVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjYXZvaWQtcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wTmFtZSBleGlzdHMgb24gdGhlIHByb3RvdHlwZSBvZiBgQ3N0cmAsIHRoaXMgdXBkYXRlIG1heSBiZSBhIHJlc3VsdCBvZiBTdGVuY2lsIHVzaW5nIG5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVBJcyB0byByZWZsZWN0IHByb3BzIGFzIGF0dHJpYnV0ZXMuIENhbGxzIHRvIGBzZXRBdHRyaWJ1dGUoc29tZUVsZW1lbnQsIHByb3BOYW1lKWAgd2lsbCByZXN1bHQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBwcm9wTmFtZWAgdG8gYmUgY29udmVydGVkIHRvIGEgYERPTVN0cmluZ2AsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB3ZSB3YW50IGZvciBvdGhlciBwcmltaXRpdmUgcHJvcHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuZXdWYWx1ZSA9PT0gbnVsbCAmJiB0eXBlb2YgdGhpc1twcm9wTmFtZV0gPT09ICdib29sZWFuJyA/IGZhbHNlIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gb2JzZXJ2ZVxuICAgICAgICAgICAgLy8gYW5kIGFsc28gY3JlYXRlIGEgbWFwIG9mIGh0bWwgYXR0cmlidXRlIG5hbWUgdG8ganMgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgQ3N0ci5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBtZW1iZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIG1dKSA9PiBtWzBdICYgMTUgLyogSGFzQXR0cmlidXRlICovKSAvLyBmaWx0ZXIgdG8gb25seSBrZWVwIHByb3BzIHRoYXQgc2hvdWxkIG1hdGNoIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAubWFwKChbcHJvcE5hbWUsIG1dKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBtWzFdIHx8IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lVG9Qcm9wTmFtZS5zZXQoYXR0ck5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCAmJiBtWzBdICYgNTEyIC8qIFJlZmxlY3RBdHRyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5wdXNoKFtwcm9wTmFtZSwgYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIENzdHI7XG59O1xuY29uc3QgaW5pdGlhbGl6ZUNvbXBvbmVudCA9IGFzeW5jIChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCwgQ3N0cikgPT4ge1xuICAgIC8vIGluaXRpYWxpemVDb21wb25lbnRcbiAgICBpZiAoKEJVSUxELmxhenlMb2FkIHx8IEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELnN0eWxlKSAmJlxuICAgICAgICAoaG9zdFJlZi4kZmxhZ3MkICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pID09PSAwKSB7XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZW4ndCBpbml0aWFsaXplZCB0aGlzIGVsZW1lbnQgeWV0XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi87XG4gICAgICAgICAgICAvLyBsYXp5IGxvYWRlZCBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyByZXF1ZXN0IHRoZSBjb21wb25lbnQncyBpbXBsZW1lbnRhdGlvbiB0byBiZVxuICAgICAgICAgICAgLy8gd2lyZWQgdXAgd2l0aCB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICBDc3RyID0gbG9hZE1vZHVsZShjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKENzdHIudGhlbikge1xuICAgICAgICAgICAgICAgIC8vIEF3YWl0IGNyZWF0ZXMgYSBtaWNyby10YXNrIGF2b2lkIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTG9hZCA9IHVuaXF1ZVRpbWUoYHN0OmxvYWQ6JHtjbXBNZXRhLiR0YWdOYW1lJH06JHtob3N0UmVmLiRtb2RlTmFtZSR9YCwgYFtTdGVuY2lsXSBMb2FkIG1vZHVsZSBmb3IgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PmApO1xuICAgICAgICAgICAgICAgIENzdHIgPSBhd2FpdCBDc3RyO1xuICAgICAgICAgICAgICAgIGVuZExvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoQlVJTEQuaXNEZXYgfHwgQlVJTEQuaXNEZWJ1ZykgJiYgIUNzdHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIGZvciBcIiR7Y21wTWV0YS4kdGFnTmFtZSR9IyR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiIHdhcyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIgJiYgIUNzdHIuaXNQcm94aWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbmV2ZXIgcHJveGllZCB0aGlzIENvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGxldCdzIGFkZCB0aGUgZ2V0dGVycy9zZXR0ZXJzIHRvIGl0cyBwcm90b3R5cGUgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHRpbWUgd2UgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDIgLyogcHJveHlTdGF0ZSAqLyk7XG4gICAgICAgICAgICAgICAgQ3N0ci5pc1Byb3hpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kTmV3SW5zdGFuY2UgPSBjcmVhdGVUaW1lKCdjcmVhdGVJbnN0YW5jZScsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgIC8vIG9rLCB0aW1lIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBrZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnQgYW5kIHN0b3BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGdldHRlcnMvc2V0dGVycyBkb24ndCBpbmNvcnJlY3RseSBzdGVwIG9uIGRhdGFcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSBsYXp5LWxvYWRlZCBjb21wb25lbnQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIHBhc3NpbmcgdGhlIGhvc3RSZWYgaXMgdmVyeSBpbXBvcnRhbnQgZHVyaW5nXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3Rpb24gaW4gb3JkZXIgdG8gZGlyZWN0bHkgd2lyZSB0b2dldGhlciB0aGVcbiAgICAgICAgICAgIC8vIGhvc3QgZWxlbWVudCBhbmQgdGhlIGxhenktbG9hZGVkIGluc3RhbmNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBDc3RyKGhvc3RSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH44IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN5bmMgY29uc3RydWN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICBDc3RyID0gZWxtLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSB0byBtYXJrIHRoZSBjb21wb25lbnQgYXMgcmVhZHkgYmVmb3JlIHNldHRpbmcgYGlzV2F0Y2hSZWFkeWAuIE90aGVyd2lzZSxcbiAgICAgICAgICAgIC8vIHdhdGNoZXJzIG1heSBmaXJlIHByZW1hdHVyZWx5IGlmIGBjdXN0b21FbGVtZW50cy5nZXQoKWAvYGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKClgIHJlc29sdmVzIF9iZWZvcmVfXG4gICAgICAgICAgICAvLyBTdGVuY2lsIGhhcyBjb21wbGV0ZWQgaW5zdGFudGlhdGluZyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoY21wTWV0YS4kdGFnTmFtZSQpLnRoZW4oKCkgPT4gKGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnN0eWxlICYmIENzdHIuc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGhhcyBzdHlsZXMgYnV0IHdlIGhhdmVuJ3QgcmVnaXN0ZXJlZCB0aGVtIHlldFxuICAgICAgICAgICAgbGV0IHN0eWxlID0gQ3N0ci5zdHlsZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5tb2RlICYmIHR5cGVvZiBzdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlWyhob3N0UmVmLiRtb2RlTmFtZSQgPSBjb21wdXRlTW9kZShlbG0pKV07XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIGhvc3RSZWYuJG1vZGVOYW1lJCkge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdzLW1vZGUnLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRSZWdpc3RlclN0eWxlcyA9IGNyZWF0ZVRpbWUoJ3JlZ2lzdGVyU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgQlVJTEQuc2hhZG93RG9tICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbVNoaW0gJiZcbiAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkICYgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBhd2FpdCBpbXBvcnQoJy4vc2hhZG93LWNzcy5qcycpLnRoZW4oKG0pID0+IG0uc2NvcGVDc3Moc3R5bGUsIHNjb3BlSWQsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgIGVuZFJlZ2lzdGVyU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UndmUgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYSBsYXp5IGluc3RhbmNlXG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSAoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCB0cnVlKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaW5pdGlhbCBsb2FkIGFuZCB0aGlzIGNvbXBvbmVudCBpdCBoYXMgYW4gYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGJ1dCB0aGUgYW5jZXN0b3IgY29tcG9uZW50IGhhcyBOT1QgZmlyZWQgaXRzIHdpbGwgdXBkYXRlIGxpZmVjeWNsZSB5ZXRcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBjb29sIG91ciBqZXRzIGFuZCB3YWl0IGZvciB0aGUgYW5jZXN0b3IgdG8gY29udGludWUgZmlyc3RcbiAgICAgICAgLy8gdGhpcyB3aWxsIGdldCBmaXJlZCBvZmYgd2hlbiB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGZpbmFsbHkgZ2V0cyBhcm91bmQgdG8gcmVuZGVyaW5nIGl0cyBsYXp5IHNlbGZcbiAgICAgICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10ucHVzaChzY2hlZHVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbn07XG5jb25zdCBmaXJlQ29ubmVjdGVkQ2FsbGJhY2sgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgIH1cbn07XG5jb25zdCBjb25uZWN0ZWRDYWxsYmFjayA9IChlbG0pID0+IHtcbiAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDApIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICBjb25zdCBlbmRDb25uZWN0ZWQgPSBjcmVhdGVUaW1lKCdjb25uZWN0ZWRDYWxsYmFjaycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gb25seSBydW4gaWYgd2UgaGF2ZSBsaXN0ZW5lcnMgYmVpbmcgYXR0YWNoZWQgdG8gYSBwYXJlbnRcbiAgICAgICAgICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDEgLyogaGFzQ29ubmVjdGVkICovKSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZSB0aGlzIGNvbXBvbmVudCBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMSAvKiBoYXNDb25uZWN0ZWQgKi87XG4gICAgICAgICAgICBsZXQgaG9zdElkO1xuICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgaG9zdElkID0gZWxtLmdldEF0dHJpYnV0ZShIWURSQVRFX0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZUlkID0gQlVJTEQubW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEsIGVsbS5nZXRBdHRyaWJ1dGUoJ3MtbW9kZScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUoc2NvcGVJZCArICctaCcsIHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZShlbG0sIGNtcE1ldGEuJHRhZ05hbWUkLCBob3N0SWQsIGhvc3RSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdFVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzbG90IHBvbHlmaWxsIGlzIHJlcXVpcmVkIHdlJ2xsIG5lZWQgdG8gcHV0IHNvbWUgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBoZXJlIHRvIGFjdCBhcyBvcmlnaW5hbCBjb250ZW50IGFuY2hvcnMgYXMgd2UgbW92ZSBub2RlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgaGFzIGJlZW4gY29ubmVjdGVkIHRvIHRoZSBET01cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgKChCVUlMRC5zbG90IHx8IEJVSUxELnNoYWRvd0RvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmICg0IC8qIGhhc1Nsb3RSZWxvY2F0aW9uICovIHwgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50UmVmZXJlbmNlKGVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudCAoaWYgdGhlcmUgaXMgb25lKSBhbmQgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBhcyBvbmUgb2YgdGhlIGFjdGl2ZWx5IGxvYWRpbmcgY2hpbGQgY29tcG9uZW50cyBmb3IgaXRzIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgbGV0IGFuY2VzdG9yQ29tcG9uZW50ID0gZWxtO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYW5jZXN0b3JDb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudC5wYXJlbnROb2RlIHx8IGFuY2VzdG9yQ29tcG9uZW50Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaW1iIHVwIHRoZSBhbmNlc3RvcnMgbG9va2luZyBmb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCB0aGF0IGhhc24ndCBmaW5pc2hlZCBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnQubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lmhhc0F0dHJpYnV0ZSgncy1pZCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIHRoaXMgY29tcG9uZW50cyBmaXJzdCBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBjb21wb25lbnQncyBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgKGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCA9IGFuY2VzdG9yQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExhenkgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy93ZWItY29tcG9uZW50cy9iZXN0LXByYWN0aWNlcyNsYXp5LXByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC5wcm9wICYmICFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKS5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5pbml0aWFsaXplTmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjaywgdGFza1F1ZXVlLCBpbml0aWFsTG9hZFxuICAgICAgICAgICAgICAgIC8vIGFuZ3VsYXIgc2V0cyBhdHRyaWJ1dGUgQUZURVIgY29ubmVjdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg5MDlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTk0MFxuICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGZpcnN0IHRpbWUgdGhpcyBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyByZWF0dGFjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBob3N0XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IHdvdWxkIGhhdmUgYmVlbiByZW1vdmVkIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiBjb25uZWN0ZWRDYWxsYmFjaygpIG9uIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgZmlyZUNvbm5lY3RlZENhbGxiYWNrKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgICAgICB9XG4gICAgICAgIGVuZENvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5jb25zdCBzZXRDb250ZW50UmVmZXJlbmNlID0gKGVsbSkgPT4ge1xuICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgLy8gb3IgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmUgc2hhZG93IGRvbVxuICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgLy8gY3JlYXRlIGEgbm9kZSB0byByZXByZXNlbnQgd2hlcmUgdGhlIG9yaWdpbmFsXG4gICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICBjb25zdCBjb250ZW50UmVmRWxtID0gKGVsbVsncy1jciddID0gZG9jLmNyZWF0ZUNvbW1lbnQoQlVJTEQuaXNEZWJ1ZyA/IGBjb250ZW50LXJlZiAoaG9zdD0ke2VsbS5sb2NhbE5hbWV9KWAgOiAnJykpO1xuICAgIGNvbnRlbnRSZWZFbG1bJ3MtY24nXSA9IHRydWU7XG4gICAgZWxtLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCBlbG0uZmlyc3RDaGlsZCk7XG59O1xuY29uc3QgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcCgocm1MaXN0ZW5lcikgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgQ1NTIHZhci1zaGltIHRyYWNraW5nXG4gICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgIHBsdC4kY3NzU2hpbSQucmVtb3ZlSG9zdChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVbmxvYWQpIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVW5sb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjb21wYWN0TWV0YVsxXSwgcHJveHlDdXN0b21FbGVtZW50KENzdHIsIGNvbXBhY3RNZXRhKSk7XG59O1xuY29uc3QgcHJveHlDdXN0b21FbGVtZW50ID0gKENzdHIsIGNvbXBhY3RNZXRhKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgfTtcbiAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgY21wTWV0YS4kbGlzdGVuZXJzJCA9IGNvbXBhY3RNZXRhWzNdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLiR3YXRjaGVycyQ7XG4gICAgfVxuICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrID0gQ3N0ci5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIE9iamVjdC5hc3NpZ24oQ3N0ci5wcm90b3R5cGUsIHtcbiAgICAgICAgX19yZWdpc3Rlckhvc3QoKSB7XG4gICAgICAgICAgICByZWdpc3Rlckhvc3QodGhpcywgY21wTWV0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjayAmJiBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfX2F0dGFjaFNoYWRvdygpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1NoYWRvdykge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEZWxlZ2F0ZXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXNGb2N1czogISEoY21wTWV0YS4kZmxhZ3MkICYgMTYgLyogc2hhZG93RGVsZWdhdGVzRm9jdXMgKi8pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgQ3N0ci5pcyA9IGNtcE1ldGEuJHRhZ05hbWUkO1xuICAgIHJldHVybiBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovIHwgMiAvKiBwcm94eVN0YXRlICovKTtcbn07XG5jb25zdCBmb3JjZU1vZGVVcGRhdGUgPSAoZWxtKSA9PiB7XG4gICAgaWYgKEJVSUxELnN0eWxlICYmIEJVSUxELm1vZGUgJiYgIUJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBjb21wdXRlTW9kZShlbG0pO1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBpZiAoaG9zdFJlZi4kbW9kZU5hbWUkICE9PSBtb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgICAgICAgICBjb25zdCBvbGRTY29wZUlkID0gZWxtWydzLXNjJ107XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWxtLmNvbnN0cnVjdG9yLnN0eWxlW21vZGVdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzY29wZUlkLCBzdHlsZSwgISEoZmxhZ3MgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kbW9kZU5hbWUkID0gbW9kZTtcbiAgICAgICAgICAgICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShvbGRTY29wZUlkICsgJy1oJywgb2xkU2NvcGVJZCArICctcycpO1xuICAgICAgICAgICAgICAgIGF0dGFjaFN0eWxlcyhob3N0UmVmKTtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGhtclN0YXJ0ID0gKGVsbSwgY21wTWV0YSwgaG1yVmVyc2lvbklkKSA9PiB7XG4gICAgLy8gwq9cXF8o44OEKV8vwq9cbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgIC8vIHJlc2V0IHN0YXRlIGZsYWdzIHRvIG9ubHkgaGF2ZSBiZWVuIGNvbm5lY3RlZFxuICAgIGhvc3RSZWYuJGZsYWdzJCA9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgIC8vIFRPRE9cbiAgICAvLyBkZXRhdGNoIGFueSBldmVudCBsaXN0ZW5lcnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGFkZGVkXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSBub3QgcGFzc2luZyBhbiBleGFjdCBldmVudCBuYW1lIGl0J2xsXG4gICAgLy8gcmVtb3ZlIGFsbCBvZiB0aGlzIGVsZW1lbnQncyBldmVudCwgd2hpY2ggaXMgZ29vZFxuICAgIC8vIGNyZWF0ZSBhIGNhbGxiYWNrIGZvciB3aGVuIHRoaXMgY29tcG9uZW50IGZpbmlzaGVzIGhtclxuICAgIGVsbVsncy1obXItbG9hZCddID0gKCkgPT4ge1xuICAgICAgICAvLyBmaW5pc2hlZCBobXIgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICBkZWxldGUgZWxtWydzLWhtci1sb2FkJ107XG4gICAgfTtcbiAgICAvLyByZS1pbml0aWFsaXplIHRoZSBjb21wb25lbnRcbiAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSwgaG1yVmVyc2lvbklkKTtcbn07XG5jb25zdCBwYXRjaENsb25lTm9kZSA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIGNvbnN0IG9yZ0Nsb25lTm9kZSA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZTtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICBjb25zdCBzcmNOb2RlID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNTaGFkb3dEb20gPSBCVUlMRC5zaGFkb3dEb20gPyBzcmNOb2RlLnNoYWRvd1Jvb3QgJiYgc3VwcG9ydHNTaGFkb3cgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvbmVkTm9kZSA9IG9yZ0Nsb25lTm9kZS5jYWxsKHNyY05vZGUsIGlzU2hhZG93RG9tID8gZGVlcCA6IGZhbHNlKTtcbiAgICAgICAgaWYgKEJVSUxELnNsb3QgJiYgIWlzU2hhZG93RG9tICYmIGRlZXApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBzbG90dGVkLCBub25TdGVuY2lsTm9kZTtcbiAgICAgICAgICAgIGxldCBzdGVuY2lsUHJpdmF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3MtaWQnLFxuICAgICAgICAgICAgICAgICdzLWNyJyxcbiAgICAgICAgICAgICAgICAncy1scicsXG4gICAgICAgICAgICAgICAgJ3MtcmMnLFxuICAgICAgICAgICAgICAgICdzLXNjJyxcbiAgICAgICAgICAgICAgICAncy1wJyxcbiAgICAgICAgICAgICAgICAncy1jbicsXG4gICAgICAgICAgICAgICAgJ3Mtc3InLFxuICAgICAgICAgICAgICAgICdzLXNuJyxcbiAgICAgICAgICAgICAgICAncy1obicsXG4gICAgICAgICAgICAgICAgJ3Mtb2wnLFxuICAgICAgICAgICAgICAgICdzLW5yJyxcbiAgICAgICAgICAgICAgICAncy1zaScsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBzcmNOb2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzbG90dGVkID0gc3JjTm9kZS5jaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgbm9uU3RlbmNpbE5vZGUgPSBzdGVuY2lsUHJpdmF0ZXMuZXZlcnkoKHByaXZhdGVGaWVsZCkgPT4gIXNyY05vZGUuY2hpbGROb2Rlc1tpXVtwcml2YXRlRmllbGRdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuYXBwZW5kQ2hpbGRTbG90Rml4ICYmIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5fX2FwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc2xvdHRlZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub25TdGVuY2lsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNyY05vZGUuY2hpbGROb2Rlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkTm9kZTtcbiAgICB9O1xufTtcbmNvbnN0IHBhdGNoU2xvdEFwcGVuZENoaWxkID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuX19hcHBlbmRDaGlsZCA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmFwcGVuZENoaWxkO1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5ld0NoaWxkKSB7XG4gICAgICAgIGNvbnN0IHNsb3ROYW1lID0gKG5ld0NoaWxkWydzLXNuJ10gPSBnZXRTbG90TmFtZShuZXdDaGlsZCkpO1xuICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsIHNsb3ROYW1lKTtcbiAgICAgICAgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90Q2hpbGROb2RlcyA9IGdldEhvc3RTbG90Q2hpbGROb2RlcyhzbG90Tm9kZSwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYXBwZW5kQWZ0ZXIgPSBzbG90Q2hpbGROb2Rlc1tzbG90Q2hpbGROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmRBZnRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZCwgYXBwZW5kQWZ0ZXIubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgIH07XG59O1xuLyoqXG4gKiBQYXRjaGVzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gdW5uYW1lZCBzbG90dGVkIG5vZGUgaW5zaWRlIGEgc2NvcGVkIGNvbXBvbmVudFxuICogQHBhcmFtIGhvc3RFbGVtZW50UHJvdG90eXBlIHRoZSBgRWxlbWVudGAgdG8gYmUgcGF0Y2hlZFxuICogQHBhcmFtIGNtcE1ldGEgY29tcG9uZW50IHJ1bnRpbWUgbWV0YWRhdGEgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgcGF0Y2hlZCBvciBub3RcbiAqL1xuY29uc3QgcGF0Y2hUZXh0Q29udGVudCA9IChob3N0RWxlbWVudFByb3RvdHlwZSwgY21wTWV0YSkgPT4ge1xuICAgIGlmIChCVUlMRC5zY29wZWQgJiYgY21wTWV0YS4kZmxhZ3MkICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAnX190ZXh0Q29udGVudCcsIGRlc2NyaXB0b3IpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdEVsZW1lbnRQcm90b3R5cGUsICd0ZXh0Q29udGVudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBiZSBmb3VuZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLCBkZXBlbmRpbmcgb24gaG93XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb20gdGhlIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS5uZXh0U2libGluZy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3ROb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlICdkZWZhdWx0IHNsb3QnLCB3aGljaCB3b3VsZCBiZSB0aGUgZmlyc3Qgc2xvdCBpbiBhIHNoYWRvdyB0cmVlIChpZiB3ZSB3ZXJlIHVzaW5nIG9uZSksIHdob3NlIG5hbWUgaXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIHNsb3Qgbm9kZSBpcyBmb3VuZCwgdGhlIHRleHRDb250ZW50IF9tYXlfIG5lZWQgdG8gYmUgcGxhY2VkIGluIHRoZSBuZXh0IHNpYmxpbmcgKHRleHQpIG5vZGUsXG4gICAgICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGhvdyBub2RlcyB3ZXJlIHJlb3JkZXJlZCBkdXJpbmcgdGhlIHZkb20gcmVuZGVyLiBmaXJzdCB0cnkgdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2libGluZy5cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHNsb3ROb2RlID09PSBudWxsIHx8IHNsb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbG90Tm9kZS5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGVUeXBlKSA9PT0gMyAvKiBURVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkbid0IGZpbmQgYSBzbG90LCBidXQgdGhhdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGVyZSBpc24ndCBvbmUuIGlmIHRoaXMgY2hlY2sgcmFuIGJlZm9yZSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvYWRlZCwgd2UgY291bGQgaGF2ZSBtaXNzZWQgaXQuIGNoZWNrIGZvciBhIGNvbnRlbnQgcmVmZXJlbmNlIGVsZW1lbnQgb24gdGhlIHNjb3BlZCBjb21wb25lbnQgYW5kIGluc2VydFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudFJlZkVsbSA9IHRoaXNbJ3MtY3InXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRSZWZFbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNvbnRlbnRSZWZFbG0sIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGF0Y2hDaGlsZFNsb3ROb2RlcyA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjbGFzcyBGYWtlTm9kZUxpc3QgZXh0ZW5kcyBBcnJheSB7XG4gICAgICAgIGl0ZW0obikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXNGbiA9IGVsbS5fX2xvb2t1cEdldHRlcl9fKCdjaGlsZE5vZGVzJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZHJlbicsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcCgobikgPT4gbi5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkRWxlbWVudENvdW50Jywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbG0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZE5vZGVzJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzRm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0SG9zdFJlZih0aGlzKS4kZmxhZ3MkICYgMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmFrZU5vZGVMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkTm9kZXNbaV1bJ3MtbnInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2xvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZha2VOb2RlTGlzdC5mcm9tKGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFNsb3ROYW1lID0gKG5vZGUpID0+IG5vZGVbJ3Mtc24nXSB8fCAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB8fCAnJztcbi8qKlxuICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgYSBzZXJpZXMgb2YgY2hpbGQgbm9kZXMgZm9yIGEgc2xvdCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lLlxuICogQHBhcmFtIGNoaWxkTm9kZXMgdGhlIG5vZGVzIHRvIHNlYXJjaCBmb3IgYSBzbG90IHdpdGggYSBzcGVjaWZpYyBuYW1lLlxuICogQHBhcmFtIHNsb3ROYW1lIHRoZSBuYW1lIG9mIHRoZSBzbG90IHRvIG1hdGNoIG9uLlxuICogQHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNsb3Qgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG5hbWUsIGBudWxsYCBvdGhlcndpc2VcbiAqL1xuY29uc3QgZ2V0SG9zdFNsb3ROb2RlID0gKGNoaWxkTm9kZXMsIHNsb3ROYW1lKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgZm9yICg7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiBjaGlsZE5vZGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKGNoaWxkTm9kZS5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0SG9zdFNsb3RDaGlsZE5vZGVzID0gKG4sIHNsb3ROYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IFtuXTtcbiAgICB3aGlsZSAoKG4gPSBuLm5leHRTaWJsaW5nKSAmJiBuWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChuKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkTm9kZXM7XG59O1xuY29uc3QgYm9vdHN0cmFwTGF6eSA9IChsYXp5QnVuZGxlcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG4gICAgaW5zdGFsbERldlRvb2xzKCk7XG4gICAgY29uc3QgZW5kQm9vdHN0cmFwID0gY3JlYXRlVGltZSgnYm9vdHN0cmFwTGF6eScpO1xuICAgIGNvbnN0IGNtcFRhZ3MgPSBbXTtcbiAgICBjb25zdCBleGNsdWRlID0gb3B0aW9ucy5leGNsdWRlIHx8IFtdO1xuICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gd2luLmN1c3RvbUVsZW1lbnRzO1xuICAgIGNvbnN0IGhlYWQgPSBkb2MuaGVhZDtcbiAgICBjb25zdCBtZXRhQ2hhcnNldCA9IC8qQF9fUFVSRV9fKi8gaGVhZC5xdWVyeVNlbGVjdG9yKCdtZXRhW2NoYXJzZXRdJyk7XG4gICAgY29uc3QgdmlzaWJpbGl0eVN0eWxlID0gLypAX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjb25zdCBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlcyA9IC8qQF9fUFVSRV9fKi8gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoYFske0hZRFJBVEVEX1NUWUxFX0lEfV1gKTtcbiAgICBsZXQgYXBwTG9hZEZhbGxiYWNrO1xuICAgIGxldCBpc0Jvb3RzdHJhcHBpbmcgPSB0cnVlO1xuICAgIGxldCBpID0gMDtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgb3B0aW9ucyk7XG4gICAgcGx0LiRyZXNvdXJjZXNVcmwkID0gbmV3IFVSTChvcHRpb25zLnJlc291cmNlc1VybCB8fCAnLi8nLCBkb2MuYmFzZVVSSSkuaHJlZjtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zeW5jUXVldWUpIHtcbiAgICAgICAgICAgIHBsdC4kZmxhZ3MkIHw9IDQgLyogcXVldWVTeW5jICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAvLyBJZiB0aGUgYXBwIGlzIGFscmVhZHkgaHlkcmF0ZWQgdGhlcmUgaXMgbm90IHBvaW50IHRvIGRpc2FibGUgdGhlXG4gICAgICAgIC8vIGFzeW5jIHF1ZXVlLiBUaGlzIHdpbGwgaW1wcm92ZSB0aGUgZmlyc3QgaW5wdXQgZGVsYXlcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJiBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgZm9yICg7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc3R5bGVzW2ldLmdldEF0dHJpYnV0ZShIWURSQVRFRF9TVFlMRV9JRCksIGNvbnZlcnRTY29wZWRUb1NoYWRvdyhzdHlsZXNbaV0uaW5uZXJIVE1MKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF6eUJ1bmRsZXMubWFwKChsYXp5QnVuZGxlKSA9PiB7XG4gICAgICAgIGxhenlCdW5kbGVbMV0ubWFwKChjb21wYWN0TWV0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgICAgICAgICAkZmxhZ3MkOiBjb21wYWN0TWV0YVswXSxcbiAgICAgICAgICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgICAgICAgICAgICAgICRtZW1iZXJzJDogY29tcGFjdE1ldGFbMl0sXG4gICAgICAgICAgICAgICAgJGxpc3RlbmVycyQ6IGNvbXBhY3RNZXRhWzNdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IEJVSUxELnRyYW5zZm9ybVRhZ05hbWUgJiYgb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUoY21wTWV0YS4kdGFnTmFtZSQpXG4gICAgICAgICAgICAgICAgOiBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICAgICAgICAgIGNvbnN0IEhvc3RFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICAgICAgLy8gU3RlbmNpbExhenlIb3N0XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHNlbGYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgaXMgdXNpbmcgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBzaGFkb3cgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHJlYWQtb25seSBwcm9wZXJ0eSBcInNoYWRvd1Jvb3RcIiB0byB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdGhlIHNoYWRvdyByb290IGJ1aWxkIGNvbmRpdGlvbmFscyB0byBtaW5pbWl6ZSBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgISgnc2hhZG93Um9vdCcgaW4gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNoYWRvd1Jvb3QgPSBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDaGlsZFNsb3ROb2RlcyhzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcExvYWRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFwcExvYWRGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBMb2FkRmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb3RzdHJhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RlZENhbGxiYWNrIHdpbGwgYmUgcHJvY2Vzc2VkIG9uY2UgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5jbG9uZU5vZGVGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENsb25lTm9kZShIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCkge1xuICAgICAgICAgICAgICAgIHBhdGNoU2xvdEFwcGVuZENoaWxkKEhvc3RFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBIb3N0RWxlbWVudC5wcm90b3R5cGVbJ3MtaG1yJ10gPSBmdW5jdGlvbiAoaG1yVmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhtclN0YXJ0KHRoaXMsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zY29wZWRTbG90VGV4dENvbnRlbnRGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFRleHRDb250ZW50KEhvc3RFbGVtZW50LnByb3RvdHlwZSwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbXBNZXRhLiRsYXp5QnVuZGxlSWQkID0gbGF6eUJ1bmRsZVswXTtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyh0YWdOYW1lKSAmJiAhY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgY21wVGFncy5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBwcm94eUNvbXBvbmVudChIb3N0RWxlbWVudCwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuaW52aXNpYmxlUHJlaHlkcmF0aW9uICYmIChCVUlMRC5oeWRyYXRlZENsYXNzIHx8IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlKSkge1xuICAgICAgICB2aXNpYmlsaXR5U3R5bGUuaW5uZXJIVE1MID0gY21wVGFncyArIEhZRFJBVEVEX0NTUztcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdHlsZXMnLCAnJyk7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHZpc2liaWxpdHlTdHlsZSwgbWV0YUNoYXJzZXQgPyBtZXRhQ2hhcnNldC5uZXh0U2libGluZyA6IGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZGVmZXJyZWQgY29ubmVjdGVkQ2FsbGJhY2tzIG5vdyBhbGwgY29tcG9uZW50cyBoYXZlIGJlZW4gcmVnaXN0ZXJlZFxuICAgIGlzQm9vdHN0cmFwcGluZyA9IGZhbHNlO1xuICAgIGlmIChkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubWFwKChob3N0KSA9PiBob3N0LmNvbm5lY3RlZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJVSUxELnByb2ZpbGUpIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzAsICd0aW1lb3V0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzApKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgYXBwTG9hZCBldmVudFxuICAgIGVuZEJvb3RzdHJhcCgpO1xufTtcbmNvbnN0IGdldEFzc2V0UGF0aCA9IChwYXRoKSA9PiB7XG4gICAgY29uc3QgYXNzZXRVcmwgPSBuZXcgVVJMKHBhdGgsIHBsdC4kcmVzb3VyY2VzVXJsJCk7XG4gICAgcmV0dXJuIGFzc2V0VXJsLm9yaWdpbiAhPT0gd2luLmxvY2F0aW9uLm9yaWdpbiA/IGFzc2V0VXJsLmhyZWYgOiBhc3NldFVybC5wYXRobmFtZTtcbn07XG5jb25zdCBzZXRBc3NldFBhdGggPSAocGF0aCkgPT4gKHBsdC4kcmVzb3VyY2VzVXJsJCA9IHBhdGgpO1xuY29uc3QgZ2V0Q29ubmVjdCA9IChfcmVmLCB0YWdOYW1lKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50T25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgbGV0IGVsbSA9IGRvYy5xdWVyeVNlbGVjdG9yKHRhZ05hbWUpO1xuICAgICAgICBpZiAoIWVsbSkge1xuICAgICAgICAgICAgZWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWxtLmNvbXBvbmVudE9uUmVhZHkgPT09ICdmdW5jdGlvbicgPyBlbG0uY29tcG9uZW50T25SZWFkeSgpIDogUHJvbWlzZS5yZXNvbHZlKGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50T25SZWFkeSgpLnRoZW4oKGVsKSA9PiBlbC5jcmVhdGUoLi4uYXJncykpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBjb21wb25lbnRPblJlYWR5LFxuICAgIH07XG59O1xuY29uc3QgZ2V0Q29udGV4dCA9IChfZWxtLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKGNvbnRleHQgaW4gQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gQ29udGV4dFtjb250ZXh0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgcmV0dXJuIHdpbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNTZXJ2ZXInIHx8IGNvbnRleHQgPT09ICdpc1ByZXJlbmRlcicpIHtcbiAgICAgICAgcmV0dXJuIEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNDbGllbnQnKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3Jlc291cmNlc1VybCcgfHwgY29udGV4dCA9PT0gJ3B1YmxpY1BhdGgnKSB7XG4gICAgICAgIHJldHVybiBnZXRBc3NldFBhdGgoJy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3F1ZXVlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IHdyaXRlVGFzayxcbiAgICAgICAgICAgIHJlYWQ6IHJlYWRUYXNrLFxuICAgICAgICAgICAgdGljazoge1xuICAgICAgICAgICAgICAgIHRoZW4oY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBpbnNlcnRWZG9tQW5ub3RhdGlvbnMgPSAoZG9jLCBzdGF0aWNDb21wb25lbnRzKSA9PiB7XG4gICAgaWYgKGRvYyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvY0RhdGEgPSB7XG4gICAgICAgICAgICBob3N0SWRzOiAwLFxuICAgICAgICAgICAgcm9vdExldmVsSWRzOiAwLFxuICAgICAgICAgICAgc3RhdGljQ29tcG9uZW50czogbmV3IFNldChzdGF0aWNDb21wb25lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBkb2MuYm9keSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMuZm9yRWFjaCgob3JnTG9jYXRpb25Ob2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVmID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgbGV0IGhvc3RJZCA9IG5vZGVSZWZbJ3MtaG9zdC1pZCddO1xuICAgICAgICAgICAgICAgIGxldCBub2RlSWQgPSBub2RlUmVmWydzLW5vZGUtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9YDtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdElkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG9jRGF0YS5yb290TGV2ZWxJZHMrKztcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkID0gZG9jRGF0YS5yb290TGV2ZWxJZHM7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlUmVmLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUmVmLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlUmVmLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdElkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlUmVmLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VsZXNzIHdoaXRlc3BhY2Ugbm9kZSBhdCB0aGUgZG9jdW1lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudChjaGlsZElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmVUZXh0Tm9kZS5ub2RlVmFsdWUgPSBgJHtURVhUX05PREVfSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb21tZW50QmVmb3JlVGV4dE5vZGUsIG5vZGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGVJZCA9IGAke09SR19MT0NBVElPTl9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25QYXJlbnROb2RlID0gb3JnTG9jYXRpb25Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLlwiIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvbiBpcyBhIFNIQURPVyBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGVbJ3MtZW4nXSA9PT0gJ2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLmNcIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTQ09QRUQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuY2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLm5vZGVWYWx1ZSA9IG9yZ0xvY2F0aW9uTm9kZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGFyc2VWTm9kZUFubm90YXRpb25zID0gKGRvYywgbm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2RlcykgPT4ge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZVsncy1uciddICE9IG51bGwpIHtcbiAgICAgICAgb3JnTG9jYXRpb25Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYgIT0gbnVsbCAmJiAhZG9jRGF0YS5zdGF0aWNDb21wb25lbnRzLmhhcyhjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXBEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlSWRzOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgaG9zdFJlZi4kdm5vZGUkLCBkb2NEYXRhLCBjbXBEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlVk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBpbnNlcnRWTm9kZUFubm90YXRpb25zID0gKGRvYywgaG9zdEVsbSwgdm5vZGUsIGRvY0RhdGEsIGNtcERhdGEpID0+IHtcbiAgICBpZiAodm5vZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBob3N0SWQgPSArK2RvY0RhdGEuaG9zdElkcztcbiAgICAgICAgaG9zdEVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCwgaG9zdElkKTtcbiAgICAgICAgaWYgKGhvc3RFbG1bJ3MtY3InXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBob3N0RWxtWydzLWNyJ10ubm9kZVZhbHVlID0gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLiRjaGlsZHJlbiQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVwdGggPSAwO1xuICAgICAgICAgICAgdm5vZGUuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZUNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlQ2hpbGQsIGNtcERhdGEsIGhvc3RJZCwgZGVwdGgsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0RWxtICYmIHZub2RlICYmIHZub2RlLiRlbG0kICYmICFob3N0RWxtLmhhc0F0dHJpYnV0ZSgnYy1pZCcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBob3N0RWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2hpbGROb2RlcyA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBwYXJlbnRDaGlsZE5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8gJiYgbm9kZVsncy1zciddKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudENoaWxkTm9kZXMuaW5kZXhPZihob3N0RWxtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLiRlbG0kLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBgJHtjb21tZW50WydzLWhvc3QtaWQnXX0uJHtjb21tZW50WydzLW5vZGUtaWQnXX0uMC4ke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkRWxtID0gdm5vZGVDaGlsZC4kZWxtJDtcbiAgICBpZiAoY2hpbGRFbG0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVJZCA9IGNtcERhdGEubm9kZUlkcysrO1xuICAgIGNvbnN0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWA7XG4gICAgY2hpbGRFbG1bJ3MtaG9zdC1pZCddID0gaG9zdElkO1xuICAgIGNoaWxkRWxtWydzLW5vZGUtaWQnXSA9IG5vZGVJZDtcbiAgICBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGRFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY2hpbGRFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAobm9kZU5hbWUgIT09ICdTVFlMRScgJiYgbm9kZU5hbWUgIT09ICdTQ1JJUFQnKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZUlkID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSA9IGRvYy5jcmVhdGVDb21tZW50KHRleHROb2RlSWQpO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBjaGlsZEVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKGNoaWxkRWxtWydzLXNyJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROYW1lID0gY2hpbGRFbG1bJ3Mtc24nXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlSWQgPSBgJHtTTE9UX05PREVfSUR9LiR7Y2hpbGRJZH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgY2hpbGRFbG0ubm9kZVZhbHVlID0gc2xvdE5vZGVJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGVDaGlsZC4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hpbGREZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgdm5vZGVDaGlsZC4kY2hpbGRyZW4kLmZvckVhY2goKHZub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zKGRvYywgdm5vZGUsIGNtcERhdGEsIGhvc3RJZCwgY2hpbGREZXB0aCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3Qgc2V0UGxhdGZvcm1PcHRpb25zID0gKG9wdHMpID0+IE9iamVjdC5hc3NpZ24ocGx0LCBvcHRzKTtcbmNvbnN0IEZyYWdtZW50ID0gKF8sIGNoaWxkcmVuKSA9PiBjaGlsZHJlbjtcbmNvbnN0IGhvc3RSZWZzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEhvc3RSZWYgPSAocmVmKSA9PiBob3N0UmVmcy5nZXQocmVmKTtcbmNvbnN0IHJlZ2lzdGVySW5zdGFuY2UgPSAobGF6eUluc3RhbmNlLCBob3N0UmVmKSA9PiBob3N0UmVmcy5zZXQoKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgPSBsYXp5SW5zdGFuY2UpLCBob3N0UmVmKTtcbmNvbnN0IHJlZ2lzdGVySG9zdCA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkaG9zdEVsZW1lbnQkOiBlbG0sXG4gICAgICAgICRjbXBNZXRhJDogY21wTWV0YSxcbiAgICAgICAgJGluc3RhbmNlVmFsdWVzJDogbmV3IE1hcCgpLFxuICAgIH07XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCA9IDA7XG4gICAgfVxuICAgIGlmIChCVUlMRC5tZXRob2QgJiYgQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQgPSByKSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKSk7XG4gICAgICAgIGVsbVsncy1wJ10gPSBbXTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSBbXTtcbiAgICB9XG4gICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgIHJldHVybiBob3N0UmVmcy5zZXQoZWxtLCBob3N0UmVmKTtcbn07XG5jb25zdCBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xuY29uc3QgY29uc29sZUVycm9yID0gKGUsIGVsKSA9PiAoY3VzdG9tRXJyb3IgfHwgY29uc29sZS5lcnJvcikoZSwgZWwpO1xuY29uc3QgU1RFTkNJTF9ERVZfTU9ERSA9IEJVSUxELmlzVGVzdGluZ1xuICAgID8gWydTVEVOQ0lMOiddIC8vIEUyRSB0ZXN0aW5nXG4gICAgOiBbXG4gICAgICAgICclY3N0ZW5jaWwnLFxuICAgICAgICAnY29sb3I6IHdoaXRlO2JhY2tncm91bmQ6IzRjNDdmZjtmb250LXdlaWdodDogYm9sZDsgZm9udC1zaXplOjEwcHg7IHBhZGRpbmc6MnB4IDZweDsgYm9yZGVyLXJhZGl1czogNXB4JyxcbiAgICBdO1xuY29uc3QgY29uc29sZURldkVycm9yID0gKC4uLm0pID0+IGNvbnNvbGUuZXJyb3IoLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2V2FybiA9ICguLi5tKSA9PiBjb25zb2xlLndhcm4oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2SW5mbyA9ICguLi5tKSA9PiBjb25zb2xlLmluZm8oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBzZXRFcnJvckhhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGN1c3RvbUVycm9yID0gaGFuZGxlcik7XG5jb25zdCBjbXBNb2R1bGVzID0gLypAX19QVVJFX18qLyBuZXcgTWFwKCk7XG5jb25zdCBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIGxvYWRNb2R1bGVJbXBvcnRcbiAgICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdHlwZW9mIGJ1bmRsZUlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRyeWluZyB0byBsYXppbHkgbG9hZCBjb21wb25lbnQgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PiB3aXRoIHN0eWxlIG1vZGUgXCIke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiwgYnV0IGl0IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGUgPSAhQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgPyBjbXBNb2R1bGVzLmdldChidW5kbGVJZCkgOiBmYWxzZTtcbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnQoXG4gICAgLyogd2VicGFja0luY2x1ZGU6IC9cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrRXhjbHVkZTogL1xcLnN5c3RlbVxcLmVudHJ5XFwuanMkLyAqL1xuICAgIC8qIHdlYnBhY2tNb2RlOiBcImxhenlcIiAqL1xuICAgIGAuLyR7YnVuZGxlSWR9LmVudHJ5LmpzJHtCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCAmJiBobXJWZXJzaW9uSWQgPyAnP3MtaG1yPScgKyBobXJWZXJzaW9uSWQgOiAnJ31gKS50aGVuKChpbXBvcnRlZE1vZHVsZSkgPT4ge1xuICAgICAgICBpZiAoIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjbXBNb2R1bGVzLnNldChidW5kbGVJZCwgaW1wb3J0ZWRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRlZE1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9LCBjb25zb2xlRXJyb3IpO1xufTtcbmNvbnN0IHN0eWxlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IG1vZGVSZXNvbHV0aW9uQ2hhaW4gPSBbXTtcbmNvbnN0IHF1ZXVlRG9tUmVhZHMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlc0xvdyA9IFtdO1xuY29uc3QgcXVldWVUYXNrID0gKHF1ZXVlLCB3cml0ZSkgPT4gKGNiKSA9PiB7XG4gICAgcXVldWUucHVzaChjYik7XG4gICAgaWYgKCFxdWV1ZVBlbmRpbmcpIHtcbiAgICAgICAgcXVldWVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHdyaXRlICYmIHBsdC4kZmxhZ3MkICYgNCAvKiBxdWV1ZVN5bmMgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNvbnN1bWUgPSAocXVldWUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZVtpXShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xufTtcbmNvbnN0IGNvbnN1bWVUaW1lb3V0ID0gKHF1ZXVlLCB0aW1lb3V0KSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB0cyA9IDA7XG4gICAgd2hpbGUgKGkgPCBxdWV1ZS5sZW5ndGggJiYgKHRzID0gcGVyZm9ybWFuY2Uubm93KCkpIDwgdGltZW91dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaSsrXSh0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKDAsIGkpO1xuICAgIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBxdWV1ZUNvbmdlc3Rpb24rKztcbiAgICB9XG4gICAgLy8gYWx3YXlzIGZvcmNlIGEgYnVuY2ggb2YgbWVkaXVtIGNhbGxiYWNrcyB0byBydW4sIGJ1dCBzdGlsbCBoYXZlXG4gICAgLy8gYSB0aHJvdHRsZSBvbiBob3cgbWFueSBjYW4gcnVuIGluIGEgY2VydGFpbiB0aW1lXG4gICAgLy8gRE9NIFJFQURTISEhXG4gICAgY29uc3VtZShxdWV1ZURvbVJlYWRzKTtcbiAgICAvLyBET00gV1JJVEVTISEhXG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChwbHQuJGZsYWdzJCAmIDYgLyogcXVldWVNYXNrICovKSA9PT0gMiAvKiBhcHBMb2FkZWQgKi9cbiAgICAgICAgICAgID8gcGVyZm9ybWFuY2Uubm93KCkgKyAxNCAqIE1hdGguY2VpbChxdWV1ZUNvbmdlc3Rpb24gKiAoMS4wIC8gMTAuMCkpXG4gICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlcywgdGltZW91dCk7XG4gICAgICAgIGNvbnN1bWVUaW1lb3V0KHF1ZXVlRG9tV3JpdGVzTG93LCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzTG93LnB1c2goLi4ucXVldWVEb21Xcml0ZXMpO1xuICAgICAgICAgICAgcXVldWVEb21Xcml0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXNMb3cubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWVDb25nZXN0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3VtZShxdWV1ZURvbVdyaXRlcyk7XG4gICAgICAgIGlmICgocXVldWVQZW5kaW5nID0gcXVldWVEb21SZWFkcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gc3RpbGwgbW9yZSB0byBkbyB5ZXQsIGJ1dCB3ZSd2ZSBydW4gb3V0IG9mIHRpbWVcbiAgICAgICAgICAgIC8vIGxldCdzIGxldCB0aGlzIHRoaW5nIGNvb2wgb2ZmIGFuZCB0cnkgYWdhaW4gaW4gdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbmV4dFRpY2sgPSAvKkBfX1BVUkVfXyovIChjYikgPT4gcHJvbWlzZVJlc29sdmUoKS50aGVuKGNiKTtcbmNvbnN0IHJlYWRUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21SZWFkcywgZmFsc2UpO1xuY29uc3Qgd3JpdGVUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21Xcml0ZXMsIHRydWUpO1xuY29uc3QgQnVpbGQgPSB7XG4gICAgaXNEZXY6IEJVSUxELmlzRGV2ID8gdHJ1ZSA6IGZhbHNlLFxuICAgIGlzQnJvd3NlcjogdHJ1ZSxcbiAgICBpc1NlcnZlcjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBCVUlMRC5pc1Rlc3RpbmcgPyB0cnVlIDogZmFsc2UsXG59O1xuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5leHBvcnQgeyBCdWlsZCwgQ1NTLCBDb250ZXh0LCBGcmFnbWVudCwgSCwgSCBhcyBIVE1MRWxlbWVudCwgSG9zdCwgU1RFTkNJTF9ERVZfTU9ERSwgYWRkSG9zdEV2ZW50TGlzdGVuZXJzLCBib290c3RyYXBMYXp5LCBjbXBNb2R1bGVzLCBjb25uZWN0ZWRDYWxsYmFjaywgY29uc29sZURldkVycm9yLCBjb25zb2xlRGV2SW5mbywgY29uc29sZURldldhcm4sIGNvbnNvbGVFcnJvciwgY3JlYXRlRXZlbnQsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRpc2Nvbm5lY3RlZENhbGxiYWNrLCBkb2MsIGZvcmNlTW9kZVVwZGF0ZSwgZm9yY2VVcGRhdGUsIGdldEFzc2V0UGF0aCwgZ2V0Q29ubmVjdCwgZ2V0Q29udGV4dCwgZ2V0RWxlbWVudCwgZ2V0SG9zdFJlZiwgZ2V0TW9kZSwgZ2V0UmVuZGVyaW5nUmVmLCBnZXRWYWx1ZSwgaCwgaW5zZXJ0VmRvbUFubm90YXRpb25zLCBpc01lbWJlckluRWxlbWVudCwgbG9hZE1vZHVsZSwgbW9kZVJlc29sdXRpb25DaGFpbiwgbmV4dFRpY2ssIHBhcnNlUHJvcGVydHlWYWx1ZSwgcGx0LCBwb3N0VXBkYXRlQ29tcG9uZW50LCBwcm9taXNlUmVzb2x2ZSwgcHJveHlDb21wb25lbnQsIHByb3h5Q3VzdG9tRWxlbWVudCwgcmVhZFRhc2ssIHJlZ2lzdGVySG9zdCwgcmVnaXN0ZXJJbnN0YW5jZSwgcmVuZGVyVmRvbSwgc2V0QXNzZXRQYXRoLCBzZXRFcnJvckhhbmRsZXIsIHNldE1vZGUsIHNldFBsYXRmb3JtSGVscGVycywgc2V0UGxhdGZvcm1PcHRpb25zLCBzZXRWYWx1ZSwgc3R5bGVzLCBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cywgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzU2hhZG93LCB3aW4sIHdyaXRlVGFzayB9O1xuIiwiaW1wb3J0IHsgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQnO1xuXG5sZXQgQ0FDSEVEX01BUDtcbmNvbnN0IGdldEljb25NYXAgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgTWFwKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCFDQUNIRURfTUFQKSB7XG4gICAgICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gICAgICB3aW4uSW9uaWNvbnMgPSB3aW4uSW9uaWNvbnMgfHwge307XG4gICAgICBDQUNIRURfTUFQID0gd2luLklvbmljb25zLm1hcCA9IHdpbi5Jb25pY29ucy5tYXAgfHwgbmV3IE1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gQ0FDSEVEX01BUDtcbiAgfVxufTtcbmNvbnN0IGFkZEljb25zID0gKGljb25zKSA9PiB7XG4gIGNvbnN0IG1hcCA9IGdldEljb25NYXAoKTtcbiAgT2JqZWN0LmtleXMoaWNvbnMpLmZvckVhY2gobmFtZSA9PiBtYXAuc2V0KG5hbWUsIGljb25zW25hbWVdKSk7XG59O1xuY29uc3QgZ2V0VXJsID0gKGkpID0+IHtcbiAgbGV0IHVybCA9IGdldFNyYyhpLnNyYyk7XG4gIGlmICh1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHVybCA9IGdldE5hbWUoaS5uYW1lLCBpLmljb24sIGkubW9kZSwgaS5pb3MsIGkubWQpO1xuICBpZiAodXJsKSB7XG4gICAgcmV0dXJuIGdldE5hbWVkVXJsKHVybCk7XG4gIH1cbiAgaWYgKGkuaWNvbikge1xuICAgIHVybCA9IGdldFNyYyhpLmljb24pO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHVybCA9IGdldFNyYyhpLmljb25baS5tb2RlXSk7XG4gICAgaWYgKHVybCkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0TmFtZWRVcmwgPSAoaWNvbk5hbWUpID0+IHtcbiAgY29uc3QgdXJsID0gZ2V0SWNvbk1hcCgpLmdldChpY29uTmFtZSk7XG4gIGlmICh1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHJldHVybiBnZXRBc3NldFBhdGgoYHN2Zy8ke2ljb25OYW1lfS5zdmdgKTtcbn07XG5jb25zdCBnZXROYW1lID0gKGljb25OYW1lLCBpY29uLCBtb2RlLCBpb3MsIG1kKSA9PiB7XG4gIC8vIGRlZmF1bHQgdG8gXCJtZFwiIGlmIHNvbWVob3cgdGhlIG1vZGUgd2Fzbid0IHNldFxuICBtb2RlID0gKG1vZGUgJiYgdG9Mb3dlcihtb2RlKSkgPT09ICdpb3MnID8gJ2lvcycgOiAnbWQnO1xuICAvLyBpZiBhbiBpY29uIHdhcyBwYXNzZWQgaW4gdXNpbmcgdGhlIGlvcyBvciBtZCBhdHRyaWJ1dGVzXG4gIC8vIHNldCB0aGUgaWNvbk5hbWUgdG8gd2hhdGV2ZXIgd2FzIHBhc3NlZCBpblxuICBpZiAoaW9zICYmIG1vZGUgPT09ICdpb3MnKSB7XG4gICAgaWNvbk5hbWUgPSB0b0xvd2VyKGlvcyk7XG4gIH1cbiAgZWxzZSBpZiAobWQgJiYgbW9kZSA9PT0gJ21kJykge1xuICAgIGljb25OYW1lID0gdG9Mb3dlcihtZCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCFpY29uTmFtZSAmJiBpY29uICYmICFpc1NyYyhpY29uKSkge1xuICAgICAgaWNvbk5hbWUgPSBpY29uO1xuICAgIH1cbiAgICBpZiAoaXNTdHIoaWNvbk5hbWUpKSB7XG4gICAgICBpY29uTmFtZSA9IHRvTG93ZXIoaWNvbk5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU3RyKGljb25OYW1lKSB8fCBpY29uTmFtZS50cmltKCkgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gb25seSBhbGxvdyBhbHBoYSBjaGFyYWN0ZXJzIGFuZCBkYXNoXG4gIGNvbnN0IGludmFsaWRDaGFycyA9IGljb25OYW1lLnJlcGxhY2UoL1thLXpdfC18XFxkL2dpLCAnJyk7XG4gIGlmIChpbnZhbGlkQ2hhcnMgIT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGljb25OYW1lO1xufTtcbmNvbnN0IGdldFNyYyA9IChzcmMpID0+IHtcbiAgaWYgKGlzU3RyKHNyYykpIHtcbiAgICBzcmMgPSBzcmMudHJpbSgpO1xuICAgIGlmIChpc1NyYyhzcmMpKSB7XG4gICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBpc1NyYyA9IChzdHIpID0+IHN0ci5sZW5ndGggPiAwICYmIC8oXFwvfFxcLikvLnRlc3Qoc3RyKTtcbmNvbnN0IGlzU3RyID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5jb25zdCB0b0xvd2VyID0gKHZhbCkgPT4gdmFsLnRvTG93ZXJDYXNlKCk7XG4vKipcbiAqIEVsZW1lbnRzIGluc2lkZSBvZiB3ZWIgY29tcG9uZW50cyBzb21ldGltZXMgbmVlZCB0byBpbmhlcml0IGdsb2JhbCBhdHRyaWJ1dGVzXG4gKiBzZXQgb24gdGhlIGhvc3QuIEZvciBleGFtcGxlLCB0aGUgaW5uZXIgaW5wdXQgaW4gYGlvbi1pbnB1dGAgc2hvdWxkIGluaGVyaXRcbiAqIHRoZSBgdGl0bGVgIGF0dHJpYnV0ZSB0aGF0IGRldmVsb3BlcnMgc2V0IGRpcmVjdGx5IG9uIGBpb24taW5wdXRgLiBUaGlzXG4gKiBoZWxwZXIgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBpbiBjb21wb25lbnRXaWxsTG9hZCBhbmQgYXNzaWduZWQgdG8gYSB2YXJpYWJsZVxuICogdGhhdCBpcyBsYXRlciB1c2VkIGluIHRoZSByZW5kZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlYWN0aXZlIGFzIGNoYW5naW5nIGF0dHJpYnV0ZXMgb24gdGhlIGhvc3QgZWxlbWVudFxuICogZG9lcyBub3QgdHJpZ2dlciBhIHJlLXJlbmRlci5cbiAqL1xuY29uc3QgaW5oZXJpdEF0dHJpYnV0ZXMgPSAoZWwsIGF0dHJpYnV0ZXMgPSBbXSkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVPYmplY3QgPSB7fTtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZU9iamVjdFthdHRyXSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXR0cmlidXRlT2JqZWN0O1xufTtcblxuZXhwb3J0IHsgYWRkSWNvbnMgYXMgYSwgaW5oZXJpdEF0dHJpYnV0ZXMgYXMgYiwgZ2V0TmFtZSBhcyBjLCBnZXRVcmwgYXMgZywgaXNTdHIgYXMgaSB9O1xuIiwiaW1wb3J0IHsgSFRNTEVsZW1lbnQsIEJ1aWxkLCBoLCBIb3N0LCBwcm94eUN1c3RvbUVsZW1lbnQgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBpIGFzIGlzU3RyLCBiIGFzIGluaGVyaXRBdHRyaWJ1dGVzLCBnIGFzIGdldFVybCwgYyBhcyBnZXROYW1lIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IHZhbGlkYXRlQ29udGVudCA9IChzdmdDb250ZW50KSA9PiB7XG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gc3ZnQ29udGVudDtcbiAgLy8gc2V0dXAgdGhpcyB3YXkgdG8gZW5zdXJlIGl0IHdvcmtzIG9uIG91ciBidWRkeSBJRVxuICBmb3IgKGxldCBpID0gZGl2LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoZGl2LmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3N2ZycpIHtcbiAgICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuY2hpbGROb2Rlc1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIG11c3Qgb25seSBoYXZlIDEgcm9vdCBlbGVtZW50XG4gIGNvbnN0IHN2Z0VsbSA9IGRpdi5maXJzdEVsZW1lbnRDaGlsZDtcbiAgaWYgKHN2Z0VsbSAmJiBzdmdFbG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICBjb25zdCBzdmdDbGFzcyA9IHN2Z0VsbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgc3ZnRWxtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoc3ZnQ2xhc3MgKyAnIHMtaW9uLWljb24nKS50cmltKCkpO1xuICAgIC8vIHJvb3QgZWxlbWVudCBtdXN0IGJlIGFuIHN2Z1xuICAgIC8vIGxldHMgZG91YmxlIGNoZWNrIHdlJ3ZlIGdvdCB2YWxpZCBlbGVtZW50c1xuICAgIC8vIGRvIG5vdCBhbGxvdyBzY3JpcHRzXG4gICAgaWYgKGlzVmFsaWQoc3ZnRWxtKSkge1xuICAgICAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn07XG5jb25zdCBpc1ZhbGlkID0gKGVsbSkgPT4ge1xuICBpZiAoZWxtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgaWYgKGVsbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWwgPSBlbG0uYXR0cmlidXRlc1tpXS52YWx1ZTtcbiAgICAgIGlmIChpc1N0cih2YWwpICYmIHZhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ29uJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzVmFsaWQoZWxtLmNoaWxkTm9kZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpb25pY29uQ29udGVudCA9IG5ldyBNYXAoKTtcbmNvbnN0IHJlcXVlc3RzID0gbmV3IE1hcCgpO1xuY29uc3QgZ2V0U3ZnQ29udGVudCA9ICh1cmwsIHNhbml0aXplKSA9PiB7XG4gIC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSByZXF1ZXN0IGZvciB0aGlzIHVybFxuICBsZXQgcmVxID0gcmVxdWVzdHMuZ2V0KHVybCk7XG4gIGlmICghcmVxKSB7XG4gICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgcmVxdWVzdFxuICAgICAgcmVxID0gZmV0Y2godXJsKS50aGVuKChyc3ApID0+IHtcbiAgICAgICAgaWYgKHJzcC5vaykge1xuICAgICAgICAgIHJldHVybiByc3AudGV4dCgpLnRoZW4oKHN2Z0NvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChzdmdDb250ZW50ICYmIHNhbml0aXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzdmdDb250ZW50ID0gdmFsaWRhdGVDb250ZW50KHN2Z0NvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW9uaWNvbkNvbnRlbnQuc2V0KHVybCwgc3ZnQ29udGVudCB8fCAnJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW9uaWNvbkNvbnRlbnQuc2V0KHVybCwgJycpO1xuICAgICAgfSk7XG4gICAgICAvLyBjYWNoZSBmb3IgdGhlIHNhbWUgcmVxdWVzdHNcbiAgICAgIHJlcXVlc3RzLnNldCh1cmwsIHJlcSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gc2V0IHRvIGVtcHR5IGZvciBzc3Igc2NlbmFyaW9zIGFuZCByZXNvbHZlIHByb21pc2VcbiAgICAgIGlvbmljb25Db250ZW50LnNldCh1cmwsICcnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcTtcbn07XG5cbmNvbnN0IGljb25Dc3MgPSBcIjpob3N0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjFlbTtoZWlnaHQ6MWVtO2NvbnRhaW46c3RyaWN0O2ZpbGw6Y3VycmVudENvbG9yOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveCAhaW1wb3J0YW50O2JveC1zaXppbmc6Y29udGVudC1ib3ggIWltcG9ydGFudH06aG9zdCAuaW9uaWNvbntzdHJva2U6Y3VycmVudENvbG9yfS5pb25pY29uLWZpbGwtbm9uZXtmaWxsOm5vbmV9Lmlvbmljb24tc3Ryb2tlLXdpZHRoe3N0cm9rZS13aWR0aDozMnB4O3N0cm9rZS13aWR0aDp2YXIoLS1pb25pY29uLXN0cm9rZS13aWR0aCwgMzJweCl9Lmljb24taW5uZXIsLmlvbmljb24sc3Zne2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX06aG9zdCguZmxpcC1ydGwpIC5pY29uLWlubmVyey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlWCgtMSl9Omhvc3QoLmljb24tc21hbGwpe2ZvbnQtc2l6ZToxOHB4ICFpbXBvcnRhbnR9Omhvc3QoLmljb24tbGFyZ2Upe2ZvbnQtc2l6ZTozMnB4ICFpbXBvcnRhbnR9Omhvc3QoLmlvbi1jb2xvcil7Y29sb3I6dmFyKC0taW9uLWNvbG9yLWJhc2UpICFpbXBvcnRhbnR9Omhvc3QoLmlvbi1jb2xvci1wcmltYXJ5KXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1wcmltYXJ5LCAjMzg4MGZmKX06aG9zdCguaW9uLWNvbG9yLXNlY29uZGFyeSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3Itc2Vjb25kYXJ5LCAjMGNkMWU4KX06aG9zdCguaW9uLWNvbG9yLXRlcnRpYXJ5KXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci10ZXJ0aWFyeSwgI2Y0YTk0Mil9Omhvc3QoLmlvbi1jb2xvci1zdWNjZXNzKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1zdWNjZXNzLCAjMTBkYzYwKX06aG9zdCguaW9uLWNvbG9yLXdhcm5pbmcpey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLXdhcm5pbmcsICNmZmNlMDApfTpob3N0KC5pb24tY29sb3ItZGFuZ2VyKXstLWlvbi1jb2xvci1iYXNlOnZhcigtLWlvbi1jb2xvci1kYW5nZXIsICNmMTQxNDEpfTpob3N0KC5pb24tY29sb3ItbGlnaHQpey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLWxpZ2h0LCAjZjRmNWY4KX06aG9zdCguaW9uLWNvbG9yLW1lZGl1bSl7LS1pb24tY29sb3ItYmFzZTp2YXIoLS1pb24tY29sb3ItbWVkaXVtLCAjOTg5YWEyKX06aG9zdCguaW9uLWNvbG9yLWRhcmspey0taW9uLWNvbG9yLWJhc2U6dmFyKC0taW9uLWNvbG9yLWRhcmssICMyMjI0MjgpfVwiO1xuXG5sZXQgSWNvbiA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pY29uTmFtZSA9IG51bGw7XG4gICAgdGhpcy5pbmhlcml0ZWRBdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZSBkZXRlcm1pbmVzIHdoaWNoIHBsYXRmb3JtIHN0eWxlcyB0byB1c2UuXG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gZ2V0SW9uTW9kZSgpO1xuICAgIC8qKlxuICAgICAqIElmIGVuYWJsZWQsIGlvbi1pY29uIHdpbGwgYmUgbG9hZGVkIGxhemlseSB3aGVuIGl0J3MgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogRGVmYXVsdCwgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB0aGlzLmxhenkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBTVkcgY29udGVudCB0aGF0IGlzIEhUVFAgZmV0Y2hlZCB3aWxsIG5vdCBiZSBjaGVja2VkXG4gICAgICogaWYgdGhlIHJlc3BvbnNlIFNWRyBjb250ZW50IGhhcyBhbnkgYDxzY3JpcHQ+YCBlbGVtZW50cywgb3IgYW55IGF0dHJpYnV0ZXNcbiAgICAgKiB0aGF0IHN0YXJ0IHdpdGggYG9uYCwgc3VjaCBhcyBgb25jbGlja2AuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc2FuaXRpemUgPSB0cnVlO1xuICAgIHRoaXMuaGFzQXJpYUhpZGRlbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpICYmIGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSA9PT0gJ3RydWUnO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5pbmhlcml0ZWRBdHRyaWJ1dGVzID0gaW5oZXJpdEF0dHJpYnV0ZXModGhpcy5lbCwgWydhcmlhLWxhYmVsJ10pO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIHB1cnBvc2VseSBkbyBub3QgcmV0dXJuIHRoZSBwcm9taXNlIGhlcmUgYmVjYXVzZSBsb2FkaW5nXG4gICAgLy8gdGhlIHN2ZyBmaWxlIHNob3VsZCBub3QgaG9sZCB1cCBsb2FkaW5nIHRoZSBhcHBcbiAgICAvLyBvbmx5IGxvYWQgdGhlIHN2ZyBpZiBpdCdzIHZpc2libGVcbiAgICB0aGlzLndhaXRVbnRpbFZpc2libGUodGhpcy5lbCwgJzUwcHgnLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLmxvYWRJY29uKCk7XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuaW8pIHtcbiAgICAgIHRoaXMuaW8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5pbyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgd2FpdFVudGlsVmlzaWJsZShlbCwgcm9vdE1hcmdpbiwgY2IpIHtcbiAgICBpZiAoQnVpbGQuaXNCcm93c2VyICYmIHRoaXMubGF6eSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGlvID0gKHRoaXMuaW8gPSBuZXcgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhWzBdLmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuaW8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfSwgeyByb290TWFyZ2luIH0pKTtcbiAgICAgIGlvLm9ic2VydmUoZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICAvLyBzbyBqdXN0IGZhbGxiYWNrIHRvIGFsd2F5cyBzaG93IGl0XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuICBsb2FkSWNvbigpIHtcbiAgICBpZiAoQnVpbGQuaXNCcm93c2VyICYmIHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICBjb25zdCB1cmwgPSBnZXRVcmwodGhpcyk7XG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGlmIChpb25pY29uQ29udGVudC5oYXModXJsKSkge1xuICAgICAgICAgIC8vIHN5bmMgaWYgaXQncyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgIHRoaXMuc3ZnQ29udGVudCA9IGlvbmljb25Db250ZW50LmdldCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFzeW5jIGlmIGl0IGhhc24ndCBiZWVuIGxvYWRlZFxuICAgICAgICAgIGdldFN2Z0NvbnRlbnQodXJsLCB0aGlzLnNhbml0aXplKS50aGVuKCgpID0+ICh0aGlzLnN2Z0NvbnRlbnQgPSBpb25pY29uQ29udGVudC5nZXQodXJsKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5pY29uTmFtZSA9IGdldE5hbWUodGhpcy5uYW1lLCB0aGlzLmljb24sIHRoaXMubW9kZSwgdGhpcy5pb3MsIHRoaXMubWQpO1xuICAgIC8qKlxuICAgICAqIENvbWUgdXAgd2l0aCBhIGRlZmF1bHQgbGFiZWxcbiAgICAgKiBpbiBjYXNlIHVzZXIgZG9lcyBub3QgcHJvdmlkZSB0aGVpciBvd24uXG4gICAgICovXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB0aGlzLmFyaWFMYWJlbCA9IGxhYmVsLnJlcGxhY2UoL1xcLS9nLCAnICcpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpY29uTmFtZSwgYXJpYUxhYmVsLCBpbmhlcml0ZWRBdHRyaWJ1dGVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGUgfHwgJ21kJztcbiAgICBjb25zdCBmbGlwUnRsID0gdGhpcy5mbGlwUnRsIHx8XG4gICAgICAoaWNvbk5hbWUgJiZcbiAgICAgICAgKGljb25OYW1lLmluZGV4T2YoJ2Fycm93JykgPiAtMSB8fCBpY29uTmFtZS5pbmRleE9mKCdjaGV2cm9uJykgPiAtMSkgJiZcbiAgICAgICAgdGhpcy5mbGlwUnRsICE9PSBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogT25seSBzZXQgdGhlIGFyaWEtbGFiZWwgaWYgYSkgd2UgaGF2ZSBnZW5lcmF0ZWRcbiAgICAgKiBvbmUgZm9yIHRoZSBpY29uIGFuZCBpZiBhcmlhLWhpZGRlbiBpcyBub3Qgc2V0IHRvIFwidHJ1ZVwiLlxuICAgICAqIElmIGRldmVsb3BlciB3YW50cyB0byBzZXQgdGhlaXIgb3duIGFyaWEtbGFiZWwsIHRoZW5cbiAgICAgKiBpbmhlcml0ZWRBdHRyaWJ1dGVzIGRvd24gYmVsb3cgd2lsbCBvdmVycmlkZSB3aGF0ZXZlclxuICAgICAqIGRlZmF1bHQgbGFiZWwgd2UgaGF2ZSBzZXQuXG4gICAgICovXG4gICAgcmV0dXJuIChoKEhvc3QsIE9iamVjdC5hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzQXJpYUhpZGRlbigpID8gYXJpYUxhYmVsIDogbnVsbCwgcm9sZTogXCJpbWdcIiwgY2xhc3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IFttb2RlXTogdHJ1ZSB9LCBjcmVhdGVDb2xvckNsYXNzZXModGhpcy5jb2xvcikpLCB7IFtgaWNvbi0ke3RoaXMuc2l6ZX1gXTogISF0aGlzLnNpemUsICdmbGlwLXJ0bCc6ICEhZmxpcFJ0bCAmJiB0aGlzLmVsLm93bmVyRG9jdW1lbnQuZGlyID09PSAncnRsJyB9KSB9LCBpbmhlcml0ZWRBdHRyaWJ1dGVzKSwgQnVpbGQuaXNCcm93c2VyICYmIHRoaXMuc3ZnQ29udGVudCA/IChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaWNvbi1pbm5lclwiLCBpbm5lckhUTUw6IHRoaXMuc3ZnQ29udGVudCB9KSkgOiAoaChcImRpdlwiLCB7IGNsYXNzOiBcImljb24taW5uZXJcIiB9KSkpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJzdmdcIl07IH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwibmFtZVwiOiBbXCJsb2FkSWNvblwiXSxcbiAgICBcInNyY1wiOiBbXCJsb2FkSWNvblwiXSxcbiAgICBcImljb25cIjogW1wibG9hZEljb25cIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gaWNvbkNzczsgfVxufTtcbmNvbnN0IGdldElvbk1vZGUgPSAoKSA9PiAoQnVpbGQuaXNCcm93c2VyICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kZScpKSB8fCAnbWQnO1xuY29uc3QgY3JlYXRlQ29sb3JDbGFzc2VzID0gKGNvbG9yKSA9PiB7XG4gIHJldHVybiBjb2xvclxuICAgID8ge1xuICAgICAgJ2lvbi1jb2xvcic6IHRydWUsXG4gICAgICBbYGlvbi1jb2xvci0ke2NvbG9yfWBdOiB0cnVlLFxuICAgIH1cbiAgICA6IG51bGw7XG59O1xuSWNvbiA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KEljb24sIFsxLCBcImlvbi1pY29uXCIsIHtcbiAgICBcIm1vZGVcIjogWzEwMjVdLFxuICAgIFwiY29sb3JcIjogWzFdLFxuICAgIFwiaW9zXCI6IFsxXSxcbiAgICBcIm1kXCI6IFsxXSxcbiAgICBcImZsaXBSdGxcIjogWzQsIFwiZmxpcC1ydGxcIl0sXG4gICAgXCJuYW1lXCI6IFs1MTNdLFxuICAgIFwic3JjXCI6IFsxXSxcbiAgICBcImljb25cIjogWzhdLFxuICAgIFwic2l6ZVwiOiBbMV0sXG4gICAgXCJsYXp5XCI6IFs0XSxcbiAgICBcInNhbml0aXplXCI6IFs0XSxcbiAgICBcInN2Z0NvbnRlbnRcIjogWzMyXSxcbiAgICBcImlzVmlzaWJsZVwiOiBbMzJdLFxuICAgIFwiYXJpYUxhYmVsXCI6IFszMl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJpb24taWNvblwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiaW9uLWljb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBJY29uKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuXG5jb25zdCBJb25JY29uID0gSWNvbjtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IElvbkljb24sIGRlZmluZUN1c3RvbUVsZW1lbnQgfTtcbiIsImV4cG9ydCAqIGZyb20gJy4vZXNtLWVzNS9pbmRleC5qcyc7IiwiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0LCBjcmVhdGVFbGVtZW50LCB1c2VTdGF0ZSwgRnJhZ21lbnQsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybSBhcyBpc1BsYXRmb3JtJDEsIGdldFBsYXRmb3JtcyBhcyBnZXRQbGF0Zm9ybXMkMSwgYWxlcnRDb250cm9sbGVyLCBsb2FkaW5nQ29udHJvbGxlciwgdG9hc3RDb250cm9sbGVyIGFzIHRvYXN0Q29udHJvbGxlciQxLCBwaWNrZXJDb250cm9sbGVyLCBhY3Rpb25TaGVldENvbnRyb2xsZXIgYXMgYWN0aW9uU2hlZXRDb250cm9sbGVyJDEsIGNyZWF0ZUFuaW1hdGlvbiwgbW9kYWxDb250cm9sbGVyLCBwb3BvdmVyQ29udHJvbGxlciwgaW5pdGlhbGl6ZSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuZXhwb3J0IHsgSW9uaWNTYWZlU3RyaW5nLCBJb25pY1NsaWRlcywgSW9uaWNTd2lwZXIsIGNyZWF0ZUFuaW1hdGlvbiwgY3JlYXRlR2VzdHVyZSwgZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24sIGlvc1RyYW5zaXRpb25BbmltYXRpb24sIG1kVHJhbnNpdGlvbkFuaW1hdGlvbiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFjY29yZGlvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWFjY29yZGlvbi1ncm91cC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWF2YXRhci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkNCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJhY2tkcm9wLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQ1IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYmFkZ2UuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1icmVhZGNydW1icy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkNyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJ1dHRvbnMuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jYXJkLWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDkgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jYXJkLWhlYWRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkYSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWNhcmQtc3VidGl0bGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jYXJkLXRpdGxlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRjIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2hlY2tib3guanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1jaGlwLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRlIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY29sLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRmIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY29udGVudC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkZyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWRhdGV0aW1lLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRoIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZmFiLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRpIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tZmFiLWxpc3QuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGogfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1mb290ZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JGsgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1ncmlkLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRsIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taGVhZGVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRtIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taW1nLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRuIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taW5maW5pdGUtc2Nyb2xsLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRvIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taW5maW5pdGUtc2Nyb2xsLWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHAgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pbnB1dC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkcSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWl0ZW0tZGl2aWRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkciB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWl0ZW0tZ3JvdXAuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHMgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLW9wdGlvbnMuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLXNsaWRpbmcuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1sYWJlbC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkdiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWxpc3QuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHcgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1saXN0LWhlYWRlci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkeCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW1lbnUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JHkgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1tZW51LWJ1dHRvbi5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkeiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW1lbnUtdG9nZ2xlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRBIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbmF2LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRCIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tbmF2LWxpbmsuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEMgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1ub3RlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCREIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcHJvZ3Jlc3MtYmFyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRFIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmFkaW8uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yYWRpby1ncm91cC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkRyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJhbmdlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRIIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmVmcmVzaGVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRJIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmVmcmVzaGVyLWNvbnRlbnQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JEogfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yZW9yZGVyLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRLIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcmVvcmRlci1ncm91cC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkTCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJpcHBsZS1lZmZlY3QuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JE0gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1yb3cuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JE4gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zZWFyY2hiYXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JE8gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zZWdtZW50LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRQIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2VnbWVudC1idXR0b24uanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zZWxlY3QuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1zZWxlY3Qtb3B0aW9uLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRTIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2tlbGV0b24tdGV4dC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkVCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNsaWRlLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRVIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc2xpZGVzLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRWIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tc3Bpbm5lci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkVyB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXNwbGl0LXBhbmUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFggfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10YWIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JFkgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10ZXh0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCRaIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGV4dGFyZWEuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JF8gfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10aHVtYm5haWwuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JCQgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10aXRsZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTAgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10b2dnbGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDExIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdG9vbGJhci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTIgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi12aXJ0dWFsLXNjcm9sbC5qcyc7XG5pbXBvcnQgeyBJb25CcmVhZGNydW1iIGFzIElvbkJyZWFkY3J1bWIkMSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJyZWFkY3J1bWIuanMnO1xuaW1wb3J0IHsgSW9uQnV0dG9uIGFzIElvbkJ1dHRvbiQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYnV0dG9uLmpzJztcbmltcG9ydCB7IElvbkNhcmQgYXMgSW9uQ2FyZCQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tY2FyZC5qcyc7XG5pbXBvcnQgeyBJb25GYWJCdXR0b24gYXMgSW9uRmFiQnV0dG9uJDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1mYWItYnV0dG9uLmpzJztcbmltcG9ydCB7IElvbkl0ZW1PcHRpb24gYXMgSW9uSXRlbU9wdGlvbiQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24taXRlbS1vcHRpb24uanMnO1xuaW1wb3J0IHsgSW9uSXRlbSBhcyBJb25JdGVtJDEgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1pdGVtLmpzJztcbmltcG9ydCB7IElvblJvdXRlckxpbmsgYXMgSW9uUm91dGVyTGluayQxIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tcm91dGVyLWxpbmsuanMnO1xuaW1wb3J0IHsgSW9uQWxlcnQgYXMgSW9uQWxlcnQkMSwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDFjIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYWxlcnQuanMnO1xuaW1wb3J0IHsgSW9uTG9hZGluZyBhcyBJb25Mb2FkaW5nJDEsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZiB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWxvYWRpbmcuanMnO1xuaW1wb3J0IHsgSW9uVG9hc3QgYXMgSW9uVG9hc3QkMSwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDFkIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdG9hc3QuanMnO1xuaW1wb3J0IHsgSW9uUGlja2VyIGFzIElvblBpY2tlciQxLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMWUgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi1waWNrZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEzIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYWN0aW9uLXNoZWV0LmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLW1vZGFsLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXBvcG92ZXIuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDFhIH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tYXBwLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxOCB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLWJhY2stYnV0dG9uLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxOSB9IGZyb20gJ0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW9uLXJvdXRlci1vdXRsZXQuanMnO1xuaW1wb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDE3IH0gZnJvbSAnQGlvbmljL2NvcmUvY29tcG9uZW50cy9pb24tdGFiLWJhci5qcyc7XG5pbXBvcnQgeyBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMTYgfSBmcm9tICdAaW9uaWMvY29yZS9jb21wb25lbnRzL2lvbi10YWItYnV0dG9uLmpzJztcbmltcG9ydCB7IGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxYiB9IGZyb20gJ2lvbmljb25zL2NvbXBvbmVudHMvaW9uLWljb24uanMnO1xuaW1wb3J0IHsgY29tcG9uZW50T25SZWFkeSB9IGZyb20gJ0Bpb25pYy9jb3JlJztcblxuY29uc3QgSW9uTGlmZUN5Y2xlQ29udGV4dCA9IC8qQF9fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgb25Jb25WaWV3V2lsbEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGlvblZpZXdXaWxsRW50ZXI6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgb25Jb25WaWV3RGlkRW50ZXI6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgaW9uVmlld0RpZEVudGVyOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIG9uSW9uVmlld1dpbGxMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBpb25WaWV3V2lsbExlYXZlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIG9uSW9uVmlld0RpZExlYXZlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGlvblZpZXdEaWRMZWF2ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbn0pO1xuY29uc3QgRGVmYXVsdElvbkxpZmVDeWNsZUNvbnRleHQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW9uVmlld1dpbGxFbnRlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5pb25WaWV3RGlkTGVhdmVDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgb25Jb25WaWV3V2lsbEVudGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5pZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MuZmluZEluZGV4KCh4KSA9PiB4LmlkID09PSBjYWxsYmFjay5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxFbnRlckNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxFbnRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxFbnRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3V2lsbEVudGVyKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdXaWxsRW50ZXJDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIH1cbiAgICBvbklvblZpZXdEaWRFbnRlcihjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MuZmluZEluZGV4KCh4KSA9PiB4LmlkID09PSBjYWxsYmFjay5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkRW50ZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRFbnRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3RGlkRW50ZXIoKSB7XG4gICAgICAgIHRoaXMuaW9uVmlld0RpZEVudGVyQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9XG4gICAgb25Jb25WaWV3V2lsbExlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5pZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MuZmluZEluZGV4KCh4KSA9PiB4LmlkID09PSBjYWxsYmFjay5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUNhbGxiYWNrc1tpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW9uVmlld1dpbGxMZWF2ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3V2lsbExlYXZlKCkge1xuICAgICAgICB0aGlzLmlvblZpZXdXaWxsTGVhdmVDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIH1cbiAgICBvbklvblZpZXdEaWRMZWF2ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2suaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pb25WaWV3RGlkTGVhdmVDYWxsYmFja3MuZmluZEluZGV4KCh4KSA9PiB4LmlkID09PSBjYWxsYmFjay5pZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pb25WaWV3RGlkTGVhdmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlvblZpZXdEaWRMZWF2ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpb25WaWV3RGlkTGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaW9uVmlld0RpZExlYXZlQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDYW5CZURlc3Ryb3llZCgpO1xuICAgIH1cbiAgICBvbkNvbXBvbmVudENhbkJlRGVzdHJveWVkKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBjb21wb25lbnRDYW5CZURlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50Q2FuQmVEZXN0cm95ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRDYW5CZURlc3Ryb3llZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCB3aXRoSW9uTGlmZUN5Y2xlID0gKFdyYXBwZWRDb21wb25lbnQpID0+IHtcbiAgICByZXR1cm4gY2xhc3MgSW9uTGlmZUN5Y2xlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jb21wb25lbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbklvblZpZXdXaWxsRW50ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld1dpbGxFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlvblZpZXdXaWxsRW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbklvblZpZXdEaWRFbnRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5pb25WaWV3RGlkRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3RGlkRW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbklvblZpZXdXaWxsTGVhdmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaW9uVmlld1dpbGxMZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlvblZpZXdXaWxsTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5vbklvblZpZXdEaWRMZWF2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5pb25WaWV3RGlkTGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pb25WaWV3RGlkTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uTGlmZUN5Y2xlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMuY29tcG9uZW50UmVmIH0sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5jb25zdCB1c2VJb25WaWV3V2lsbEVudGVyID0gKGNhbGxiYWNrLCBkZXBzID0gW10pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJb25MaWZlQ3ljbGVDb250ZXh0KTtcbiAgICBjb25zdCBpZCA9IHVzZVJlZigpO1xuICAgIGlkLmN1cnJlbnQgPSBpZC5jdXJyZW50IHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmlkID0gaWQuY3VycmVudDtcbiAgICAgICAgY29udGV4dC5vbklvblZpZXdXaWxsRW50ZXIoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcbmNvbnN0IHVzZUlvblZpZXdEaWRFbnRlciA9IChjYWxsYmFjaywgZGVwcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW9uTGlmZUN5Y2xlQ29udGV4dCk7XG4gICAgY29uc3QgaWQgPSB1c2VSZWYoKTtcbiAgICBpZC5jdXJyZW50ID0gaWQuY3VycmVudCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjay5pZCA9IGlkLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQub25Jb25WaWV3RGlkRW50ZXIoY2FsbGJhY2spO1xuICAgIH0sIGRlcHMpO1xufTtcbmNvbnN0IHVzZUlvblZpZXdXaWxsTGVhdmUgPSAoY2FsbGJhY2ssIGRlcHMgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KElvbkxpZmVDeWNsZUNvbnRleHQpO1xuICAgIGNvbnN0IGlkID0gdXNlUmVmKCk7XG4gICAgaWQuY3VycmVudCA9IGlkLmN1cnJlbnQgfHwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2suaWQgPSBpZC5jdXJyZW50O1xuICAgICAgICBjb250ZXh0Lm9uSW9uVmlld1dpbGxMZWF2ZShjYWxsYmFjayk7XG4gICAgfSwgZGVwcyk7XG59O1xuY29uc3QgdXNlSW9uVmlld0RpZExlYXZlID0gKGNhbGxiYWNrLCBkZXBzID0gW10pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJb25MaWZlQ3ljbGVDb250ZXh0KTtcbiAgICBjb25zdCBpZCA9IHVzZVJlZigpO1xuICAgIGlkLmN1cnJlbnQgPSBpZC5jdXJyZW50IHx8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmlkID0gaWQuY3VycmVudDtcbiAgICAgICAgY29udGV4dC5vbklvblZpZXdEaWRMZWF2ZShjYWxsYmFjayk7XG4gICAgfSwgZGVwcyk7XG59O1xuXG5jb25zdCBOYXZDb250ZXh0ID0gLypAX19QVVJFX18qLyBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgICBnZXRJb25SZWRpcmVjdDogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldElvblJvdXRlOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ2V0UGFnZU1hbmFnZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnZXRTdGFja01hbmFnZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnb0JhY2s6IChyb3V0ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lID0gcm91dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG5hdmlnYXRlOiAocGF0aCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhc0lvbmljUm91dGVyOiAoKSA9PiBmYWxzZSxcbiAgICByb3V0ZUluZm86IHVuZGVmaW5lZCxcbiAgICBzZXRDdXJyZW50VGFiOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY2hhbmdlVGFiOiAoX3RhYiwgcGF0aCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0VGFiOiAoX3RhYiwgcGF0aCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbmNvbnN0IGRhc2hUb1Bhc2NhbENhc2UgPSAoc3RyKSA9PiBzdHJcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5zcGxpdCgnLScpXG4gICAgLm1hcCgoc2VnbWVudCkgPT4gc2VnbWVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlZ21lbnQuc2xpY2UoMSkpXG4gICAgLmpvaW4oJycpO1xuY29uc3QgY2FtZWxUb0Rhc2hDYXNlID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgKG0pID0+IGAtJHttWzBdLnRvTG93ZXJDYXNlKCl9YCk7XG5cbmNvbnN0IGF0dGFjaFByb3BzID0gKG5vZGUsIG5ld1Byb3BzLCBvbGRQcm9wcyA9IHt9KSA9PiB7XG4gICAgLy8gc29tZSB0ZXN0IGZyYW1ld29ya3MgZG9uJ3QgcmVuZGVyIERPTSBlbGVtZW50cywgc28gd2UgdGVzdCBoZXJlIHRvIG1ha2Ugc3VyZSB3ZSBhcmUgZGVhbGluZyB3aXRoIERPTSBmaXJzdFxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAvLyBhZGQgYW55IGNsYXNzZXMgaW4gY2xhc3NOYW1lIHRvIHRoZSBjbGFzcyBsaXN0XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShub2RlLmNsYXNzTGlzdCwgbmV3UHJvcHMsIG9sZFByb3BzKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gJycpIHtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1Byb3BzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NoaWxkcmVuJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAncmVmJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAnY2xhc3NOYW1lJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdmb3J3YXJkZWRSZWYnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignb24nKSA9PT0gMCAmJiBuYW1lWzJdID09PSBuYW1lWzJdLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBuYW1lLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWVMYyA9IGV2ZW50TmFtZVswXS50b0xvd2VyQ2FzZSgpICsgZXZlbnROYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ292ZXJlZEJ5UmVhY3QoZXZlbnROYW1lTGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNFdmVudChub2RlLCBldmVudE5hbWVMYywgbmV3UHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVbbmFtZV0gPSBuZXdQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHR5cGVvZiBuZXdQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNhbWVsVG9EYXNoQ2FzZShuYW1lKSwgbmV3UHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGdldENsYXNzTmFtZSA9IChjbGFzc0xpc3QsIG5ld1Byb3BzLCBvbGRQcm9wcykgPT4ge1xuICAgIGNvbnN0IG5ld0NsYXNzUHJvcCA9IG5ld1Byb3BzLmNsYXNzTmFtZSB8fCBuZXdQcm9wcy5jbGFzcztcbiAgICBjb25zdCBvbGRDbGFzc1Byb3AgPSBvbGRQcm9wcy5jbGFzc05hbWUgfHwgb2xkUHJvcHMuY2xhc3M7XG4gICAgLy8gbWFwIHRoZSBjbGFzc2VzIHRvIE1hcHMgZm9yIHBlcmZvcm1hbmNlXG4gICAgY29uc3QgY3VycmVudENsYXNzZXMgPSBhcnJheVRvTWFwKGNsYXNzTGlzdCk7XG4gICAgY29uc3QgaW5jb21pbmdQcm9wQ2xhc3NlcyA9IGFycmF5VG9NYXAobmV3Q2xhc3NQcm9wID8gbmV3Q2xhc3NQcm9wLnNwbGl0KCcgJykgOiBbXSk7XG4gICAgY29uc3Qgb2xkUHJvcENsYXNzZXMgPSBhcnJheVRvTWFwKG9sZENsYXNzUHJvcCA/IG9sZENsYXNzUHJvcC5zcGxpdCgnICcpIDogW10pO1xuICAgIGNvbnN0IGZpbmFsQ2xhc3NOYW1lcyA9IFtdO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIG9mIHRoZSBjdXJyZW50IGNsYXNzZXMgb24gdGhlIGNvbXBvbmVudFxuICAgIC8vIHRvIHNlZSBpZiBpdCBzaG91bGQgYmUgYSBwYXJ0IG9mIHRoZSBjbGFzc05hbWVzIGFkZGVkXG4gICAgY3VycmVudENsYXNzZXMuZm9yRWFjaCgoY3VycmVudENsYXNzKSA9PiB7XG4gICAgICAgIGlmIChpbmNvbWluZ1Byb3BDbGFzc2VzLmhhcyhjdXJyZW50Q2xhc3MpKSB7XG4gICAgICAgICAgICAvLyBhZGQgaXQgYXMgaXRzIGFscmVhZHkgaW5jbHVkZWQgaW4gY2xhc3NuYW1lcyBjb21pbmcgaW4gZnJvbSBuZXdQcm9wc1xuICAgICAgICAgICAgZmluYWxDbGFzc05hbWVzLnB1c2goY3VycmVudENsYXNzKTtcbiAgICAgICAgICAgIGluY29taW5nUHJvcENsYXNzZXMuZGVsZXRlKGN1cnJlbnRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9sZFByb3BDbGFzc2VzLmhhcyhjdXJyZW50Q2xhc3MpKSB7XG4gICAgICAgICAgICAvLyBhZGQgaXQgYXMgaXQgaGFzIE5PVCBiZWVuIHJlbW92ZWQgYnkgdXNlclxuICAgICAgICAgICAgZmluYWxDbGFzc05hbWVzLnB1c2goY3VycmVudENsYXNzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGluY29taW5nUHJvcENsYXNzZXMuZm9yRWFjaCgocykgPT4gZmluYWxDbGFzc05hbWVzLnB1c2gocykpO1xuICAgIHJldHVybiBmaW5hbENsYXNzTmFtZXMuam9pbignICcpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuY29uc3QgaXNDb3ZlcmVkQnlSZWFjdCA9IChldmVudE5hbWVTdWZmaXgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gICAgICAgIGxldCBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcbiAgICAgICAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9XG59O1xuY29uc3Qgc3luY0V2ZW50ID0gKG5vZGUsIGV2ZW50TmFtZSwgbmV3RXZlbnRIYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgZXZlbnRTdG9yZSA9IG5vZGUuX19ldmVudHMgfHwgKG5vZGUuX19ldmVudHMgPSB7fSk7XG4gICAgY29uc3Qgb2xkRXZlbnRIYW5kbGVyID0gZXZlbnRTdG9yZVtldmVudE5hbWVdO1xuICAgIC8vIFJlbW92ZSBvbGQgbGlzdGVuZXIgc28gdGhleSBkb24ndCBkb3VibGUgdXAuXG4gICAgaWYgKG9sZEV2ZW50SGFuZGxlcikge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvbGRFdmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBCaW5kIG5ldyBsaXN0ZW5lci5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZXZlbnRTdG9yZVtldmVudE5hbWVdID0gZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgIGlmIChuZXdFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIG5ld0V2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgfSkpO1xufTtcbmNvbnN0IGFycmF5VG9NYXAgPSAoYXJyKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGFyci5mb3JFYWNoKChzKSA9PiBtYXAuc2V0KHMsIHMpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuY29uc3Qgc2V0UmVmID0gKHJlZiwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAvLyBDYXN0IGFzIGEgTXV0YWJsZVJlZiBzbyB3ZSBjYW4gYXNzaWduIGN1cnJlbnRcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG59O1xuY29uc3QgbWVyZ2VSZWZzID0gKC4uLnJlZnMpID0+IHtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcbmNvbnN0IGNyZWF0ZUZvcndhcmRSZWYkMSA9IChSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpID0+IHtcbiAgICBjb25zdCBmb3J3YXJkUmVmID0gKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3RDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9O1xuICAgIGZvcndhcmRSZWYuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZihmb3J3YXJkUmVmKTtcbn07XG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50ID0gKHRhZ05hbWUsIGN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBpZiAoY3VzdG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBjdXN0b21FbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgY3VzdG9tRWxlbWVudCk7XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlUmVhY3RDb21wb25lbnQgPSAodGFnTmFtZSwgUmVhY3RDb21wb25lbnRDb250ZXh0LCBtYW5pcHVsYXRlUHJvcHNGdW5jdGlvbiwgZGVmaW5lQ3VzdG9tRWxlbWVudCkgPT4ge1xuICAgIGlmIChkZWZpbmVDdXN0b21FbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLnNldENvbXBvbmVudEVsUmVmID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudEVsID0gZWxlbWVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyh0aGlzLmNvbXBvbmVudEVsLCB0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmLCBzdHlsZSwgY2xhc3NOYW1lLCByZWYgfSA9IF9hLCBjUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJyZWZcIl0pO1xuICAgICAgICAgICAgbGV0IHByb3BzVG9QYXNzID0gT2JqZWN0LmtleXMoY1Byb3BzKS5yZWR1Y2UoKGFjYywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbmFtZVsyXSA9PT0gbmFtZVsyXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGlzQ292ZXJlZEJ5UmVhY3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBpZiAobWFuaXB1bGF0ZVByb3BzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9wc1RvUGFzcyA9IG1hbmlwdWxhdGVQcm9wc0Z1bmN0aW9uKHRoaXMucHJvcHMsIHByb3BzVG9QYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wc1RvUGFzcyksIHsgcmVmOiBtZXJnZVJlZnMoZm9yd2FyZGVkUmVmLCB0aGlzLnNldENvbXBvbmVudEVsUmVmKSwgc3R5bGUgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHVzZSBjcmVhdGVFbGVtZW50IGhlcmUgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICogUmVhY3QuY3JlYXRlRWxlbWVudCB0byB3b3JrIGFyb3VuZCBhXG4gICAgICAgICAgICAgKiBidWcgaW4gVml0ZSAoaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy82MTA0KS5cbiAgICAgICAgICAgICAqIFJlYWN0LmNyZWF0ZUVsZW1lbnQgY2F1c2VzIGFsbCBlbGVtZW50cyB0byBiZSByZW5kZXJlZFxuICAgICAgICAgICAgICogYXMgPHRhZ25hbWU+IGluc3RlYWQgb2YgdGhlIGFjdHVhbCBXZWIgQ29tcG9uZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBuZXdQcm9wcywgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIGNvbnRleHQgd2FzIHBhc3NlZCB0byBjcmVhdGVSZWFjdENvbXBvbmVudCB0aGVuIGNvbmRpdGlvbmFsbHkgYWRkIGl0IHRvIHRoZSBDb21wb25lbnQgQ2xhc3NcbiAgICBpZiAoUmVhY3RDb21wb25lbnRDb250ZXh0KSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50LmNvbnRleHRUeXBlID0gUmVhY3RDb21wb25lbnRDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRm9yd2FyZFJlZiQxKFJlYWN0Q29tcG9uZW50LCBkaXNwbGF5TmFtZSk7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgSW9uQWNjb3JkaW9uID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWFjY29yZGlvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDEpO1xuY29uc3QgSW9uQWNjb3JkaW9uR3JvdXAgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYWNjb3JkaW9uLWdyb3VwJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMik7XG5jb25zdCBJb25BdmF0YXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYXZhdGFyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMyk7XG5jb25zdCBJb25CYWNrZHJvcCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1iYWNrZHJvcCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDQpO1xuY29uc3QgSW9uQmFkZ2UgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYmFkZ2UnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ1KTtcbmNvbnN0IElvbkJyZWFkY3J1bWJzID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJyZWFkY3J1bWJzJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkNik7XG5jb25zdCBJb25CdXR0b25zID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWJ1dHRvbnMnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQ3KTtcbmNvbnN0IElvbkNhcmRDb250ZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWNhcmQtY29udGVudCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDgpO1xuY29uc3QgSW9uQ2FyZEhlYWRlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLWhlYWRlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDkpO1xuY29uc3QgSW9uQ2FyZFN1YnRpdGxlID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWNhcmQtc3VidGl0bGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRhKTtcbmNvbnN0IElvbkNhcmRUaXRsZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jYXJkLXRpdGxlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkYik7XG5jb25zdCBJb25DaGVja2JveCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jaGVja2JveCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JGMpO1xuY29uc3QgSW9uQ2hpcCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1jaGlwJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkZCk7XG5jb25zdCBJb25Db2wgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tY29sJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkZSk7XG5jb25zdCBJb25Db250ZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWNvbnRlbnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRmKTtcbmNvbnN0IElvbkRhdGV0aW1lID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWRhdGV0aW1lJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkZyk7XG5jb25zdCBJb25GYWIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tZmFiJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkaCk7XG5jb25zdCBJb25GYWJMaXN0ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWZhYi1saXN0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkaSk7XG5jb25zdCBJb25Gb290ZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tZm9vdGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkaik7XG5jb25zdCBJb25HcmlkID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWdyaWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRrKTtcbmNvbnN0IElvbkhlYWRlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1oZWFkZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRsKTtcbmNvbnN0IElvbkltZyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbWcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRtKTtcbmNvbnN0IElvbkluZmluaXRlU2Nyb2xsID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWluZmluaXRlLXNjcm9sbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JG4pO1xuY29uc3QgSW9uSW5maW5pdGVTY3JvbGxDb250ZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWluZmluaXRlLXNjcm9sbC1jb250ZW50JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkbyk7XG5jb25zdCBJb25JbnB1dCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pbnB1dCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHApO1xuY29uc3QgSW9uSXRlbURpdmlkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taXRlbS1kaXZpZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkcSk7XG5jb25zdCBJb25JdGVtR3JvdXAgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taXRlbS1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHIpO1xuY29uc3QgSW9uSXRlbU9wdGlvbnMgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24taXRlbS1vcHRpb25zJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkcyk7XG5jb25zdCBJb25JdGVtU2xpZGluZyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pdGVtLXNsaWRpbmcnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR0KTtcbmNvbnN0IElvbkxhYmVsID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWxhYmVsJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkdSk7XG5jb25zdCBJb25MaXN0ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLWxpc3QnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR2KTtcbmNvbnN0IElvbkxpc3RIZWFkZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbGlzdC1oZWFkZXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCR3KTtcbmNvbnN0IElvbk1lbnUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tbWVudScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHgpO1xuY29uc3QgSW9uTWVudUJ1dHRvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1tZW51LWJ1dHRvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHkpO1xuY29uc3QgSW9uTWVudVRvZ2dsZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1tZW51LXRvZ2dsZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JHopO1xuY29uc3QgSW9uTmF2ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLW5hdicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEEpO1xuY29uc3QgSW9uTmF2TGluayA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1uYXYtbGluaycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEIpO1xuY29uc3QgSW9uTm90ZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1ub3RlJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkQyk7XG5jb25zdCBJb25Qcm9ncmVzc0JhciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1wcm9ncmVzcy1iYXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCREKTtcbmNvbnN0IElvblJhZGlvID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJhZGlvJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkRSk7XG5jb25zdCBJb25SYWRpb0dyb3VwID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJhZGlvLWdyb3VwJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkRik7XG5jb25zdCBJb25SYW5nZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yYW5nZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEcpO1xuY29uc3QgSW9uUmVmcmVzaGVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJlZnJlc2hlcicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEgpO1xuY29uc3QgSW9uUmVmcmVzaGVyQ29udGVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yZWZyZXNoZXItY29udGVudCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEkpO1xuY29uc3QgSW9uUmVvcmRlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yZW9yZGVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkSik7XG5jb25zdCBJb25SZW9yZGVyR3JvdXAgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tcmVvcmRlci1ncm91cCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JEspO1xuY29uc3QgSW9uUmlwcGxlRWZmZWN0ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXJpcHBsZS1lZmZlY3QnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRMKTtcbmNvbnN0IElvblJvdyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yb3cnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRNKTtcbmNvbnN0IElvblNlYXJjaGJhciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWFyY2hiYXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCROKTtcbmNvbnN0IElvblNlZ21lbnQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc2VnbWVudCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JE8pO1xuY29uc3QgSW9uU2VnbWVudEJ1dHRvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zZWdtZW50LWJ1dHRvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFApO1xuY29uc3QgSW9uU2VsZWN0ID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNlbGVjdCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFEpO1xuY29uc3QgSW9uU2VsZWN0T3B0aW9uID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNlbGVjdC1vcHRpb24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCRSKTtcbmNvbnN0IElvblNrZWxldG9uVGV4dCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1za2VsZXRvbi10ZXh0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkUyk7XG5jb25zdCBJb25TbGlkZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zbGlkZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFQpO1xuY29uc3QgSW9uU2xpZGVzID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXNsaWRlcycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFUpO1xuY29uc3QgSW9uU3Bpbm5lciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1zcGlubmVyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkVik7XG5jb25zdCBJb25TcGxpdFBhbmUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tc3BsaXQtcGFuZScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFcpO1xuY29uc3QgSW9uVGFiID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRhYicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFgpO1xuY29uc3QgSW9uVGV4dCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10ZXh0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkWSk7XG5jb25zdCBJb25UZXh0YXJlYSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10ZXh0YXJlYScsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JFopO1xuY29uc3QgSW9uVGh1bWJuYWlsID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRodW1ibmFpbCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JF8pO1xuY29uc3QgSW9uVGl0bGUgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGl0bGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQkKTtcbmNvbnN0IElvblRvZ2dsZSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi10b2dnbGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMCk7XG5jb25zdCBJb25Ub29sYmFyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRvb2xiYXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxMSk7XG5jb25zdCBJb25WaXJ0dWFsU2Nyb2xsID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXZpcnR1YWwtc2Nyb2xsJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTIpO1xuXG5jb25zdCBjcmVhdGVGb3J3YXJkUmVmID0gKFJlYWN0Q29tcG9uZW50LCBkaXNwbGF5TmFtZSkgPT4ge1xuICAgIGNvbnN0IGZvcndhcmRSZWYgPSAocHJvcHMsIHJlZikgPT4ge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiByZWYgfSkpO1xuICAgIH07XG4gICAgZm9yd2FyZFJlZi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKGZvcndhcmRSZWYpO1xufTtcbmNvbnN0IGlzUGxhdGZvcm0gPSAocGxhdGZvcm0pID0+IHtcbiAgICByZXR1cm4gaXNQbGF0Zm9ybSQxKHdpbmRvdywgcGxhdGZvcm0pO1xufTtcbmNvbnN0IGdldFBsYXRmb3JtcyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2V0UGxhdGZvcm1zJDEod2luZG93KTtcbn07XG5jb25zdCBnZXRDb25maWcgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IElvbmljID0gd2luZG93LklvbmljO1xuICAgICAgICBpZiAoSW9uaWMgJiYgSW9uaWMuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gSW9uaWMuY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgY3JlYXRlUm91dGluZ0NvbXBvbmVudCA9ICh0YWdOYW1lLCBjdXN0b21FbGVtZW50KSA9PiB7XG4gICAgZGVmaW5lQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBjdXN0b21FbGVtZW50KTtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGRhc2hUb1Bhc2NhbENhc2UodGFnTmFtZSk7XG4gICAgY29uc3QgUmVhY3RDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJvdXRlckxpbmssIHJvdXRlckRpcmVjdGlvbiwgcm91dGVyT3B0aW9ucywgcm91dGVyQW5pbWF0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXJMaW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQubmF2aWdhdGUocm91dGVyTGluaywgcm91dGVyRGlyZWN0aW9uLCB1bmRlZmluZWQsIHJvdXRlckFuaW1hdGlvbiwgcm91dGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxvY2FsIHJlZiB0byB0byBhdHRhY2ggcHJvcHMgdG8gdGhlIHdyYXBwZWQgZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMucmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgICAvLyBSZWFjdCByZWZzIG11c3QgYmUgc3RhYmxlIChub3QgY3JlYXRlZCBpbmxpbmUpLlxuICAgICAgICAgICAgdGhpcy5zdGFibGVNZXJnZWRSZWZzID0gbWVyZ2VSZWZzKHRoaXMucmVmLCB0aGlzLnByb3BzLmZvcndhcmRlZFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5yZWYuY3VycmVudDtcbiAgICAgICAgICAgIGF0dGFjaFByb3BzKG5vZGUsIHRoaXMucHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNoaWxkcmVuLCBmb3J3YXJkZWRSZWYsIHN0eWxlLCBjbGFzc05hbWUsIHJlZiB9ID0gX2EsIGNQcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJmb3J3YXJkZWRSZWZcIiwgXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiLCBcInJlZlwiXSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvUGFzcyA9IE9iamVjdC5rZXlzKGNQcm9wcykucmVkdWNlKChhY2MsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdvbicpID09PSAwICYmIG5hbWVbMl0gPT09IG5hbWVbMl0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb3ZlcmVkQnlSZWFjdChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoWydzdHJpbmcnLCAnYm9vbGVhbicsICdudW1iZXInXS5pbmNsdWRlcyh0eXBlb2YgY1Byb3BzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbY2FtZWxUb0Rhc2hDYXNlKG5hbWUpXSA9IGNQcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wc1RvUGFzcyksIHsgcmVmOiB0aGlzLnN0YWJsZU1lcmdlZFJlZnMsIHN0eWxlIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMucm91dGVyTGluayAmJiAhdGhpcy5wcm9wcy5ocmVmKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvcHMuaHJlZiA9IHRoaXMucHJvcHMucm91dGVyTGluaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdQcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2xpY2sgPSBuZXdQcm9wcy5vbkNsaWNrO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbGRDbGljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvcHMub25DbGljayA9IHRoaXMuaGFuZGxlQ2xpY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBuZXdQcm9wcywgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlRm9yd2FyZFJlZihSZWFjdENvbXBvbmVudCwgZGlzcGxheU5hbWUpO1xufTtcblxuY29uc3QgSW9uUm91dGVyTGluayA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLXJvdXRlci1saW5rJywgSW9uUm91dGVyTGluayQxKTtcbmNvbnN0IElvbkJ1dHRvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWJ1dHRvbicsIElvbkJ1dHRvbiQxKTtcbmNvbnN0IElvbkNhcmQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJvdXRpbmdDb21wb25lbnQoJ2lvbi1jYXJkJywgSW9uQ2FyZCQxKTtcbmNvbnN0IElvbkZhYkJ1dHRvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWZhYi1idXR0b24nLCBJb25GYWJCdXR0b24kMSk7XG5jb25zdCBJb25JdGVtID0gLypAX19QVVJFX18qLyBjcmVhdGVSb3V0aW5nQ29tcG9uZW50KCdpb24taXRlbScsIElvbkl0ZW0kMSk7XG5jb25zdCBJb25JdGVtT3B0aW9uID0gLypAX19QVVJFX18qLyBjcmVhdGVSb3V0aW5nQ29tcG9uZW50KCdpb24taXRlbS1vcHRpb24nLCBJb25JdGVtT3B0aW9uJDEpO1xuY29uc3QgSW9uQnJlYWRjcnVtYiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUm91dGluZ0NvbXBvbmVudCgnaW9uLWJyZWFkY3J1bWInLCBJb25CcmVhZGNydW1iJDEpO1xuXG5jb25zdCBjcmVhdGVDb250cm9sbGVyQ29tcG9uZW50ID0gKHRhZ05hbWUsIGNvbnRyb2xsZXIsIGN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KHRhZ05hbWUsIGN1c3RvbUVsZW1lbnQpO1xuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZGFzaFRvUGFzY2FsQ2FzZSh0YWdOYW1lKTtcbiAgICBjb25zdCBkaWREaXNtaXNzRXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWREaXNtaXNzYDtcbiAgICBjb25zdCBkaWRQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1EaWRQcmVzZW50YDtcbiAgICBjb25zdCB3aWxsRGlzbWlzc0V2ZW50TmFtZSA9IGBvbiR7ZGlzcGxheU5hbWV9V2lsbERpc21pc3NgO1xuICAgIGNvbnN0IHdpbGxQcmVzZW50RXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1XaWxsUHJlc2VudGA7XG4gICAgY2xhc3MgT3ZlcmxheSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmlzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc21pc3MgPSB0aGlzLmhhbmRsZURpc21pc3MuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgeyBpc09wZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkuZGlzbWlzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VudChwcmV2UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxheSAmJiBwcmV2UHJvcHMuaXNPcGVuICE9PSB0aGlzLnByb3BzLmlzT3BlbiAmJiB0aGlzLnByb3BzLmlzT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkuZGlzbWlzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZURpc21pc3MoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uRGlkRGlzbWlzcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25EaWREaXNtaXNzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcHJlc2VudChwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJpc09wZW5cIiwgXCJvbkRpZERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxEaXNtaXNzXCIsIFwib25XaWxsUHJlc2VudFwiXSk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkgPSBhd2FpdCBjb250cm9sbGVyLmNyZWF0ZShPYmplY3QuYXNzaWduKHt9LCBjUHJvcHMpKTtcbiAgICAgICAgICAgIGF0dGFjaFByb3BzKHRoaXMub3ZlcmxheSwge1xuICAgICAgICAgICAgICAgIFtkaWREaXNtaXNzRXZlbnROYW1lXTogdGhpcy5oYW5kbGVEaXNtaXNzLFxuICAgICAgICAgICAgICAgIFtkaWRQcmVzZW50RXZlbnROYW1lXTogKGUpID0+IHRoaXMucHJvcHMub25EaWRQcmVzZW50ICYmIHRoaXMucHJvcHMub25EaWRQcmVzZW50KGUpLFxuICAgICAgICAgICAgICAgIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiB0aGlzLnByb3BzLm9uV2lsbERpc21pc3MgJiYgdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzKGUpLFxuICAgICAgICAgICAgICAgIFt3aWxsUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiB0aGlzLnByb3BzLm9uV2lsbFByZXNlbnQgJiYgdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50KGUpLFxuICAgICAgICAgICAgfSwgcHJldlByb3BzKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlzT3BlbiBhZ2FpbiBzaW5jZSB0aGUgdmFsdWUgY291bGQgaGF2ZSBjaGFuZ2VkIGR1cmluZyB0aGUgYXN5bmMgY2FsbCB0byBjb250cm9sbGVyLmNyZWF0ZVxuICAgICAgICAgICAgLy8gSXQncyBhbHNvIHBvc3NpYmxlIGZvciB0aGUgY29tcG9uZW50IHRvIGhhdmUgYmVjb21lIHVubW91bnRlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiA9PT0gdHJ1ZSAmJiB0aGlzLmlzVW5tb3VudGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgdGhpcy5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm92ZXJsYXkucHJlc2VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXksIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IElvbkFsZXJ0ID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyQ29tcG9uZW50KCdpb24tYWxlcnQnLCBhbGVydENvbnRyb2xsZXIsIElvbkFsZXJ0JDEpO1xuXG5jb25zdCBJb25Mb2FkaW5nID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyQ29tcG9uZW50KCdpb24tbG9hZGluZycsIGxvYWRpbmdDb250cm9sbGVyLCBJb25Mb2FkaW5nJDEpO1xuXG5jb25zdCB0b2FzdENvbnRyb2xsZXIgPSB7XG4gICAgY3JlYXRlOiAob3B0aW9ucykgPT4gdG9hc3RDb250cm9sbGVyJDEuY3JlYXRlKG9wdGlvbnMpLFxuICAgIGRpc21pc3M6IChkYXRhLCByb2xlLCBpZCkgPT4gdG9hc3RDb250cm9sbGVyJDEuZGlzbWlzcyhkYXRhLCByb2xlLCBpZCksXG4gICAgZ2V0VG9wOiAoKSA9PiB0b2FzdENvbnRyb2xsZXIkMS5nZXRUb3AoKSxcbn07XG5jb25zdCBJb25Ub2FzdCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ29udHJvbGxlckNvbXBvbmVudCgnaW9uLXRvYXN0JywgdG9hc3RDb250cm9sbGVyLCBJb25Ub2FzdCQxKTtcblxuY29uc3QgSW9uUGlja2VyID0gLypAX19QVVJFX18qLyBjcmVhdGVDb250cm9sbGVyQ29tcG9uZW50KCdpb24tcGlja2VyJywgcGlja2VyQ29udHJvbGxlciwgSW9uUGlja2VyJDEpO1xuXG5jb25zdCBjcmVhdGVPdmVybGF5Q29tcG9uZW50ID0gKHRhZ05hbWUsIGNvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBpZiAoZGVmaW5lQ3VzdG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBkYXNoVG9QYXNjYWxDYXNlKHRhZ05hbWUpO1xuICAgIGNvbnN0IGRpZERpc21pc3NFdmVudE5hbWUgPSBgb24ke2Rpc3BsYXlOYW1lfURpZERpc21pc3NgO1xuICAgIGNvbnN0IGRpZFByZXNlbnRFdmVudE5hbWUgPSBgb24ke2Rpc3BsYXlOYW1lfURpZFByZXNlbnRgO1xuICAgIGNvbnN0IHdpbGxEaXNtaXNzRXZlbnROYW1lID0gYG9uJHtkaXNwbGF5TmFtZX1XaWxsRGlzbWlzc2A7XG4gICAgY29uc3Qgd2lsbFByZXNlbnRFdmVudE5hbWUgPSBgb24ke2Rpc3BsYXlOYW1lfVdpbGxQcmVzZW50YDtcbiAgICBjbGFzcyBPdmVybGF5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuaXNEaXNtaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzbWlzcyA9IHRoaXMuaGFuZGxlRGlzbWlzcy5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgZGlzcGxheU5hbWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkuZGlzbWlzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZURpc21pc3MoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uRGlkRGlzbWlzcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25EaWREaXNtaXNzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmZvcndhcmRlZFJlZiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG92ZXJsYXkgY29tcG9uZW50IGlzIGFib3V0IHRvIGRpc21pc3NcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXkgJiYgbmV4dFByb3BzLmlzT3BlbiAhPT0gdGhpcy5wcm9wcy5pc09wZW4gJiYgbmV4dFByb3BzLmlzT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRGlzbWlzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoUHJvcHModGhpcy5vdmVybGF5LCB0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZQcm9wcy5pc09wZW4gIT09IHRoaXMucHJvcHMuaXNPcGVuICYmIHRoaXMucHJvcHMuaXNPcGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50KHByZXZQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGF5ICYmIHByZXZQcm9wcy5pc09wZW4gIT09IHRoaXMucHJvcHMuaXNPcGVuICYmIHRoaXMucHJvcHMuaXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub3ZlcmxheS5kaXNtaXNzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc21pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBOb3cgdGhhdCB0aGUgb3ZlcmxheSBpcyBkaXNtaXNzZWRcbiAgICAgICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIHJlbmRlciBhZ2FpbiBzbyB0aGF0IGFueVxuICAgICAgICAgICAgICAgICAqIGlubmVyIGNvbXBvbmVudHMgd2lsbCBiZSB1bm1vdW50ZWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcHJlc2VudChwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgY1Byb3BzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImlzT3BlblwiLCBcIm9uRGlkRGlzbWlzc1wiLCBcIm9uRGlkUHJlc2VudFwiLCBcIm9uV2lsbERpc21pc3NcIiwgXCJvbldpbGxQcmVzZW50XCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY1Byb3BzKSwgeyByZWY6IHRoaXMucHJvcHMuZm9yd2FyZGVkUmVmLCBbZGlkRGlzbWlzc0V2ZW50TmFtZV06IHRoaXMuaGFuZGxlRGlzbWlzcywgW2RpZFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbkRpZFByZXNlbnQgJiYgdGhpcy5wcm9wcy5vbkRpZFByZXNlbnQoZSksIFt3aWxsRGlzbWlzc0V2ZW50TmFtZV06IChlKSA9PiB0aGlzLnByb3BzLm9uV2lsbERpc21pc3MgJiYgdGhpcy5wcm9wcy5vbldpbGxEaXNtaXNzKGUpLCBbd2lsbFByZXNlbnRFdmVudE5hbWVdOiAoZSkgPT4gdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50ICYmIHRoaXMucHJvcHMub25XaWxsUHJlc2VudChlKSB9KTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheSA9IGF3YWl0IGNvbnRyb2xsZXIuY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudFByb3BzKSwgeyBjb21wb25lbnQ6IHRoaXMuZWwsIGNvbXBvbmVudFByb3BzOiB7fSB9KSk7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5mb3J3YXJkZWRSZWYsIHRoaXMub3ZlcmxheSk7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyh0aGlzLm92ZXJsYXksIGVsZW1lbnRQcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMub3ZlcmxheS5wcmVzZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb250aW51ZSB0byByZW5kZXIgdGhlIGNvbXBvbmVudCBldmVuIHdoZW5cbiAgICAgICAgICAgICAqIG92ZXJsYXkgaXMgZGlzbWlzc2luZyBvdGhlcndpc2UgY29tcG9uZW50XG4gICAgICAgICAgICAgKiB3aWxsIGJlIGhpZGRlbiBiZWZvcmUgYW5pbWF0aW9uIGlzIGRvbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwodGhpcy5wcm9wcy5pc09wZW4gfHwgdGhpcy5pc0Rpc21pc3NpbmcgPyB0aGlzLnByb3BzLmNoaWxkcmVuIDogbnVsbCwgdGhpcy5lbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheSwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZm9yd2FyZGVkUmVmOiByZWYgfSkpO1xuICAgIH0pO1xufTtcblxuY29uc3QgYWN0aW9uU2hlZXRDb250cm9sbGVyID0ge1xuICAgIGNyZWF0ZTogKG9wdGlvbnMpID0+IGFjdGlvblNoZWV0Q29udHJvbGxlciQxLmNyZWF0ZShvcHRpb25zKSxcbiAgICBkaXNtaXNzOiAoZGF0YSwgcm9sZSwgaWQpID0+IGFjdGlvblNoZWV0Q29udHJvbGxlciQxLmRpc21pc3MoZGF0YSwgcm9sZSwgaWQpLFxuICAgIGdldFRvcDogKCkgPT4gYWN0aW9uU2hlZXRDb250cm9sbGVyJDEuZ2V0VG9wKCksXG59O1xuY29uc3QgSW9uQWN0aW9uU2hlZXQgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZU92ZXJsYXlDb21wb25lbnQoJ2lvbi1hY3Rpb24tc2hlZXQnLCBhY3Rpb25TaGVldENvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTMpO1xuXG5jb25zdCBjcmVhdGVJbmxpbmVPdmVybGF5Q29tcG9uZW50ID0gKHRhZ05hbWUsIGRlZmluZUN1c3RvbUVsZW1lbnQpID0+IHtcbiAgICBpZiAoZGVmaW5lQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZGFzaFRvUGFzY2FsQ2FzZSh0YWdOYW1lKTtcbiAgICBjb25zdCBSZWFjdENvbXBvbmVudCA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxvY2FsIHJlZiB0byB0byBhdHRhY2ggcHJvcHMgdG8gdGhlIHdyYXBwZWQgZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMucmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgICAvLyBSZWFjdCByZWZzIG11c3QgYmUgc3RhYmxlIChub3QgY3JlYXRlZCBpbmxpbmUpLlxuICAgICAgICAgICAgdGhpcy5zdGFibGVNZXJnZWRSZWZzID0gbWVyZ2VSZWZzKHRoaXMucmVmLCB0aGlzLnByb3BzLmZvcndhcmRlZFJlZik7XG4gICAgICAgICAgICAvLyBDb21wb25lbnQgaXMgaGlkZGVuIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7IGlzT3BlbjogZmFsc2UgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGxvY2FsIHJlZiB0byB0aGUgaW5uZXIgY2hpbGQgZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMud3JhcHBlclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNb3VudCB0aGUgaW5uZXIgY29tcG9uZW50XG4gICAgICAgICAgICAgKiB3aGVuIG92ZXJsYXkgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgICAgICAgICAqIEFsc28gbWFudWFsbHkgY2FsbCB0aGUgb25XaWxsUHJlc2VudFxuICAgICAgICAgICAgICogaGFuZGxlciBpZiBwcmVzZW50IGFzIHNldFN0YXRlIHdpbGxcbiAgICAgICAgICAgICAqIGNhdXNlIHRoZSBldmVudCBoYW5kbGVycyB0byBiZVxuICAgICAgICAgICAgICogZGVzdHJveWVkIGFuZCByZS1jcmVhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcignd2lsbFByZXNlbnQnLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uV2lsbFByZXNlbnQgJiYgdGhpcy5wcm9wcy5vbldpbGxQcmVzZW50KGV2dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVW5tb3VudCB0aGUgaW5uZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICogUmVhY3Qgd2lsbCBjYWxsIE5vZGUucmVtb3ZlQ2hpbGRcbiAgICAgICAgICAgICAqIHdoaWNoIGV4cGVjdHMgdGhlIGNoaWxkIHRvIGJlXG4gICAgICAgICAgICAgKiBhIGRpcmVjdCBkZXNjZW5kZW50IG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAqIGJ1dCBkdWUgdG8gdGhlIHByZXNlbmNlIG9mXG4gICAgICAgICAgICAgKiBXZWIgQ29tcG9uZW50IHNsb3RzLCB0aGlzIGlzIG5vdFxuICAgICAgICAgICAgICogYWx3YXlzIHRoZSBjYXNlLiBUbyB3b3JrIGFyb3VuZCB0aGlzXG4gICAgICAgICAgICAgKiB3ZSBtb3ZlIHRoZSBpbm5lciBjb21wb25lbnQgdG8gdGhlIHJvb3RcbiAgICAgICAgICAgICAqIG9mIHRoZSBXZWIgQ29tcG9uZW50IHNvIFJlYWN0IGNhblxuICAgICAgICAgICAgICogY2xlYW51cCBwcm9wZXJseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKF9iID0gdGhpcy5yZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ2RpZERpc21pc3MnLCAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRoaXMud3JhcHBlclJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5yZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGNvbXBvbmVudCBtaWdodCBiZSB1bm1vdW50ZWQgYWxyZWFkeSwgaWYgdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgICAgKiBlbGVtZW50IHdhcyByZW1vdmVkIHdoaWxlIHRoZSBwb3BvdmVyIHdhcyBzdGlsbCBvcGVuLiAoRm9yXG4gICAgICAgICAgICAgICAgICogZXhhbXBsZSwgaWYgYW4gaXRlbSBjb250YWlucyBhbiBpbmxpbmUgcG9wb3ZlciB3aXRoIGEgYnV0dG9uXG4gICAgICAgICAgICAgICAgICogdGhhdCByZW1vdmVzIHRoZSBpdGVtLilcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAod3JhcHBlciAmJiBlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmQod3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyAmJiB0aGlzLnByb3BzLm9uRGlkRGlzbWlzcyhldnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBhdHRhY2hQcm9wcyhub2RlLCB0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjaGlsZHJlbiwgZm9yd2FyZGVkUmVmLCBzdHlsZSwgY2xhc3NOYW1lLCByZWYgfSA9IF9hLCBjUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZm9yd2FyZGVkUmVmXCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJyZWZcIl0pO1xuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1Bhc3MgPSBPYmplY3Qua2V5cyhjUHJvcHMpLnJlZHVjZSgoYWNjLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignb24nKSA9PT0gMCAmJiBuYW1lWzJdID09PSBuYW1lWzJdLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ292ZXJlZEJ5UmVhY3QoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY1Byb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIGNQcm9wc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2NhbWVsVG9EYXNoQ2FzZShuYW1lKV0gPSBjUHJvcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNUb1Bhc3MpLCB7IHJlZjogdGhpcy5zdGFibGVNZXJnZWRSZWZzLCBzdHlsZSB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugb25seSB3YW50IHRoZSBpbm5lciBjb21wb25lbnRcbiAgICAgICAgICAgICAqIHRvIGJlIG1vdW50ZWQgaWYgdGhlIG92ZXJsYXkgaXMgb3BlbixcbiAgICAgICAgICAgICAqIHNvIGNvbmRpdGlvbmFsbHkgcmVuZGVyIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAqIGJhc2VkIG9uIHRoZSBpc09wZW4gc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIG5ld1Byb3BzLCAodGhpcy5zdGF0ZS5pc09wZW4pID9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaW9uLXJlYWN0LXdyYXBwZXInLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRoaXMud3JhcHBlclJlZixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuKSA6XG4gICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZUZvcndhcmRSZWYoUmVhY3RDb21wb25lbnQsIGRpc3BsYXlOYW1lKTtcbn07XG5cbmNvbnN0IElvbk1vZGFsID0gLypAX19QVVJFX18qLyBjcmVhdGVJbmxpbmVPdmVybGF5Q29tcG9uZW50KCdpb24tbW9kYWwnLCBkZWZpbmVDdXN0b21FbGVtZW50JDE0KTtcblxuY29uc3QgSW9uUG9wb3ZlciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlSW5saW5lT3ZlcmxheUNvbXBvbmVudCgnaW9uLXBvcG92ZXInLCBkZWZpbmVDdXN0b21FbGVtZW50JDE1KTtcblxuY29uc3QgSW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIGFkZE92ZXJsYXk6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgcmVtb3ZlT3ZlcmxheTogKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIE1hbmFnZXMgb3ZlcmxheXMgdGhhdCBhcmUgYWRkZWQgdmlhIHRoZSB1c2VPdmVybGF5IGhvb2suXG4gKiBUaGlzIGlzIGEgc3RhbmRhbG9uZSBjb21wb25lbnQgc28gY2hhbmdlcyB0byBpdHMgY2hpbGRyZW4gZG9uJ3QgY2F1c2Ugb3RoZXIgZGVzY2VuZGFudFxuICogY29tcG9uZW50cyB0byByZS1yZW5kZXIgd2hlbiBvdmVybGF5cyBhcmUgYWRkZWQuIEhvd2V2ZXIsIHdlIG5lZWQgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgSW9uQ29udGV4dFxuICogdGhhdCBpcyBzZXQgdXAgaW4gPElvbkFwcCAvPiwgc28gd2UgcmVnaXN0ZXIgY2FsbGJhY2tzIHNvIHdoZW4gb3ZlcmxheXMgYXJlIGFkZGVkIHRvIElvbkNvbnRleHQsXG4gKiB0aGV5IHVsdGltYXRlbHkgYWRkZWQgaGVyZS5cbiAqL1xuY29uc3QgSW9uT3ZlcmxheU1hbmFnZXIgPSAoeyBvbkFkZE92ZXJsYXksIG9uUmVtb3ZlT3ZlcmxheSwgfSkgPT4ge1xuICAgIC8qKlxuICAgICAqIEJlY2F1c2Ugb2YgdGhlIHdheSB3ZSdyZSBwYXNzaW5nIGFyb3VuZCB0aGUgYWRkT3ZlcmxheSBhbmQgcmVtb3ZlT3ZlcmxheVxuICAgICAqIGNhbGxiYWNrcywgYnkgdGhlIHRpbWUgdGhleSBmaW5hbGx5IGdldCBjYWxsZWQsIHRoZXkgdXNlIGEgc3RhbGUgcmVmZXJlbmNlXG4gICAgICogdG8gdGhlIHN0YXRlIHRoYXQgb25seSBoYXMgdGhlIGluaXRpYWwgdmFsdWVzLiBTbyBpZiB0d28gb3ZlcmxheXMgYXJlIG9wZW5lZFxuICAgICAqIGF0IHRoZSBzYW1lIHRpbWUsIGJvdGggdXNpbmcgdXNlSW9uTW9kYWwgb3Igc2ltaWxhciAoc3VjaCBhcyB0aHJvdWdoIG5lc3RpbmcpLFxuICAgICAqIHRoZSBzZWNvbmQgd2lsbCBlcmFzZSB0aGUgZmlyc3QgZnJvbSB0aGUgb3ZlcmxheXMgbGlzdC4gVGhpcyBjYXVzZXMgdGhlIGNvbnRlbnRcbiAgICAgKiBvZiB0aGUgZmlyc3Qgb3ZlcmxheSB0byB1bm1vdW50LlxuICAgICAqXG4gICAgICogV2Ugd3JhcCB0aGUgc3RhdGUgaW4gdXNlUmVmIHRvIGVuc3VyZSB0aGUgdHdvIGNhbGxiYWNrcyBhbHdheXMgdXNlIHRoZSBtb3N0XG4gICAgICogdXAtdG8tZGF0ZSB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogRnVydGhlciByZWFkaW5nOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTY1NTQwNTZcbiAgICAgKi9cbiAgICBjb25zdCBbb3ZlcmxheXMsIHNldE92ZXJsYXlzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBvdmVybGF5c1JlZiA9IHVzZVJlZih7fSk7XG4gICAgb3ZlcmxheXNSZWYuY3VycmVudCA9IG92ZXJsYXlzO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8qIFNldHVwIHRoZSBjYWxsYmFja3MgdGhhdCBnZXQgY2FsbGVkIGZyb20gPElvbkFwcCAvPiAqL1xuICAgICAgICBvbkFkZE92ZXJsYXkoYWRkT3ZlcmxheSk7XG4gICAgICAgIG9uUmVtb3ZlT3ZlcmxheShyZW1vdmVPdmVybGF5KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgYWRkT3ZlcmxheSA9IChpZCwgY29tcG9uZW50LCBjb250YWluZXJFbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld092ZXJsYXlzID0gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcmxheXNSZWYuY3VycmVudCk7XG4gICAgICAgIG5ld092ZXJsYXlzW2lkXSA9IHsgY29tcG9uZW50LCBjb250YWluZXJFbGVtZW50IH07XG4gICAgICAgIHNldE92ZXJsYXlzKG5ld092ZXJsYXlzKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZU92ZXJsYXkgPSAoaWQpID0+IHtcbiAgICAgICAgY29uc3QgbmV3T3ZlcmxheXMgPSBPYmplY3QuYXNzaWduKHt9LCBvdmVybGF5c1JlZi5jdXJyZW50KTtcbiAgICAgICAgZGVsZXRlIG5ld092ZXJsYXlzW2lkXTtcbiAgICAgICAgc2V0T3ZlcmxheXMobmV3T3ZlcmxheXMpO1xuICAgIH07XG4gICAgY29uc3Qgb3ZlcmxheUtleXMgPSBPYmplY3Qua2V5cyhvdmVybGF5cyk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBvdmVybGF5S2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheXNba2V5XTtcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChvdmVybGF5LmNvbXBvbmVudCwgb3ZlcmxheS5jb250YWluZXJFbGVtZW50LCBgb3ZlcmxheS0ke2tleX1gKTtcbiAgICB9KSkpO1xufTtcblxuY29uc3QgSW9uVGFiQnV0dG9uSW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tdGFiLWJ1dHRvbicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZWZpbmVDdXN0b21FbGVtZW50JDE2KTtcbmNvbnN0IElvblRhYkJhcklubmVyID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWFjdENvbXBvbmVudCgnaW9uLXRhYi1iYXInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNyk7XG5jb25zdCBJb25CYWNrQnV0dG9uSW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYmFjay1idXR0b24nLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxOCk7XG5jb25zdCBJb25Sb3V0ZXJPdXRsZXRJbm5lciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1yb3V0ZXItb3V0bGV0JywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTkpO1xuY29uc3QgSW9uQXBwSW5uZXIgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlYWN0Q29tcG9uZW50KCdpb24tYXBwJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMWEpO1xuLy8gaW9uaWNvbnNcbmNvbnN0IElvbkljb25Jbm5lciA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVhY3RDb21wb25lbnQoJ2lvbi1pY29uJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlZmluZUN1c3RvbUVsZW1lbnQkMWIpO1xuXG5jb25zdCBJb25BcHAgPSAvKkBfX1BVUkVfXyovICgoKSA9PiBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAvKlxuICAgICAgICAgIFdpcmUgdXAgbWV0aG9kcyB0byBjYWxsIGludG8gSW9uT3ZlcmxheU1hbmFnZXJcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgYWRkT3ZlcmxheTogKGlkLCBvdmVybGF5LCBjb250YWluZXJFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkT3ZlcmxheUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxheUNhbGxiYWNrKGlkLCBvdmVybGF5LCBjb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlT3ZlcmxheTogKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlT3ZlcmxheUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlT3ZlcmxheUNhbGxiYWNrKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmlvbkNvbnRleHQgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uQXBwSW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpLCB0aGlzLnByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uT3ZlcmxheU1hbmFnZXIsIHsgb25BZGRPdmVybGF5OiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPdmVybGF5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9LCBvblJlbW92ZU92ZXJsYXk6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXlDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIH0gfSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdJb25BcHAnO1xuICAgIH1cbn0pKCk7XG5cbmNvbnN0IFN0YWNrQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIHJlZ2lzdGVySW9uUGFnZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGlzSW5PdXRsZXQ6ICgpID0+IGZhbHNlLFxufSk7XG5cbmNsYXNzIFBhZ2VNYW5hZ2VyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIC8vIFJlYWN0IHJlZnMgbXVzdCBiZSBzdGFibGUgKG5vdCBjcmVhdGVkIGlubGluZSkuXG4gICAgICAgIHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyA9IG1lcmdlUmVmcyh0aGlzLmlvblBhZ2VFbGVtZW50UmVmLCB0aGlzLnByb3BzLmZvcndhcmRlZFJlZik7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmlzSW5PdXRsZXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5jbGFzc0xpc3QuYWRkKCdpb24tcGFnZS1pbnZpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlcklvblBhZ2UodGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLnJvdXRlSW5mbyk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxFbnRlcicsIHRoaXMuaW9uVmlld1dpbGxFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblBhZ2VFbGVtZW50UmVmLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZEVudGVyJywgdGhpcy5pb25WaWV3RGlkRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsTGVhdmUnLCB0aGlzLmlvblZpZXdXaWxsTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRMZWF2ZScsIHRoaXMuaW9uVmlld0RpZExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsRW50ZXInLCB0aGlzLmlvblZpZXdXaWxsRW50ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25QYWdlRWxlbWVudFJlZi5jdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRFbnRlcicsIHRoaXMuaW9uVmlld0RpZEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUGFnZUVsZW1lbnRSZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkTGVhdmUnLCB0aGlzLmlvblZpZXdEaWRMZWF2ZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW9uVmlld1dpbGxFbnRlckhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dC5pb25WaWV3V2lsbEVudGVyKCk7XG4gICAgfVxuICAgIGlvblZpZXdEaWRFbnRlckhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dC5pb25WaWV3RGlkRW50ZXIoKTtcbiAgICB9XG4gICAgaW9uVmlld1dpbGxMZWF2ZUhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dC5pb25WaWV3V2lsbExlYXZlKCk7XG4gICAgfVxuICAgIGlvblZpZXdEaWRMZWF2ZUhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dC5pb25WaWV3RGlkTGVhdmUoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMucHJvcHMsIHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcm91dGVJbmZvLCBmb3J3YXJkZWRSZWYgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJyb3V0ZUluZm9cIiwgXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uTGlmZUN5Y2xlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfSBpb24tcGFnZWAgOiBgaW9uLXBhZ2VgLCByZWY6IHRoaXMuc3RhYmxlTWVyZ2VkUmVmcyB9LCBwcm9wcyksIGNoaWxkcmVuKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFN0YWNrQ29udGV4dDtcbiAgICB9XG59XG5cbmNsYXNzIElvblBhZ2VJbnRlcm5hbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyBjbGFzc05hbWUsIGNoaWxkcmVuLCBmb3J3YXJkZWRSZWYgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlTWFuYWdlciwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfWAgOiAnJywgcm91dGVJbmZvOiB0aGlzLmNvbnRleHQucm91dGVJbmZvLCBmb3J3YXJkZWRSZWY6IGZvcndhcmRlZFJlZiB9LCBwcm9wcyksIGNoaWxkcmVuKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgaW9uLXBhZ2UgJHtjbGFzc05hbWV9YCA6ICdpb24tcGFnZScsIHJlZjogZm9yd2FyZGVkUmVmIH0sIHByb3BzKSwgY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdJb25QYWdlJztcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuY29uc3QgSW9uUGFnZSA9IGNyZWF0ZUZvcndhcmRSZWYoSW9uUGFnZUludGVybmFsLCAnSW9uUGFnZScpO1xuXG5jb25zdCBJb25UYWJzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIGFjdGl2ZVRhYjogdW5kZWZpbmVkLFxuICAgIHNlbGVjdFRhYjogKCkgPT4gZmFsc2UsXG59KTtcblxuY29uc3QgSFRNTEVsZW1lbnRTU1IgPSAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gSFRNTEVsZW1lbnRcbiAgICA6IGNsYXNzIHtcbiAgICB9KTtcblxuY2xhc3MgT3V0bGV0UGFnZU1hbmFnZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlvblJvdXRlck91dGxldCkge1xuICAgICAgICAgICAgY29tcG9uZW50T25SZWFkeSh0aGlzLmlvblJvdXRlck91dGxldCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlcklvblBhZ2UodGhpcy5pb25Sb3V0ZXJPdXRsZXQsIHRoaXMucHJvcHMucm91dGVJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQuYWRkRXZlbnRMaXN0ZW5lcignaW9uVmlld1dpbGxFbnRlcicsIHRoaXMuaW9uVmlld1dpbGxFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3RGlkRW50ZXInLCB0aGlzLmlvblZpZXdEaWRFbnRlckhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5hZGRFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbExlYXZlJywgdGhpcy5pb25WaWV3V2lsbExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRMZWF2ZScsIHRoaXMuaW9uVmlld0RpZExlYXZlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW9uUm91dGVyT3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLmlvblJvdXRlck91dGxldC5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25WaWV3V2lsbEVudGVyJywgdGhpcy5pb25WaWV3V2lsbEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdEaWRFbnRlcicsIHRoaXMuaW9uVmlld0RpZEVudGVySGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuaW9uUm91dGVyT3V0bGV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lvblZpZXdXaWxsTGVhdmUnLCB0aGlzLmlvblZpZXdXaWxsTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5pb25Sb3V0ZXJPdXRsZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uVmlld0RpZExlYXZlJywgdGhpcy5pb25WaWV3RGlkTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlvblZpZXdXaWxsRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxFbnRlcigpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkRW50ZXJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZEVudGVyKCk7XG4gICAgfVxuICAgIGlvblZpZXdXaWxsTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld1dpbGxMZWF2ZSgpO1xuICAgIH1cbiAgICBpb25WaWV3RGlkTGVhdmVIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQuaW9uVmlld0RpZExlYXZlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IFN0YWNrTWFuYWdlciwgY2hpbGRyZW4sIHJvdXRlSW5mbyB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJTdGFja01hbmFnZXJcIiwgXCJjaGlsZHJlblwiLCBcInJvdXRlSW5mb1wiXSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25MaWZlQ3ljbGVDb250ZXh0LkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pb25MaWZlQ3ljbGVDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChTdGFja01hbmFnZXIsIHsgcm91dGVJbmZvOiByb3V0ZUluZm8gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlck91dGxldElubmVyLCBPYmplY3QuYXNzaWduKHsgc2V0UmVmOiAodmFsKSA9PiAodGhpcy5pb25Sb3V0ZXJPdXRsZXQgPSB2YWwpIH0sIHByb3BzKSwgY2hpbGRyZW4pKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFN0YWNrQ29udGV4dDtcbiAgICB9XG59XG5cbmNsYXNzIElvblJvdXRlck91dGxldENvbnRhaW5lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IFN0YWNrTWFuYWdlciA9IHRoaXMuY29udGV4dC5nZXRTdGFja01hbmFnZXIoKTtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNoaWxkcmVuLCBmb3J3YXJkZWRSZWYgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJmb3J3YXJkZWRSZWZcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgPyAocHJvcHMuaW9uUGFnZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KE91dGxldFBhZ2VNYW5hZ2VyLCBPYmplY3QuYXNzaWduKHsgU3RhY2tNYW5hZ2VyOiBTdGFja01hbmFnZXIsIHJvdXRlSW5mbzogdGhpcy5jb250ZXh0LnJvdXRlSW5mbyB9LCBwcm9wcyksIGNoaWxkcmVuKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChTdGFja01hbmFnZXIsIHsgcm91dGVJbmZvOiB0aGlzLmNvbnRleHQucm91dGVJbmZvIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElvblJvdXRlck91dGxldElubmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRSZWY6IGZvcndhcmRlZFJlZiB9KSwgY2hpbGRyZW4pKSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uUm91dGVyT3V0bGV0SW5uZXIsIE9iamVjdC5hc3NpZ24oeyByZWY6IGZvcndhcmRlZFJlZiB9LCB0aGlzLnByb3BzKSwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59XG5jb25zdCBJb25Sb3V0ZXJPdXRsZXQgPSBjcmVhdGVGb3J3YXJkUmVmKElvblJvdXRlck91dGxldENvbnRhaW5lciwgJ0lvblJvdXRlck91dGxldCcpO1xuXG5jb25zdCBJb25UYWJCdXR0b24gPSAvKkBfX1BVUkVfXyovICgoKSA9PiBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUlvblRhYkJ1dHRvbkNsaWNrID0gdGhpcy5oYW5kbGVJb25UYWJCdXR0b25DbGljay5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVJb25UYWJCdXR0b25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiQnV0dG9uQ2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhYjogdGhpcy5wcm9wcy50YWIsXG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcm91dGVPcHRpb25zOiB0aGlzLnByb3BzLnJvdXRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgcmVzdCA9IF9fcmVzdChfYSwgW1wib25DbGlja1wiXSk7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25UYWJCdXR0b25Jbm5lciwgT2JqZWN0LmFzc2lnbih7IG9uSW9uVGFiQnV0dG9uQ2xpY2s6IHRoaXMuaGFuZGxlSW9uVGFiQnV0dG9uQ2xpY2sgfSwgcmVzdCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBkaXNwbGF5TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdJb25UYWJCdXR0b24nO1xuICAgIH1cbn0pKCk7XG5cbmNsYXNzIElvblRhYkJhclVud3JhcHBlZCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVUYWJPbkNvbnRleHQgPSAoX3RhYikgPT4geyB9O1xuICAgICAgICBjb25zdCB0YWJzID0ge307XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMgJiZcbiAgICAgICAgICAgICAgICAoY2hpbGQudHlwZSA9PT0gSW9uVGFiQnV0dG9uIHx8IGNoaWxkLnR5cGUuaXNUYWJCdXR0b24pKSB7XG4gICAgICAgICAgICAgICAgdGFic1tjaGlsZC5wcm9wcy50YWJdID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhyZWY6IGNoaWxkLnByb3BzLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIcmVmOiBjaGlsZC5wcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJvdXRlT3B0aW9uczogY2hpbGQucHJvcHMuaHJlZiA9PT0gKChfYSA9IHByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGhuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2IgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yb3V0ZU9wdGlvbnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZU9wdGlvbnM6IGNoaWxkLnByb3BzLmhyZWYgPT09ICgoX2MgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXRobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9kID0gcHJvcHMucm91dGVJbmZvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qucm91dGVPcHRpb25zIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGFicyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRhYkJ1dHRvbkNsaWNrID0gdGhpcy5vblRhYkJ1dHRvbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyVGFiQnV0dG9uID0gdGhpcy5yZW5kZXJUYWJCdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVUYWJPbkNvbnRleHQgPSB0aGlzLnNldEFjdGl2ZVRhYk9uQ29udGV4dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbGVjdFRhYiA9IHRoaXMuc2VsZWN0VGFiLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB0YWJzID0gdGhpcy5zdGF0ZS50YWJzO1xuICAgICAgICBjb25zdCB0YWJLZXlzID0gT2JqZWN0LmtleXModGFicyk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhYiA9IHRhYktleXMuZmluZCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gdGFic1trZXldLm9yaWdpbmFsSHJlZjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnJvdXRlSW5mby5wYXRobmFtZS5zdGFydHNXaXRoKGhyZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5hY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0KHRoaXMuc3RhdGUuYWN0aXZlVGFiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RUYWIodGFiKSB7XG4gICAgICAgIGNvbnN0IHRhYlVybCA9IHRoaXMuc3RhdGUudGFic1t0YWJdO1xuICAgICAgICBpZiAodGFiVXJsKSB7XG4gICAgICAgICAgICB0aGlzLm9uVGFiQnV0dG9uQ2xpY2sobmV3IEN1c3RvbUV2ZW50KCdpb25UYWJCdXR0b25DbGljaycsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZjogdGFiVXJsLmN1cnJlbnRIcmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWIsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YWIgPT09IHRoaXMuc3RhdGUuYWN0aXZlVGFiLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZU9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdGFicyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnRhYnMpO1xuICAgICAgICBjb25zdCB0YWJLZXlzID0gT2JqZWN0LmtleXMoc3RhdGUudGFicyk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhYiA9IHRhYktleXMuZmluZCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gc3RhdGUudGFic1trZXldLm9yaWdpbmFsSHJlZjtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5yb3V0ZUluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aChocmVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgdGFiIGJ1dHRvbiBocmVmIGhhcyBjaGFuZ2VkLCBhbmQgaWYgc28sIHVwZGF0ZSBpdCBpbiB0aGUgdGFicyBzdGF0ZVxuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkLnR5cGUgPT09IElvblRhYkJ1dHRvbiB8fCBjaGlsZC50eXBlLmlzVGFiQnV0dG9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYiA9IHRhYnNbY2hpbGQucHJvcHMudGFiXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhYiB8fCB0YWIub3JpZ2luYWxIcmVmICE9PSBjaGlsZC5wcm9wcy5ocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYnNbY2hpbGQucHJvcHMudGFiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSHJlZjogY2hpbGQucHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIcmVmOiBjaGlsZC5wcm9wcy5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSb3V0ZU9wdGlvbnM6IGNoaWxkLnByb3BzLnJvdXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZU9wdGlvbnM6IGNoaWxkLnByb3BzLnJvdXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGFjdGl2ZVRhYjogcHJldkFjdGl2ZVRhYiB9ID0gc3RhdGU7XG4gICAgICAgIGlmIChhY3RpdmVUYWIgJiYgcHJldkFjdGl2ZVRhYikge1xuICAgICAgICAgICAgY29uc3QgcHJldkhyZWYgPSBzdGF0ZS50YWJzW3ByZXZBY3RpdmVUYWJdLmN1cnJlbnRIcmVmO1xuICAgICAgICAgICAgY29uc3QgcHJldlJvdXRlT3B0aW9ucyA9IHN0YXRlLnRhYnNbcHJldkFjdGl2ZVRhYl0uY3VycmVudFJvdXRlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWIgIT09IHByZXZBY3RpdmVUYWIgfHxcbiAgICAgICAgICAgICAgICBwcmV2SHJlZiAhPT0gKChfYSA9IHByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGhuYW1lKSB8fFxuICAgICAgICAgICAgICAgIHByZXZSb3V0ZU9wdGlvbnMgIT09ICgoX2IgPSBwcm9wcy5yb3V0ZUluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yb3V0ZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGFic1thY3RpdmVUYWJdID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhyZWY6IHRhYnNbYWN0aXZlVGFiXS5vcmlnaW5hbEhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIcmVmOiBwcm9wcy5yb3V0ZUluZm8ucGF0aG5hbWUgKyAocHJvcHMucm91dGVJbmZvLnNlYXJjaCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUm91dGVPcHRpb25zOiB0YWJzW2FjdGl2ZVRhYl0ub3JpZ2luYWxSb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZU9wdGlvbnM6IChfYyA9IHByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJvdXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5yb3V0ZUluZm8ucm91dGVBY3Rpb24gPT09ICdwb3AnICYmIGFjdGl2ZVRhYiAhPT0gcHJldkFjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBuYXZpZ2F0aW5nIGJhY2sgYW5kIHRoZSB0YWJzIGNoYW5nZSwgc2V0IHRoZSBwcmV2IHRhYiBiYWNrIHRvIGl0cyBvcmlnaW5hbCBocmVmXG4gICAgICAgICAgICAgICAgICAgIHRhYnNbcHJldkFjdGl2ZVRhYl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEhyZWY6IHRhYnNbcHJldkFjdGl2ZVRhYl0ub3JpZ2luYWxIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhyZWY6IHRhYnNbcHJldkFjdGl2ZVRhYl0ub3JpZ2luYWxIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSb3V0ZU9wdGlvbnM6IHRhYnNbcHJldkFjdGl2ZVRhYl0ub3JpZ2luYWxSb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVPcHRpb25zOiB0YWJzW3ByZXZBY3RpdmVUYWJdLmN1cnJlbnRSb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRhYiAmJiBwcm9wcy5vblNldEN1cnJlbnRUYWIoYWN0aXZlVGFiLCBwcm9wcy5yb3V0ZUluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZlVGFiLFxuICAgICAgICAgICAgdGFicyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25UYWJCdXR0b25DbGljayhlKSB7XG4gICAgICAgIGNvbnN0IHRhcHBlZFRhYiA9IHRoaXMuc3RhdGUudGFic1tlLmRldGFpbC50YWJdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEhyZWYgPSB0YXBwZWRUYWIub3JpZ2luYWxIcmVmO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZiA9IGUuZGV0YWlsLmhyZWY7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlVGFiOiBwcmV2QWN0aXZlVGFiIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAvLyB0aGlzLnByb3BzLm9uU2V0Q3VycmVudFRhYihlLmRldGFpbC50YWIsIHRoaXMucHJvcHMucm91dGVJbmZvKTtcbiAgICAgICAgLy8gQ2xpY2tpbmcgdGhlIGN1cnJlbnQgdGFiIHdpbGwgYnJpbmcgeW91IGJhY2sgdG8gdGhlIG9yaWdpbmFsIGhyZWZcbiAgICAgICAgaWYgKHByZXZBY3RpdmVUYWIgPT09IGUuZGV0YWlsLnRhYikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsSHJlZiAhPT0gY3VycmVudEhyZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzZXRUYWIoZS5kZXRhaWwudGFiLCBvcmlnaW5hbEhyZWYsIHRhcHBlZFRhYi5vcmlnaW5hbFJvdXRlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbklvblRhYnNXaWxsQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbklvblRhYnNXaWxsQ2hhbmdlKG5ldyBDdXN0b21FdmVudCgnaW9uVGFiV2lsbENoYW5nZScsIHsgZGV0YWlsOiB7IHRhYjogZS5kZXRhaWwudGFiIH0gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Jb25UYWJzRGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbklvblRhYnNEaWRDaGFuZ2UobmV3IEN1c3RvbUV2ZW50KCdpb25UYWJEaWRDaGFuZ2UnLCB7IGRldGFpbDogeyB0YWI6IGUuZGV0YWlsLnRhYiB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiT25Db250ZXh0KGUuZGV0YWlsLnRhYik7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2hhbmdlVGFiKGUuZGV0YWlsLnRhYiwgY3VycmVudEhyZWYsIGUuZGV0YWlsLnJvdXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVGFiQnV0dG9uKGFjdGl2ZVRhYikge1xuICAgICAgICByZXR1cm4gKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcyAmJlxuICAgICAgICAgICAgICAgIChjaGlsZC50eXBlID09PSBJb25UYWJCdXR0b24gfHwgY2hpbGQudHlwZS5pc1RhYkJ1dHRvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gY2hpbGQucHJvcHMudGFiID09PSBhY3RpdmVUYWJcbiAgICAgICAgICAgICAgICAgICAgPyAoX2EgPSB0aGlzLnByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGhuYW1lIDogdGhpcy5zdGF0ZS50YWJzW2NoaWxkLnByb3BzLnRhYl0uY3VycmVudEhyZWY7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVPcHRpb25zID0gY2hpbGQucHJvcHMudGFiID09PSBhY3RpdmVUYWJcbiAgICAgICAgICAgICAgICAgICAgPyAoX2IgPSB0aGlzLnByb3BzLnJvdXRlSW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJvdXRlT3B0aW9ucyA6IHRoaXMuc3RhdGUudGFic1tjaGlsZC5wcm9wcy50YWJdLmN1cnJlbnRSb3V0ZU9wdGlvbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMub25UYWJCdXR0b25DbGljayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgYWN0aXZlVGFiIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uVGFiQmFySW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgc2VsZWN0ZWRUYWI6IGFjdGl2ZVRhYiB9KSwgUmVhY3QuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIHRoaXMucmVuZGVyVGFiQnV0dG9uKGFjdGl2ZVRhYikpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgY29udGV4dFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOYXZDb250ZXh0O1xuICAgIH1cbn1cbmNvbnN0IElvblRhYkJhckNvbnRhaW5lciA9IFJlYWN0Lm1lbW8oKF9hKSA9PiB7XG4gICAgdmFyIHsgZm9yd2FyZGVkUmVmIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImZvcndhcmRlZFJlZlwiXSk7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTmF2Q29udGV4dCk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvblRhYkJhclVud3JhcHBlZCwgT2JqZWN0LmFzc2lnbih7IHJlZjogZm9yd2FyZGVkUmVmIH0sIHByb3BzLCB7IHJvdXRlSW5mbzogcHJvcHMucm91dGVJbmZvIHx8IGNvbnRleHQucm91dGVJbmZvIHx8IHsgcGF0aG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSB9LCBvblNldEN1cnJlbnRUYWI6IGNvbnRleHQuc2V0Q3VycmVudFRhYiB9KSwgcHJvcHMuY2hpbGRyZW4pKTtcbn0pO1xuY29uc3QgSW9uVGFiQmFyID0gY3JlYXRlRm9yd2FyZFJlZihJb25UYWJCYXJDb250YWluZXIsICdJb25UYWJCYXInKTtcblxuY2xhc3MgSW9uVGFic0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudFNTUiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jdXN0b21FbGVtZW50cykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KCdpb24tdGFicycpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdpb24tdGFicycsIElvblRhYnNFbGVtZW50KTtcbiAgICB9XG59XG5jb25zdCBob3N0U3R5bGVzID0ge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICcwJyxcbiAgICBsZWZ0OiAnMCcsXG4gICAgcmlnaHQ6ICcwJyxcbiAgICBib3R0b206ICcwJyxcbiAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIGNvbnRhaW46ICdsYXlvdXQgc2l6ZSBzdHlsZScsXG59O1xuY29uc3QgdGFic0lubmVyID0ge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGZsZXg6IDEsXG4gICAgY29udGFpbjogJ2xheW91dCBzaXplIHN0eWxlJyxcbn07XG5jb25zdCBJb25UYWJzID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5yb3V0ZXJPdXRsZXRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy50YWJCYXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pb25UYWJDb250ZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICBhY3RpdmVUYWI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlbGVjdFRhYjogKCkgPT4gZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy50YWJCYXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gR3JhYiBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICB0aGlzLmlvblRhYkNvbnRleHRTdGF0ZS5hY3RpdmVUYWIgPSB0aGlzLnRhYkJhclJlZi5jdXJyZW50LnN0YXRlLmFjdGl2ZVRhYjtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1ldGhvZFxuICAgICAgICAgICAgdGhpcy50YWJCYXJSZWYuY3VycmVudC5zZXRBY3RpdmVUYWJPbkNvbnRleHQgPSAodGFiKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pb25UYWJDb250ZXh0U3RhdGUuYWN0aXZlVGFiID0gdGFiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW9uVGFiQ29udGV4dFN0YXRlLnNlbGVjdFRhYiA9IHRoaXMudGFiQmFyUmVmLmN1cnJlbnQuc2VsZWN0VGFiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IG91dGxldDtcbiAgICAgICAgbGV0IHRhYkJhcjtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IGNsYXNzTmFtZSwgb25Jb25UYWJzRGlkQ2hhbmdlLCBvbklvblRhYnNXaWxsQ2hhbmdlIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcIm9uSW9uVGFic0RpZENoYW5nZVwiLCBcIm9uSW9uVGFic1dpbGxDaGFuZ2VcIl0pO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVvZiB0aGlzLnByb3BzLmNoaWxkcmVuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5pb25UYWJDb250ZXh0U3RhdGUpXG4gICAgICAgICAgICA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCAhY2hpbGQuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBJb25Sb3V0ZXJPdXRsZXQgfHwgY2hpbGQudHlwZS5pc1JvdXRlck91dGxldCkge1xuICAgICAgICAgICAgICAgIG91dGxldCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiBjaGlsZC5wcm9wcy5jaGlsZHJlblswXS50eXBlID09PSBJb25Sb3V0ZXJPdXRsZXQpIHtcbiAgICAgICAgICAgICAgICBvdXRsZXQgPSBjaGlsZC5wcm9wcy5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZFByb3BzID0ge1xuICAgICAgICAgICAgICAgIHJlZjogdGhpcy50YWJCYXJSZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9ubHkgcGFzcyB0aGVzZSBwcm9wc1xuICAgICAgICAgICAgICogZG93biBmcm9tIElvblRhYnMgdG8gSW9uVGFiQmFyXG4gICAgICAgICAgICAgKiBpZiB0aGV5IGFyZSBkZWZpbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgICAqIGlmIHlvdSBoYXZlIGEgaGFuZGxlciBzZXQgb25cbiAgICAgICAgICAgICAqIElvblRhYkJhciBpdCB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvbklvblRhYnNEaWRDaGFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoaWxkUHJvcHMpLCB7IG9uSW9uVGFic0RpZENoYW5nZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbklvblRhYnNXaWxsQ2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGlsZFByb3BzKSwgeyBvbklvblRhYnNXaWxsQ2hhbmdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IElvblRhYkJhciB8fCBjaGlsZC50eXBlLmlzVGFiQmFyKSB7XG4gICAgICAgICAgICAgICAgdGFiQmFyID0gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXG4gICAgICAgICAgICAgICAgKGNoaWxkLnByb3BzLmNoaWxkcmVuWzFdLnR5cGUgPT09IElvblRhYkJhciB8fCBjaGlsZC5wcm9wcy5jaGlsZHJlblsxXS50eXBlLmlzVGFiQmFyKSkge1xuICAgICAgICAgICAgICAgIHRhYkJhciA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZC5wcm9wcy5jaGlsZHJlblsxXSwgY2hpbGRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW91dGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJb25UYWJzIG11c3QgY29udGFpbiBhbiBJb25Sb3V0ZXJPdXRsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhYkJhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJb25UYWJzIG5lZWRzIGEgSW9uVGFiQmFyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvblRhYnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmlvblRhYkNvbnRleHRTdGF0ZSB9LCB0aGlzLmNvbnRleHQuaGFzSW9uaWNSb3V0ZXIoKSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2VNYW5hZ2VyLCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9YCA6ICcnLCByb3V0ZUluZm86IHRoaXMuY29udGV4dC5yb3V0ZUluZm8gfSwgcHJvcHMpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlvbi10YWJzXCIsIHsgY2xhc3NOYW1lOiBcImlvbi10YWJzXCIsIHN0eWxlOiBob3N0U3R5bGVzIH0sXG4gICAgICAgICAgICAgICAgdGFiQmFyLnByb3BzLnNsb3QgPT09ICd0b3AnID8gdGFiQmFyIDogbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHRhYnNJbm5lciwgY2xhc3NOYW1lOiBcInRhYnMtaW5uZXJcIiB9LCBvdXRsZXQpLFxuICAgICAgICAgICAgICAgIHRhYkJhci5wcm9wcy5zbG90ID09PSAnYm90dG9tJyA/IHRhYkJhciA6IG51bGwpKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9YCA6ICdpb24tdGFicycgfSwgcHJvcHMsIHsgc3R5bGU6IGhvc3RTdHlsZXMgfSksXG4gICAgICAgICAgICB0YWJCYXIucHJvcHMuc2xvdCA9PT0gJ3RvcCcgPyB0YWJCYXIgOiBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB0YWJzSW5uZXIsIGNsYXNzTmFtZTogXCJ0YWJzLWlubmVyXCIgfSwgb3V0bGV0KSxcbiAgICAgICAgICAgIHRhYkJhci5wcm9wcy5zbG90ID09PSAnYm90dG9tJyA/IHRhYkJhciA6IG51bGwpKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59KSgpO1xuXG5jb25zdCBJb25CYWNrQnV0dG9uID0gLypAX19QVVJFX18qLyAoKCkgPT4gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNsaWNrQnV0dG9uID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdEhyZWYsIHJvdXRlckFuaW1hdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaGFzSW9uaWNSb3V0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmdvQmFjayhkZWZhdWx0SHJlZiwgcm91dGVyQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlZmF1bHRIcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlZmF1bHRIcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KElvbkJhY2tCdXR0b25Jbm5lciwgT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6IHRoaXMuY2xpY2tCdXR0b24gfSwgdGhpcy5wcm9wcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGRpc3BsYXlOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0lvbkJhY2tCdXR0b24nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59KSgpO1xuXG5jbGFzcyBJb25JY29uQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5uYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0luIElvbmljIFJlYWN0LCB5b3UgaW1wb3J0IGljb25zIGZyb20gXCJpb25pY29ucy9pY29uc1wiIGFuZCBzZXQgdGhlIGljb24geW91IGltcG9ydGVkIHRvIHRoZSBcImljb25cIiBwcm9wZXJ0eS4gU2V0dGluZyB0aGUgXCJuYW1lXCIgcHJvcGVydHkgaGFzIG5vIGVmZmVjdC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IF9jID0gdGhpcy5wcm9wcywgeyBpY29uLCBpb3MsIG1kIH0gPSBfYywgcmVzdCA9IF9fcmVzdChfYywgW1wiaWNvblwiLCBcImlvc1wiLCBcIm1kXCJdKTtcbiAgICAgICAgbGV0IGljb25Ub1VzZTtcbiAgICAgICAgaWYgKGlvcyB8fCBtZCkge1xuICAgICAgICAgICAgaWYgKGlzUGxhdGZvcm0oJ2lvcycpKSB7XG4gICAgICAgICAgICAgICAgaWNvblRvVXNlID0gKF9hID0gaW9zICE9PSBudWxsICYmIGlvcyAhPT0gdm9pZCAwID8gaW9zIDogbWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGljb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpY29uVG9Vc2UgPSAoX2IgPSBtZCAhPT0gbnVsbCAmJiBtZCAhPT0gdm9pZCAwID8gbWQgOiBpb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGljb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpY29uVG9Vc2UgPSBpY29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChJb25JY29uSW5uZXIsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMucHJvcHMuZm9yd2FyZGVkUmVmLCBpY29uOiBpY29uVG9Vc2UgfSwgcmVzdCksIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuY29uc3QgSW9uSWNvbiA9IGNyZWF0ZUZvcndhcmRSZWYoSW9uSWNvbkNvbnRhaW5lciwgJ0lvbkljb24nKTtcblxuY2xhc3MgSW9uUm91dGUgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IElvblJvdXRlSW5uZXIgPSB0aGlzLmNvbnRleHQuZ2V0SW9uUm91dGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaGFzSW9uaWNSb3V0ZXIoKSB8fCAhSW9uUm91dGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBlaXRoZXIgZG8gbm90IGhhdmUgYW4gSW9uaWMgUm91dGVyIHBhY2thZ2UsIG9yIHlvdXIgcm91dGVyIGRvZXMgbm90IHN1cHBvcnQgdXNpbmcgPElvblJvdXRlPicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW9uUm91dGVJbm5lciwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGNvbnRleHRUeXBlKCkge1xuICAgICAgICByZXR1cm4gTmF2Q29udGV4dDtcbiAgICB9XG59XG5cbmNsYXNzIElvblJlZGlyZWN0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBJb25SZWRpcmVjdElubmVyID0gdGhpcy5jb250ZXh0LmdldElvblJlZGlyZWN0KCk7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc0lvbmljUm91dGVyKCkgfHwgIUlvblJlZGlyZWN0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgZWl0aGVyIGRvIG5vdCBoYXZlIGFuIElvbmljIFJvdXRlciBwYWNrYWdlLCBvciB5b3VyIHJvdXRlciBkb2VzIG5vdCBzdXBwb3J0IHVzaW5nIDxJb25SZWRpcmVjdD4nKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KElvblJlZGlyZWN0SW5uZXIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb250ZXh0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdkNvbnRleHQ7XG4gICAgfVxufVxuXG5jb25zdCBJb25Sb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgcm91dGVJbmZvOiB1bmRlZmluZWQsXG4gICAgcHVzaDogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG4gICAgYmFjazogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElvbmljIFJvdXRlciBpcyByZXF1aXJlZCBmb3IgSW9uUm91dGVyQ29udGV4dCcpO1xuICAgIH0sXG4gICAgY2FuR29CYWNrOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gSW9uaWMgUm91dGVyIGlzIHJlcXVpcmVkIGZvciBJb25Sb3V0ZXJDb250ZXh0Jyk7XG4gICAgfSxcbiAgICBuYXRpdmVCYWNrOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gSW9uaWMgUm91dGVyIGlzIHJlcXVpcmVkIGZvciBJb25Sb3V0ZXJDb250ZXh0Jyk7XG4gICAgfSxcbn0pO1xuLyoqXG4gKiBBIGhvb2sgZm9yIG1vcmUgZGlyZWN0IGNvbnRyb2wgb3ZlciByb3V0aW5nIGluIGFuIElvbmljIFJlYWN0IGFwcGxpY2F0aW9uLiBBbGxvd3MgeW91IHRvIHBhc3MgYWRkaXRpb25hbCBtZXRhLWRhdGEgdG8gdGhlIHJvdXRlciBiZWZvcmUgdGhlIGNhbGwgdG8gdGhlIG5hdGl2ZSByb3V0ZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZUlvblJvdXRlcigpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJb25Sb3V0ZXJDb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrOiBjb250ZXh0LmJhY2ssXG4gICAgICAgIHB1c2g6IGNvbnRleHQucHVzaCxcbiAgICAgICAgZ29CYWNrOiBjb250ZXh0LmJhY2ssXG4gICAgICAgIGNhbkdvQmFjazogY29udGV4dC5jYW5Hb0JhY2ssXG4gICAgICAgIHJvdXRlSW5mbzogY29udGV4dC5yb3V0ZUluZm8sXG4gICAgfTtcbn1cblxuY2xhc3MgQ3JlYXRlQW5pbWF0aW9uIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLm5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGNyZWF0ZUFuaW1hdGlvbihwcm9wcy5pZCk7XG4gICAgfVxuICAgIHNldHVwQW5pbWF0aW9uKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLmFkZEVsZW1lbnQoQXJyYXkuZnJvbSh0aGlzLm5vZGVzLnZhbHVlcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDb25maWcoYW5pbWF0aW9uLCBwcm9wcyk7XG4gICAgICAgIGNoZWNrUGxheWJhY2soYW5pbWF0aW9uLCBwcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuc2V0dXBBbmltYXRpb24ocHJvcHMpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNoZWNrQ29uZmlnKGFuaW1hdGlvbiwgcHJvcHMsIHByZXZQcm9wcyk7XG4gICAgICAgIGNoZWNrUHJvZ3Jlc3MoYW5pbWF0aW9uLCBwcm9wcywgcHJldlByb3BzKTtcbiAgICAgICAgY2hlY2tQbGF5YmFjayhhbmltYXRpb24sIHByb3BzLCBwcmV2UHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGlkKSA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgcmVmOiAoZWwpID0+IHRoaXMubm9kZXMuc2V0KGlkLCBlbCkgfSkpKSk7XG4gICAgfVxufVxuY29uc3QgY2hlY2tDb25maWcgPSAoYW5pbWF0aW9uLCBjdXJyZW50UHJvcHMgPSB7fSwgcHJldlByb3BzID0ge30pID0+IHtcbiAgICBjb25zdCByZXNlcnZlZFByb3BzID0gW1xuICAgICAgICAnY2hpbGRyZW4nLFxuICAgICAgICAncHJvZ3Jlc3NTdGFydCcsXG4gICAgICAgICdwcm9ncmVzc1N0ZXAnLFxuICAgICAgICAncHJvZ3Jlc3NFbmQnLFxuICAgICAgICAncGF1c2UnLFxuICAgICAgICAnc3RvcCcsXG4gICAgICAgICdkZXN0cm95JyxcbiAgICAgICAgJ3BsYXknLFxuICAgICAgICAnZnJvbScsXG4gICAgICAgICd0bycsXG4gICAgICAgICdmcm9tVG8nLFxuICAgICAgICAnb25GaW5pc2gnLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudFByb3BzKSB7XG4gICAgICAgIGlmIChjdXJyZW50UHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgIXJlc2VydmVkUHJvcHMuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgY3VycmVudFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldKSB7XG4gICAgICAgICAgICBhbmltYXRpb25ba2V5XShjdXJyZW50UHJvcHNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGN1cnJlbnRQcm9wcy5mcm9tO1xuICAgIGlmIChmcm9tVmFsdWVzICYmIGZyb21WYWx1ZXMgIT09IHByZXZQcm9wcy5mcm9tKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoZnJvbVZhbHVlcykgPyBmcm9tVmFsdWVzIDogW2Zyb21WYWx1ZXNdO1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsKSA9PiBhbmltYXRpb24uZnJvbSh2YWwucHJvcGVydHksIHZhbC52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCB0b1ZhbHVlcyA9IGN1cnJlbnRQcm9wcy50bztcbiAgICBpZiAodG9WYWx1ZXMgJiYgdG9WYWx1ZXMgIT09IHByZXZQcm9wcy50bykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHRvVmFsdWVzKSA/IHRvVmFsdWVzIDogW3RvVmFsdWVzXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbCkgPT4gYW5pbWF0aW9uLnRvKHZhbC5wcm9wZXJ0eSwgdmFsLnZhbHVlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub1ZhbHVlcyA9IGN1cnJlbnRQcm9wcy5mcm9tVG87XG4gICAgaWYgKGZyb21Ub1ZhbHVlcyAmJiBmcm9tVG9WYWx1ZXMgIT09IHByZXZQcm9wcy5mcm9tVG8pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShmcm9tVG9WYWx1ZXMpID8gZnJvbVRvVmFsdWVzIDogW2Zyb21Ub1ZhbHVlc107XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWwpID0+IGFuaW1hdGlvbi5mcm9tVG8odmFsLnByb3BlcnR5LCB2YWwuZnJvbVZhbHVlLCB2YWwudG9WYWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBvbkZpbmlzaFZhbHVlcyA9IGN1cnJlbnRQcm9wcy5vbkZpbmlzaDtcbiAgICBpZiAob25GaW5pc2hWYWx1ZXMgJiYgb25GaW5pc2hWYWx1ZXMgIT09IHByZXZQcm9wcy5vbkZpbmlzaCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KG9uRmluaXNoVmFsdWVzKSA/IG9uRmluaXNoVmFsdWVzIDogW29uRmluaXNoVmFsdWVzXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbCkgPT4gYW5pbWF0aW9uLm9uRmluaXNoKHZhbC5jYWxsYmFjaywgdmFsLm9wdHMpKTtcbiAgICB9XG59O1xuY29uc3QgY2hlY2tQcm9ncmVzcyA9IChhbmltYXRpb24sIGN1cnJlbnRQcm9wcyA9IHt9LCBwcmV2UHJvcHMgPSB7fSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgeyBwcm9ncmVzc1N0YXJ0LCBwcm9ncmVzc1N0ZXAsIHByb2dyZXNzRW5kIH0gPSBjdXJyZW50UHJvcHM7XG4gICAgaWYgKHByb2dyZXNzU3RhcnQgJiZcbiAgICAgICAgKCgoX2EgPSBwcmV2UHJvcHMucHJvZ3Jlc3NTdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlTGluZWFyRWFzaW5nKSAhPT0gKHByb2dyZXNzU3RhcnQgPT09IG51bGwgfHwgcHJvZ3Jlc3NTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NTdGFydC5mb3JjZUxpbmVhckVhc2luZykgfHxcbiAgICAgICAgICAgICgoX2IgPSBwcmV2UHJvcHMucHJvZ3Jlc3NTdGFydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0ZXApICE9PSAocHJvZ3Jlc3NTdGFydCA9PT0gbnVsbCB8fCBwcm9ncmVzc1N0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9ncmVzc1N0YXJ0LnN0ZXApKSkge1xuICAgICAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGFydChwcm9ncmVzc1N0YXJ0LmZvcmNlTGluZWFyRWFzaW5nLCBwcm9ncmVzc1N0YXJ0LnN0ZXApO1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NTdGVwICYmICgoX2MgPSBwcmV2UHJvcHMucHJvZ3Jlc3NTdGVwKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RlcCkgIT09IChwcm9ncmVzc1N0ZXAgPT09IG51bGwgfHwgcHJvZ3Jlc3NTdGVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9ncmVzc1N0ZXAuc3RlcCkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RlcChwcm9ncmVzc1N0ZXAuc3RlcCk7XG4gICAgfVxuICAgIGlmIChwcm9ncmVzc0VuZCAmJlxuICAgICAgICAoKChfZCA9IHByZXZQcm9wcy5wcm9ncmVzc0VuZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnBsYXlUbykgIT09IChwcm9ncmVzc0VuZCA9PT0gbnVsbCB8fCBwcm9ncmVzc0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NFbmQucGxheVRvKSB8fFxuICAgICAgICAgICAgKChfZSA9IHByZXZQcm9wcy5wcm9ncmVzc0VuZCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnN0ZXApICE9PSAocHJvZ3Jlc3NFbmQgPT09IG51bGwgfHwgcHJvZ3Jlc3NFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2dyZXNzRW5kLnN0ZXApIHx8XG4gICAgICAgICAgICAocHJldlByb3BzID09PSBudWxsIHx8IHByZXZQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlByb3BzLmR1cikgIT09IChwcm9ncmVzc0VuZCA9PT0gbnVsbCB8fCBwcm9ncmVzc0VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZ3Jlc3NFbmQuZHVyKSkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnByb2dyZXNzRW5kKHByb2dyZXNzRW5kLnBsYXlUbywgcHJvZ3Jlc3NFbmQuc3RlcCwgcHJvZ3Jlc3NFbmQuZHVyKTtcbiAgICB9XG59O1xuY29uc3QgY2hlY2tQbGF5YmFjayA9IChhbmltYXRpb24sIGN1cnJlbnRQcm9wcyA9IHt9LCBwcmV2UHJvcHMgPSB7fSkgPT4ge1xuICAgIGlmICghcHJldlByb3BzLnBsYXkgJiYgY3VycmVudFByb3BzLnBsYXkpIHtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMucGF1c2UgJiYgY3VycmVudFByb3BzLnBhdXNlKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH1cbiAgICBpZiAoIXByZXZQcm9wcy5zdG9wICYmIGN1cnJlbnRQcm9wcy5zdG9wKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzLmRlc3Ryb3kgJiYgY3VycmVudFByb3BzLmRlc3Ryb3kpIHtcbiAgICAgICAgYW5pbWF0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB1c2VDb250cm9sbGVyKGRpc3BsYXlOYW1lLCBjb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3Qgb3ZlcmxheVJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IGRpZERpc21pc3NFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkRGlzbWlzc2AsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IGRpZFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9RGlkUHJlc2VudGAsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IHdpbGxEaXNtaXNzRXZlbnROYW1lID0gdXNlTWVtbygoKSA9PiBgb24ke2Rpc3BsYXlOYW1lfVdpbGxEaXNtaXNzYCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgY29uc3Qgd2lsbFByZXNlbnRFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9V2lsbFByZXNlbnRgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBkZWZpbmVDdXN0b21FbGVtZW50KCk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChvdmVybGF5UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uRGlkRGlzbWlzcywgb25XaWxsRGlzbWlzcywgb25EaWRQcmVzZW50LCBvbldpbGxQcmVzZW50IH0gPSBvcHRpb25zLCByZXN0ID0gX19yZXN0KG9wdGlvbnMsIFtcIm9uRGlkRGlzbWlzc1wiLCBcIm9uV2lsbERpc21pc3NcIiwgXCJvbkRpZFByZXNlbnRcIiwgXCJvbldpbGxQcmVzZW50XCJdKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRGlzbWlzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9uRGlkRGlzbWlzcykge1xuICAgICAgICAgICAgICAgIG9uRGlkRGlzbWlzcyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IGF3YWl0IGNvbnRyb2xsZXIuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpKTtcbiAgICAgICAgYXR0YWNoUHJvcHMob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICBbZGlkRGlzbWlzc0V2ZW50TmFtZV06IGhhbmRsZURpc21pc3MsXG4gICAgICAgICAgICBbZGlkUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiBvbkRpZFByZXNlbnQgJiYgb25EaWRQcmVzZW50KGUpLFxuICAgICAgICAgICAgW3dpbGxEaXNtaXNzRXZlbnROYW1lXTogKGUpID0+IG9uV2lsbERpc21pc3MgJiYgb25XaWxsRGlzbWlzcyhlKSxcbiAgICAgICAgICAgIFt3aWxsUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiBvbldpbGxQcmVzZW50ICYmIG9uV2lsbFByZXNlbnQoZSksXG4gICAgICAgIH0pO1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQucHJlc2VudCgpO1xuICAgIH0sIFtjb250cm9sbGVyXSk7XG4gICAgY29uc3QgZGlzbWlzcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ICYmIChhd2FpdCBvdmVybGF5UmVmLmN1cnJlbnQuZGlzbWlzcygpKTtcbiAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVzZW50LFxuICAgICAgICBkaXNtaXNzLFxuICAgIH07XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uQWN0aW9uU2hlZXQgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uQWN0aW9uU2hlZXQoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHVzZUNvbnRyb2xsZXIoJ0lvbkFjdGlvblNoZWV0JywgYWN0aW9uU2hlZXRDb250cm9sbGVyJDEsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTMpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygoYnV0dG9uc09yT3B0aW9ucywgaGVhZGVyKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1dHRvbnNPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KHtcbiAgICAgICAgICAgICAgICBidXR0b25zOiBidXR0b25zT3JPcHRpb25zLFxuICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudChidXR0b25zT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyLnByZXNlbnRdKTtcbiAgICByZXR1cm4gW3ByZXNlbnQsIGNvbnRyb2xsZXIuZGlzbWlzc107XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uQWxlcnQgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uQWxlcnQoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHVzZUNvbnRyb2xsZXIoJ0lvbkFsZXJ0JywgYWxlcnRDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDFjKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2VPck9wdGlvbnMsIGJ1dHRvbnMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBidXR0b25zOiBidXR0b25zICE9PSBudWxsICYmIGJ1dHRvbnMgIT09IHZvaWQgMCA/IGJ1dHRvbnMgOiBbeyB0ZXh0OiAnT2snIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KG1lc3NhZ2VPck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZXIucHJlc2VudF0pO1xuICAgIHJldHVybiBbcHJlc2VudCwgY29udHJvbGxlci5kaXNtaXNzXTtcbn1cblxuLyoqXG4gKiBBIGhvb2sgZm9yIHByZXNlbnRpbmcvZGlzbWlzc2luZyBhbiBJb25Ub2FzdCBjb21wb25lbnRcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHByZXNlbnQgYW5kIGRpc21pc3MgbWV0aG9kcyBpbiBhbiBhcnJheVxuICovXG5mdW5jdGlvbiB1c2VJb25Ub2FzdCgpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gdXNlQ29udHJvbGxlcignSW9uVG9hc3QnLCB0b2FzdENvbnRyb2xsZXIkMSwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxZCk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChtZXNzYWdlT3JPcHRpb25zLCBkdXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlT3JPcHRpb25zLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQobWVzc2FnZU9yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJlc2VudCxcbiAgICAgICAgY29udHJvbGxlci5kaXNtaXNzXG4gICAgXTtcbn1cblxuY29uc3QgaWRzID0geyBtYWluOiAwIH07XG5jb25zdCBnZW5lcmF0ZUlkID0gKHR5cGUgPSAnbWFpbicpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaWQgPSAoKF9hID0gaWRzW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIDE7XG4gICAgaWRzW3R5cGVdID0gaWQ7XG4gICAgcmV0dXJuIGlkLnRvU3RyaW5nKCk7XG59O1xuXG5mdW5jdGlvbiB1c2VPdmVybGF5KGRpc3BsYXlOYW1lLCBjb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50LCBjb21wb25lbnQsIGNvbXBvbmVudFByb3BzKSB7XG4gICAgY29uc3Qgb3ZlcmxheVJlZiA9IHVzZVJlZigpO1xuICAgIGNvbnN0IGNvbnRhaW5lckVsUmVmID0gdXNlUmVmKCk7XG4gICAgY29uc3QgZGlkRGlzbWlzc0V2ZW50TmFtZSA9IHVzZU1lbW8oKCkgPT4gYG9uJHtkaXNwbGF5TmFtZX1EaWREaXNtaXNzYCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgY29uc3QgZGlkUHJlc2VudEV2ZW50TmFtZSA9IHVzZU1lbW8oKCkgPT4gYG9uJHtkaXNwbGF5TmFtZX1EaWRQcmVzZW50YCwgW2Rpc3BsYXlOYW1lXSk7XG4gICAgY29uc3Qgd2lsbERpc21pc3NFdmVudE5hbWUgPSB1c2VNZW1vKCgpID0+IGBvbiR7ZGlzcGxheU5hbWV9V2lsbERpc21pc3NgLCBbZGlzcGxheU5hbWVdKTtcbiAgICBjb25zdCB3aWxsUHJlc2VudEV2ZW50TmFtZSA9IHVzZU1lbW8oKCkgPT4gYG9uJHtkaXNwbGF5TmFtZX1XaWxsUHJlc2VudGAsIFtkaXNwbGF5TmFtZV0pO1xuICAgIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaW9uQ29udGV4dCA9IHVzZUNvbnRleHQoSW9uQ29udGV4dCk7XG4gICAgY29uc3QgW292ZXJsYXlJZF0gPSB1c2VTdGF0ZShnZW5lcmF0ZUlkKCdvdmVybGF5JykpO1xuICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNPcGVuICYmIGNvbXBvbmVudCAmJiBjb250YWluZXJFbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGlvbkNvbnRleHQuYWRkT3ZlcmxheShvdmVybGF5SWQsIGNvbXBvbmVudCwgY29udGFpbmVyRWxSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIGNvbXBvbmVudFByb3BzKTtcbiAgICAgICAgICAgICAgICBpb25Db250ZXh0LmFkZE92ZXJsYXkob3ZlcmxheUlkLCBlbGVtZW50LCBjb250YWluZXJFbFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb21wb25lbnQsIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQsIGlzT3BlbiwgY29tcG9uZW50UHJvcHNdKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKG92ZXJsYXlSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb25EaWREaXNtaXNzLCBvbldpbGxEaXNtaXNzLCBvbkRpZFByZXNlbnQsIG9uV2lsbFByZXNlbnQgfSA9IG9wdGlvbnMsIHJlc3QgPSBfX3Jlc3Qob3B0aW9ucywgW1wib25EaWREaXNtaXNzXCIsIFwib25XaWxsRGlzbWlzc1wiLCBcIm9uRGlkUHJlc2VudFwiLCBcIm9uV2lsbFByZXNlbnRcIl0pO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29udGFpbmVyRWxSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJsYXlSZWYuY3VycmVudCA9IGF3YWl0IGNvbnRyb2xsZXIuY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHsgY29tcG9uZW50OiBjb250YWluZXJFbFJlZi5jdXJyZW50IH0pKTtcbiAgICAgICAgYXR0YWNoUHJvcHMob3ZlcmxheVJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgICBbZGlkRGlzbWlzc0V2ZW50TmFtZV06IGhhbmRsZURpc21pc3MsXG4gICAgICAgICAgICBbZGlkUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiBvbkRpZFByZXNlbnQgJiYgb25EaWRQcmVzZW50KGUpLFxuICAgICAgICAgICAgW3dpbGxEaXNtaXNzRXZlbnROYW1lXTogKGUpID0+IG9uV2lsbERpc21pc3MgJiYgb25XaWxsRGlzbWlzcyhlKSxcbiAgICAgICAgICAgIFt3aWxsUHJlc2VudEV2ZW50TmFtZV06IChlKSA9PiBvbldpbGxQcmVzZW50ICYmIG9uV2lsbFByZXNlbnQoZSksXG4gICAgICAgIH0pO1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQucHJlc2VudCgpO1xuICAgICAgICBzZXRJc09wZW4odHJ1ZSk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZURpc21pc3MoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChvbkRpZERpc21pc3MpIHtcbiAgICAgICAgICAgICAgICBvbkRpZERpc21pc3MoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGFpbmVyRWxSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNldElzT3BlbihmYWxzZSk7XG4gICAgICAgICAgICBpb25Db250ZXh0LnJlbW92ZU92ZXJsYXkob3ZlcmxheUlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBkaXNtaXNzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgJiYgKGF3YWl0IG92ZXJsYXlSZWYuY3VycmVudC5kaXNtaXNzKCkpO1xuICAgICAgICBvdmVybGF5UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRhaW5lckVsUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZXNlbnQsXG4gICAgICAgIGRpc21pc3MsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBBIGhvb2sgZm9yIHByZXNlbnRpbmcvZGlzbWlzc2luZyBhbiBJb25Nb2RhbCBjb21wb25lbnRcbiAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0aGF0IHRoZSBtb2RhbCB3aWxsIHNob3cuIENhbiBiZSBhIFJlYWN0IENvbXBvbmVudCwgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCwgb3IgYSBKU1ggRWxlbWVudFxuICogQHBhcmFtIGNvbXBvbmVudFByb3BzIFRoZSBwcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQsIGlmIHJlcXVpcmVkXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uTW9kYWwoY29tcG9uZW50LCBjb21wb25lbnRQcm9wcykge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VPdmVybGF5KCdJb25Nb2RhbCcsIG1vZGFsQ29udHJvbGxlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCQxNCwgY29tcG9uZW50LCBjb21wb25lbnRQcm9wcyk7XG4gICAgY29uc3QgcHJlc2VudCA9IHVzZUNhbGxiYWNrKChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29udHJvbGxlci5wcmVzZW50KG9wdGlvbnMpO1xuICAgIH0sIFtjb250cm9sbGVyLnByZXNlbnRdKTtcbiAgICByZXR1cm4gW3ByZXNlbnQsIGNvbnRyb2xsZXIuZGlzbWlzc107XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uUGlja2VyIGNvbXBvbmVudFxuICogQHBhcmFtIGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRoYXQgdGhlIHBvcG92ZXIgd2lsbCBzaG93LiBDYW4gYmUgYSBSZWFjdCBDb21wb25lbnQsIGEgZnVuY3Rpb25hbCBjb21wb25lbnQsIG9yIGEgSlNYIEVsZW1lbnRcbiAqIEBwYXJhbSBjb21wb25lbnRQcm9wcyBUaGUgcHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50LCBpZiByZXF1aXJlZFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgcHJlc2VudCBhbmQgZGlzbWlzcyBtZXRob2RzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVzZUlvblBvcG92ZXIoY29tcG9uZW50LCBjb21wb25lbnRQcm9wcykge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VPdmVybGF5KCdJb25Qb3BvdmVyJywgcG9wb3ZlckNvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQkMTUsIGNvbXBvbmVudCwgY29tcG9uZW50UHJvcHMpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucHJlc2VudChvcHRpb25zKTtcbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJlc2VudCxcbiAgICAgICAgY29udHJvbGxlci5kaXNtaXNzXG4gICAgXTtcbn1cblxuLyoqXG4gKiBBIGhvb2sgZm9yIHByZXNlbnRpbmcvZGlzbWlzc2luZyBhbiBJb25QaWNrZXIgY29tcG9uZW50XG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBwcmVzZW50IGFuZCBkaXNtaXNzIG1ldGhvZHMgaW4gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gdXNlSW9uUGlja2VyKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25QaWNrZXInLCBwaWNrZXJDb250cm9sbGVyLCBkZWZpbmVDdXN0b21FbGVtZW50JDFlKTtcbiAgICBjb25zdCBwcmVzZW50ID0gdXNlQ2FsbGJhY2soKGNvbHVtbnNPck9wdGlvbnMsIGJ1dHRvbnMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnNPck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9ucyAhPT0gbnVsbCAmJiBidXR0b25zICE9PSB2b2lkIDAgPyBidXR0b25zIDogW3sgdGV4dDogJ09rJyB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucHJlc2VudChjb2x1bW5zT3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyLnByZXNlbnRdKTtcbiAgICByZXR1cm4gW3ByZXNlbnQsIGNvbnRyb2xsZXIuZGlzbWlzc107XG59XG5cbi8qKlxuICogQSBob29rIGZvciBwcmVzZW50aW5nL2Rpc21pc3NpbmcgYW4gSW9uTG9hZGluZyBjb21wb25lbnRcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHByZXNlbnQgYW5kIGRpc21pc3MgbWV0aG9kcyBpbiBhbiBhcnJheVxuICovXG5mdW5jdGlvbiB1c2VJb25Mb2FkaW5nKCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB1c2VDb250cm9sbGVyKCdJb25Mb2FkaW5nJywgbG9hZGluZ0NvbnRyb2xsZXIsIGRlZmluZUN1c3RvbUVsZW1lbnQkMWYpO1xuICAgIGNvbnN0IHByZXNlbnQgPSB1c2VDYWxsYmFjaygobWVzc2FnZU9yT3B0aW9ucyA9ICcnLCBkdXJhdGlvbiwgc3Bpbm5lcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2VPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5wcmVzZW50KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlT3JPcHRpb25zLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHNwaW5uZXI6IHNwaW5uZXIgIT09IG51bGwgJiYgc3Bpbm5lciAhPT0gdm9pZCAwID8gc3Bpbm5lciA6ICdsaW5lcycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnByZXNlbnQobWVzc2FnZU9yT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlci5wcmVzZW50XSk7XG4gICAgcmV0dXJuIFtwcmVzZW50LCBjb250cm9sbGVyLmRpc21pc3NdO1xufVxuXG5jb25zdCBzZXR1cElvbmljUmVhY3QgPSAoY29uZmlnID0ge30pID0+IHtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IElvbmljIEZyYW1ld29yayBoaWRlcyBlbGVtZW50cyB0aGF0XG4gICAgICogYXJlIG5vdCBoeWRyYXRlZCwgYnV0IGluIHRoZSBDRSBidWlsZCB0aGVyZSBpcyBub1xuICAgICAqIGh5ZHJhdGlvbi5cbiAgICAgKiBUT0RPOiBSZW1vdmUgd2hlbiBhbGwgaW50ZWdyYXRpb25zIGhhdmUgYmVlblxuICAgICAqIG1pZ3JhdGVkIHRvIENFIGJ1aWxkLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpb24tY2UnKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShPYmplY3QuYXNzaWduKHt9LCBjb25maWcpKTtcbn07XG5cbmNvbnN0IFJvdXRlTWFuYWdlckNvbnRleHQgPSAvKkBfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICAgIGFkZFZpZXdJdGVtOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY2FuR29CYWNrOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgY2xlYXJPdXRsZXQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBjcmVhdGVWaWV3SXRlbTogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGZpbmRWaWV3SXRlbUJ5UGF0aG5hbWU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBmaW5kTGVhdmluZ1ZpZXdJdGVtQnlSb3V0ZUluZm86ICgpID0+IHVuZGVmaW5lZCxcbiAgICBmaW5kVmlld0l0ZW1CeVJvdXRlSW5mbzogKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldENoaWxkcmVuVG9SZW5kZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBnb0JhY2s6ICgpID0+IHVuZGVmaW5lZCxcbiAgICB1bk1vdW50Vmlld0l0ZW06ICgpID0+IHVuZGVmaW5lZCxcbn0pO1xuXG5jbGFzcyBWaWV3TGlmZUN5Y2xlTWFuYWdlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmlvbkxpZmVDeWNsZUNvbnRleHQgPSBuZXcgRGVmYXVsdElvbkxpZmVDeWNsZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dC5vbkNvbXBvbmVudENhbkJlRGVzdHJveWVkKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5tb3VudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgKCkgPT4gdGhpcy5wcm9wcy5yZW1vdmVWaWV3KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgc2hvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KElvbkxpZmVDeWNsZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuaW9uTGlmZUN5Y2xlQ29udGV4dCB9LCBzaG93ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG59XG5cbi8vIGNvbnN0IFJFU1RSSUNUX1NJWkUgPSAxMDA7XG5jbGFzcyBMb2NhdGlvbkhpc3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLnRhYkhpc3RvcnkgPSB7fTtcbiAgICB9XG4gICAgYWRkKHJvdXRlSW5mbykge1xuICAgICAgICBpZiAocm91dGVJbmZvLnJvdXRlQWN0aW9uID09PSAncHVzaCcgfHwgcm91dGVJbmZvLnJvdXRlQWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZChyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PT0gJ3BvcCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcChyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdXRlSW5mby5yb3V0ZUFjdGlvbiA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlKHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlSW5mby5yb3V0ZURpcmVjdGlvbiA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fYWRkKHJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJUYWJTdGFjayh0YWIpIHtcbiAgICAgICAgY29uc3Qgcm91dGVJbmZvcyA9IHRoaXMuX2dldFJvdXRlSW5mb3NCeUtleSh0YWIpO1xuICAgICAgICBpZiAocm91dGVJbmZvcykge1xuICAgICAgICAgICAgcm91dGVJbmZvcy5mb3JFYWNoKChyaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5ID0gdGhpcy5sb2NhdGlvbkhpc3RvcnkuZmlsdGVyKCh4KSA9PiB4LmlkICE9PSByaS5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGFiSGlzdG9yeVt0YWJdID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHJvdXRlSW5mbykge1xuICAgICAgICBjb25zdCBsb2NhdGlvbkluZGV4ID0gdGhpcy5sb2NhdGlvbkhpc3RvcnkuZmluZEluZGV4KCh4KSA9PiB4LmlkID09PSByb3V0ZUluZm8uaWQpO1xuICAgICAgICBpZiAobG9jYXRpb25JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeS5zcGxpY2UobG9jYXRpb25JbmRleCwgMSwgcm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJBcnJheSA9IHRoaXMudGFiSGlzdG9yeVtyb3V0ZUluZm8udGFiIHx8ICcnXTtcbiAgICAgICAgaWYgKHRhYkFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCB0YWJJbmRleCA9IHRhYkFycmF5LmZpbmRJbmRleCgoeCkgPT4geC5pZCA9PT0gcm91dGVJbmZvLmlkKTtcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGFiQXJyYXkuc3BsaWNlKHRhYkluZGV4LCAxLCByb3V0ZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiQXJyYXkucHVzaChyb3V0ZUluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdXRlSW5mby50YWIpIHtcbiAgICAgICAgICAgIHRoaXMudGFiSGlzdG9yeVtyb3V0ZUluZm8udGFiXSA9IFtyb3V0ZUluZm9dO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGQocm91dGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkocm91dGVJbmZvLnRhYik7XG4gICAgICAgIGlmIChyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGF0ZXN0IHJvdXRlSW5mbyBpcyB0aGUgc2FtZSAoZ29pbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0YWJzKSwgcmVwbGFjZSBpdFxuICAgICAgICAgICAgaWYgKHRoaXMuX2FyZVJvdXRlc0VxdWFsKHJvdXRlSW5mb3Nbcm91dGVJbmZvcy5sZW5ndGggLSAxXSwgcm91dGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mb3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZUluZm9zLnB1c2gocm91dGVJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeS5wdXNoKHJvdXRlSW5mbyk7XG4gICAgfVxuICAgIF9hcmVSb3V0ZXNFcXVhbChyb3V0ZTEsIHJvdXRlMikge1xuICAgICAgICBpZiAoIXJvdXRlMSB8fCAhcm91dGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlMS5wYXRobmFtZSA9PT0gcm91dGUyLnBhdGhuYW1lICYmIHJvdXRlMS5zZWFyY2ggPT09IHJvdXRlMi5zZWFyY2g7XG4gICAgfVxuICAgIF9wb3Aocm91dGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkocm91dGVJbmZvLnRhYik7XG4gICAgICAgIGlmIChyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHJvdXRlXG4gICAgICAgICAgICByb3V0ZUluZm9zLnBvcCgpO1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY3VycmVudCByb3V0ZSB3aXRoIGFuIHVwZGF0ZWQgdmVyc2lvblxuICAgICAgICAgICAgcm91dGVJbmZvcy5wb3AoKTtcbiAgICAgICAgICAgIHJvdXRlSW5mb3MucHVzaChyb3V0ZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgcm91dGVcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkucG9wKCk7XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgcm91dGUgd2l0aCBhbiB1cGRhdGVkIHZlcnNpb25cbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkucG9wKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25IaXN0b3J5LnB1c2gocm91dGVJbmZvKTtcbiAgICB9XG4gICAgX3JlcGxhY2Uocm91dGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkocm91dGVJbmZvLnRhYik7XG4gICAgICAgIHJvdXRlSW5mb3MgJiYgcm91dGVJbmZvcy5wb3AoKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnkucG9wKCk7XG4gICAgICAgIHRoaXMuX2FkZChyb3V0ZUluZm8pO1xuICAgIH1cbiAgICBfY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnRhYkhpc3RvcnkpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+ICh0aGlzLnRhYkhpc3Rvcnlba10gPSBbXSkpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uSGlzdG9yeSA9IFtdO1xuICAgIH1cbiAgICBfZ2V0Um91dGVJbmZvc0J5S2V5KGtleSkge1xuICAgICAgICBsZXQgcm91dGVJbmZvcztcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgcm91dGVJbmZvcyA9IHRoaXMudGFiSGlzdG9yeVtrZXldO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvcyA9IHRoaXMudGFiSGlzdG9yeVtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlSW5mb3M7XG4gICAgfVxuICAgIGdldEZpcnN0Um91dGVJbmZvRm9yVGFiKHRhYikge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHRhYik7XG4gICAgICAgIGlmIChyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRDdXJyZW50Um91dGVJbmZvRm9yVGFiKHRhYikge1xuICAgICAgICBjb25zdCByb3V0ZUluZm9zID0gdGhpcy5fZ2V0Um91dGVJbmZvc0J5S2V5KHRhYik7XG4gICAgICAgIGlmIChyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvc1tyb3V0ZUluZm9zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmRMYXN0TG9jYXRpb24ocm91dGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlSW5mb3MgPSB0aGlzLl9nZXRSb3V0ZUluZm9zQnlLZXkocm91dGVJbmZvLnRhYik7XG4gICAgICAgIGlmIChyb3V0ZUluZm9zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcm91dGVJbmZvcy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpID0gcm91dGVJbmZvc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpLnBhdGhuYW1lID09PSByb3V0ZUluZm8ucHVzaGVkQnlSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxvY2F0aW9uSGlzdG9yeS5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgcmkgPSB0aGlzLmxvY2F0aW9uSGlzdG9yeVtpXTtcbiAgICAgICAgICAgIGlmIChyaSkge1xuICAgICAgICAgICAgICAgIGlmIChyaS5wYXRobmFtZSA9PT0gcm91dGVJbmZvLnB1c2hlZEJ5Um91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwcmV2aW91cygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvY2F0aW9uSGlzdG9yeVt0aGlzLmxvY2F0aW9uSGlzdG9yeS5sZW5ndGggLSAyXSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbkhpc3RvcnlbdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgICBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbkhpc3RvcnlbdGhpcy5sb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNhbkdvQmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25IaXN0b3J5Lmxlbmd0aCA+IDE7XG4gICAgfVxufVxuXG5jbGFzcyBOYXZNYW5hZ2VyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pb25Sb3V0ZXJDb250ZXh0VmFsdWUgPSB7XG4gICAgICAgICAgICBwdXNoOiAocGF0aG5hbWUsIHJvdXRlckRpcmVjdGlvbiwgcm91dGVBY3Rpb24sIHJvdXRlck9wdGlvbnMsIGFuaW1hdGlvbkJ1aWxkZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlKHBhdGhuYW1lLCByb3V0ZXJEaXJlY3Rpb24sIHJvdXRlQWN0aW9uLCBhbmltYXRpb25CdWlsZGVyLCByb3V0ZXJPcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrOiAoYW5pbWF0aW9uQnVpbGRlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrKHVuZGVmaW5lZCwgYW5pbWF0aW9uQnVpbGRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuR29CYWNrOiAoKSA9PiB0aGlzLnByb3BzLmxvY2F0aW9uSGlzdG9yeS5jYW5Hb0JhY2soKSxcbiAgICAgICAgICAgIG5hdGl2ZUJhY2s6ICgpID0+IHRoaXMucHJvcHMub25OYXRpdmVCYWNrKCksXG4gICAgICAgICAgICByb3V0ZUluZm86IHRoaXMucHJvcHMucm91dGVJbmZvLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZ29CYWNrOiB0aGlzLmdvQmFjay5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaGFzSW9uaWNSb3V0ZXI6ICgpID0+IHRydWUsXG4gICAgICAgICAgICBuYXZpZ2F0ZTogdGhpcy5uYXZpZ2F0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0SW9uUmVkaXJlY3Q6IHRoaXMuZ2V0SW9uUmVkaXJlY3QuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldElvblJvdXRlOiB0aGlzLmdldElvblJvdXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRTdGFja01hbmFnZXI6IHRoaXMuZ2V0U3RhY2tNYW5hZ2VyLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRQYWdlTWFuYWdlcjogdGhpcy5nZXRQYWdlTWFuYWdlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyxcbiAgICAgICAgICAgIHNldEN1cnJlbnRUYWI6IHRoaXMucHJvcHMub25TZXRDdXJyZW50VGFiLFxuICAgICAgICAgICAgY2hhbmdlVGFiOiB0aGlzLnByb3BzLm9uQ2hhbmdlVGFiLFxuICAgICAgICAgICAgcmVzZXRUYWI6IHRoaXMucHJvcHMub25SZXNldFRhYixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGFyZHdhcmVCYWNrQnV0dG9uID0gdGhpcy5oYW5kbGVIYXJkd2FyZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbkJhY2tCdXR0b24nLCB0aGlzLmhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uQmFja0J1dHRvbicsIHRoaXMuaGFuZGxlSGFyZHdhcmVCYWNrQnV0dG9uKTtcbiAgICAgICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUhhcmR3YXJlQmFja0J1dHRvbihlKSB7XG4gICAgICAgIGUuZGV0YWlsLnJlZ2lzdGVyKDAsIChwcm9jZXNzTmV4dEhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZUdvQmFjaygpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0SGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ29CYWNrKHJvdXRlLCBhbmltYXRpb25CdWlsZGVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25OYXZpZ2F0ZUJhY2socm91dGUsIGFuaW1hdGlvbkJ1aWxkZXIpO1xuICAgIH1cbiAgICBuYXRpdmVHb0JhY2soKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25OYXRpdmVCYWNrKCk7XG4gICAgfVxuICAgIG5hdmlnYXRlKHBhdGgsIGRpcmVjdGlvbiA9ICdmb3J3YXJkJywgYWN0aW9uID0gJ3B1c2gnLCBhbmltYXRpb25CdWlsZGVyLCBvcHRpb25zLCB0YWIpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk5hdmlnYXRlKHBhdGgsIGFjdGlvbiwgZGlyZWN0aW9uLCBhbmltYXRpb25CdWlsZGVyLCBvcHRpb25zLCB0YWIpO1xuICAgIH1cbiAgICBnZXRQYWdlTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIFBhZ2VNYW5hZ2VyO1xuICAgIH1cbiAgICBnZXRJb25SZWRpcmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW9uUmVkaXJlY3Q7XG4gICAgfVxuICAgIGdldElvblJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5pb25Sb3V0ZTtcbiAgICB9XG4gICAgZ2V0U3RhY2tNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdGFja01hbmFnZXI7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE5hdkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHsgcm91dGVJbmZvOiB0aGlzLnByb3BzLnJvdXRlSW5mbyB9KSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJb25Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW9uUm91dGVyQ29udGV4dFZhbHVlKSwgeyByb3V0ZUluZm86IHRoaXMucHJvcHMucm91dGVJbmZvIH0pIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pKSk7XG4gICAgfVxufVxuXG5jbGFzcyBWaWV3U3RhY2tzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aWV3U3RhY2tzID0ge307XG4gICAgICAgIHRoaXMuYWRkID0gdGhpcy5hZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbGVhciA9IHRoaXMuY2xlYXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRWaWV3SXRlbXNGb3JPdXRsZXQgPSB0aGlzLmdldFZpZXdJdGVtc0Zvck91dGxldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZSA9IHRoaXMucmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGFkZCh2aWV3SXRlbSkge1xuICAgICAgICBjb25zdCB7IG91dGxldElkIH0gPSB2aWV3SXRlbTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdID0gW3ZpZXdJdGVtXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YWNrc1tvdXRsZXRJZF0ucHVzaCh2aWV3SXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIob3V0bGV0SWQpIHtcbiAgICAgICAgLy8gR2l2ZSBzb21lIHRpbWUgZm9yIHRoZSBsZWF2aW5nIHZpZXdzIHRvIHRyYW5zaXRpb24gYmVmb3JlIHJlbW92aW5nXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JlbW92aW5nIHZpZXdzdGFjayBmb3Igb3V0bGV0SUQgJyArIG91dGxldElkKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICBnZXRWaWV3SXRlbXNGb3JPdXRsZXQob3V0bGV0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YWNrc1tvdXRsZXRJZF0gfHwgW107XG4gICAgfVxuICAgIHJlbW92ZSh2aWV3SXRlbSkge1xuICAgICAgICBjb25zdCB7IG91dGxldElkIH0gPSB2aWV3SXRlbTtcbiAgICAgICAgY29uc3Qgdmlld1N0YWNrID0gdGhpcy52aWV3U3RhY2tzW291dGxldElkXTtcbiAgICAgICAgaWYgKHZpZXdTdGFjaykge1xuICAgICAgICAgICAgY29uc3Qgdmlld0l0ZW1Ub1JlbW92ZSA9IHZpZXdTdGFjay5maW5kKCh4KSA9PiB4LmlkID09PSB2aWV3SXRlbS5pZCk7XG4gICAgICAgICAgICBpZiAodmlld0l0ZW1Ub1JlbW92ZSkge1xuICAgICAgICAgICAgICAgIHZpZXdJdGVtVG9SZW1vdmUubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGFja3Nbb3V0bGV0SWRdID0gdmlld1N0YWNrLmZpbHRlcigoeCkgPT4geC5pZCAhPT0gdmlld0l0ZW1Ub1JlbW92ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3RhY2tJZHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZpZXdTdGFja3MpO1xuICAgIH1cbiAgICBnZXRBbGxWaWV3SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmdldFN0YWNrSWRzKCk7XG4gICAgICAgIGNvbnN0IHZpZXdJdGVtcyA9IFtdO1xuICAgICAgICBrZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHZpZXdJdGVtcy5wdXNoKC4uLnRoaXMudmlld1N0YWNrc1trXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmlld0l0ZW1zO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ3JlYXRlQW5pbWF0aW9uLCBEZWZhdWx0SW9uTGlmZUN5Y2xlQ29udGV4dCwgSW9uQWNjb3JkaW9uLCBJb25BY2NvcmRpb25Hcm91cCwgSW9uQWN0aW9uU2hlZXQsIElvbkFsZXJ0LCBJb25BcHAsIElvbkF2YXRhciwgSW9uQmFja0J1dHRvbiwgSW9uQmFja2Ryb3AsIElvbkJhZGdlLCBJb25CcmVhZGNydW1iLCBJb25CcmVhZGNydW1icywgSW9uQnV0dG9uLCBJb25CdXR0b25zLCBJb25DYXJkLCBJb25DYXJkQ29udGVudCwgSW9uQ2FyZEhlYWRlciwgSW9uQ2FyZFN1YnRpdGxlLCBJb25DYXJkVGl0bGUsIElvbkNoZWNrYm94LCBJb25DaGlwLCBJb25Db2wsIElvbkNvbnRlbnQsIElvbkRhdGV0aW1lLCBJb25GYWIsIElvbkZhYkJ1dHRvbiwgSW9uRmFiTGlzdCwgSW9uRm9vdGVyLCBJb25HcmlkLCBJb25IZWFkZXIsIElvbkljb24sIElvbkltZywgSW9uSW5maW5pdGVTY3JvbGwsIElvbkluZmluaXRlU2Nyb2xsQ29udGVudCwgSW9uSW5wdXQsIElvbkl0ZW0sIElvbkl0ZW1EaXZpZGVyLCBJb25JdGVtR3JvdXAsIElvbkl0ZW1PcHRpb24sIElvbkl0ZW1PcHRpb25zLCBJb25JdGVtU2xpZGluZywgSW9uTGFiZWwsIElvbkxpZmVDeWNsZUNvbnRleHQsIElvbkxpc3QsIElvbkxpc3RIZWFkZXIsIElvbkxvYWRpbmcsIElvbk1lbnUsIElvbk1lbnVCdXR0b24sIElvbk1lbnVUb2dnbGUsIElvbk1vZGFsLCBJb25OYXYsIElvbk5hdkxpbmssIElvbk5vdGUsIElvblBhZ2UsIElvblBpY2tlciwgSW9uUG9wb3ZlciwgSW9uUHJvZ3Jlc3NCYXIsIElvblJhZGlvLCBJb25SYWRpb0dyb3VwLCBJb25SYW5nZSwgSW9uUmVkaXJlY3QsIElvblJlZnJlc2hlciwgSW9uUmVmcmVzaGVyQ29udGVudCwgSW9uUmVvcmRlciwgSW9uUmVvcmRlckdyb3VwLCBJb25SaXBwbGVFZmZlY3QsIElvblJvdXRlLCBJb25Sb3V0ZXJDb250ZXh0LCBJb25Sb3V0ZXJMaW5rLCBJb25Sb3V0ZXJPdXRsZXQsIElvblJvdywgSW9uU2VhcmNoYmFyLCBJb25TZWdtZW50LCBJb25TZWdtZW50QnV0dG9uLCBJb25TZWxlY3QsIElvblNlbGVjdE9wdGlvbiwgSW9uU2tlbGV0b25UZXh0LCBJb25TbGlkZSwgSW9uU2xpZGVzLCBJb25TcGlubmVyLCBJb25TcGxpdFBhbmUsIElvblRhYiwgSW9uVGFiQmFyLCBJb25UYWJCdXR0b24sIElvblRhYnMsIElvblRhYnNDb250ZXh0LCBJb25UZXh0LCBJb25UZXh0YXJlYSwgSW9uVGh1bWJuYWlsLCBJb25UaXRsZSwgSW9uVG9hc3QsIElvblRvZ2dsZSwgSW9uVG9vbGJhciwgSW9uVmlydHVhbFNjcm9sbCwgTG9jYXRpb25IaXN0b3J5LCBOYXZDb250ZXh0LCBOYXZNYW5hZ2VyLCBSb3V0ZU1hbmFnZXJDb250ZXh0LCBTdGFja0NvbnRleHQsIFZpZXdMaWZlQ3ljbGVNYW5hZ2VyLCBWaWV3U3RhY2tzLCBnZW5lcmF0ZUlkLCBnZXRDb25maWcsIGdldFBsYXRmb3JtcywgaXNQbGF0Zm9ybSwgc2V0dXBJb25pY1JlYWN0LCB1c2VJb25BY3Rpb25TaGVldCwgdXNlSW9uQWxlcnQsIHVzZUlvbkxvYWRpbmcsIHVzZUlvbk1vZGFsLCB1c2VJb25QaWNrZXIsIHVzZUlvblBvcG92ZXIsIHVzZUlvblJvdXRlciwgdXNlSW9uVG9hc3QsIHVzZUlvblZpZXdEaWRFbnRlciwgdXNlSW9uVmlld0RpZExlYXZlLCB1c2VJb25WaWV3V2lsbEVudGVyLCB1c2VJb25WaWV3V2lsbExlYXZlLCB3aXRoSW9uTGlmZUN5Y2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5087\n")},8463:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6010);\n/* harmony import */ var _Paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9895);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4670);\n\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    overflow: \'hidden\'\n  }\n};\nvar Card = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Card(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$raised = props.raised,\n      raised = _props$raised === void 0 ? false : _props$raised,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["classes", "className", "raised"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Paper__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(classes.root, className),\n    elevation: raised ? 8 : 1,\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCard\'\n})(Card));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ2My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQ2dDO0FBQzNEO0FBQ0k7QUFDWDtBQUNLO0FBQ2lCO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVHQUF3Qjs7QUFFdEMsc0JBQXNCLGdEQUFtQixDQUFDLHVEQUFLLEVBQUUsdUZBQVE7QUFDekQsZUFBZSx5REFBSTtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxNQUFxQyxHQUFHLENBMEJ2QyxDQUFDO0FBQ0YsaUVBQWUsdUVBQVU7QUFDekI7QUFDQSxDQUFDLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9DYXJkL0NhcmQuanM/ZGY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgUGFwZXIgZnJvbSAnLi4vUGFwZXInO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgfVxufTtcbnZhciBDYXJkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FyZChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRyYWlzZWQgPSBwcm9wcy5yYWlzZWQsXG4gICAgICByYWlzZWQgPSBfcHJvcHMkcmFpc2VkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRyYWlzZWQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcInJhaXNlZFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhcGVyLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICBlbGV2YXRpb246IHJhaXNlZCA/IDggOiAxLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNhcmQgd2lsbCB1c2UgcmFpc2VkIHN0eWxpbmcuXG4gICAqL1xuICByYWlzZWQ6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUNhcmQnXG59KShDYXJkKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8463\n')},1907:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4670);\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: \'flex\',\n    alignItems: \'center\',\n    padding: 8\n  },\n\n  /* Styles applied to the root element if `disableSpacing={false}`. */\n  spacing: {\n    \'& > :not(:first-child)\': {\n      marginLeft: 8\n    }\n  }\n};\nvar CardActions = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardActions(props, ref) {\n  var _props$disableSpacing = props.disableSpacing,\n      disableSpacing = _props$disableSpacing === void 0 ? false : _props$disableSpacing,\n      classes = props.classes,\n      className = props.className,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["disableSpacing", "classes", "className"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className, !disableSpacing && classes.spacing),\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardActions\'\n})(CardActions));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDZ0M7QUFDM0Q7QUFDSTtBQUNYO0FBQ3NCO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUdBQXdCOztBQUV0QyxzQkFBc0IsZ0RBQW1CLFFBQVEsdUZBQVE7QUFDekQsZUFBZSx5REFBSTtBQUNuQjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsTUFBcUMsR0FBRyxDQTBCdkMsQ0FBQztBQUNGLGlFQUFlLHVFQUFVO0FBQ3pCO0FBQ0EsQ0FBQyxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQ2FyZEFjdGlvbnMvQ2FyZEFjdGlvbnMuanM/YTM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBwYWRkaW5nOiA4XG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZVNwYWNpbmc9e2ZhbHNlfWAuICovXG4gIHNwYWNpbmc6IHtcbiAgICAnJiA+IDpub3QoOmZpcnN0LWNoaWxkKSc6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDhcbiAgICB9XG4gIH1cbn07XG52YXIgQ2FyZEFjdGlvbnMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYXJkQWN0aW9ucyhwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkZGlzYWJsZVNwYWNpbmcgPSBwcm9wcy5kaXNhYmxlU3BhY2luZyxcbiAgICAgIGRpc2FibGVTcGFjaW5nID0gX3Byb3BzJGRpc2FibGVTcGFjaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlU3BhY2luZyxcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImRpc2FibGVTcGFjaW5nXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsICFkaXNhYmxlU3BhY2luZyAmJiBjbGFzc2VzLnNwYWNpbmcpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRBY3Rpb25zLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBhY3Rpb25zIGRvIG5vdCBoYXZlIGFkZGl0aW9uYWwgbWFyZ2luLlxuICAgKi9cbiAgZGlzYWJsZVNwYWNpbmc6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUNhcmRBY3Rpb25zJ1xufSkoQ2FyZEFjdGlvbnMpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1907\n')},9912:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4670);\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 16,\n    \'&:last-child\': {\n      paddingBottom: 24\n    }\n  }\n};\nvar CardContent = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardContent(props, ref) {\n  var classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? \'div\' : _props$component,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["classes", "className", "component"]);\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className),\n    ref: ref\n  }, other));\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardContent\'\n})(CardContent));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDZ0M7QUFDM0Q7QUFDSTtBQUNYO0FBQ3NCO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVHQUF3Qjs7QUFFdEMsc0JBQXNCLGdEQUFtQixZQUFZLHVGQUFRO0FBQzdELGVBQWUseURBQUk7QUFDbkI7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELE1BQXFDLEdBQUcsQ0E2QnZDLENBQUM7QUFDRixpRUFBZSx1RUFBVTtBQUN6QjtBQUNBLENBQUMsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRDb250ZW50L0NhcmRDb250ZW50LmpzP2ExYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBwYWRkaW5nOiAxNixcbiAgICAnJjpsYXN0LWNoaWxkJzoge1xuICAgICAgcGFkZGluZ0JvdHRvbTogMjRcbiAgICB9XG4gIH1cbn07XG52YXIgQ2FyZENvbnRlbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYXJkQ29udGVudChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnZGl2JyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbXBvbmVudFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQ2FyZENvbnRlbnQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUNhcmRDb250ZW50J1xufSkoQ2FyZENvbnRlbnQpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9912\n')},951:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export styles */\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7462);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5987);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6010);\n/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4670);\n\n\n\n\n\n\n\nvar styles = {\n  /* Styles applied to the root element. */\n  root: {\n    display: \'block\',\n    backgroundSize: \'cover\',\n    backgroundRepeat: \'no-repeat\',\n    backgroundPosition: \'center\'\n  },\n\n  /* Styles applied to the root element if `component="video, audio, picture, iframe, or img"`. */\n  media: {\n    width: \'100%\'\n  },\n\n  /* Styles applied to the root element if `component="picture or img"`. */\n  img: {\n    //  object-fit is not supported by IE 11.\n    objectFit: \'cover\'\n  }\n};\nvar MEDIA_COMPONENTS = [\'video\', \'audio\', \'picture\', \'iframe\', \'img\'];\nvar CardMedia = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CardMedia(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? \'div\' : _props$component,\n      image = props.image,\n      src = props.src,\n      style = props.style,\n      other = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(props, ["children", "classes", "className", "component", "image", "src", "style"]);\n\n  var isMediaComponent = MEDIA_COMPONENTS.indexOf(Component) !== -1;\n  var composedStyle = !isMediaComponent && image ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    backgroundImage: "url(\\"".concat(image, "\\")")\n  }, style) : style;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(classes.root, className, isMediaComponent && classes.media, "picture img".indexOf(Component) !== -1 && classes.img),\n    ref: ref,\n    style: composedStyle,\n    src: isMediaComponent ? image || src : undefined\n  }, other), children);\n});\n false ? 0 : void 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_styles_withStyles__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(styles, {\n  name: \'MuiCardMedia\'\n})(CardMedia));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNnQztBQUMzRDtBQUNJO0FBQ1g7QUFDc0I7QUFDTTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUdBQXdCOztBQUV0QztBQUNBLG1EQUFtRCx1RkFBUTtBQUMzRDtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLFlBQVksdUZBQVE7QUFDN0QsZUFBZSx5REFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELE1BQXFDLEdBQUcsQ0FzRHZDLENBQUM7QUFDRixpRUFBZSx1RUFBVTtBQUN6QjtBQUNBLENBQUMsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NhcmRNZWRpYS9DYXJkTWVkaWEuanM/MjFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgYmFja2dyb3VuZFNpemU6ICdjb3ZlcicsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCcsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbXBvbmVudD1cInZpZGVvLCBhdWRpbywgcGljdHVyZSwgaWZyYW1lLCBvciBpbWdcImAuICovXG4gIG1lZGlhOiB7XG4gICAgd2lkdGg6ICcxMDAlJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbXBvbmVudD1cInBpY3R1cmUgb3IgaW1nXCJgLiAqL1xuICBpbWc6IHtcbiAgICAvLyDimqDvuI8gb2JqZWN0LWZpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFIDExLlxuICAgIG9iamVjdEZpdDogJ2NvdmVyJ1xuICB9XG59O1xudmFyIE1FRElBX0NPTVBPTkVOVFMgPSBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3BpY3R1cmUnLCAnaWZyYW1lJywgJ2ltZyddO1xudmFyIENhcmRNZWRpYSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhcmRNZWRpYShwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgaW1hZ2UgPSBwcm9wcy5pbWFnZSxcbiAgICAgIHNyYyA9IHByb3BzLnNyYyxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiaW1hZ2VcIiwgXCJzcmNcIiwgXCJzdHlsZVwiXSk7XG5cbiAgdmFyIGlzTWVkaWFDb21wb25lbnQgPSBNRURJQV9DT01QT05FTlRTLmluZGV4T2YoQ29tcG9uZW50KSAhPT0gLTE7XG4gIHZhciBjb21wb3NlZFN0eWxlID0gIWlzTWVkaWFDb21wb25lbnQgJiYgaW1hZ2UgPyBfZXh0ZW5kcyh7XG4gICAgYmFja2dyb3VuZEltYWdlOiBcInVybChcXFwiXCIuY29uY2F0KGltYWdlLCBcIlxcXCIpXCIpXG4gIH0sIHN0eWxlKSA6IHN0eWxlO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBpc01lZGlhQ29tcG9uZW50ICYmIGNsYXNzZXMubWVkaWEsIFwicGljdHVyZSBpbWdcIi5pbmRleE9mKENvbXBvbmVudCkgIT09IC0xICYmIGNsYXNzZXMuaW1nKSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogY29tcG9zZWRTdHlsZSxcbiAgICBzcmM6IGlzTWVkaWFDb21wb25lbnQgPyBpbWFnZSB8fCBzcmMgOiB1bmRlZmluZWRcbiAgfSwgb3RoZXIpLCBjaGlsZHJlbik7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENhcmRNZWRpYS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5ub2RlLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmNoaWxkcmVuICYmICFwcm9wcy5pbWFnZSAmJiAhcHJvcHMuc3JjICYmICFwcm9wcy5jb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01hdGVyaWFsLVVJOiBFaXRoZXIgYGNoaWxkcmVuYCwgYGltYWdlYCwgYHNyY2Agb3IgYGNvbXBvbmVudGAgcHJvcCBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSW1hZ2UgdG8gYmUgZGlzcGxheWVkIGFzIGEgYmFja2dyb3VuZCBpbWFnZS5cbiAgICogRWl0aGVyIGBpbWFnZWAgb3IgYHNyY2AgcHJvcCBtdXN0IGJlIHNwZWNpZmllZC5cbiAgICogTm90ZSB0aGF0IGNhbGxlciBtdXN0IHNwZWNpZnkgaGVpZ2h0IG90aGVyd2lzZSB0aGUgaW1hZ2Ugd2lsbCBub3QgYmUgdmlzaWJsZS5cbiAgICovXG4gIGltYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgYGltYWdlYCBwcm9wZXJ0eS5cbiAgICogQXZhaWxhYmxlIG9ubHkgd2l0aCBtZWRpYSBjb21wb25lbnRzLlxuICAgKiBNZWRpYSBjb21wb25lbnRzOiBgdmlkZW9gLCBgYXVkaW9gLCBgcGljdHVyZWAsIGBpZnJhbWVgLCBgaW1nYC5cbiAgICovXG4gIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2FyZE1lZGlhJ1xufSkoQ2FyZE1lZGlhKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///951\n')},9460:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n\nvar _interopRequireDefault = __webpack_require__(5318);\n\nvar _interopRequireWildcard = __webpack_require__(862);\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports.Z = void 0;\n\nvar React = _interopRequireWildcard(__webpack_require__(7294));\n\nvar _createSvgIcon = _interopRequireDefault(__webpack_require__(2108));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement("path", {\n  d: "M17.5 4.5c-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .65.73.45.75.45C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.41.21.75-.19.75-.45V6c-1.49-1.12-3.63-1.5-5.5-1.5zm3.5 14c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5v11.5z"\n}), \'ImportContacts\');\n\nexports.Z = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ2MC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsSUFBOEM7O0FBRW5GLDhCQUE4QixtQkFBTyxDQUFDLEdBQStDOztBQUVyRiw2QkFBNkM7QUFDN0M7QUFDQSxDQUFDLENBQUM7QUFDRixTQUFlOztBQUVmLG9DQUFvQyxtQkFBTyxDQUFDLElBQU87O0FBRW5ELDRDQUE0QyxtQkFBTyxDQUFDLElBQXVCOztBQUUzRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxTQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvaWNvbnMvSW1wb3J0Q29udGFjdHMuanM/NzAzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfY3JlYXRlU3ZnSWNvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvY3JlYXRlU3ZnSWNvblwiKSk7XG5cbnZhciBfZGVmYXVsdCA9ICgwLCBfY3JlYXRlU3ZnSWNvbi5kZWZhdWx0KSggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNMTcuNSA0LjVjLTEuOTUgMC00LjA1LjQtNS41IDEuNS0xLjQ1LTEuMS0zLjU1LTEuNS01LjUtMS41UzIuNDUgNC45IDEgNnYxNC42NWMwIC42NS43My40NS43NS40NUMzLjEgMjAuNDUgNS4wNSAyMCA2LjUgMjBjMS45NSAwIDQuMDUuNCA1LjUgMS41IDEuMzUtLjg1IDMuOC0xLjUgNS41LTEuNSAxLjY1IDAgMy4zNS4zIDQuNzUgMS4wNS40MS4yMS43NS0uMTkuNzUtLjQ1VjZjLTEuNDktMS4xMi0zLjYzLTEuNS01LjUtMS41em0zLjUgMTRjLTEuMS0uMzUtMi4zLS41LTMuNS0uNS0xLjcgMC00LjE1LjY1LTUuNSAxLjVWOGMxLjM1LS44NSAzLjgtMS41IDUuNS0xLjUgMS4yIDAgMi40LjE1IDMuNS41djExLjV6XCJcbn0pLCAnSW1wb3J0Q29udGFjdHMnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9460\n')},6990:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n\nvar _interopRequireDefault = __webpack_require__(5318);\n\nvar _interopRequireWildcard = __webpack_require__(862);\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports.Z = void 0;\n\nvar React = _interopRequireWildcard(__webpack_require__(7294));\n\nvar _createSvgIcon = _interopRequireDefault(__webpack_require__(2108));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement("path", {\n  d: "M7.58 4.08L6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z"\n}), \'NotificationsActive\');\n\nexports.Z = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk5MC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsSUFBOEM7O0FBRW5GLDhCQUE4QixtQkFBTyxDQUFDLEdBQStDOztBQUVyRiw2QkFBNkM7QUFDN0M7QUFDQSxDQUFDLENBQUM7QUFDRixTQUFlOztBQUVmLG9DQUFvQyxtQkFBTyxDQUFDLElBQU87O0FBRW5ELDRDQUE0QyxtQkFBTyxDQUFDLElBQXVCOztBQUUzRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxTQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvaWNvbnMvTm90aWZpY2F0aW9uc0FjdGl2ZS5qcz9kZGJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9jcmVhdGVTdmdJY29uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9jcmVhdGVTdmdJY29uXCIpKTtcblxudmFyIF9kZWZhdWx0ID0gKDAsIF9jcmVhdGVTdmdJY29uLmRlZmF1bHQpKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk03LjU4IDQuMDhMNi4xNSAyLjY1QzMuNzUgNC40OCAyLjE3IDcuMyAyLjAzIDEwLjVoMmMuMTUtMi42NSAxLjUxLTQuOTcgMy41NS02LjQyem0xMi4zOSA2LjQyaDJjLS4xNS0zLjItMS43My02LjAyLTQuMTItNy44NWwtMS40MiAxLjQzYzIuMDIgMS40NSAzLjM5IDMuNzcgMy41NCA2LjQyek0xOCAxMWMwLTMuMDctMS42NC01LjY0LTQuNS02LjMyVjRjMC0uODMtLjY3LTEuNS0xLjUtMS41cy0xLjUuNjctMS41IDEuNXYuNjhDNy42MyA1LjM2IDYgNy45MiA2IDExdjVsLTIgMnYxaDE2di0xbC0yLTJ2LTV6bS02IDExYy4xNCAwIC4yNy0uMDEuNC0uMDQuNjUtLjE0IDEuMTgtLjU4IDEuNDQtMS4xOC4xLS4yNC4xNS0uNS4xNS0uNzhoLTRjLjAxIDEuMS45IDIgMi4wMSAyelwiXG59KSwgJ05vdGlmaWNhdGlvbnNBY3RpdmUnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6990\n')},7210:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z5\": () => (/* binding */ Build),\n  \"mv\": () => (/* binding */ H),\n  \"AA\": () => (/* binding */ Host),\n  \"yM\": () => (/* binding */ createEvent),\n  \"iJ\": () => (/* binding */ getMode),\n  \"h\": () => (/* binding */ h),\n  \"GH\": () => (/* binding */ proxyCustomElement),\n  \"wj\": () => (/* binding */ readTask),\n  \"Iu\": () => (/* binding */ writeTask)\n});\n\n// UNUSED EXPORTS: BUILD, CSS, Context, Env, Fragment, H, NAMESPACE, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getRenderingRef, getValue, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructibleStylesheets, supportsListenerOptions, supportsShadow, win\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/app-data/index.js\nconst app_data_BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@stencil/core/internal/client/index.js\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.14.1 | MIT Licensed | https://stenciljs.com\n */\n\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = app_data_BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = app_data_BUILD.shadowDomShim && app_data_BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructibleStylesheets = app_data_BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replace === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst Context = {};\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (app_data_BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = app_data_BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (app_data_BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (app_data_BUILD.hostListenerTargetDocument && flags & 4 /* TargetDocument */)\n        return doc;\n    if (app_data_BUILD.hostListenerTargetWindow && flags & 8 /* TargetWindow */)\n        return win;\n    if (app_data_BUILD.hostListenerTargetBody && flags & 16 /* TargetBody */)\n        return doc.body;\n    if (app_data_BUILD.hostListenerTargetParent && flags & 32 /* TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* Passive */) !== 0,\n        capture: (flags & 2 /* Capture */) !== 0,\n    })\n    : (flags & 2 /* Capture */) !== 0;\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst createTime = (fnName, tagName = '') => {\n    if (app_data_BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (app_data_BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* hasRendered */),\n            hasConnected: !!(flags & 1 /* hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* isWatchReady */),\n            isListenReady: !!(flags & 256 /* isListenReady */),\n            needsRerender: !!(flags & 512 /* needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst rootAppliedStyles = new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructibleStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        style.replace(cssText);\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    let style = styles.get(scopeId);\n    if (!app_data_BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (app_data_BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (app_data_BUILD.hydrateServerSide || app_data_BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (app_data_BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(app_data_BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && app_data_BUILD.cssAnnotations && flags & 10 /* needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (app_data_BUILD.scoped && flags & 2 /* scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (app_data_BUILD.mode && mode && cmp.$flags$ & 32 /* hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    let vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (app_data_BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (app_data_BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (app_data_BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (app_data_BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (app_data_BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (app_data_BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (app_data_BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (app_data_BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (app_data_BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (app_data_BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (app_data_BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (app_data_BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (app_data_BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!app_data_BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (app_data_BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (app_data_BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (app_data_BUILD.vdomListener &&\n            (app_data_BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (app_data_BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        let n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (app_data_BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (app_data_BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (app_data_BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (app_data_BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    let newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (app_data_BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* isSlotReference */;\n        }\n    }\n    if (app_data_BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (app_data_BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (app_data_BUILD.slotRelocation && newVNode.$flags$ & 1 /* isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (app_data_BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (app_data_BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(app_data_BUILD.slotRelocation && newVNode.$flags$ & 2 /* isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (app_data_BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (app_data_BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((app_data_BUILD.shadowDom || app_data_BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (app_data_BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (app_data_BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((app_data_BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (app_data_BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, app_data_BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (app_data_BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // Vnode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            if (app_data_BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // createKeyToOldIdx\n            idxInOld = -1;\n            if (app_data_BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (app_data_BUILD.vdomKey && idxInOld >= 0) {\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // new element\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                if (app_data_BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (app_data_BUILD.updatable && newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\nconst isSameVnode = (vnode1, vnode2) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (vnode1.$tag$ === vnode2.$tag$) {\n        if (app_data_BUILD.slotRelocation && vnode1.$tag$ === 'slot') {\n            return vnode1.$name$ === vnode2.$name$;\n        }\n        if (app_data_BUILD.vdomKey) {\n            return vnode1.$key$ === vnode2.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!app_data_BUILD.vdomText || text === null) {\n        if (app_data_BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        // element node\n        if (app_data_BUILD.vdomAttribute || app_data_BUILD.reflect) {\n            if (app_data_BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (app_data_BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (app_data_BUILD.updatable && app_data_BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (app_data_BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (app_data_BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (app_data_BUILD.vdomText && app_data_BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (app_data_BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* ElementNode */ ||\n                            (nodeType === 3 /* TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    let childNodes = elm.childNodes;\n    let ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (app_data_BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (app_data_BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (app_data_BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (app_data_BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (app_data_BUILD.scoped || app_data_BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (app_data_BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (app_data_BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        app_data_BUILD.isDebug || app_data_BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst getElement = (ref) => (app_data_BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (app_data_BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* Bubbles */),\n                composed: !!(flags & 2 /* Composed */),\n                cancelable: !!(flags & 1 /* Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (app_data_BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (app_data_BUILD.taskQueue && app_data_BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n    }\n    if (app_data_BUILD.asyncLoading && hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return app_data_BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (app_data_BUILD.cmpWillLoad) {\n            promise = safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (app_data_BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (app_data_BUILD.cmpWillRender) {\n        promise = then(promise, () => safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (app_data_BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (app_data_BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* devOnRender */;\n    }\n    if (app_data_BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (app_data_BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (app_data_BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = app_data_BUILD.allRenderFn ? true : false;\n    const lazyLoad = app_data_BUILD.lazyLoad ? true : false;\n    const taskQueue = app_data_BUILD.taskQueue ? true : false;\n    const updatable = app_data_BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* hasRendered */;\n        }\n        if (app_data_BUILD.hasRenderFn || app_data_BUILD.reflect) {\n            if (app_data_BUILD.vdomRender || app_data_BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (app_data_BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (app_data_BUILD.cmpDidRender) {\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* devOnRender */;\n        }\n        safeCall(instance, 'componentDidRender');\n        if (app_data_BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n        if (app_data_BUILD.asyncLoading && app_data_BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (app_data_BUILD.cmpDidLoad) {\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* devOnDidLoad */;\n            }\n            safeCall(instance, 'componentDidLoad');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (app_data_BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (app_data_BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* devOnRender */;\n            }\n            safeCall(instance, 'componentDidUpdate');\n            if (app_data_BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (app_data_BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (app_data_BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);\n    }\n    // ( _)\n    // ( _)>-\n    // (_)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (app_data_BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (app_data_BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (app_data_BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (app_data_BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => app_data_BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : app_data_BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = app_data_BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (app_data_BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (app_data_BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (app_data_BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (app_data_BUILD.propBoolean && propType & 4 /* Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (app_data_BUILD.propNumber && propType & 2 /* Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (app_data_BUILD.propString && propType & 1 /* String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = app_data_BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n    const didValueChange = newVal !== oldVal && !areBothNaN;\n    if ((!app_data_BUILD.lazyLoad || !(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (app_data_BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!app_data_BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (app_data_BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (app_data_BUILD.updatable &&\n                (flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n                if (app_data_BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (app_data_BUILD.member && cmpMeta.$members$) {\n        if (app_data_BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((app_data_BUILD.prop || app_data_BUILD.state) &&\n                (memberFlags & 31 /* Prop */ ||\n                    ((!app_data_BUILD.lazyLoad || flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (app_data_BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (app_data_BUILD.lazyLoad &&\n                app_data_BUILD.method &&\n                flags & 1 /* isElementConstructor */ &&\n                memberFlags & 64 /* Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (app_data_BUILD.observeAttribute && (!app_data_BUILD.lazyLoad || flags & 1 /* isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    \x3c!-- this component has _not_ been upgraded yet --\x3e\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    <\/script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (app_data_BUILD.reflect && m[0] & 512 /* ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((app_data_BUILD.lazyLoad || app_data_BUILD.hydrateServerSide || app_data_BUILD.style) &&\n        (hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n        if (app_data_BUILD.lazyLoad || app_data_BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((app_data_BUILD.isDev || app_data_BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (app_data_BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (app_data_BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ |= 8 /* isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (app_data_BUILD.member) {\n                hostRef.$flags$ &= ~8 /* isConstructingInstance */;\n            }\n            if (app_data_BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* isWatchReady */));\n        }\n        if (app_data_BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (app_data_BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (app_data_BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!app_data_BUILD.hydrateServerSide &&\n                    app_data_BUILD.shadowDom &&\n                    app_data_BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n                    style = await __webpack_require__.e(/* import() */ 576).then(__webpack_require__.bind(__webpack_require__, 576)).then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (app_data_BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (app_data_BUILD.lazyLoad && app_data_BUILD.connectedCallback) {\n        safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (app_data_BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* hasConnected */;\n            let hostId;\n            if (app_data_BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (app_data_BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        const scopeId = app_data_BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (app_data_BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (app_data_BUILD.hydrateServerSide ||\n                    ((app_data_BUILD.slot || app_data_BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (app_data_BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((app_data_BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (app_data_BUILD.prop && !app_data_BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (app_data_BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(app_data_BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = app_data_BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (app_data_BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (app_data_BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (app_data_BUILD.lazyLoad && app_data_BUILD.disconnectedCallback) {\n            safeCall(instance, 'disconnectedCallback');\n        }\n        if (app_data_BUILD.cmpDidUnload) {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (app_data_BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (app_data_BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (app_data_BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (app_data_BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (app_data_BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (app_data_BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (app_data_BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (app_data_BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* isElementConstructor */ | 2 /* proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // \\_()_/\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            let stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            if (BUILD.shadowDelegatesFocus) {\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* shadowDelegatesFocus */),\n                                });\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst Fragment = (_, children) => children;\nconst hostRefs = new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (app_data_BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (app_data_BUILD.method && app_data_BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (app_data_BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = app_data_BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (app_data_BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !app_data_BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    return __webpack_require__(1993)(`./${bundleId}.entry.js${app_data_BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!app_data_BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = new Map();\nconst modeResolutionChain = [];\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (app_data_BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (app_data_BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* queueMask */) === 2 /* appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nconst Build = {\n    isDev: app_data_BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: app_data_BUILD.isTesting ? true : false,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLEdBQUcsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLEdBQUcsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ZTtBQUM5QjtBQUN3RTtBQUM0dkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvYXBwLWRhdGEvaW5kZXguanM/YmE5NSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzPzMxMDUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQlVJTEQgPSB7XG4gICAgYWxsUmVuZGVyRm46IGZhbHNlLFxuICAgIGNtcERpZExvYWQ6IHRydWUsXG4gICAgY21wRGlkVW5sb2FkOiBmYWxzZSxcbiAgICBjbXBEaWRVcGRhdGU6IHRydWUsXG4gICAgY21wRGlkUmVuZGVyOiB0cnVlLFxuICAgIGNtcFdpbGxMb2FkOiB0cnVlLFxuICAgIGNtcFdpbGxVcGRhdGU6IHRydWUsXG4gICAgY21wV2lsbFJlbmRlcjogdHJ1ZSxcbiAgICBjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSxcbiAgICBlbGVtZW50OiB0cnVlLFxuICAgIGV2ZW50OiB0cnVlLFxuICAgIGhhc1JlbmRlckZuOiB0cnVlLFxuICAgIGxpZmVjeWNsZTogdHJ1ZSxcbiAgICBob3N0TGlzdGVuZXI6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50OiB0cnVlLFxuICAgIGhvc3RMaXN0ZW5lclRhcmdldEJvZHk6IHRydWUsXG4gICAgaG9zdExpc3RlbmVyVGFyZ2V0UGFyZW50OiBmYWxzZSxcbiAgICBob3N0TGlzdGVuZXJUYXJnZXQ6IHRydWUsXG4gICAgbWVtYmVyOiB0cnVlLFxuICAgIG1ldGhvZDogdHJ1ZSxcbiAgICBtb2RlOiB0cnVlLFxuICAgIG9ic2VydmVBdHRyaWJ1dGU6IHRydWUsXG4gICAgcHJvcDogdHJ1ZSxcbiAgICBwcm9wTXV0YWJsZTogdHJ1ZSxcbiAgICByZWZsZWN0OiB0cnVlLFxuICAgIHNjb3BlZDogdHJ1ZSxcbiAgICBzaGFkb3dEb206IHRydWUsXG4gICAgc2xvdDogdHJ1ZSxcbiAgICBjc3NBbm5vdGF0aW9uczogdHJ1ZSxcbiAgICBzdGF0ZTogdHJ1ZSxcbiAgICBzdHlsZTogdHJ1ZSxcbiAgICBzdmc6IHRydWUsXG4gICAgdXBkYXRhYmxlOiB0cnVlLFxuICAgIHZkb21BdHRyaWJ1dGU6IHRydWUsXG4gICAgdmRvbVhsaW5rOiB0cnVlLFxuICAgIHZkb21DbGFzczogdHJ1ZSxcbiAgICB2ZG9tRnVuY3Rpb25hbDogdHJ1ZSxcbiAgICB2ZG9tS2V5OiB0cnVlLFxuICAgIHZkb21MaXN0ZW5lcjogdHJ1ZSxcbiAgICB2ZG9tUmVmOiB0cnVlLFxuICAgIHZkb21Qcm9wT3JBdHRyOiB0cnVlLFxuICAgIHZkb21SZW5kZXI6IHRydWUsXG4gICAgdmRvbVN0eWxlOiB0cnVlLFxuICAgIHZkb21UZXh0OiB0cnVlLFxuICAgIHdhdGNoQ2FsbGJhY2s6IHRydWUsXG4gICAgdGFza1F1ZXVlOiB0cnVlLFxuICAgIGhvdE1vZHVsZVJlcGxhY2VtZW50OiBmYWxzZSxcbiAgICBpc0RlYnVnOiBmYWxzZSxcbiAgICBpc0RldjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBmYWxzZSxcbiAgICBoeWRyYXRlU2VydmVyU2lkZTogZmFsc2UsXG4gICAgaHlkcmF0ZUNsaWVudFNpZGU6IGZhbHNlLFxuICAgIGxpZmVjeWNsZURPTUV2ZW50czogZmFsc2UsXG4gICAgbGF6eUxvYWQ6IGZhbHNlLFxuICAgIHByb2ZpbGU6IGZhbHNlLFxuICAgIHNsb3RSZWxvY2F0aW9uOiB0cnVlLFxuICAgIGFwcGVuZENoaWxkU2xvdEZpeDogZmFsc2UsXG4gICAgY2xvbmVOb2RlRml4OiBmYWxzZSxcbiAgICBoeWRyYXRlZEF0dHJpYnV0ZTogZmFsc2UsXG4gICAgaHlkcmF0ZWRDbGFzczogdHJ1ZSxcbiAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgc2NyaXB0RGF0YU9wdHM6IGZhbHNlLFxuICAgIHNjb3BlZFNsb3RUZXh0Q29udGVudEZpeDogZmFsc2UsXG4gICAgc2hhZG93RG9tU2hpbTogZmFsc2UsXG4gICAgc2xvdENoaWxkTm9kZXNGaXg6IGZhbHNlLFxuICAgIGludmlzaWJsZVByZWh5ZHJhdGlvbjogdHJ1ZSxcbiAgICBwcm9wQm9vbGVhbjogdHJ1ZSxcbiAgICBwcm9wTnVtYmVyOiB0cnVlLFxuICAgIHByb3BTdHJpbmc6IHRydWUsXG4gICAgY3NzVmFyU2hpbTogZmFsc2UsXG4gICAgY29uc3RydWN0YWJsZUNTUzogdHJ1ZSxcbiAgICBjbXBTaG91bGRVcGRhdGU6IHRydWUsXG4gICAgZGV2VG9vbHM6IGZhbHNlLFxuICAgIGR5bmFtaWNJbXBvcnRTaGltOiBmYWxzZSxcbiAgICBzaGFkb3dEZWxlZ2F0ZXNGb2N1czogdHJ1ZSxcbiAgICBpbml0aWFsaXplTmV4dFRpY2s6IGZhbHNlLFxuICAgIGFzeW5jTG9hZGluZzogZmFsc2UsXG4gICAgYXN5bmNRdWV1ZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtVGFnTmFtZTogZmFsc2UsXG4gICAgYXR0YWNoU3R5bGVzOiB0cnVlLFxufTtcbmNvbnN0IEVudiA9IHt9O1xuY29uc3QgTkFNRVNQQUNFID0gLyogZGVmYXVsdCAqLyAnYXBwJztcblxuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH07XG4iLCJsZXQgc2NvcGVJZDtcbmxldCBjb250ZW50UmVmO1xubGV0IGhvc3RUYWdOYW1lO1xubGV0IGN1c3RvbUVycm9yO1xubGV0IGkgPSAwO1xubGV0IHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdEZhbGxiYWNrVmlzaWJpbGl0eSA9IGZhbHNlO1xubGV0IGNoZWNrU2xvdFJlbG9jYXRlID0gZmFsc2U7XG5sZXQgaXNTdmdNb2RlID0gZmFsc2U7XG5sZXQgcmVuZGVyaW5nUmVmID0gbnVsbDtcbmxldCBxdWV1ZUNvbmdlc3Rpb24gPSAwO1xubGV0IHF1ZXVlUGVuZGluZyA9IGZhbHNlO1xuLypcbiBTdGVuY2lsIENsaWVudCBQbGF0Zm9ybSB2Mi4xNC4xIHwgTUlUIExpY2Vuc2VkIHwgaHR0cHM6Ly9zdGVuY2lsanMuY29tXG4gKi9cbmltcG9ydCB7IEJVSUxELCBOQU1FU1BBQ0UgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2FwcC1kYXRhJztcbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG5jb25zdCBDU1MgPSBCVUlMRC5jc3NWYXJTaGltID8gd2luLkNTUyA6IG51bGw7XG5jb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQgfHwgeyBoZWFkOiB7fSB9O1xuY29uc3QgSCA9ICh3aW4uSFRNTEVsZW1lbnQgfHwgY2xhc3Mge1xufSk7XG5jb25zdCBwbHQgPSB7XG4gICAgJGZsYWdzJDogMCxcbiAgICAkcmVzb3VyY2VzVXJsJDogJycsXG4gICAgam1wOiAoaCkgPT4gaCgpLFxuICAgIHJhZjogKGgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShoKSxcbiAgICBhZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICByZWw6IChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cykgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSxcbiAgICBjZTogKGV2ZW50TmFtZSwgb3B0cykgPT4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgb3B0cyksXG59O1xuY29uc3Qgc2V0UGxhdGZvcm1IZWxwZXJzID0gKGhlbHBlcnMpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgaGVscGVycyk7XG59O1xuY29uc3Qgc3VwcG9ydHNTaGFkb3cgPSBCVUlMRC5zaGFkb3dEb21TaGltICYmIEJVSUxELnNoYWRvd0RvbVxuICAgID8gLypAX19QVVJFX18qLyAoKCkgPT4gKGRvYy5oZWFkLmF0dGFjaFNoYWRvdyArICcnKS5pbmRleE9mKCdbbmF0aXZlJykgPiAtMSkoKVxuICAgIDogdHJ1ZTtcbmNvbnN0IHN1cHBvcnRzTGlzdGVuZXJPcHRpb25zID0gLypAX19QVVJFX18qLyAoKCkgPT4ge1xuICAgIGxldCBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c0xpc3RlbmVyT3B0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnM7XG59KSgpO1xuY29uc3QgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xuY29uc3Qgc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgPSBCVUlMRC5jb25zdHJ1Y3RhYmxlQ1NTXG4gICAgPyAvKkBfX1BVUkVfXyovICgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBuZXcgQ1NTU3R5bGVTaGVldCgpLnJlcGxhY2UgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoKVxuICAgIDogZmFsc2U7XG5jb25zdCBDb250ZXh0ID0ge307XG5jb25zdCBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMgPSAoZWxtLCBob3N0UmVmLCBsaXN0ZW5lcnMsIGF0dGFjaFBhcmVudExpc3RlbmVycykgPT4ge1xuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIgJiYgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IHdpdGhpbiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGluaXRpYWxpemUgb3VyIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgIC8vIHdlIGRvIHRoaXMgbm93IHNvIHRoYXQgd2UgY2FuIGxpc3RlbiB0byBldmVudHMgdGhhdCBtYXlcbiAgICAgICAgLy8gaGF2ZSBmaXJlZCBldmVuIGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgcmVhZHlcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgbWF5IGhhdmUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGlmIChhdHRhY2hQYXJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBpcyBpbXBvcnRhbnQgc28gdGhhdCB3ZSBrbm93IHRoZSBob3N0IGVsZW1lbnQgYWN0dWFsbHkgaGFzIGEgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRoZSBsaXN0ZW5lcnMgdG8gb25seSBoYXZlIHRoZSBvbmVzIHRoYXQgQVJFIGJlaW5nIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChbZmxhZ3NdKSA9PiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlaW5nIHJhbiBmcm9tIHdpdGhpbiB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgLy8gZXZlcnl0aGluZyBCVVQgdGhlIHBhcmVudCBlbGVtZW50IGxpc3RlbmVycyBzaG91bGQgYmUgYXR0YWNoZWQgYXQgdGhpcyB0aW1lXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGUgbGlzdGVuZXJzIHRoYXQgYXJlIE5PVCBiZWluZyBhdHRhY2hlZCB0byB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigoW2ZsYWdzXSkgPT4gIShmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy5tYXAoKFtmbGFncywgbmFtZSwgbWV0aG9kXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0ID8gZ2V0SG9zdExpc3RlbmVyVGFyZ2V0KGVsbSwgZmxhZ3MpIDogZWxtO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhvc3RMaXN0ZW5lclByb3h5KGhvc3RSZWYsIG1ldGhvZCk7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gaG9zdExpc3RlbmVyT3B0cyhmbGFncyk7XG4gICAgICAgICAgICBwbHQuYWVsKHRhcmdldCwgbmFtZSwgaGFuZGxlciwgb3B0cyk7XG4gICAgICAgICAgICAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkID0gaG9zdFJlZi4kcm1MaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKCgpID0+IHBsdC5yZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBob3N0TGlzdGVuZXJQcm94eSA9IChob3N0UmVmLCBtZXRob2ROYW1lKSA9PiAoZXYpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAyNTYgLyogaXNMaXN0ZW5SZWFkeSAqLykge1xuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LCBsZXQncyBjYWxsIGl0J3MgbWVtYmVyIG1ldGhvZCBmb3IgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGxhenlJbnN0YW5jZSRbbWV0aG9kTmFtZV0oZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgPSBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkIHx8IFtdKS5wdXNoKFttZXRob2ROYW1lLCBldl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdFJlZi4kaG9zdEVsZW1lbnQkW21ldGhvZE5hbWVdKGV2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxufTtcbmNvbnN0IGdldEhvc3RMaXN0ZW5lclRhcmdldCA9IChlbG0sIGZsYWdzKSA9PiB7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldERvY3VtZW50ICYmIGZsYWdzICYgNCAvKiBUYXJnZXREb2N1bWVudCAqLylcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyVGFyZ2V0V2luZG93ICYmIGZsYWdzICYgOCAvKiBUYXJnZXRXaW5kb3cgKi8pXG4gICAgICAgIHJldHVybiB3aW47XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldEJvZHkgJiYgZmxhZ3MgJiAxNiAvKiBUYXJnZXRCb2R5ICovKVxuICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCAmJiBmbGFncyAmIDMyIC8qIFRhcmdldFBhcmVudCAqLylcbiAgICAgICAgcmV0dXJuIGVsbS5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBlbG07XG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBob3N0TGlzdGVuZXJPcHRzID0gKGZsYWdzKSA9PiBzdXBwb3J0c0xpc3RlbmVyT3B0aW9uc1xuICAgID8gKHtcbiAgICAgICAgcGFzc2l2ZTogKGZsYWdzICYgMSAvKiBQYXNzaXZlICovKSAhPT0gMCxcbiAgICAgICAgY2FwdHVyZTogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMCxcbiAgICB9KVxuICAgIDogKGZsYWdzICYgMiAvKiBDYXB0dXJlICovKSAhPT0gMDtcbmNvbnN0IENPTlRFTlRfUkVGX0lEID0gJ3InO1xuY29uc3QgT1JHX0xPQ0FUSU9OX0lEID0gJ28nO1xuY29uc3QgU0xPVF9OT0RFX0lEID0gJ3MnO1xuY29uc3QgVEVYVF9OT0RFX0lEID0gJ3QnO1xuY29uc3QgSFlEUkFURV9JRCA9ICdzLWlkJztcbmNvbnN0IEhZRFJBVEVEX1NUWUxFX0lEID0gJ3N0eS1pZCc7XG5jb25zdCBIWURSQVRFX0NISUxEX0lEID0gJ2MtaWQnO1xuY29uc3QgSFlEUkFURURfQ1NTID0gJ3t2aXNpYmlsaXR5OmhpZGRlbn0uaHlkcmF0ZWR7dmlzaWJpbGl0eTppbmhlcml0fSc7XG5jb25zdCBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IGNyZWF0ZVRpbWUgPSAoZm5OYW1lLCB0YWdOYW1lID0gJycpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGBzdDoke2ZuTmFtZX06JHt0YWdOYW1lfToke2krK31gO1xuICAgICAgICAvLyBTdGFydFxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIC8vIEVuZFxuICAgICAgICByZXR1cm4gKCkgPT4gcGVyZm9ybWFuY2UubWVhc3VyZShgW1N0ZW5jaWxdICR7Zm5OYW1lfSgpIDwke3RhZ05hbWV9PmAsIGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCB1bmlxdWVUaW1lID0gKGtleSwgbWVhc3VyZVRleHQpID0+IHtcbiAgICBpZiAoQlVJTEQucHJvZmlsZSAmJiBwZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKGtleSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKG1lYXN1cmVUZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVUZXh0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgaW5zcGVjdCA9IChyZWYpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGlmICghaG9zdFJlZikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmbGFncyA9IGhvc3RSZWYuJGZsYWdzJDtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJDb3VudDogaG9zdFJlZi4kcmVuZGVyQ291bnQkLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgaGFzUmVuZGVyZWQ6ICEhKGZsYWdzICYgMiAvKiBoYXNSZW5kZXJlZCAqLyksXG4gICAgICAgICAgICBoYXNDb25uZWN0ZWQ6ICEhKGZsYWdzICYgMSAvKiBoYXNDb25uZWN0ZWQgKi8pLFxuICAgICAgICAgICAgaXNXYWl0aW5nRm9yQ2hpbGRyZW46ICEhKGZsYWdzICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyksXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGluZ0luc3RhbmNlOiAhIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLyksXG4gICAgICAgICAgICBpc1F1ZXVlZEZvclVwZGF0ZTogISEoZmxhZ3MgJiAxNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLyksXG4gICAgICAgICAgICBoYXNJbml0aWFsaXplZENvbXBvbmVudDogISEoZmxhZ3MgJiAzMiAvKiBoYXNJbml0aWFsaXplZENvbXBvbmVudCAqLyksXG4gICAgICAgICAgICBoYXNMb2FkZWRDb21wb25lbnQ6ICEhKGZsYWdzICYgNjQgLyogaGFzTG9hZGVkQ29tcG9uZW50ICovKSxcbiAgICAgICAgICAgIGlzV2F0Y2hSZWFkeTogISEoZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSxcbiAgICAgICAgICAgIGlzTGlzdGVuUmVhZHk6ICEhKGZsYWdzICYgMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi8pLFxuICAgICAgICAgICAgbmVlZHNSZXJlbmRlcjogISEoZmxhZ3MgJiA1MTIgLyogbmVlZHNSZXJlbmRlciAqLyksXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlVmFsdWVzOiBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQsXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50OiBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQsXG4gICAgICAgIGhvc3RFbGVtZW50LFxuICAgICAgICBsYXp5SW5zdGFuY2U6IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQsXG4gICAgICAgIHZub2RlOiBob3N0UmVmLiR2bm9kZSQsXG4gICAgICAgIG1vZGVOYW1lOiBob3N0UmVmLiRtb2RlTmFtZSQsXG4gICAgICAgIG9uUmVhZHlQcm9taXNlOiBob3N0UmVmLiRvblJlYWR5UHJvbWlzZSQsXG4gICAgICAgIG9uUmVhZHlSZXNvbHZlOiBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQsXG4gICAgICAgIG9uSW5zdGFuY2VQcm9taXNlOiBob3N0UmVmLiRvbkluc3RhbmNlUHJvbWlzZSQsXG4gICAgICAgIG9uSW5zdGFuY2VSZXNvbHZlOiBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQsXG4gICAgICAgIG9uUmVuZGVyUmVzb2x2ZTogaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCxcbiAgICAgICAgcXVldWVkTGlzdGVuZXJzOiBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLFxuICAgICAgICBybUxpc3RlbmVyczogaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLFxuICAgICAgICBbJ3MtaWQnXTogaG9zdEVsZW1lbnRbJ3MtaWQnXSxcbiAgICAgICAgWydzLWNyJ106IGhvc3RFbGVtZW50WydzLWNyJ10sXG4gICAgICAgIFsncy1sciddOiBob3N0RWxlbWVudFsncy1sciddLFxuICAgICAgICBbJ3MtcCddOiBob3N0RWxlbWVudFsncy1wJ10sXG4gICAgICAgIFsncy1yYyddOiBob3N0RWxlbWVudFsncy1yYyddLFxuICAgICAgICBbJ3Mtc2MnXTogaG9zdEVsZW1lbnRbJ3Mtc2MnXSxcbiAgICB9O1xufTtcbmNvbnN0IGluc3RhbGxEZXZUb29scyA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuZGV2VG9vbHMpIHtcbiAgICAgICAgY29uc3Qgc3RlbmNpbCA9ICh3aW4uc3RlbmNpbCA9IHdpbi5zdGVuY2lsIHx8IHt9KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbnNwZWN0ID0gc3RlbmNpbC5pbnNwZWN0O1xuICAgICAgICBzdGVuY2lsLmluc3BlY3QgPSAocmVmKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIG9yaWdpbmFsSW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsSW5zcGVjdChyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3Qgcm9vdEFwcGxpZWRTdHlsZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJTdHlsZSA9IChzY29wZUlkLCBjc3NUZXh0LCBhbGxvd0NTKSA9PiB7XG4gICAgbGV0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICBpZiAoc3VwcG9ydHNDb25zdHJ1Y3RpYmxlU3R5bGVzaGVldHMgJiYgYWxsb3dDUykge1xuICAgICAgICBzdHlsZSA9IChzdHlsZSB8fCBuZXcgQ1NTU3R5bGVTaGVldCgpKTtcbiAgICAgICAgc3R5bGUucmVwbGFjZShjc3NUZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gY3NzVGV4dDtcbiAgICB9XG4gICAgc3R5bGVzLnNldChzY29wZUlkLCBzdHlsZSk7XG59O1xuY29uc3QgYWRkU3R5bGUgPSAoc3R5bGVDb250YWluZXJOb2RlLCBjbXBNZXRhLCBtb2RlLCBob3N0RWxtKSA9PiB7XG4gICAgbGV0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIG1vZGUpO1xuICAgIGxldCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZCk7XG4gICAgaWYgKCFCVUlMRC5hdHRhY2hTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlSWQ7XG4gICAgfVxuICAgIC8vIGlmIGFuIGVsZW1lbnQgaXMgTk9UIGNvbm5lY3RlZCB0aGVuIGdldFJvb3ROb2RlKCkgd2lsbCByZXR1cm4gdGhlIHdyb25nIHJvb3Qgbm9kZVxuICAgIC8vIHNvIHRoZSBmYWxsYmFjayBpcyB0byBhbHdheXMgdXNlIHRoZSBkb2N1bWVudCBmb3IgdGhlIHJvb3Qgbm9kZSBpbiB0aG9zZSBjYXNlc1xuICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLyA/IHN0eWxlQ29udGFpbmVyTm9kZSA6IGRvYztcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5oZWFkIHx8IHN0eWxlQ29udGFpbmVyTm9kZTtcbiAgICAgICAgICAgIGxldCBhcHBsaWVkU3R5bGVzID0gcm9vdEFwcGxpZWRTdHlsZXMuZ2V0KHN0eWxlQ29udGFpbmVyTm9kZSk7XG4gICAgICAgICAgICBsZXQgc3R5bGVFbG07XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByb290QXBwbGllZFN0eWxlcy5zZXQoc3R5bGVDb250YWluZXJOb2RlLCAoYXBwbGllZFN0eWxlcyA9IG5ldyBTZXQoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzLmhhcyhzY29wZUlkKSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICBzdHlsZUNvbnRhaW5lck5vZGUuaG9zdCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGVFbG0gPSBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvcihgWyR7SFlEUkFURURfU1RZTEVfSUR9PVwiJHtzY29wZUlkfVwiXWApKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgaGFwcGVuaW5nIG9uIG5hdGl2ZSBzaGFkb3ctZG9tLCBkbyBub3QgbmVlZHMgQ1NTIHZhciBzaGltXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRWxtLmlubmVySFRNTCA9IHN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmNzc1ZhclNoaW0gJiYgcGx0LiRjc3NTaGltJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0gPSBwbHQuJGNzc1NoaW0kLmNyZWF0ZUhvc3RTdHlsZShob3N0RWxtLCBzY29wZUlkLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTY29wZUlkID0gc3R5bGVFbG1bJ3Mtc2MnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY29wZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVJZCA9IG5ld1Njb3BlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhZGQgdGhpcyBzdHlsZUlEIHRvIHRoZSBhcHBsaWVkU3R5bGVzIFNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjc3NWYXJTaGltIG1pZ2h0IG5lZWQgdG8gYXBwbHkgc2V2ZXJhbCBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXNoZWV0cyBmb3IgdGhlIHNhbWUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURURfU1RZTEVfSUQsIHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKCdsaW5rJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkU3R5bGVzLmFkZChzY29wZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQuY29uc3RydWN0YWJsZUNTUyAmJiAhc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZUlkO1xufTtcbmNvbnN0IGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKCdhdHRhY2hTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IGFkZFN0eWxlKEJVSUxELnNoYWRvd0RvbSAmJiBzdXBwb3J0c1NoYWRvdyAmJiBlbG0uc2hhZG93Um9vdCA/IGVsbS5zaGFkb3dSb290IDogZWxtLmdldFJvb3ROb2RlKCksIGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCwgZWxtKTtcbiAgICBpZiAoKEJVSUxELnNoYWRvd0RvbSB8fCBCVUlMRC5zY29wZWQpICYmIEJVSUxELmNzc0Fubm90YXRpb25zICYmIGZsYWdzICYgMTAgLyogbmVlZHNTY29wZWRFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgICAgIC8vIG9yIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgbmF0aXZlIHNoYWRvdyBkb21cbiAgICAgICAgLy8gYW5kIHRoaXMgaG9zdCBlbGVtZW50IHdhcyBOT1QgY3JlYXRlZCB3aXRoIFNTUlxuICAgICAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5vZGUgdG8gcmVwcmVzZW50IHdoZXJlIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBjb250ZW50IHdhcyBmaXJzdCBwbGFjZWQsIHdoaWNoIGlzIHVzZWZ1bCBsYXRlciBvblxuICAgICAgICAvLyBET00gV1JJVEUhIVxuICAgICAgICBlbG1bJ3Mtc2MnXSA9IHNjb3BlSWQ7XG4gICAgICAgIGVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLWgnKTtcbiAgICAgICAgaWYgKEJVSUxELnNjb3BlZCAmJiBmbGFncyAmIDIgLyogc2NvcGVkQ3NzRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZCArICctcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbmNvbnN0IGdldFNjb3BlSWQgPSAoY21wLCBtb2RlKSA9PiAnc2MtJyArIChCVUlMRC5tb2RlICYmIG1vZGUgJiYgY21wLiRmbGFncyQgJiAzMiAvKiBoYXNNb2RlICovID8gY21wLiR0YWdOYW1lJCArICctJyArIG1vZGUgOiBjbXAuJHRhZ05hbWUkKTtcbmNvbnN0IGNvbnZlcnRTY29wZWRUb1NoYWRvdyA9IChjc3MpID0+IGNzcy5yZXBsYWNlKC9cXC9cXCohQChbXlxcL10rKVxcKlxcL1teXFx7XStcXHsvZywgJyQxeycpO1xuLy8gUHJpdmF0ZVxuY29uc3QgY29tcHV0ZU1vZGUgPSAoZWxtKSA9PiBtb2RlUmVzb2x1dGlvbkNoYWluLm1hcCgoaCkgPT4gaChlbG0pKS5maW5kKChtKSA9PiAhIW0pO1xuLy8gUHVibGljXG5jb25zdCBzZXRNb2RlID0gKGhhbmRsZXIpID0+IG1vZGVSZXNvbHV0aW9uQ2hhaW4ucHVzaChoYW5kbGVyKTtcbmNvbnN0IGdldE1vZGUgPSAocmVmKSA9PiBnZXRIb3N0UmVmKHJlZikuJG1vZGVOYW1lJDtcbi8qKlxuICogRGVmYXVsdCBzdHlsZSBtb2RlIGlkXG4gKi9cbi8qKlxuICogUmV1c2FibGUgZW1wdHkgb2JqL2FycmF5XG4gKiBEb24ndCBhZGQgdmFsdWVzIHRvIHRoZXNlISFcbiAqL1xuY29uc3QgRU1QVFlfT0JKID0ge307XG4vKipcbiAqIE5hbWVzcGFjZXNcbiAqL1xuY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBpc0RlZiA9ICh2KSA9PiB2ICE9IG51bGw7XG5jb25zdCBpc0NvbXBsZXhUeXBlID0gKG8pID0+IHtcbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdHlwZW9mLWZuLW9iamVjdC81XG4gICAgbyA9IHR5cGVvZiBvO1xuICAgIHJldHVybiBvID09PSAnb2JqZWN0JyB8fCBvID09PSAnZnVuY3Rpb24nO1xufTtcbi8qKlxuICogUHJvZHVjdGlvbiBoKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbi8vIGNvbnN0IHN0YWNrOiBhbnlbXSA9IFtdO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgY2hpbGQ/OiBkLkNoaWxkVHlwZSk6IGQuVk5vZGU7XG4vLyBleHBvcnQgZnVuY3Rpb24gaChub2RlTmFtZTogc3RyaW5nIHwgZC5GdW5jdGlvbmFsQ29tcG9uZW50LCB2bm9kZURhdGE6IGQuUHJvcHNUeXBlLCAuLi5jaGlsZHJlbjogZC5DaGlsZFR5cGVbXSk6IGQuVk5vZGU7XG5jb25zdCBoID0gKG5vZGVOYW1lLCB2bm9kZURhdGEsIC4uLmNoaWxkcmVuKSA9PiB7XG4gICAgbGV0IGNoaWxkID0gbnVsbDtcbiAgICBsZXQga2V5ID0gbnVsbDtcbiAgICBsZXQgc2xvdE5hbWUgPSBudWxsO1xuICAgIGxldCBzaW1wbGUgPSBmYWxzZTtcbiAgICBsZXQgbGFzdFNpbXBsZSA9IGZhbHNlO1xuICAgIGxldCB2Tm9kZUNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgd2FsayA9IChjKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIHR5cGVvZiBjaGlsZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgIWlzQ29tcGxleFR5cGUoY2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELmlzRGV2ICYmIHR5cGVvZiBub2RlTmFtZSAhPT0gJ2Z1bmN0aW9uJyAmJiBjaGlsZC4kZmxhZ3MkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZURldkVycm9yKGB2Tm9kZSBwYXNzZWQgYXMgY2hpbGRyZW4gaGFzIHVuZXhwZWN0ZWQgdHlwZS5cbk1ha2Ugc3VyZSBpdCdzIHVzaW5nIHRoZSBjb3JyZWN0IGgoKSBmdW5jdGlvbi5cbkVtcHR5IG9iamVjdHMgY2FuIGFsc28gYmUgdGhlIGNhdXNlLCBsb29rIGZvciBKU1ggY29tbWVudHMgdGhhdCBiZWNhbWUgb2JqZWN0cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGlsZCB3YXMgc2ltcGxlIChzdHJpbmcpLCB3ZSBtZXJnZSBib3RoXG4gICAgICAgICAgICAgICAgICAgIHZOb2RlQ2hpbGRyZW5bdk5vZGVDaGlsZHJlbi5sZW5ndGggLSAxXS4kdGV4dCQgKz0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYSBuZXcgdk5vZGUsIGlmIGl0J3MgdGV4dCwgd2UgY3JlYXRlIGEgdGV4dCB2Tm9kZVxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuLnB1c2goc2ltcGxlID8gbmV3Vk5vZGUobnVsbCwgY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB3YWxrKGNoaWxkcmVuKTtcbiAgICBpZiAodm5vZGVEYXRhKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0RldiAmJiBub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXModm5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemUgY2xhc3MgLyBjbGFzc25hbWUgYXR0cmlidXRlc1xuICAgICAgICBpZiAoQlVJTEQudmRvbUtleSAmJiB2bm9kZURhdGEua2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB2bm9kZURhdGEua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiB2bm9kZURhdGEubmFtZSkge1xuICAgICAgICAgICAgc2xvdE5hbWUgPSB2bm9kZURhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0RhdGEgPSB2bm9kZURhdGEuY2xhc3NOYW1lIHx8IHZub2RlRGF0YS5jbGFzcztcbiAgICAgICAgICAgIGlmIChjbGFzc0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZURhdGEuY2xhc3MgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2xhc3NEYXRhICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGFzc0RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXMoY2xhc3NEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGNsYXNzRGF0YVtrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0RldiAmJiB2Tm9kZUNoaWxkcmVuLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LiBNYWtlIHN1cmU6XG4tIFlvdSBhcmUgTk9UIHVzaW5nIGhvc3REYXRhKCkgYW5kIDxIb3N0PiBpbiB0aGUgc2FtZSBjb21wb25lbnQuXG4tIDxIb3N0PiBpcyB1c2VkIG9uY2UsIGFuZCBpdCdzIHRoZSBzaW5nbGUgcm9vdCBjb21wb25lbnQgb2YgdGhlIHJlbmRlcigpIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbUZ1bmN0aW9uYWwgJiYgdHlwZW9mIG5vZGVOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vZGVOYW1lIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgICAgcmV0dXJuIG5vZGVOYW1lKHZub2RlRGF0YSA9PT0gbnVsbCA/IHt9IDogdm5vZGVEYXRhLCB2Tm9kZUNoaWxkcmVuLCB2ZG9tRm5VdGlscyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZU5hbWUsIG51bGwpO1xuICAgIHZub2RlLiRhdHRycyQgPSB2bm9kZURhdGE7XG4gICAgaWYgKHZOb2RlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2bm9kZS4kY2hpbGRyZW4kID0gdk5vZGVDaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgdm5vZGUuJGtleSQgPSBrZXk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICB2bm9kZS4kbmFtZSQgPSBzbG90TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IG5ld1ZOb2RlID0gKHRhZywgdGV4dCkgPT4ge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkdGFnJDogdGFnLFxuICAgICAgICAkdGV4dCQ6IHRleHQsXG4gICAgICAgICRlbG0kOiBudWxsLFxuICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgIH07XG4gICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgdm5vZGUuJGF0dHJzJCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgIHZub2RlLiRrZXkkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIHZub2RlLiRuYW1lJCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZTtcbn07XG5jb25zdCBIb3N0ID0ge307XG5jb25zdCBpc0hvc3QgPSAobm9kZSkgPT4gbm9kZSAmJiBub2RlLiR0YWckID09PSBIb3N0O1xuY29uc3QgdmRvbUZuVXRpbHMgPSB7XG4gICAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gICAgbWFwOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5tYXAoY2IpLm1hcChjb252ZXJ0VG9Qcml2YXRlKSxcbn07XG5jb25zdCBjb252ZXJ0VG9QdWJsaWMgPSAobm9kZSkgPT4gKHtcbiAgICB2YXR0cnM6IG5vZGUuJGF0dHJzJCxcbiAgICB2Y2hpbGRyZW46IG5vZGUuJGNoaWxkcmVuJCxcbiAgICB2a2V5OiBub2RlLiRrZXkkLFxuICAgIHZuYW1lOiBub2RlLiRuYW1lJCxcbiAgICB2dGFnOiBub2RlLiR0YWckLFxuICAgIHZ0ZXh0OiBub2RlLiR0ZXh0JCxcbn0pO1xuY29uc3QgY29udmVydFRvUHJpdmF0ZSA9IChub2RlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBub2RlLnZ0YWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZS52YXR0cnMpO1xuICAgICAgICBpZiAobm9kZS52a2V5KSB7XG4gICAgICAgICAgICB2bm9kZURhdGEua2V5ID0gbm9kZS52a2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnZuYW1lKSB7XG4gICAgICAgICAgICB2bm9kZURhdGEubmFtZSA9IG5vZGUudm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgobm9kZS52dGFnLCB2bm9kZURhdGEsIC4uLihub2RlLnZjaGlsZHJlbiB8fCBbXSkpO1xuICAgIH1cbiAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGUudnRhZywgbm9kZS52dGV4dCk7XG4gICAgdm5vZGUuJGF0dHJzJCA9IG5vZGUudmF0dHJzO1xuICAgIHZub2RlLiRjaGlsZHJlbiQgPSBub2RlLnZjaGlsZHJlbjtcbiAgICB2bm9kZS4ka2V5JCA9IG5vZGUudmtleTtcbiAgICB2bm9kZS4kbmFtZSQgPSBub2RlLnZuYW1lO1xuICAgIHJldHVybiB2bm9kZTtcbn07XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgb3JkZXJpbmcgb2YgYXR0cmlidXRlcyBvbiBhbiBpbnB1dCBlbGVtZW50XG4gKiBAcGFyYW0gaW5wdXRFbG0gdGhlIGVsZW1lbnQgdG8gdmFsaWRhdGVcbiAqL1xuY29uc3QgdmFsaWRhdGVJbnB1dFByb3BlcnRpZXMgPSAoaW5wdXRFbG0pID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGlucHV0RWxtKTtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzLmluZGV4T2YoJ3ZhbHVlJyk7XG4gICAgaWYgKHZhbHVlID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGVJbmRleCA9IHByb3BzLmluZGV4T2YoJ3R5cGUnKTtcbiAgICBjb25zdCBtaW5JbmRleCA9IHByb3BzLmluZGV4T2YoJ21pbicpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gcHJvcHMuaW5kZXhPZignbWF4Jyk7XG4gICAgY29uc3Qgc3RlcEluZGV4ID0gcHJvcHMuaW5kZXhPZignc3RlcCcpO1xuICAgIGlmICh2YWx1ZSA8IHR5cGVJbmRleCB8fCB2YWx1ZSA8IG1pbkluZGV4IHx8IHZhbHVlIDwgbWF4SW5kZXggfHwgdmFsdWUgPCBzdGVwSW5kZXgpIHtcbiAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBcInZhbHVlXCIgcHJvcCBvZiA8aW5wdXQ+IHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJtaW5cIiwgXCJtYXhcIiwgXCJ0eXBlXCIgYW5kIFwic3RlcFwiYCk7XG4gICAgfVxufTtcbi8qKlxuICogUHJvZHVjdGlvbiBzZXRBY2Nlc3NvcigpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG5jb25zdCBzZXRBY2Nlc3NvciA9IChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgaXNTdmcsIGZsYWdzKSA9PiB7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgaXNQcm9wID0gaXNNZW1iZXJJbkVsZW1lbnQoZWxtLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgbGV0IGxuID0gbWVtYmVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoQlVJTEQudmRvbUNsYXNzICYmIG1lbWJlck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsbS5jbGFzc0xpc3Q7XG4gICAgICAgICAgICBjb25zdCBvbGRDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3Qob2xkVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHBhcnNlQ2xhc3NMaXN0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW5ld0NsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcy5maWx0ZXIoKGMpID0+IGMgJiYgIW9sZENsYXNzZXMuaW5jbHVkZXMoYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tU3R5bGUgJiYgbWVtYmVyTmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHN0eWxlIGF0dHJpYnV0ZSwgY3NzIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgICAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1ZhbHVlIHx8IG5ld1ZhbHVlW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgcHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFZhbHVlIHx8IG5ld1ZhbHVlW3Byb3BdICE9PSBvbGRWYWx1ZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIHByb3AuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIG5ld1ZhbHVlW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IG5ld1ZhbHVlW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21LZXkgJiYgbWVtYmVyTmFtZSA9PT0gJ2tleScpXG4gICAgICAgICAgICA7XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21SZWYgJiYgbWVtYmVyTmFtZSA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIC8vIG1pbmlmaWVyIHdpbGwgY2xlYW4gdGhpcyB1cFxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUoZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCVUlMRC52ZG9tTGlzdGVuZXIgJiZcbiAgICAgICAgICAgIChCVUlMRC5sYXp5TG9hZCA/ICFpc1Byb3AgOiAhZWxtLl9fbG9va3VwU2V0dGVyX18obWVtYmVyTmFtZSkpICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzBdID09PSAnbycgJiZcbiAgICAgICAgICAgIG1lbWJlck5hbWVbMV0gPT09ICduJykge1xuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxlcnNcbiAgICAgICAgICAgIC8vIHNvIGlmIHRoZSBtZW1iZXIgbmFtZSBzdGFydHMgd2l0aCBcIm9uXCIgYW5kIHRoZSAzcmQgY2hhcmFjdGVycyBpc1xuICAgICAgICAgICAgLy8gYSBjYXBpdGFsIGxldHRlciwgYW5kIGl0J3Mgbm90IGFscmVhZHkgYSBtZW1iZXIgb24gdGhlIGVsZW1lbnQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlJ3JlIGFzc3VtaW5nIGl0J3MgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmIChtZW1iZXJOYW1lWzJdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAvLyBvbi0gcHJlZml4ZWQgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRvIGJlIGV4cGxpY2l0IGFib3V0IHRoZSBkb20gZXZlbnQgdG8gbGlzdGVuIHdpdGhvdXQgYW55IG1hZ2ljXG4gICAgICAgICAgICAgICAgLy8gdW5kZXIgdGhlIGhvb2Q6XG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1jbGljaz4gLy8gbGlzdGVucyBmb3IgXCJjbGlja1wiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1DbGljaz4gLy8gbGlzdGVucyBmb3IgXCJDbGlja1wiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1pb25DaGFuZ2U+IC8vIGxpc3RlbnMgZm9yIFwiaW9uQ2hhbmdlXCJcbiAgICAgICAgICAgICAgICAvLyA8bXktY21wIG9uLUVWRU5UUz4gLy8gbGlzdGVucyBmb3IgXCJFVkVOVFNcIlxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNNZW1iZXJJbkVsZW1lbnQod2luLCBsbikpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSBKU1ggYXR0cmlidXRlIGNvdWxkIGhhdmUgYmVlbiBcIm9uTW91c2VPdmVyXCIgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIG1lbWJlciBuYW1lIFwib25tb3VzZW92ZXJcIiBpcyBvbiB0aGUgd2luZG93J3MgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgYWRkIHRoZSBsaXN0ZW5lciBcIm1vdXNlb3ZlclwiLCB3aGljaCBpcyBhbGwgbG93ZXJjYXNlZFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbi5zbGljZSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSBKU1ggYXR0cmlidXRlIGNvdWxkIGhhdmUgYmVlbiBcIm9uTXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gc28gbGV0J3MgdHJpbSBvZmYgdGhlIFwib25cIiBwcmVmaXggYW5kIGxvd2VyY2FzZSB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFkZCB0aGUgbGlzdGVuZXIgXCJteUN1c3RvbUV2ZW50XCJcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIsIHdlIGtlZXAgdGhlIGV2ZW50IG5hbWUgY2FzZVxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsblsyXSArIG1lbWJlck5hbWUuc2xpY2UoMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQucmVsKGVsbSwgbWVtYmVyTmFtZSwgb2xkVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5hZWwoZWxtLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJVSUxELnZkb21Qcm9wT3JBdHRyKSB7XG4gICAgICAgICAgICAvLyBTZXQgcHJvcGVydHkgaWYgaXQgZXhpc3RzIGFuZCBpdCdzIG5vdCBhIFNWR1xuICAgICAgICAgICAgY29uc3QgaXNDb21wbGV4ID0gaXNDb21wbGV4VHlwZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoKGlzUHJvcCB8fCAoaXNDb21wbGV4ICYmIG5ld1ZhbHVlICE9PSBudWxsKSkgJiYgIWlzU3ZnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbG0udGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IG5ld1ZhbHVlID09IG51bGwgPyAnJyA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgU2FmYXJpLCBtb3ZpbmcgdGhlIDxpbnB1dD4gY2FyZXQgd2hlbiByZS1hc3NpZ25pbmcgdGhlIHNhbWUgdmFsdWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyTmFtZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZSA9PSBudWxsIHx8IGVsbVttZW1iZXJOYW1lXSAhPSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmVlZCB0byBtYW51YWxseSB1cGRhdGUgYXR0cmlidXRlIGlmOlxuICAgICAgICAgICAgICogLSBtZW1iZXJOYW1lIGlzIG5vdCBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIC0gaWYgd2UgYXJlIHJlbmRlcmluZyB0aGUgaG9zdCBlbGVtZW50IGluIG9yZGVyIHRvIHJlZmxlY3QgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIGl0J3MgYSBTVkcsIHNpbmNlIHByb3BlcnRpZXMgbWlnaHQgbm90IHdvcmsgaW4gPHN2Zz5cbiAgICAgICAgICAgICAqIC0gaWYgdGhlIG5ld1ZhbHVlIGlzIG51bGwvdW5kZWZpbmVkIG9yICdmYWxzZScuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCB4bGluayA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21YbGluaykge1xuICAgICAgICAgICAgICAgIGlmIChsbiAhPT0gKGxuID0gbG4ucmVwbGFjZSgvXnhsaW5rXFw6Py8sICcnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyTmFtZSA9IGxuO1xuICAgICAgICAgICAgICAgICAgICB4bGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmYWxzZSB8fCBlbG0uZ2V0QXR0cmlidXRlKG1lbWJlck5hbWUpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQudmRvbVhsaW5rICYmIHhsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghaXNQcm9wIHx8IGZsYWdzICYgNCAvKiBpc0hvc3QgKi8gfHwgaXNTdmcpICYmICFpc0NvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB0cnVlID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQudmRvbVhsaW5rICYmIHhsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgbWVtYmVyTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShtZW1iZXJOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHBhcnNlQ2xhc3NMaXN0UmVnZXggPSAvXFxzLztcbmNvbnN0IHBhcnNlQ2xhc3NMaXN0ID0gKHZhbHVlKSA9PiAoIXZhbHVlID8gW10gOiB2YWx1ZS5zcGxpdChwYXJzZUNsYXNzTGlzdFJlZ2V4KSk7XG5jb25zdCB1cGRhdGVFbGVtZW50ID0gKG9sZFZub2RlLCBuZXdWbm9kZSwgaXNTdmdNb2RlLCBtZW1iZXJOYW1lKSA9PiB7XG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgcGFzc2VkIGluIGlzIGEgc2hhZG93IHJvb3QsIHdoaWNoIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAvLyB0aGVuIHdlIHdhbnQgdG8gYmUgYWRkaW5nIGF0dHJzL3Byb3BzIHRvIHRoZSBzaGFkb3cgcm9vdCdzIFwiaG9zdFwiIGVsZW1lbnRcbiAgICAvLyBpZiBpdCdzIG5vdCBhIHNoYWRvdyByb290LCB0aGVuIHdlIGFkZCBhdHRycy9wcm9wcyB0byB0aGUgc2FtZSBlbGVtZW50XG4gICAgY29uc3QgZWxtID0gbmV3Vm5vZGUuJGVsbSQubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gJiYgbmV3Vm5vZGUuJGVsbSQuaG9zdFxuICAgICAgICA/IG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgOiBuZXdWbm9kZS4kZWxtJDtcbiAgICBjb25zdCBvbGRWbm9kZUF0dHJzID0gKG9sZFZub2RlICYmIG9sZFZub2RlLiRhdHRycyQpIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdWbm9kZUF0dHJzID0gbmV3Vm5vZGUuJGF0dHJzJCB8fCBFTVBUWV9PQko7XG4gICAgaWYgKEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICAvLyByZW1vdmUgYXR0cmlidXRlcyBubyBsb25nZXIgcHJlc2VudCBvbiB0aGUgdm5vZGUgYnkgc2V0dGluZyB0aGVtIHRvIHVuZGVmaW5lZFxuICAgICAgICBmb3IgKG1lbWJlck5hbWUgaW4gb2xkVm5vZGVBdHRycykge1xuICAgICAgICAgICAgaWYgKCEobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSkge1xuICAgICAgICAgICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgdW5kZWZpbmVkLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBuZXcgJiB1cGRhdGUgY2hhbmdlZCBhdHRyaWJ1dGVzXG4gICAgZm9yIChtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpIHtcbiAgICAgICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBuZXdWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgIH1cbn07XG5jb25zdCBjcmVhdGVFbG0gPSAob2xkUGFyZW50Vk5vZGUsIG5ld1BhcmVudFZOb2RlLCBjaGlsZEluZGV4LCBwYXJlbnRFbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGxldCBuZXdWTm9kZSA9IG5ld1BhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRJbmRleF07XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBlbG07XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgb2xkVk5vZGU7XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmICF1c2VOYXRpdmVTaGFkb3dEb20pIHtcbiAgICAgICAgLy8gcmVtZW1iZXIgZm9yIGxhdGVyIHdlIG5lZWQgdG8gY2hlY2sgdG8gcmVsb2NhdGUgbm9kZXNcbiAgICAgICAgY2hlY2tTbG90UmVsb2NhdGUgPSB0cnVlO1xuICAgICAgICBpZiAobmV3Vk5vZGUuJHRhZyQgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzY29wZWQgY3NzIG5lZWRzIHRvIGFkZCBpdHMgc2NvcGVkIGlkIHRvIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgIHBhcmVudEVsbS5jbGFzc0xpc3QuYWRkKHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ZOb2RlLiRmbGFncyQgfD0gbmV3Vk5vZGUuJGNoaWxkcmVuJFxuICAgICAgICAgICAgICAgID8gLy8gc2xvdCBlbGVtZW50IGhhcyBmYWxsYmFjayBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDIgLyogaXNTbG90RmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICA6IC8vIHNsb3QgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGZhbGxiYWNrIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmlzRGV2ICYmIG5ld1ZOb2RlLiRlbG0kKSB7XG4gICAgICAgIGNvbnNvbGVEZXZFcnJvcihgVGhlIEpTWCAke25ld1ZOb2RlLiR0ZXh0JCAhPT0gbnVsbCA/IGBcIiR7bmV3Vk5vZGUuJHRleHQkfVwiIHRleHRgIDogYFwiJHtuZXdWTm9kZS4kdGFnJH1cIiBlbGVtZW50YH0gbm9kZSBzaG91bGQgbm90IGJlIHNoYXJlZCB3aXRoaW4gdGhlIHNhbWUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjYWNoZXMgZWxlbWVudCBsb29rdXBzIGluIG9yZGVyIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuIEhvd2V2ZXIsIGEgc2lkZSBlZmZlY3QgZnJvbSB0aGlzIGlzIHRoYXQgdGhlIGV4YWN0IHNhbWUgSlNYIG5vZGUgc2hvdWxkIG5vdCBiZSByZXVzZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgaHR0cHM6Ly9zdGVuY2lsanMuY29tL2RvY3MvdGVtcGxhdGluZy1qc3gjYXZvaWQtc2hhcmVkLWpzeC1ub2Rlc2ApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQudmRvbVRleHQgJiYgbmV3Vk5vZGUuJHRleHQkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcbiAgICAgICAgZWxtID0gbmV3Vk5vZGUuJGVsbSQgPSBkb2MuY3JlYXRlVGV4dE5vZGUobmV3Vk5vZGUuJHRleHQkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUuJGZsYWdzJCAmIDEgLyogaXNTbG90UmVmZXJlbmNlICovKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHNsb3QgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgZWxtID0gbmV3Vk5vZGUuJGVsbSQgPVxuICAgICAgICAgICAgQlVJTEQuaXNEZWJ1ZyB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUobmV3Vk5vZGUpIDogZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgIWlzU3ZnTW9kZSkge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbmV3Vk5vZGUuJHRhZyQgPT09ICdzdmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGVsbSA9IG5ld1ZOb2RlLiRlbG0kID0gKEJVSUxELnN2Z1xuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKGlzU3ZnTW9kZSA/IFNWR19OUyA6IEhUTUxfTlMsIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIG5ld1ZOb2RlLiRmbGFncyQgJiAyIC8qIGlzU2xvdEZhbGxiYWNrICovXG4gICAgICAgICAgICAgICAgPyAnc2xvdC1mYidcbiAgICAgICAgICAgICAgICA6IG5ld1ZOb2RlLiR0YWckKVxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiBuZXdWTm9kZS4kZmxhZ3MkICYgMiAvKiBpc1Nsb3RGYWxsYmFjayAqL1xuICAgICAgICAgICAgICAgID8gJ3Nsb3QtZmInXG4gICAgICAgICAgICAgICAgOiBuZXdWTm9kZS4kdGFnJCkpO1xuICAgICAgICBpZiAoQlVJTEQuc3ZnICYmIGlzU3ZnTW9kZSAmJiBuZXdWTm9kZS4kdGFnJCA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY3NzIGNsYXNzZXMsIGF0dHJzLCBwcm9wcywgbGlzdGVuZXJzLCBldGMuXG4gICAgICAgIGlmIChCVUlMRC52ZG9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVFbGVtZW50KG51bGwsIG5ld1ZOb2RlLCBpc1N2Z01vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoQlVJTEQuc2hhZG93RG9tIHx8IEJVSUxELnNjb3BlZCkgJiYgaXNEZWYoc2NvcGVJZCkgJiYgZWxtWydzLXNpJ10gIT09IHNjb3BlSWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc2NvcGVJZCBhbmQgdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIC8vIHRoZW4gbGV0J3MgYWRkIHRoZSBzY29wZUlkIGFzIGEgY3NzIGNsYXNzXG4gICAgICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZCgoZWxtWydzLXNpJ10gPSBzY29wZUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1ZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdWTm9kZS4kY2hpbGRyZW4kLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY3JlYXRlRWxtKG9sZFBhcmVudFZOb2RlLCBuZXdWTm9kZSwgaSwgZWxtKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbm9kZSBjb3VsZCBoYXZlIGJlZW4gbnVsbFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIG91ciBuZXcgbm9kZVxuICAgICAgICAgICAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnN2Zykge1xuICAgICAgICAgICAgaWYgKG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIFNWRyBjb250ZXh0IHdoZW4gd2UncmUgZXhpdGluZyA8c3ZnPiBlbGVtZW50XG4gICAgICAgICAgICAgICAgaXNTdmdNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbG0udGFnTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVlbnRlciBTVkcgY29udGV4dCB3aGVuIHdlJ3JlIGV4aXRpbmcgPGZvcmVpZ25PYmplY3Q+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpc1N2Z01vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICBlbG1bJ3MtaG4nXSA9IGhvc3RUYWdOYW1lO1xuICAgICAgICBpZiAobmV3Vk5vZGUuJGZsYWdzJCAmICgyIC8qIGlzU2xvdEZhbGxiYWNrICovIHwgMSAvKiBpc1Nsb3RSZWZlcmVuY2UgKi8pKSB7XG4gICAgICAgICAgICAvLyByZW1lbWJlciB0aGUgY29udGVudCByZWZlcmVuY2UgY29tbWVudFxuICAgICAgICAgICAgZWxtWydzLXNyJ10gPSB0cnVlO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIGNvbW1lbnRcbiAgICAgICAgICAgIGVsbVsncy1jciddID0gY29udGVudFJlZjtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBzbG90IG5hbWUsIG9yIGVtcHR5IHN0cmluZyBmb3IgZGVmYXVsdCBzbG90XG4gICAgICAgICAgICBlbG1bJ3Mtc24nXSA9IG5ld1ZOb2RlLiRuYW1lJCB8fCAnJztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlJ3ZlIGdvdCBhbiBvbGQgdm5vZGUgZm9yIHRoaXMgc2xvdFxuICAgICAgICAgICAgb2xkVk5vZGUgPSBvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS4kY2hpbGRyZW4kICYmIG9sZFBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRJbmRleF07XG4gICAgICAgICAgICBpZiAob2xkVk5vZGUgJiYgb2xkVk5vZGUuJHRhZyQgPT09IG5ld1ZOb2RlLiR0YWckICYmIG9sZFBhcmVudFZOb2RlLiRlbG0kKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgZ290IGFuIG9sZCBzbG90IHZub2RlIGFuZCB0aGUgd3JhcHBlciBpcyBiZWluZyByZXBsYWNlZFxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIG1vdmUgdGhlIG9sZCBzbG90IGNvbnRlbnQgYmFjayB0byBpdCdzIG9yaWdpbmFsIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRQYXJlbnRWTm9kZS4kZWxtJCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbG07XG59O1xuY29uc3QgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbiA9IChwYXJlbnRFbG0sIHJlY3Vyc2l2ZSkgPT4ge1xuICAgIHBsdC4kZmxhZ3MkIHw9IDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi87XG4gICAgY29uc3Qgb2xkU2xvdENoaWxkTm9kZXMgPSBwYXJlbnRFbG0uY2hpbGROb2RlcztcbiAgICBmb3IgKGxldCBpID0gb2xkU2xvdENoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gb2xkU2xvdENoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3MtaG4nXSAhPT0gaG9zdFRhZ05hbWUgJiYgY2hpbGROb2RlWydzLW9sJ10pIHtcbiAgICAgICAgICAgIC8vIC8vIHRoaXMgY2hpbGQgbm9kZSBpbiB0aGUgb2xkIGVsZW1lbnQgaXMgZnJvbSBhbm90aGVyIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gLy8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHRoZSBvbGQgc2xvdCdzIHBhcmVudFxuICAgICAgICAgICAgLy8gY2hpbGROb2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gYW5kIHJlbG9jYXRlIGl0IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgcGFyZW50UmVmZXJlbmNlTm9kZShjaGlsZE5vZGUpLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUoY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9sZCBvcmlnaW5hbCBsb2NhdGlvbiBjb21tZW50IGVudGlyZWx5XG4gICAgICAgICAgICAvLyBsYXRlciBvbiB0aGUgcGF0Y2ggZnVuY3Rpb24gd2lsbCBrbm93IHdoYXQgdG8gZG9cbiAgICAgICAgICAgIC8vIGFuZCBtb3ZlIHRoaXMgdG8gdGhlIGNvcnJlY3Qgc3BvdCBpbiBuZWVkIGJlXG4gICAgICAgICAgICBjaGlsZE5vZGVbJ3Mtb2wnXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGNoaWxkTm9kZVsncy1vbCddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2hlY2tTbG90UmVsb2NhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oY2hpbGROb2RlLCByZWN1cnNpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsdC4kZmxhZ3MkICY9IH4xIC8qIGlzVG1wRGlzY29ubmVjdGVkICovO1xufTtcbmNvbnN0IGFkZFZub2RlcyA9IChwYXJlbnRFbG0sIGJlZm9yZSwgcGFyZW50Vk5vZGUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkgPT4ge1xuICAgIGxldCBjb250YWluZXJFbG0gPSAoKEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIHBhcmVudEVsbVsncy1jciddICYmIHBhcmVudEVsbVsncy1jciddLnBhcmVudE5vZGUpIHx8IHBhcmVudEVsbSk7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIGNvbnRhaW5lckVsbS5zaGFkb3dSb290ICYmIGNvbnRhaW5lckVsbS50YWdOYW1lID09PSBob3N0VGFnTmFtZSkge1xuICAgICAgICBjb250YWluZXJFbG0gPSBjb250YWluZXJFbG0uc2hhZG93Um9vdDtcbiAgICB9XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICBpZiAodm5vZGVzW3N0YXJ0SWR4XSkge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY3JlYXRlRWxtKG51bGwsIHBhcmVudFZOb2RlLCBzdGFydElkeCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bm9kZXNbc3RhcnRJZHhdLiRlbG0kID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsbS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBCVUlMRC5zbG90UmVsb2NhdGlvbiA/IHJlZmVyZW5jZU5vZGUoYmVmb3JlKSA6IGJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcmVtb3ZlVm5vZGVzID0gKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgdm5vZGUsIGVsbSkgPT4ge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgICAgaWYgKCh2bm9kZSA9IHZub2Rlc1tzdGFydElkeF0pKSB7XG4gICAgICAgICAgICBlbG0gPSB2bm9kZS4kZWxtJDtcbiAgICAgICAgICAgIGNhbGxOb2RlUmVmcyh2bm9kZSk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZW1vdmluZyB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG8gc2hvdyBzbG90IGZhbGxiYWNrIGNvbnRlbnQgbm93XG4gICAgICAgICAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGVsbVsncy1vbCddLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IGNoaWxkIG5vZGVzIG9mIHRoZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQncyBiZWluZyByZW1vdmVkIGFyZSBzbG90IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24oZWxtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIHZub2RlJ3MgZWxlbWVudCBmcm9tIHRoZSBkb21cbiAgICAgICAgICAgIGVsbS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB1cGRhdGVDaGlsZHJlbiA9IChwYXJlbnRFbG0sIG9sZENoLCBuZXdWTm9kZSwgbmV3Q2gpID0+IHtcbiAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgIGxldCBuZXdTdGFydElkeCA9IDA7XG4gICAgbGV0IGlkeEluT2xkID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZWxtVG9Nb3ZlO1xuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZub2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkRW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3RW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAob2xkU3RhcnRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnIHx8IG5ld0VuZFZub2RlLiR0YWckID09PSAnc2xvdCcpKSB7XG4gICAgICAgICAgICAgICAgcHV0QmFja0luT3JpZ2luYWxMb2NhdGlvbihvbGRTdGFydFZub2RlLiRlbG0kLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkU3RhcnRWbm9kZS4kZWxtJCwgb2xkRW5kVm5vZGUuJGVsbSQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgKG9sZFN0YXJ0Vm5vZGUuJHRhZyQgPT09ICdzbG90JyB8fCBuZXdFbmRWbm9kZS4kdGFnJCA9PT0gJ3Nsb3QnKSkge1xuICAgICAgICAgICAgICAgIHB1dEJhY2tJbk9yaWdpbmFsTG9jYXRpb24ob2xkRW5kVm5vZGUuJGVsbSQucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRFbmRWbm9kZS4kZWxtJCwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZUtleVRvT2xkSWR4XG4gICAgICAgICAgICBpZHhJbk9sZCA9IC0xO1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBvbGRTdGFydElkeDsgaSA8PSBvbGRFbmRJZHg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ2hbaV0gJiYgb2xkQ2hbaV0uJGtleSQgIT09IG51bGwgJiYgb2xkQ2hbaV0uJGtleSQgPT09IG5ld1N0YXJ0Vm5vZGUuJGtleSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21LZXkgJiYgaWR4SW5PbGQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLiR0YWckICE9PSBuZXdTdGFydFZub2RlLiR0YWckKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgaWR4SW5PbGQsIHBhcmVudEVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbG1Ub01vdmUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUVsbShvbGRDaCAmJiBvbGRDaFtuZXdTdGFydElkeF0sIG5ld1ZOb2RlLCBuZXdTdGFydElkeCwgcGFyZW50RWxtKTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpLmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2VOb2RlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUuJGVsbSQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLiRlbG0kLCBuZXdWTm9kZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChCVUlMRC51cGRhdGFibGUgJiYgbmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG59O1xuY29uc3QgaXNTYW1lVm5vZGUgPSAodm5vZGUxLCB2bm9kZTIpID0+IHtcbiAgICAvLyBjb21wYXJlIGlmIHR3byB2bm9kZSB0byBzZWUgaWYgdGhleSdyZSBcInRlY2huaWNhbGx5XCIgdGhlIHNhbWVcbiAgICAvLyBuZWVkIHRvIGhhdmUgdGhlIHNhbWUgZWxlbWVudCB0YWcsIGFuZCBzYW1lIGtleSB0byBiZSB0aGUgc2FtZVxuICAgIGlmICh2bm9kZTEuJHRhZyQgPT09IHZub2RlMi4kdGFnJCkge1xuICAgICAgICBpZiAoQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgdm5vZGUxLiR0YWckID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZTEuJG5hbWUkID09PSB2bm9kZTIuJG5hbWUkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC52ZG9tS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUxLiRrZXkkID09PSB2bm9kZTIuJGtleSQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCByZWZlcmVuY2VOb2RlID0gKG5vZGUpID0+IHtcbiAgICAvLyB0aGlzIG5vZGUgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBsb2NhdGlvbiBpbiB0aGUgZG9tXG4gICAgLy8gYmVjYXVzZSBvZiBzb21lIG90aGVyIGNvbXBvbmVudCdzIHNsb3RcbiAgICAvLyBidXQgd2Ugc3RpbGwgaGF2ZSBhbiBodG1sIGNvbW1lbnQgaW4gcGxhY2Ugb2Ygd2hlcmVcbiAgICAvLyBpdCdzIG9yaWdpbmFsIGxvY2F0aW9uIHdhcyBhY2NvcmRpbmcgdG8gaXQncyBvcmlnaW5hbCB2ZG9tXG4gICAgcmV0dXJuIChub2RlICYmIG5vZGVbJ3Mtb2wnXSkgfHwgbm9kZTtcbn07XG5jb25zdCBwYXJlbnRSZWZlcmVuY2VOb2RlID0gKG5vZGUpID0+IChub2RlWydzLW9sJ10gPyBub2RlWydzLW9sJ10gOiBub2RlKS5wYXJlbnROb2RlO1xuY29uc3QgcGF0Y2ggPSAob2xkVk5vZGUsIG5ld1ZOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxtID0gKG5ld1ZOb2RlLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQpO1xuICAgIGNvbnN0IG9sZENoaWxkcmVuID0gb2xkVk5vZGUuJGNoaWxkcmVuJDtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IG5ld1ZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgdGFnID0gbmV3Vk5vZGUuJHRhZyQ7XG4gICAgY29uc3QgdGV4dCA9IG5ld1ZOb2RlLiR0ZXh0JDtcbiAgICBsZXQgZGVmYXVsdEhvbGRlcjtcbiAgICBpZiAoIUJVSUxELnZkb21UZXh0IHx8IHRleHQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKEJVSUxELnN2Zykge1xuICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZW5kZXJpbmcgYW4gc3ZnIGVsZW1lbnQsIG9yIHN0aWxsIHJlbmRlcmluZyBub2RlcyBpbnNpZGUgb2Ygb25lXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGlzIHRvIHRoZSB3aGVuIHRoZSBjb21waWxlciBzZWVzIHdlJ3JlIHVzaW5nIGFuIHN2ZyBzb21ld2hlcmVcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRhZyA9PT0gJ3N2ZycgPyB0cnVlIDogdGFnID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbGVtZW50IG5vZGVcbiAgICAgICAgaWYgKEJVSUxELnZkb21BdHRyaWJ1dGUgfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgaWYgKEJVSUxELnNsb3QgJiYgdGFnID09PSAnc2xvdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBvZiBhbiBlbGVtZW50IE9SIGl0J3MgYW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gQU5EIHdlIGFscmVhZHkga25vdyBpdCdzIHBvc3NpYmxlIGl0IGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgZWxlbWVudCdzIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQob2xkVk5vZGUsIG5ld1ZOb2RlLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiYgb2xkQ2hpbGRyZW4gIT09IG51bGwgJiYgbmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvb2tzIGxpa2UgdGhlcmUncyBjaGlsZCB2bm9kZXMgZm9yIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZub2Rlc1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaGlsZHJlbiwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gb2xkIGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBuZXcgY2hpbGQgdm5vZGVzIHRvIGFkZFxuICAgICAgICAgICAgaWYgKEJVSUxELnVwZGF0YWJsZSAmJiBCVUlMRC52ZG9tVGV4dCAmJiBvbGRWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZub2RlIHdhcyB0ZXh0LCBzbyBiZSBzdXJlIHRvIGNsZWFyIGl0IG91dFxuICAgICAgICAgICAgICAgIGVsbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgdm5vZGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIG5ld1ZOb2RlLCBuZXdDaGlsZHJlbiwgMCwgbmV3Q2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQlVJTEQudXBkYXRhYmxlICYmIG9sZENoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBuZXcgY2hpbGQgdm5vZGVzLCBidXQgdGhlcmUgYXJlIG9sZCBjaGlsZCB2bm9kZXMgdG8gcmVtb3ZlXG4gICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2hpbGRyZW4sIDAsIG9sZENoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5zdmcgJiYgaXNTdmdNb2RlICYmIHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIEJVSUxELnNsb3RSZWxvY2F0aW9uICYmIChkZWZhdWx0SG9sZGVyID0gZWxtWydzLWNyJ10pKSB7XG4gICAgICAgIC8vIHRoaXMgZWxlbWVudCBoYXMgc2xvdHRlZCBjb250ZW50XG4gICAgICAgIGRlZmF1bHRIb2xkZXIucGFyZW50Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJVSUxELnZkb21UZXh0ICYmIG9sZFZOb2RlLiR0ZXh0JCAhPT0gdGV4dCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIHRleHQgb25seSB2bm9kZVxuICAgICAgICAvLyBhbmQgYWxzbyBvbmx5IGlmIHRoZSB0ZXh0IGlzIGRpZmZlcmVudCB0aGFuIGJlZm9yZVxuICAgICAgICBlbG0uZGF0YSA9IHRleHQ7XG4gICAgfVxufTtcbmNvbnN0IHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkgPSAoZWxtKSA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmVmZXItY29uc3RcbiAgICBsZXQgY2hpbGROb2RlcyA9IGVsbS5jaGlsZE5vZGVzO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgbGV0IGk7XG4gICAgbGV0IGlsZW47XG4gICAgbGV0IGo7XG4gICAgbGV0IHNsb3ROYW1lQXR0cjtcbiAgICBsZXQgbm9kZVR5cGU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG90IGZhbGxiYWNrIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHNsb3QgbmFtZSBmb3IgdGhpcyBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgc2xvdE5hbWVBdHRyID0gY2hpbGROb2RlWydzLXNuJ107XG4gICAgICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbHdheXMgc2hvdyBhIGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaGlkZSBpdCBpZiB0aGVyZSBhcmUgb3RoZXIgc2xvdHMgaW4gdGhlIGxpZ2h0IGRvbVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaWxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gY2hpbGROb2Rlc1tqXS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNbal1bJ3MtaG4nXSAhPT0gY2hpbGROb2RlWydzLWhuJ10gfHwgc2xvdE5hbWVBdHRyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzaWJsaW5nIG5vZGUgaXMgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgT1IgaXMgYSBuYW1lZCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyAmJiBzbG90TmFtZUF0dHIgPT09IGNoaWxkTm9kZXNbal0uZ2V0QXR0cmlidXRlKCdzbG90JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBkZWZhdWx0IGZhbGxiYWNrIHNsb3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IGVsZW1lbnQgb3IgdGV4dCBub2RlICh3aXRoIGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgaGlkZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBzbG90IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLyAmJiBjaGlsZE5vZGVzW2pdLnRleHRDb250ZW50LnRyaW0oKSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWVwIGRyaWxsaW5nIGRvd25cbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCByZWxvY2F0ZU5vZGVzID0gW107XG5jb25zdCByZWxvY2F0ZVNsb3RDb250ZW50ID0gKGVsbSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWNvbnN0XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgaG9zdENvbnRlbnROb2RlcztcbiAgICBsZXQgc2xvdE5hbWVBdHRyO1xuICAgIGxldCByZWxvY2F0ZU5vZGVEYXRhO1xuICAgIGxldCBqO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY2hpbGROb2RlcyA9IGVsbS5jaGlsZE5vZGVzO1xuICAgIGxldCBpbGVuID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZVsncy1zciddICYmIChub2RlID0gY2hpbGROb2RlWydzLWNyJ10pICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgZ290IHRoZSBjb250ZW50IHJlZmVyZW5jZSBjb21tZW50IG5vZGVcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZ290IGl0J3MgcGFyZW50LCB3aGljaCBpcyB3aGVyZSBhbGwgdGhlIGhvc3QgY29udGVudCBpcyBpbiBub3dcbiAgICAgICAgICAgIGhvc3RDb250ZW50Tm9kZXMgPSBub2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHNsb3ROYW1lQXR0ciA9IGNoaWxkTm9kZVsncy1zbiddO1xuICAgICAgICAgICAgZm9yIChqID0gaG9zdENvbnRlbnROb2Rlcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBob3N0Q29udGVudE5vZGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVsncy1jbiddICYmICFub2RlWydzLW5yJ10gJiYgbm9kZVsncy1obiddICE9PSBjaGlsZE5vZGVbJ3MtaG4nXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBkbyBzb21lIHJlbG9jYXRpbmcgdG8gaXRzIG5ldyBob21lXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBuZXZlciByZWxvY2F0ZSBhIGNvbnRlbnQgcmVmZXJlbmNlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBpcyBzdXBwb3NlIHRvIGFsd2F5cyByZXByZXNlbnQgdGhlIG9yaWdpbmFsIGNvbnRlbnQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZUxvY2F0ZWRJblNsb3Qobm9kZSwgc2xvdE5hbWVBdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB3ZSd2ZSBhbHJlYWR5IGRlY2lkZWQgdG8gcmVsb2NhdGUgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFkZSBzb21lIGNoYW5nZXMgdG8gc2xvdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB3ZSBhbHNvIGRvdWJsZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2tzIGFyZSBjb3JyZWN0bHkgaGlkZGVuIG9yIHNob3duXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1zbiddID0gbm9kZVsncy1zbiddIHx8IHNsb3ROYW1lQXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZU5vZGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNseSB3ZSBuZXZlciBmb3VuZCBhIHNsb3QgaG9tZSBmb3IgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHR1cm5zIG91dCB3ZSBkaWQsIHNvIGxldCdzIHJlbWVtYmVyIGl0IG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZURhdGEuJHNsb3RSZWZOb2RlJCA9IGNoaWxkTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byBvdXIgbGlzdCBvZiBub2RlcyB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzbG90UmVmTm9kZSQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlWydzLXNyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVzLm1hcCgocmVsb2NhdGVOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVMb2NhdGVkSW5TbG90KHJlbG9jYXRlTm9kZS4kbm9kZVRvUmVsb2NhdGUkLCBub2RlWydzLXNuJ10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxvY2F0ZU5vZGVEYXRhID0gcmVsb2NhdGVOb2Rlcy5maW5kKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbG9jYXRlTm9kZURhdGEgJiYgIXJlbG9jYXRlTm9kZS4kc2xvdFJlZk5vZGUkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2NhdGVOb2RlLiRzbG90UmVmTm9kZSQgPSByZWxvY2F0ZU5vZGVEYXRhLiRzbG90UmVmTm9kZSQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVsb2NhdGVOb2Rlcy5zb21lKChyKSA9PiByLiRub2RlVG9SZWxvY2F0ZSQgPT09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmYXIgdGhpcyBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBzbG90IGhvbWUsIG5vdCBzZXR0aW5nIHNsb3RSZWZOb2RlIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIG5ldmVyIGZpbmQgYSBob21lIGZvciB0aGlzIGVsZW1lbnQgdGhlbiB3ZSdsbCBuZWVkIHRvIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbG9jYXRlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJG5vZGVUb1JlbG9jYXRlJDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgICAgIHJlbG9jYXRlU2xvdENvbnRlbnQoY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpc05vZGVMb2NhdGVkSW5TbG90ID0gKG5vZGVUb1JlbG9jYXRlLCBzbG90TmFtZUF0dHIpID0+IHtcbiAgICBpZiAobm9kZVRvUmVsb2NhdGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLmdldEF0dHJpYnV0ZSgnc2xvdCcpID09PSBudWxsICYmIHNsb3ROYW1lQXR0ciA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlVG9SZWxvY2F0ZS5nZXRBdHRyaWJ1dGUoJ3Nsb3QnKSA9PT0gc2xvdE5hbWVBdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlVG9SZWxvY2F0ZVsncy1zbiddID09PSBzbG90TmFtZUF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90TmFtZUF0dHIgPT09ICcnO1xufTtcbmNvbnN0IGNhbGxOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICAgIGlmIChCVUlMRC52ZG9tUmVmKSB7XG4gICAgICAgIHZOb2RlLiRhdHRycyQgJiYgdk5vZGUuJGF0dHJzJC5yZWYgJiYgdk5vZGUuJGF0dHJzJC5yZWYobnVsbCk7XG4gICAgICAgIHZOb2RlLiRjaGlsZHJlbiQgJiYgdk5vZGUuJGNoaWxkcmVuJC5tYXAoY2FsbE5vZGVSZWZzKTtcbiAgICB9XG59O1xuY29uc3QgcmVuZGVyVmRvbSA9IChob3N0UmVmLCByZW5kZXJGblJlc3VsdHMpID0+IHtcbiAgICBjb25zdCBob3N0RWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICBjb25zdCBvbGRWTm9kZSA9IGhvc3RSZWYuJHZub2RlJCB8fCBuZXdWTm9kZShudWxsLCBudWxsKTtcbiAgICBjb25zdCByb290Vm5vZGUgPSBpc0hvc3QocmVuZGVyRm5SZXN1bHRzKSA/IHJlbmRlckZuUmVzdWx0cyA6IGgobnVsbCwgbnVsbCwgcmVuZGVyRm5SZXN1bHRzKTtcbiAgICBob3N0VGFnTmFtZSA9IGhvc3RFbG0udGFnTmFtZTtcbiAgICAvLyA8SG9zdD4gcnVudGltZSBjaGVja1xuICAgIGlmIChCVUlMRC5pc0RldiAmJiBBcnJheS5pc0FycmF5KHJlbmRlckZuUmVzdWx0cykgJiYgcmVuZGVyRm5SZXN1bHRzLnNvbWUoaXNIb3N0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8SG9zdD4gbXVzdCBiZSB0aGUgc2luZ2xlIHJvb3QgY29tcG9uZW50LlxuTG9va3MgbGlrZSB0aGUgcmVuZGVyKCkgZnVuY3Rpb24gb2YgXCIke2hvc3RUYWdOYW1lLnRvTG93ZXJDYXNlKCl9XCIgaXMgcmV0dXJuaW5nIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIDxIb3N0Pi5cblxuVGhlIHJlbmRlcigpIGZ1bmN0aW9uIHNob3VsZCBsb29rIGxpa2UgdGhpcyBpbnN0ZWFkOlxuXG5yZW5kZXIoKSB7XG4gIC8vIERvIG5vdCByZXR1cm4gYW4gYXJyYXlcbiAgcmV0dXJuIChcbiAgICA8SG9zdD57Y29udGVudH08L0hvc3Q+XG4gICk7XG59XG4gIGApO1xuICAgIH1cbiAgICBpZiAoQlVJTEQucmVmbGVjdCAmJiBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQpIHtcbiAgICAgICAgcm9vdFZub2RlLiRhdHRycyQgPSByb290Vm5vZGUuJGF0dHJzJCB8fCB7fTtcbiAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLm1hcCgoW3Byb3BOYW1lLCBhdHRyaWJ1dGVdKSA9PiAocm9vdFZub2RlLiRhdHRycyRbYXR0cmlidXRlXSA9IGhvc3RFbG1bcHJvcE5hbWVdKSk7XG4gICAgfVxuICAgIHJvb3RWbm9kZS4kdGFnJCA9IG51bGw7XG4gICAgcm9vdFZub2RlLiRmbGFncyQgfD0gNCAvKiBpc0hvc3QgKi87XG4gICAgaG9zdFJlZi4kdm5vZGUkID0gcm9vdFZub2RlO1xuICAgIHJvb3RWbm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kID0gKEJVSUxELnNoYWRvd0RvbSA/IGhvc3RFbG0uc2hhZG93Um9vdCB8fCBob3N0RWxtIDogaG9zdEVsbSk7XG4gICAgaWYgKEJVSUxELnNjb3BlZCB8fCBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgc2NvcGVJZCA9IGhvc3RFbG1bJ3Mtc2MnXTtcbiAgICB9XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnRlbnRSZWYgPSBob3N0RWxtWydzLWNyJ107XG4gICAgICAgIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IHN1cHBvcnRzU2hhZG93ICYmIChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pICE9PSAwO1xuICAgICAgICAvLyBhbHdheXMgcmVzZXRcbiAgICAgICAgY2hlY2tTbG90RmFsbGJhY2tWaXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIHN5bmNocm9ub3VzIHBhdGNoXG4gICAgcGF0Y2gob2xkVk5vZGUsIHJvb3RWbm9kZSk7XG4gICAgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgIC8vIHdoaWxlIHdlJ3JlIG1vdmluZyBub2RlcyBhcm91bmQgZXhpc3Rpbmcgbm9kZXMsIHRlbXBvcmFyaWx5IGRpc2FibGVcbiAgICAgICAgLy8gdGhlIGRpc2Nvbm5lY3RDYWxsYmFjayBmcm9tIHdvcmtpbmdcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgaWYgKGNoZWNrU2xvdFJlbG9jYXRlKSB7XG4gICAgICAgICAgICByZWxvY2F0ZVNsb3RDb250ZW50KHJvb3RWbm9kZS4kZWxtJCk7XG4gICAgICAgICAgICBsZXQgcmVsb2NhdGVEYXRhO1xuICAgICAgICAgICAgbGV0IG5vZGVUb1JlbG9jYXRlO1xuICAgICAgICAgICAgbGV0IG9yZ0xvY2F0aW9uTm9kZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnROb2RlUmVmO1xuICAgICAgICAgICAgbGV0IGluc2VydEJlZm9yZU5vZGU7XG4gICAgICAgICAgICBsZXQgcmVmTm9kZTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVsb2NhdGVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbG9jYXRlRGF0YSA9IHJlbG9jYXRlTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVsb2NhdGUgPSByZWxvY2F0ZURhdGEuJG5vZGVUb1JlbG9jYXRlJDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLW9sJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgcmVmZXJlbmNlIG5vZGUgbWFya2luZyB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBmb3IgbGF0ZXIgbG9va3Vwc1xuICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgQlVJTEQuaXNEZWJ1ZyB8fCBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxMb2NhdGlvbkRlYnVnTm9kZShub2RlVG9SZWxvY2F0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvYy5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZVsncy1uciddID0gbm9kZVRvUmVsb2NhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKChub2RlVG9SZWxvY2F0ZVsncy1vbCddID0gb3JnTG9jYXRpb25Ob2RlKSwgbm9kZVRvUmVsb2NhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZWxvY2F0ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVsb2NhdGVEYXRhID0gcmVsb2NhdGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZSA9IHJlbG9jYXRlRGF0YS4kbm9kZVRvUmVsb2NhdGUkO1xuICAgICAgICAgICAgICAgIGlmIChyZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlJ3JlIGp1c3QgZ29pbmcgdG8gaW5zZXJ0IGl0IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzbG90IHJlZmVyZW5jZSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGVSZWYgPSByZWxvY2F0ZURhdGEuJHNsb3RSZWZOb2RlJC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVsb2NhdGVEYXRhLiRzbG90UmVmTm9kZSQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZSA9IG5vZGVUb1JlbG9jYXRlWydzLW9sJ107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgob3JnTG9jYXRpb25Ob2RlID0gb3JnTG9jYXRpb25Ob2RlLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSBvcmdMb2NhdGlvbk5vZGVbJ3MtbnInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZOb2RlICYmIHJlZk5vZGVbJ3Mtc24nXSA9PT0gbm9kZVRvUmVsb2NhdGVbJ3Mtc24nXSAmJiBwYXJlbnROb2RlUmVmID09PSByZWZOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gcmVmTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZk5vZGUgfHwgIXJlZk5vZGVbJ3MtbnInXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gcmVmTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWluc2VydEJlZm9yZU5vZGUgJiYgcGFyZW50Tm9kZVJlZiAhPT0gbm9kZVRvUmVsb2NhdGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbG9jYXRlLm5leHRTaWJsaW5nICE9PSBpbnNlcnRCZWZvcmVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBjaGVja2VkIHRoYXQgaXQncyB3b3J0aCB3aGlsZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhhdCB0aGUgbm9kZSB0byByZWxvY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IG5leHQgc2libGluZyBvciBwYXJlbnQgcmVsb2NhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRvUmVsb2NhdGUgIT09IGluc2VydEJlZm9yZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVUb1JlbG9jYXRlWydzLWhuJ10gJiYgbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9iYWJseSBhIGNvbXBvbmVudCBpbiB0aGUgaW5kZXguaHRtbCB0aGF0IGRvZXNuJ3QgaGF2ZSBpdCdzIGhvc3RuYW1lIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZVsncy1obiddID0gbm9kZVRvUmVsb2NhdGVbJ3Mtb2wnXS5wYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXQgYmFjayB0byB0aGUgZG9tIGJ1dCBpbiBpdHMgbmV3IGhvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlUmVmLmluc2VydEJlZm9yZShub2RlVG9SZWxvY2F0ZSwgaW5zZXJ0QmVmb3JlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2Vzbid0IGhhdmUgYSBzbG90IGhvbWUgdG8gZ28gdG8sIHNvIGxldCdzIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUb1JlbG9jYXRlLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZWxvY2F0ZS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja1Nsb3RGYWxsYmFja1Zpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrU2xvdFZpc2liaWxpdHkocm9vdFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb25lIG1vdmluZyBub2RlcyBhcm91bmRcbiAgICAgICAgLy8gYWxsb3cgdGhlIGRpc2Nvbm5lY3QgY2FsbGJhY2sgdG8gd29yayBhZ2FpblxuICAgICAgICBwbHQuJGZsYWdzJCAmPSB+MSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLztcbiAgICAgICAgLy8gYWx3YXlzIHJlc2V0XG4gICAgICAgIHJlbG9jYXRlTm9kZXMubGVuZ3RoID0gMDtcbiAgICB9XG59O1xuLy8gc2xvdCBjb21tZW50IGRlYnVnIG5vZGVzIG9ubHkgY3JlYXRlZCB3aXRoIHRoZSBgLS1kZWJ1Z2AgZmxhZ1xuLy8gb3RoZXJ3aXNlIHRoZXNlIG5vZGVzIGFyZSB0ZXh0IG5vZGVzIHcvb3V0IGNvbnRlbnRcbmNvbnN0IHNsb3RSZWZlcmVuY2VEZWJ1Z05vZGUgPSAoc2xvdFZOb2RlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgPHNsb3Qke3Nsb3RWTm9kZS4kbmFtZSQgPyAnIG5hbWU9XCInICsgc2xvdFZOb2RlLiRuYW1lJCArICdcIicgOiAnJ30+IChob3N0PSR7aG9zdFRhZ05hbWUudG9Mb3dlckNhc2UoKX0pYCk7XG5jb25zdCBvcmlnaW5hbExvY2F0aW9uRGVidWdOb2RlID0gKG5vZGVUb1JlbG9jYXRlKSA9PiBkb2MuY3JlYXRlQ29tbWVudChgb3JnLWxvY2F0aW9uIGZvciBgICtcbiAgICAobm9kZVRvUmVsb2NhdGUubG9jYWxOYW1lXG4gICAgICAgID8gYDwke25vZGVUb1JlbG9jYXRlLmxvY2FsTmFtZX0+IChob3N0PSR7bm9kZVRvUmVsb2NhdGVbJ3MtaG4nXX0pYFxuICAgICAgICA6IGBbJHtub2RlVG9SZWxvY2F0ZS50ZXh0Q29udGVudH1dYCkpO1xuY29uc3QgZ2V0RWxlbWVudCA9IChyZWYpID0+IChCVUlMRC5sYXp5TG9hZCA/IGdldEhvc3RSZWYocmVmKS4kaG9zdEVsZW1lbnQkIDogcmVmKTtcbmNvbnN0IGNyZWF0ZUV2ZW50ID0gKHJlZiwgbmFtZSwgZmxhZ3MpID0+IHtcbiAgICBjb25zdCBlbG0gPSBnZXRFbGVtZW50KHJlZik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1pdDogKGRldGFpbCkgPT4ge1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2ICYmICFlbG0uaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIFwiJHtuYW1lfVwiIGV2ZW50IHdhcyBlbWl0dGVkLCBidXQgdGhlIGRpc3BhdGNoZXIgbm9kZSBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBkb20uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW1pdEV2ZW50KGVsbSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEhKGZsYWdzICYgNCAvKiBCdWJibGVzICovKSxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogISEoZmxhZ3MgJiAyIC8qIENvbXBvc2VkICovKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhIShmbGFncyAmIDEgLyogQ2FuY2VsbGFibGUgKi8pLFxuICAgICAgICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlICYgZGlzcGF0Y2ggYSBjdXN0b20gRXZlbnQgb24gYSBwcm92aWRlZCB0YXJnZXRcbiAqIEBwYXJhbSBlbG0gdGhlIHRhcmdldCBvZiB0aGUgRXZlbnRcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIHRvIGdpdmUgdGhlIGN1c3RvbSBFdmVudFxuICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgYSBjdXN0b20gRXZlbnRcbiAqIEByZXR1cm5zIHRoZSBjdXN0b20gRXZlbnRcbiAqL1xuY29uc3QgZW1pdEV2ZW50ID0gKGVsbSwgbmFtZSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IGV2ID0gcGx0LmNlKG5hbWUsIG9wdHMpO1xuICAgIGVsbS5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICByZXR1cm4gZXY7XG59O1xuY29uc3QgYXR0YWNoVG9BbmNlc3RvciA9IChob3N0UmVmLCBhbmNlc3RvckNvbXBvbmVudCkgPT4ge1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgYW5jZXN0b3JDb21wb25lbnQgJiYgIWhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXS5wdXNoKG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHIpKSk7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVkdWxlVXBkYXRlID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBpZiAoQlVJTEQudGFza1F1ZXVlICYmIEJVSUxELnVwZGF0YWJsZSkge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcgJiYgaG9zdFJlZi4kZmxhZ3MkICYgNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLykge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi87XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQpO1xuICAgIC8vIHRoZXJlIGlzIG5vIGFuY2VzdG9yIGNvbXBvbmVudCBvciB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgLy8gaGFzIGFscmVhZHkgZmlyZWQgb2ZmIGl0cyBsaWZlY3ljbGUgdXBkYXRlIHRoZW5cbiAgICAvLyBmaXJlIG9mZiB0aGUgaW5pdGlhbCB1cGRhdGVcbiAgICBjb25zdCBkaXNwYXRjaCA9ICgpID0+IGRpc3BhdGNoSG9va3MoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCk7XG4gICAgcmV0dXJuIEJVSUxELnRhc2tRdWV1ZSA/IHdyaXRlVGFzayhkaXNwYXRjaCkgOiBkaXNwYXRjaCgpO1xufTtcbmNvbnN0IGRpc3BhdGNoSG9va3MgPSAoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoJ3NjaGVkdWxlVXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMjU2IC8qIGlzTGlzdGVuUmVhZHkgKi87XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCkge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQubWFwKChbbWV0aG9kTmFtZSwgZXZlbnRdKSA9PiBzYWZlQ2FsbChpbnN0YW5jZSwgbWV0aG9kTmFtZSwgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgaWYgKEJVSUxELmNtcFdpbGxMb2FkKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsTG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICBpZiAoQlVJTEQuY21wV2lsbFVwZGF0ZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRMaWZlY3ljbGVFdmVudChlbG0sICdjb21wb25lbnRXaWxsUmVuZGVyJyk7XG4gICAgaWYgKEJVSUxELmNtcFdpbGxSZW5kZXIpIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoZW4ocHJvbWlzZSwgKCkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnRXaWxsUmVuZGVyJykpO1xuICAgIH1cbiAgICBlbmRTY2hlZHVsZSgpO1xuICAgIHJldHVybiB0aGVuKHByb21pc2UsICgpID0+IHVwZGF0ZUNvbXBvbmVudChob3N0UmVmLCBpbnN0YW5jZSwgaXNJbml0aWFsTG9hZCkpO1xufTtcbmNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IGFzeW5jIChob3N0UmVmLCBpbnN0YW5jZSwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBlbmRVcGRhdGUgPSBjcmVhdGVUaW1lKCd1cGRhdGUnLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIGNvbnN0IHJjID0gZWxtWydzLXJjJ107XG4gICAgaWYgKEJVSUxELnN0eWxlICYmIGlzSW5pdGlhbExvYWQpIHtcbiAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gICAgfVxuICAgIGNvbnN0IGVuZFJlbmRlciA9IGNyZWF0ZVRpbWUoJ3JlbmRlcicsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgYXdhaXQgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSwgZWxtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGxSZW5kZXIoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgcGx0LiRjc3NTaGltJC51cGRhdGVIb3N0KGVsbSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICBob3N0UmVmLiRyZW5kZXJDb3VudCQrKztcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xMDI0IC8qIGRldk9uUmVuZGVyICovO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG1hbnVhbGx5IGNvbm5lY3RlZCBjaGlsZCBjb21wb25lbnRzIGR1cmluZyBzZXJ2ZXItc2lkZSBoeWRyYXRlXG4gICAgICAgICAgICBzZXJ2ZXJTaWRlQ29ubmVjdGVkKGVsbSk7XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgICAgICAgICAgIC8vIHVzaW5nIG9ubHkgZHVyaW5nIHNlcnZlci1zaWRlIGh5ZHJhdGVcbiAgICAgICAgICAgICAgICBpZiAoaG9zdFJlZi4kY21wTWV0YSQuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbG1bJ3MtZW4nXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChob3N0UmVmLiRjbXBNZXRhJC4kZmxhZ3MkICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbVsncy1lbiddID0gJ2MnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiByYykge1xuICAgICAgICAvLyBvaywgc28gdHVybnMgb3V0IHRoZXJlIGFyZSBzb21lIGNoaWxkIGhvc3QgZWxlbWVudHNcbiAgICAgICAgLy8gd2FpdGluZyBvbiB0aGlzIHBhcmVudCBlbGVtZW50IHRvIGxvYWRcbiAgICAgICAgLy8gbGV0J3MgZmlyZSBvZmYgYWxsIHVwZGF0ZSBjYWxsYmFja3Mgd2FpdGluZ1xuICAgICAgICByYy5tYXAoKGNiKSA9PiBjYigpKTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZFJlbmRlcigpO1xuICAgIGVuZFVwZGF0ZSgpO1xuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Qcm9taXNlcyA9IGVsbVsncy1wJ107XG4gICAgICAgIGNvbnN0IHBvc3RVcGRhdGUgPSAoKSA9PiBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgICAgICBpZiAoY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBvc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuUHJvbWlzZXMpLnRoZW4ocG9zdFVwZGF0ZSk7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLztcbiAgICAgICAgICAgIGNoaWxkcmVuUHJvbWlzZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zdFVwZGF0ZUNvbXBvbmVudChob3N0UmVmKTtcbiAgICB9XG59O1xuY29uc3QgY2FsbFJlbmRlciA9IChob3N0UmVmLCBpbnN0YW5jZSwgZWxtKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgZm9yIGJ1bmRsZXJzIHRvIGNvcnJlY3RseSB0cmVlc2hha2UgdGhlIEJVSUxEIG9iamVjdFxuICAgIC8vIHdlIG5lZWQgdG8gZW5zdXJlIEJVSUxEIGlzIG5vdCBkZW9wdGltaXplZCB3aXRoaW4gYSB0cnkvY2F0Y2hcbiAgICAvLyBodHRwczovL3JvbGx1cGpzLm9yZy9ndWlkZS9lbi8jdHJlZXNoYWtlIHRyeUNhdGNoRGVvcHRpbWl6YXRpb25cbiAgICBjb25zdCBhbGxSZW5kZXJGbiA9IEJVSUxELmFsbFJlbmRlckZuID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IGxhenlMb2FkID0gQlVJTEQubGF6eUxvYWQgPyB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgdGFza1F1ZXVlID0gQlVJTEQudGFza1F1ZXVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IHVwZGF0YWJsZSA9IEJVSUxELnVwZGF0YWJsZSA/IHRydWUgOiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICByZW5kZXJpbmdSZWYgPSBpbnN0YW5jZTtcbiAgICAgICAgaW5zdGFuY2UgPSBhbGxSZW5kZXJGbiA/IGluc3RhbmNlLnJlbmRlcigpIDogaW5zdGFuY2UucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICBpZiAodXBkYXRhYmxlICYmIHRhc2tRdWV1ZSkge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4xNiAvKiBpc1F1ZXVlZEZvclVwZGF0ZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRhYmxlIHx8IGxhenlMb2FkKSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMiAvKiBoYXNSZW5kZXJlZCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQlVJTEQuaGFzUmVuZGVyRm4gfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgaWYgKEJVSUxELnZkb21SZW5kZXIgfHwgQlVJTEQucmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGxvb2tzIGxpa2Ugd2UndmUgZ290IGNoaWxkIG5vZGVzIHRvIHJlbmRlciBpbnRvIHRoaXMgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2UgbmVlZCB0byB1cGRhdGUgdGhlIGNzcyBjbGFzcy9hdHRycyBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluc3RhbmNlKS50aGVuKCh2YWx1ZSkgPT4gcmVuZGVyVmRvbShob3N0UmVmLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVmRvbShob3N0UmVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUsIGhvc3RSZWYuJGhvc3RFbGVtZW50JCk7XG4gICAgfVxuICAgIHJlbmRlcmluZ1JlZiA9IG51bGw7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0UmVuZGVyaW5nUmVmID0gKCkgPT4gcmVuZGVyaW5nUmVmO1xuY29uc3QgcG9zdFVwZGF0ZUNvbXBvbmVudCA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJDtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kUG9zdFVwZGF0ZSA9IGNyZWF0ZVRpbWUoJ3Bvc3RVcGRhdGUnLCB0YWdOYW1lKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA6IGVsbTtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JDtcbiAgICBpZiAoQlVJTEQuY21wRGlkUmVuZGVyKSB7XG4gICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb21wb25lbnREaWRSZW5kZXInKTtcbiAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFJlbmRlcicpO1xuICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLykpIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLztcbiAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZyAmJiBCVUlMRC5jc3NBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gRE9NIFdSSVRFIVxuICAgICAgICAgICAgYWRkSHlkcmF0ZWRGbGFnKGVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELmNtcERpZExvYWQpIHtcbiAgICAgICAgICAgIGlmIChCVUlMRC5pc0Rldikge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICAgICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4yMDQ4IC8qIGRldk9uRGlkTG9hZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbWl0TGlmZWN5Y2xlRXZlbnQoZWxtLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJChlbG0pO1xuICAgICAgICAgICAgaWYgKCFhbmNlc3RvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGFwcERpZExvYWQodGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgbG9hZGVkIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiB0aGUgdXNlcidzIGNvbXBvbmVudERpZFVwZGF0ZSBtZXRob2QgKGlmIG9uZSB3YXMgcHJvdmlkZWQpXG4gICAgICAgICAgICAvLyBjb21wb25lbnREaWRVcGRhdGUgcnVucyBBRlRFUiByZW5kZXIoKSBoYXMgYmVlbiBjYWxsZWRcbiAgICAgICAgICAgIC8vIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTAyNCAvKiBkZXZPblJlbmRlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjEwMjQgLyogZGV2T25SZW5kZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpZmVjeWNsZUV2ZW50KGVsbSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICBlbmRQb3N0VXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICBlbG1bJ3MtaG1yLWxvYWQnXSAmJiBlbG1bJ3MtaG1yLWxvYWQnXSgpO1xuICAgIH1cbiAgICBpZiAoQlVJTEQubWV0aG9kICYmIEJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uSW5zdGFuY2VSZXNvbHZlJChlbG0pO1xuICAgIH1cbiAgICAvLyBsb2FkIGV2ZW50cyBmaXJlIGZyb20gYm90dG9tIHRvIHRvcFxuICAgIC8vIHRoZSBkZWVwZXN0IGVsZW1lbnRzIGxvYWQgZmlyc3QgdGhlbiBidWJibGVzIHVwXG4gICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICBpZiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCkge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCgpO1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgNTEyIC8qIG5lZWRzUmVyZW5kZXIgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4oNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyB8IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKTtcbiAgICB9XG4gICAgLy8gKCDigKJf4oCiKVxuICAgIC8vICgg4oCiX+KAoik+4oyQ4pagLeKWoFxuICAgIC8vICjijJDilqBf4pagKVxufTtcbmNvbnN0IGZvcmNlVXBkYXRlID0gKHJlZikgPT4ge1xuICAgIGlmIChCVUlMRC51cGRhdGFibGUpIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBob3N0UmVmLiRob3N0RWxlbWVudCQuaXNDb25uZWN0ZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCAmJlxuICAgICAgICAgICAgKGhvc3RSZWYuJGZsYWdzJCAmICgyIC8qIGhhc1JlbmRlcmVkICovIHwgMTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi8pKSA9PT0gMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgXCJ0cnVlXCIgd2hlbiB0aGUgZm9yY2VkIHVwZGF0ZSB3YXMgc3VjY2Vzc2Z1bGx5IHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICAgIC8vIG9uIGFwcGxvYWRcbiAgICAvLyB3ZSBoYXZlIGZpbmlzaCB0aGUgZmlyc3QgYmlnIGluaXRpYWwgcmVuZGVyXG4gICAgaWYgKEJVSUxELmNzc0Fubm90YXRpb25zKSB7XG4gICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhkb2MuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sICdhcHBsb2FkJywgeyBkZXRhaWw6IHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0UgfSB9KSk7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWVhc3VyZSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGBbU3RlbmNpbF0gJHtOQU1FU1BBQ0V9IGluaXRpYWwgbG9hZCAoYnkgJHt3aG99KWAsICdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG59O1xuY29uc3Qgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlW21ldGhvZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHRoZW4gPSAocHJvbWlzZSwgdGhlbkZuKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuID8gcHJvbWlzZS50aGVuKHRoZW5GbikgOiB0aGVuRm4oKTtcbn07XG5jb25zdCBlbWl0TGlmZWN5Y2xlRXZlbnQgPSAoZWxtLCBsaWZlY3ljbGVOYW1lKSA9PiB7XG4gICAgaWYgKEJVSUxELmxpZmVjeWNsZURPTUV2ZW50cykge1xuICAgICAgICBlbWl0RXZlbnQoZWxtLCAnc3RlbmNpbF8nICsgbGlmZWN5Y2xlTmFtZSwge1xuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBOQU1FU1BBQ0UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgYWRkSHlkcmF0ZWRGbGFnID0gKGVsbSkgPT4gQlVJTEQuaHlkcmF0ZWRDbGFzc1xuICAgID8gZWxtLmNsYXNzTGlzdC5hZGQoJ2h5ZHJhdGVkJylcbiAgICA6IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlXG4gICAgICAgID8gZWxtLnNldEF0dHJpYnV0ZSgnaHlkcmF0ZWQnLCAnJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5jb25zdCBzZXJ2ZXJTaWRlQ29ubmVjdGVkID0gKGVsbSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxtLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkRWxtLmNvbm5lY3RlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRFbG0uY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcnZlclNpZGVDb25uZWN0ZWQoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGluaXRpYWxpemVDbGllbnRIeWRyYXRlID0gKGhvc3RFbG0sIHRhZ05hbWUsIGhvc3RJZCwgaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IGVuZEh5ZHJhdGUgPSBjcmVhdGVUaW1lKCdoeWRyYXRlQ2xpZW50JywgdGFnTmFtZSk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IGhvc3RFbG0uc2hhZG93Um9vdDtcbiAgICBjb25zdCBjaGlsZFJlbmRlck5vZGVzID0gW107XG4gICAgY29uc3Qgc2xvdE5vZGVzID0gW107XG4gICAgY29uc3Qgc2hhZG93Um9vdE5vZGVzID0gQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3QgPyBbXSA6IG51bGw7XG4gICAgY29uc3Qgdm5vZGUgPSAoaG9zdFJlZi4kdm5vZGUkID0gbmV3Vk5vZGUodGFnTmFtZSwgbnVsbCkpO1xuICAgIGlmICghcGx0LiRvcmdMb2NOb2RlcyQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShkb2MuYm9keSwgKHBsdC4kb3JnTG9jTm9kZXMkID0gbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIGhvc3RFbG1bSFlEUkFURV9JRF0gPSBob3N0SWQ7XG4gICAgaG9zdEVsbS5yZW1vdmVBdHRyaWJ1dGUoSFlEUkFURV9JRCk7XG4gICAgY2xpZW50SHlkcmF0ZSh2bm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIGhvc3RFbG0sIGhvc3RJZCk7XG4gICAgY2hpbGRSZW5kZXJOb2Rlcy5tYXAoKGMpID0+IHtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25JZCA9IGMuJGhvc3RJZCQgKyAnLicgKyBjLiRub2RlSWQkO1xuICAgICAgICBjb25zdCBvcmdMb2NhdGlvbk5vZGUgPSBwbHQuJG9yZ0xvY05vZGVzJC5nZXQob3JnTG9jYXRpb25JZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjLiRlbG0kO1xuICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlICYmIHN1cHBvcnRzU2hhZG93ICYmIG9yZ0xvY2F0aW9uTm9kZVsncy1lbiddID09PSAnJykge1xuICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG9yZ0xvY2F0aW9uTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgICAgICBub2RlWydzLWhuJ10gPSB0YWdOYW1lO1xuICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uTm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGVbJ3Mtb2wnXSA9IG9yZ0xvY2F0aW9uTm9kZTtcbiAgICAgICAgICAgICAgICBub2RlWydzLW9sJ11bJ3MtbnInXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGx0LiRvcmdMb2NOb2RlcyQuZGVsZXRlKG9yZ0xvY2F0aW9uSWQpO1xuICAgIH0pO1xuICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc2hhZG93Um9vdCkge1xuICAgICAgICBzaGFkb3dSb290Tm9kZXMubWFwKChzaGFkb3dSb290Tm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzaGFkb3dSb290Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRIeWRyYXRlKCk7XG59O1xuY29uc3QgY2xpZW50SHlkcmF0ZSA9IChwYXJlbnRWTm9kZSwgY2hpbGRSZW5kZXJOb2Rlcywgc2xvdE5vZGVzLCBzaGFkb3dSb290Tm9kZXMsIGhvc3RFbG0sIG5vZGUsIGhvc3RJZCkgPT4ge1xuICAgIGxldCBjaGlsZE5vZGVUeXBlO1xuICAgIGxldCBjaGlsZElkU3BsdDtcbiAgICBsZXQgY2hpbGRWTm9kZTtcbiAgICBsZXQgaTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBjaGlsZE5vZGVUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoSFlEUkFURV9DSElMRF9JRCk7XG4gICAgICAgIGlmIChjaGlsZE5vZGVUeXBlKSB7XG4gICAgICAgICAgICAvLyBnb3QgdGhlIG5vZGUgZGF0YSBmcm9tIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlXG4gICAgICAgICAgICAvLyBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgICAgIGNoaWxkSWRTcGx0ID0gY2hpbGROb2RlVHlwZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSWRTcGx0WzBdID09PSBob3N0SWQgfHwgY2hpbGRJZFNwbHRbMF0gPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFswXSxcbiAgICAgICAgICAgICAgICAgICAgJG5vZGVJZCQ6IGNoaWxkSWRTcGx0WzFdLFxuICAgICAgICAgICAgICAgICAgICAkZGVwdGgkOiBjaGlsZElkU3BsdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgICAgICR0YWckOiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICRhdHRycyQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkbmFtZSQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICR0ZXh0JDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkUmVuZGVyTm9kZXMucHVzaChjaGlsZFZOb2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lEKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbmV3IGNoaWxkIHZub2RlXG4gICAgICAgICAgICAgICAgLy8gc28gZW5zdXJlIGl0cyBwYXJlbnQgdm5vZGUgaGFzIHRoZSB2Y2hpbGRyZW4gYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgb3VyIGNoaWxkIHZub2RlIHRvIGEgc3BlY2lmaWMgaW5kZXggb2YgdGhlIHZub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm93IHRoZSBuZXcgcGFyZW50IHZub2RlIGZvciBhbGwgdGhlIG5leHQgY2hpbGQgY2hlY2tzXG4gICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUgPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290Tm9kZXMgJiYgY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Um9vdE5vZGVzW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlLiRlbG0kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBkcmlsbCBkb3duLCBlbmQgdG8gc3RhcnQgc28gd2UgY2FuIHJlbW92ZSBub2Rlc1xuICAgICAgICBmb3IgKGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLmNoaWxkTm9kZXNbaV0sIGhvc3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgLy8ga2VlcCBkcmlsbGluZyBkb3duIHRocm91Z2ggdGhlIHNoYWRvdyByb290IG5vZGVzXG4gICAgICAgICAgICBmb3IgKGkgPSBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEh5ZHJhdGUocGFyZW50Vk5vZGUsIGNoaWxkUmVuZGVyTm9kZXMsIHNsb3ROb2Rlcywgc2hhZG93Um9vdE5vZGVzLCBob3N0RWxtLCBub2RlLnNoYWRvd1Jvb3QuY2hpbGROb2Rlc1tpXSwgaG9zdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIENvbW1lbnROb2RlICovKSB7XG4gICAgICAgIC8vIGAke0NPTU1FTlRfVFlQRX0uJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWBcbiAgICAgICAgY2hpbGRJZFNwbHQgPSBub2RlLm5vZGVWYWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY2hpbGRJZFNwbHRbMV0gPT09IGhvc3RJZCB8fCBjaGlsZElkU3BsdFsxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAvLyBjb21tZW50IG5vZGUgZm9yIGVpdGhlciB0aGUgaG9zdCBpZCBvciBhIDAgaG9zdCBpZFxuICAgICAgICAgICAgY2hpbGROb2RlVHlwZSA9IGNoaWxkSWRTcGx0WzBdO1xuICAgICAgICAgICAgY2hpbGRWTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAgICAgICAgICRob3N0SWQkOiBjaGlsZElkU3BsdFsxXSxcbiAgICAgICAgICAgICAgICAkbm9kZUlkJDogY2hpbGRJZFNwbHRbMl0sXG4gICAgICAgICAgICAgICAgJGRlcHRoJDogY2hpbGRJZFNwbHRbM10sXG4gICAgICAgICAgICAgICAgJGluZGV4JDogY2hpbGRJZFNwbHRbNF0sXG4gICAgICAgICAgICAgICAgJGVsbSQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgJGF0dHJzJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkY2hpbGRyZW4kOiBudWxsLFxuICAgICAgICAgICAgICAgICRrZXkkOiBudWxsLFxuICAgICAgICAgICAgICAgICRuYW1lJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGFnJDogbnVsbCxcbiAgICAgICAgICAgICAgICAkdGV4dCQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFRFWFRfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRlbG0kICYmIGNoaWxkVk5vZGUuJGVsbSQubm9kZVR5cGUgPT09IDMgLyogVGV4dE5vZGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRWTm9kZS4kdGV4dCQgPSBjaGlsZFZOb2RlLiRlbG0kLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFJlbmRlck5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdGV4dCBjb21tZW50IHNpbmNlIGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZOb2RlLiRjaGlsZHJlbiQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkVk5vZGUuJGluZGV4JF0gPSBjaGlsZFZOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdE5vZGVzICYmIGNoaWxkVk5vZGUuJGRlcHRoJCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZFZOb2RlLiRob3N0SWQkID09PSBob3N0SWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbW1lbnQgbm9kZSBpcyBzcGVjaWZjYWxseSBmb3IgdGhpcyBob3N0IGlkXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZVR5cGUgPT09IFNMT1RfTk9ERV9JRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgJHtTTE9UX05PREVfSUR9LiR7aG9zdElkfS4ke25vZGVJZH0uJHtkZXB0aH0uJHtpbmRleH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFZOb2RlLiR0YWckID0gJ3Nsb3QnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJZFNwbHRbNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVbJ3Mtc24nXSA9IGNoaWxkVk5vZGUuJG5hbWUkID0gY2hpbGRJZFNwbHRbNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNuJ10gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlWydzLXNyJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciBzdXBwb3J0IHNoYWRvd1Jvb3QgYW5kIHRoaXMgaXMgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFjdHVhbCBzbG90IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQgPSBkb2MuY3JlYXRlRWxlbWVudChjaGlsZFZOb2RlLiR0YWckKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZOb2RlLiRuYW1lJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgc2xvdCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVk5vZGUuJGVsbSQuc2V0QXR0cmlidXRlKCduYW1lJywgY2hpbGRWTm9kZS4kbmFtZSQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBuZXcgc2xvdCBlbGVtZW50IGJlZm9yZSB0aGUgc2xvdCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkVk5vZGUuJGVsbSQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzbG90IGNvbW1lbnQgc2luY2UgaXQncyBub3QgbmVlZGVkIGZvciBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWTm9kZS4kZGVwdGgkID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dSb290Tm9kZXNbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGUuJGVsbSQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGVzLnB1c2goY2hpbGRWTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vk5vZGUuJGNoaWxkcmVuJCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiRbY2hpbGRWTm9kZS4kaW5kZXgkXSA9IGNoaWxkVk5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkTm9kZVR5cGUgPT09IENPTlRFTlRfUkVGX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGAke0NPTlRFTlRfUkVGX0lEfS4ke2hvc3RJZH1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIHNoYWRvd1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb250ZW50IHJlZiBjb21tZW50IHNpbmNlIGl0J3Mgbm90IG5lZWRlZCBmb3Igc2hhZG93XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEJVSUxELnNsb3RSZWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxtWydzLWNyJ10gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVsncy1jbiddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnRWTm9kZSAmJiBwYXJlbnRWTm9kZS4kdGFnJCA9PT0gJ3N0eWxlJykge1xuICAgICAgICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG51bGwsIG5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICB2bm9kZS4kZWxtJCA9IG5vZGU7XG4gICAgICAgIHZub2RlLiRpbmRleCQgPSAnMCc7XG4gICAgICAgIHBhcmVudFZOb2RlLiRjaGlsZHJlbiQgPSBbdm5vZGVdO1xuICAgIH1cbn07XG5jb25zdCBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlID0gKG5vZGUsIG9yZ0xvY05vZGVzKSA9PiB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURvY3VtZW50SHlkcmF0ZShub2RlLmNoaWxkTm9kZXNbaV0sIG9yZ0xvY05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5zaGFkb3dSb290LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplRG9jdW1lbnRIeWRyYXRlKG5vZGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzW2ldLCBvcmdMb2NOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDb21tZW50Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBjaGlsZElkU3BsdCA9IG5vZGUubm9kZVZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChjaGlsZElkU3BsdFswXSA9PT0gT1JHX0xPQ0FUSU9OX0lEKSB7XG4gICAgICAgICAgICBvcmdMb2NOb2Rlcy5zZXQoY2hpbGRJZFNwbHRbMV0gKyAnLicgKyBjaGlsZElkU3BsdFsyXSwgbm9kZSk7XG4gICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgLy8gdXNlZnVsIHRvIGtub3cgaWYgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIGlzXG4gICAgICAgICAgICAvLyB0aGUgcm9vdCBsaWdodC1kb20gb2YgYSBzaGFkb3cgZG9tIGNvbXBvbmVudFxuICAgICAgICAgICAgbm9kZVsncy1lbiddID0gY2hpbGRJZFNwbHRbM107XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBQYXJzZSBhIG5ldyBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBwcm9wZXJ0eSB0eXBlLlxuICpcbiAqIFdoaWxlIHRoZSBwcm9wIHZhbHVlIGNhbiByZWFzb25hYmx5IGJlIGV4cGVjdGVkIHRvIGJlIG9mIGBhbnlgIHR5cGUgYXMgZmFyIGFzIFR5cGVTY3JpcHQncyB0eXBlIGNoZWNrZXIgaXMgY29uY2VybmVkLFxuICogaXQgaXMgbm90IHNhZmUgdG8gYXNzdW1lIHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBldmFsdWF0aW5nIGB0eXBlb2YgcHJvcFZhbHVlYCBtYXRjaGVzOlxuICogICAxLiBgYW55YCwgdGhlIHR5cGUgZ2l2ZW4gdG8gYHByb3BWYWx1ZWAgaW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICogICAyLiB0aGUgdHlwZSBzdG9yZWQgZnJvbSBgcHJvcFR5cGVgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgdGhlIGNhcGFiaWxpdHkgdG8gcGFyc2UvY29lcmNlIGEgcHJvcGVydHkncyB2YWx1ZSB0byBwb3RlbnRpYWxseSBhbnkgb3RoZXIgSmF2YVNjcmlwdCB0eXBlLlxuICpcbiAqIFByb3BlcnR5IHZhbHVlcyByZXByZXNlbnRlZCBpbiBUU1ggcHJlc2VydmUgdGhlaXIgdHlwZSBpbmZvcm1hdGlvbi4gSW4gdGhlIGV4YW1wbGUgYmVsb3csIHRoZSBudW1iZXIgMCBpcyBwYXNzZWQgdG9cbiAqIGEgY29tcG9uZW50LiBUaGlzIGBwcm9wVmFsdWVgIHdpbGwgcHJlc2VydmUgaXRzIHR5cGUgaW5mb3JtYXRpb24gKGB0eXBlb2YgcHJvcFZhbHVlID09PSAnbnVtYmVyJ2ApLiBOb3RlIHRoYXQgaXNcbiAqIGJhc2VkIG9uIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgaW4sIG5vdCB0aGUgdHlwZSBkZWNsYXJlZCBvZiB0aGUgY2xhc3MgbWVtYmVyIGRlY29yYXRlZCB3aXRoIGBAUHJvcGAuXG4gKiBgYGB0c3hcbiAqIDxteS1jbXAgcHJvcC12YWw9ezB9PjwvbXktY21wPlxuICogYGBgXG4gKlxuICogSFRNTCBwcm9wIHZhbHVlcyBvbiB0aGUgb3RoZXIgaGFuZCwgd2lsbCBhbHdheXMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gcHJvcFZhbHVlIHRoZSBuZXcgdmFsdWUgdG8gY29lcmNlIHRvIHNvbWUgdHlwZVxuICogQHBhcmFtIHByb3BUeXBlIHRoZSB0eXBlIG9mIHRoZSBwcm9wLCBleHByZXNzZWQgYXMgYSBiaW5hcnkgbnVtYmVyXG4gKiBAcmV0dXJucyB0aGUgcGFyc2VkL2NvZXJjZWQgdmFsdWVcbiAqL1xuY29uc3QgcGFyc2VQcm9wZXJ0eVZhbHVlID0gKHByb3BWYWx1ZSwgcHJvcFR5cGUpID0+IHtcbiAgICAvLyBlbnN1cmUgdGhpcyB2YWx1ZSBpcyBvZiB0aGUgY29ycmVjdCBwcm9wIHR5cGVcbiAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgIWlzQ29tcGxleFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICBpZiAoQlVJTEQucHJvcEJvb2xlYW4gJiYgcHJvcFR5cGUgJiA0IC8qIEJvb2xlYW4gKi8pIHtcbiAgICAgICAgICAgIC8vIHBlciB0aGUgSFRNTCBzcGVjLCBhbnkgc3RyaW5nIHZhbHVlIG1lYW5zIGl0IGlzIGEgYm9vbGVhbiB0cnVlIHZhbHVlXG4gICAgICAgICAgICAvLyBidXQgd2UnbGwgY2hlYXQgaGVyZSBhbmQgc2F5IHRoYXQgdGhlIHN0cmluZyBcImZhbHNlXCIgaXMgdGhlIGJvb2xlYW4gZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHByb3BWYWx1ZSA9PT0gJycgfHwgISFwcm9wVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BOdW1iZXIgJiYgcHJvcFR5cGUgJiAyIC8qIE51bWJlciAqLykge1xuICAgICAgICAgICAgLy8gZm9yY2UgaXQgdG8gYmUgYSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnByb3BTdHJpbmcgJiYgcHJvcFR5cGUgJiAxIC8qIFN0cmluZyAqLykge1xuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBiZWVuIHBhc3NlZCBhcyBhIG51bWJlciBvciBib29sZWFuXG4gICAgICAgICAgICAvLyBidXQgd2Ugc3RpbGwgd2FudCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVuZGFudCByZXR1cm4gaGVyZSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvblxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH1cbiAgICAvLyBub3Qgc3VyZSBleGFjdGx5IHdoYXQgdHlwZSB3ZSB3YW50XG4gICAgLy8gc28gbm8gbmVlZCB0byBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgIHJldHVybiBwcm9wVmFsdWU7XG59O1xuY29uc3QgZ2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSkgPT4gZ2V0SG9zdFJlZihyZWYpLiRpbnN0YW5jZVZhbHVlcyQuZ2V0KHByb3BOYW1lKTtcbmNvbnN0IHNldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUsIG5ld1ZhbCwgY21wTWV0YSkgPT4ge1xuICAgIC8vIGNoZWNrIG91ciBuZXcgcHJvcGVydHkgdmFsdWUgYWdhaW5zdCBvdXIgaW50ZXJuYWwgdmFsdWVcbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihyZWYpO1xuICAgIGNvbnN0IGVsbSA9IEJVSUxELmxhenlMb2FkID8gaG9zdFJlZi4kaG9zdEVsZW1lbnQkIDogcmVmO1xuICAgIGNvbnN0IG9sZFZhbCA9IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuICAgIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgIG5ld1ZhbCA9IHBhcnNlUHJvcGVydHlWYWx1ZShuZXdWYWwsIGNtcE1ldGEuJG1lbWJlcnMkW3Byb3BOYW1lXVswXSk7XG4gICAgLy8gZXhwbGljaXRseSBjaGVjayBmb3IgTmFOIG9uIGJvdGggc2lkZXMsIGFzIGBOYU4gPT09IE5hTmAgaXMgYWx3YXlzIGZhbHNlXG4gICAgY29uc3QgYXJlQm90aE5hTiA9IE51bWJlci5pc05hTihvbGRWYWwpICYmIE51bWJlci5pc05hTihuZXdWYWwpO1xuICAgIGNvbnN0IGRpZFZhbHVlQ2hhbmdlID0gbmV3VmFsICE9PSBvbGRWYWwgJiYgIWFyZUJvdGhOYU47XG4gICAgaWYgKCghQlVJTEQubGF6eUxvYWQgfHwgIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB1bmRlZmluZWQpICYmIGRpZFZhbHVlQ2hhbmdlKSB7XG4gICAgICAgIC8vIGdhZHpvb2tzISB0aGUgcHJvcGVydHkncyB2YWx1ZSBoYXMgY2hhbmdlZCEhXG4gICAgICAgIC8vIHNldCBvdXIgbmV3IHZhbHVlIVxuICAgICAgICBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHByb3BOYW1lLCBuZXdWYWwpO1xuICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAxMDI0IC8qIGRldk9uUmVuZGVyICovKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZURldldhcm4oYFRoZSBzdGF0ZS9wcm9wIFwiJHtwcm9wTmFtZX1cIiBjaGFuZ2VkIGR1cmluZyByZW5kZXJpbmcuIFRoaXMgY2FuIHBvdGVudGlhbGx5IGxlYWQgdG8gaW5maW5pdGUtbG9vcHMgYW5kIG90aGVyIGJ1Z3MuYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgMjA0OCAvKiBkZXZPbkRpZExvYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRGV2V2FybihgVGhlIHN0YXRlL3Byb3AgXCIke3Byb3BOYW1lfVwiIGNoYW5nZWQgZHVyaW5nIFwiY29tcG9uZW50RGlkTG9hZCgpXCIsIHRoaXMgdHJpZ2dlcnMgZXh0cmEgcmUtcmVuZGVycywgdHJ5IHRvIHNldHVwIG9uIFwiY29tcG9uZW50V2lsbExvYWQoKVwiYCwgJ1xcbkVsZW1lbnQnLCBlbG0sICdcXG5OZXcgdmFsdWUnLCBuZXdWYWwsICdcXG5PbGQgdmFsdWUnLCBvbGRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghQlVJTEQubGF6eUxvYWQgfHwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBtZXRob2QgbmFtZXMgb2Ygd2F0Y2ggZnVuY3Rpb25zIHRvIGNhbGxcbiAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrICYmIGNtcE1ldGEuJHdhdGNoZXJzJCAmJiBmbGFncyAmIDEyOCAvKiBpc1dhdGNoUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbnN0YW5jZSBpcyB3YXRjaGluZyBmb3Igd2hlbiB0aGlzIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCgod2F0Y2hNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGVhY2ggb2YgdGhlIHdhdGNoIG1ldGhvZHMgdGhhdCBhcmUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC51cGRhdGFibGUgJiZcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuY21wU2hvdWxkVXBkYXRlICYmIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKG5ld1ZhbCwgb2xkVmFsLCBwcm9wTmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGlzIHZhbHVlIGFjdHVhbGx5IGNoYW5nZWQsIHNvIHdlJ3ZlIGdvdCB3b3JrIHRvIGRvIVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBvbmx5IGlmIHdlJ3ZlIGFscmVhZHkgcmVuZGVyZWQsIG90aGVyd2lzZSBqdXN0IGNoaWxsIG91dFxuICAgICAgICAgICAgICAgIC8vIHF1ZXVlIHRoYXQgd2UgbmVlZCB0byBkbyBhbiB1cGRhdGUsIGJ1dCBkb24ndCB3b3JyeSBhYm91dCBxdWV1aW5nXG4gICAgICAgICAgICAgICAgLy8gdXAgbWlsbGlvbnMgY3V6IHRoaXMgZnVuY3Rpb24gZW5zdXJlcyBpdCBvbmx5IHJ1bnMgb25jZVxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBwcm94eUNvbXBvbmVudCA9IChDc3RyLCBjbXBNZXRhLCBmbGFncykgPT4ge1xuICAgIGlmIChCVUlMRC5tZW1iZXIgJiYgY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgaWYgKEJVSUxELndhdGNoQ2FsbGJhY2sgJiYgQ3N0ci53YXRjaGVycykge1xuICAgICAgICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci53YXRjaGVycztcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBoYXZlIGEgY29uc3QgdGhhbiB0d28gT2JqZWN0LmVudHJpZXMoKVxuICAgICAgICBjb25zdCBtZW1iZXJzID0gT2JqZWN0LmVudHJpZXMoY21wTWV0YS4kbWVtYmVycyQpO1xuICAgICAgICBjb25zdCBwcm90b3R5cGUgPSBDc3RyLnByb3RvdHlwZTtcbiAgICAgICAgbWVtYmVycy5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgICAgaWYgKChCVUlMRC5wcm9wIHx8IEJVSUxELnN0YXRlKSAmJlxuICAgICAgICAgICAgICAgIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgKCghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAyIC8qIHByb3h5U3RhdGUgKi8pICYmIG1lbWJlckZsYWdzICYgMzIgLyogU3RhdGUgKi8pKSkge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gcHJvcFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIGdldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZHVyaW5nIGRldiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaXNEZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcHJveHlpbmcgdGhlIGluc3RhbmNlIChub3QgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBub3QgY29uc3RydWN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYuJGZsYWdzJCAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBhIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlckZsYWdzICYgMzEgLyogUHJvcCAqLykgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1lbWJlciBpcyBub3QgbXV0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWVtYmVyRmxhZ3MgJiAxMDI0IC8qIE11dGFibGUgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVEZXZXYXJuKGBAUHJvcCgpIFwiJHttZW1iZXJOYW1lfVwiIG9uIDwke2NtcE1ldGEuJHRhZ05hbWUkfT4gaXMgaW1tdXRhYmxlIGJ1dCB3YXMgbW9kaWZpZWQgZnJvbSB3aXRoaW4gdGhlIGNvbXBvbmVudC5cXG5Nb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9wcm9wZXJ0aWVzI3Byb3AtbXV0YWJpbGl0eWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50LCBzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUsIG5ld1ZhbHVlLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQlVJTEQubGF6eUxvYWQgJiZcbiAgICAgICAgICAgICAgICBCVUlMRC5tZXRob2QgJiZcbiAgICAgICAgICAgICAgICBmbGFncyAmIDEgLyogaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gJiZcbiAgICAgICAgICAgICAgICBtZW1iZXJGbGFncyAmIDY0IC8qIE1ldGhvZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByb3h5Q29tcG9uZW50IC0gbWV0aG9kXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBnZXRIb3N0UmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZi4kb25JbnN0YW5jZVByb21pc2UkLnRoZW4oKCkgPT4gcmVmLiRsYXp5SW5zdGFuY2UkW21lbWJlck5hbWVdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChCVUlMRC5vYnNlcnZlQXR0cmlidXRlICYmICghQlVJTEQubGF6eUxvYWQgfHwgZmxhZ3MgJiAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKSkge1xuICAgICAgICAgICAgY29uc3QgYXR0ck5hbWVUb1Byb3BOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGF0dHJOYW1lVG9Qcm9wTmFtZS5nZXQoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gYSB3ZWIgY29tcG9uZW50IGxpZmVjeWNsZSB0aGUgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHJ1bnMgcHJpb3IgdG8gY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gIGluIHRoZSBjYXNlIHdoZXJlIGFuIGF0dHJpYnV0ZSB3YXMgc2V0IGlubGluZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPG15LWNvbXBvbmVudCBzb21lLWF0dHJpYnV0ZT1cInNvbWUtdmFsdWVcIj48L215LWNvbXBvbmVudD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlcmUgaXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgZGV2ZWxvcGVyIHNldHMgdGhlIGF0dHJpYnV0ZSBpbmxpbmUgb24gYSBjdXN0b20gZWxlbWVudCBhbmQgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyAgcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2VzIGl0IGJlZm9yZSBpdCBoYXMgYmVlbiB1cGdyYWRlZCBhcyBzaG93biBiZWxvdzpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYGh0bWxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPCEtLSB0aGlzIGNvbXBvbmVudCBoYXMgX25vdF8gYmVlbiB1cGdyYWRlZCB5ZXQgLS0+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgaWQ9XCJ0ZXN0XCIgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgLy8gZ3JhYiBub24tdXBncmFkZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3Rlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgZWwuc29tZUF0dHJpYnV0ZSA9IFwiYW5vdGhlci12YWx1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIHVwZ3JhZGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgYGBgXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbiB0aGlzIGNhc2UgaWYgd2UgZG8gbm90IHVuc2hhZG93IGhlcmUgYW5kIHVzZSB0aGUgdmFsdWUgb2YgdGhlIHNoYWRvd2luZyBwcm9wZXJ0eSwgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICB3aWxsIGJlIGNhbGxlZCB3aXRoIGBuZXdWYWx1ZSA9IFwic29tZS12YWx1ZVwiYCBhbmQgd2lsbCBzZXQgdGhlIHNoYWRvd2VkIHByb3BlcnR5ICh0aGlzLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gIHRvIHRoZSB2YWx1ZSB0aGF0IHdhcyBzZXQgaW5saW5lIGkuZS4gXCJzb21lLXZhbHVlXCIgZnJvbSBhYm92ZSBleGFtcGxlLiBXaGVuXG4gICAgICAgICAgICAgICAgICAgIC8vICB0aGUgY29ubmVjdGVkQ2FsbGJhY2sgYXR0ZW1wdHMgdG8gdW5zaGFkb3cgaXQgd2lsbCB1c2UgXCJzb21lLXZhbHVlXCIgYXMgdGhlIGluaXRpYWwgdmFsdWUgcmF0aGVyIHRoYW4gXCJhbm90aGVyLXZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZSBjYXNlIHdoZXJlIHRoZSBhdHRyaWJ1dGUgd2FzIE5PVCBzZXQgaW5saW5lIGJ1dCB3YXMgbm90IHNldCBwcm9ncmFtbWF0aWNhbGx5IHNoYWxsIGJlIGhhbmRsZWQvdW5zaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICAvLyAgYnkgY29ubmVjdGVkQ2FsbGJhY2sgYXMgdGhpcyBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgd2lsbCBub3QgZmlyZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjbGF6eS1wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUT0RPKFNURU5DSUwtMTYpIHdlIHNob3VsZCB0aGluayBhYm91dCB3aGV0aGVyIG9yIG5vdCB3ZSBhY3R1YWxseSB3YW50IHRvIGJlIHJlZmxlY3RpbmcgdGhlIGF0dHJpYnV0ZXMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb3BlcnRpZXMgaGVyZSBnaXZlbiB0aGF0IHRoaXMgZ29lcyBhZ2FpbnN0IGJlc3QgcHJhY3RpY2VzIG91dGxpbmVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvd2ViLWNvbXBvbmVudHMvYmVzdC1wcmFjdGljZXMjYXZvaWQtcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wTmFtZSBleGlzdHMgb24gdGhlIHByb3RvdHlwZSBvZiBgQ3N0cmAsIHRoaXMgdXBkYXRlIG1heSBiZSBhIHJlc3VsdCBvZiBTdGVuY2lsIHVzaW5nIG5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQVBJcyB0byByZWZsZWN0IHByb3BzIGFzIGF0dHJpYnV0ZXMuIENhbGxzIHRvIGBzZXRBdHRyaWJ1dGUoc29tZUVsZW1lbnQsIHByb3BOYW1lKWAgd2lsbCByZXN1bHQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBwcm9wTmFtZWAgdG8gYmUgY29udmVydGVkIHRvIGEgYERPTVN0cmluZ2AsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB3ZSB3YW50IGZvciBvdGhlciBwcmltaXRpdmUgcHJvcHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuZXdWYWx1ZSA9PT0gbnVsbCAmJiB0eXBlb2YgdGhpc1twcm9wTmFtZV0gPT09ICdib29sZWFuJyA/IGZhbHNlIDogbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gb2JzZXJ2ZVxuICAgICAgICAgICAgLy8gYW5kIGFsc28gY3JlYXRlIGEgbWFwIG9mIGh0bWwgYXR0cmlidXRlIG5hbWUgdG8ganMgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgQ3N0ci5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBtZW1iZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIG1dKSA9PiBtWzBdICYgMTUgLyogSGFzQXR0cmlidXRlICovKSAvLyBmaWx0ZXIgdG8gb25seSBrZWVwIHByb3BzIHRoYXQgc2hvdWxkIG1hdGNoIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAubWFwKChbcHJvcE5hbWUsIG1dKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBtWzFdIHx8IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lVG9Qcm9wTmFtZS5zZXQoYXR0ck5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQucmVmbGVjdCAmJiBtWzBdICYgNTEyIC8qIFJlZmxlY3RBdHRyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JC5wdXNoKFtwcm9wTmFtZSwgYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIENzdHI7XG59O1xuY29uc3QgaW5pdGlhbGl6ZUNvbXBvbmVudCA9IGFzeW5jIChlbG0sIGhvc3RSZWYsIGNtcE1ldGEsIGhtclZlcnNpb25JZCwgQ3N0cikgPT4ge1xuICAgIC8vIGluaXRpYWxpemVDb21wb25lbnRcbiAgICBpZiAoKEJVSUxELmxhenlMb2FkIHx8IEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlIHx8IEJVSUxELnN0eWxlKSAmJlxuICAgICAgICAoaG9zdFJlZi4kZmxhZ3MkICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pID09PSAwKSB7XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCB8fCBCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZW4ndCBpbml0aWFsaXplZCB0aGlzIGVsZW1lbnQgeWV0XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi87XG4gICAgICAgICAgICAvLyBsYXp5IGxvYWRlZCBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyByZXF1ZXN0IHRoZSBjb21wb25lbnQncyBpbXBsZW1lbnRhdGlvbiB0byBiZVxuICAgICAgICAgICAgLy8gd2lyZWQgdXAgd2l0aCB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICBDc3RyID0gbG9hZE1vZHVsZShjbXBNZXRhLCBob3N0UmVmLCBobXJWZXJzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKENzdHIudGhlbikge1xuICAgICAgICAgICAgICAgIC8vIEF3YWl0IGNyZWF0ZXMgYSBtaWNyby10YXNrIGF2b2lkIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTG9hZCA9IHVuaXF1ZVRpbWUoYHN0OmxvYWQ6JHtjbXBNZXRhLiR0YWdOYW1lJH06JHtob3N0UmVmLiRtb2RlTmFtZSR9YCwgYFtTdGVuY2lsXSBMb2FkIG1vZHVsZSBmb3IgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PmApO1xuICAgICAgICAgICAgICAgIENzdHIgPSBhd2FpdCBDc3RyO1xuICAgICAgICAgICAgICAgIGVuZExvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoQlVJTEQuaXNEZXYgfHwgQlVJTEQuaXNEZWJ1ZykgJiYgIUNzdHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIGZvciBcIiR7Y21wTWV0YS4kdGFnTmFtZSR9IyR7aG9zdFJlZi4kbW9kZU5hbWUkfVwiIHdhcyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIgJiYgIUNzdHIuaXNQcm94aWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbmV2ZXIgcHJveGllZCB0aGlzIENvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGxldCdzIGFkZCB0aGUgZ2V0dGVycy9zZXR0ZXJzIHRvIGl0cyBwcm90b3R5cGUgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHRpbWUgd2UgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIGlmIChCVUlMRC53YXRjaENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDIgLyogcHJveHlTdGF0ZSAqLyk7XG4gICAgICAgICAgICAgICAgQ3N0ci5pc1Byb3hpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW5kTmV3SW5zdGFuY2UgPSBjcmVhdGVUaW1lKCdjcmVhdGVJbnN0YW5jZScsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgICAgIC8vIG9rLCB0aW1lIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBrZWVwIHRyYWNrIG9mIHdoZW4gd2Ugc3RhcnQgYW5kIHN0b3BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGdldHRlcnMvc2V0dGVycyBkb24ndCBpbmNvcnJlY3RseSBzdGVwIG9uIGRhdGFcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSBsYXp5LWxvYWRlZCBjb21wb25lbnQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIHBhc3NpbmcgdGhlIGhvc3RSZWYgaXMgdmVyeSBpbXBvcnRhbnQgZHVyaW5nXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3Rpb24gaW4gb3JkZXIgdG8gZGlyZWN0bHkgd2lyZSB0b2dldGhlciB0aGVcbiAgICAgICAgICAgIC8vIGhvc3QgZWxlbWVudCBhbmQgdGhlIGxhenktbG9hZGVkIGluc3RhbmNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBDc3RyKGhvc3RSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH44IC8qIGlzQ29uc3RydWN0aW5nSW5zdGFuY2UgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN5bmMgY29uc3RydWN0b3IgY29tcG9uZW50XG4gICAgICAgICAgICBDc3RyID0gZWxtLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSB0byBtYXJrIHRoZSBjb21wb25lbnQgYXMgcmVhZHkgYmVmb3JlIHNldHRpbmcgYGlzV2F0Y2hSZWFkeWAuIE90aGVyd2lzZSxcbiAgICAgICAgICAgIC8vIHdhdGNoZXJzIG1heSBmaXJlIHByZW1hdHVyZWx5IGlmIGBjdXN0b21FbGVtZW50cy5nZXQoKWAvYGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKClgIHJlc29sdmVzIF9iZWZvcmVfXG4gICAgICAgICAgICAvLyBTdGVuY2lsIGhhcyBjb21wbGV0ZWQgaW5zdGFudGlhdGluZyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoY21wTWV0YS4kdGFnTmFtZSQpLnRoZW4oKCkgPT4gKGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJVSUxELnN0eWxlICYmIENzdHIuc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGhhcyBzdHlsZXMgYnV0IHdlIGhhdmVuJ3QgcmVnaXN0ZXJlZCB0aGVtIHlldFxuICAgICAgICAgICAgbGV0IHN0eWxlID0gQ3N0ci5zdHlsZTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5tb2RlICYmIHR5cGVvZiBzdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlWyhob3N0UmVmLiRtb2RlTmFtZSQgPSBjb21wdXRlTW9kZShlbG0pKV07XG4gICAgICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlICYmIGhvc3RSZWYuJG1vZGVOYW1lJCkge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKCdzLW1vZGUnLCBob3N0UmVmLiRtb2RlTmFtZSQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEsIGhvc3RSZWYuJG1vZGVOYW1lJCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRSZWdpc3RlclN0eWxlcyA9IGNyZWF0ZVRpbWUoJ3JlZ2lzdGVyU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICAgICAgICAgIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgQlVJTEQuc2hhZG93RG9tICYmXG4gICAgICAgICAgICAgICAgICAgIEJVSUxELnNoYWRvd0RvbVNoaW0gJiZcbiAgICAgICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkICYgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSBhd2FpdCBpbXBvcnQoJy4vc2hhZG93LWNzcy5qcycpLnRoZW4oKG0pID0+IG0uc2NvcGVDc3Moc3R5bGUsIHNjb3BlSWQsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykpO1xuICAgICAgICAgICAgICAgIGVuZFJlZ2lzdGVyU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UndmUgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYSBsYXp5IGluc3RhbmNlXG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnQgPSBob3N0UmVmLiRhbmNlc3RvckNvbXBvbmVudCQ7XG4gICAgY29uc3Qgc2NoZWR1bGUgPSAoKSA9PiBzY2hlZHVsZVVwZGF0ZShob3N0UmVmLCB0cnVlKTtcbiAgICBpZiAoQlVJTEQuYXN5bmNMb2FkaW5nICYmIGFuY2VzdG9yQ29tcG9uZW50ICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaW5pdGlhbCBsb2FkIGFuZCB0aGlzIGNvbXBvbmVudCBpdCBoYXMgYW4gYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGJ1dCB0aGUgYW5jZXN0b3IgY29tcG9uZW50IGhhcyBOT1QgZmlyZWQgaXRzIHdpbGwgdXBkYXRlIGxpZmVjeWNsZSB5ZXRcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBjb29sIG91ciBqZXRzIGFuZCB3YWl0IGZvciB0aGUgYW5jZXN0b3IgdG8gY29udGludWUgZmlyc3RcbiAgICAgICAgLy8gdGhpcyB3aWxsIGdldCBmaXJlZCBvZmYgd2hlbiB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGZpbmFsbHkgZ2V0cyBhcm91bmQgdG8gcmVuZGVyaW5nIGl0cyBsYXp5IHNlbGZcbiAgICAgICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10ucHVzaChzY2hlZHVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbn07XG5jb25zdCBmaXJlQ29ubmVjdGVkQ2FsbGJhY2sgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoQlVJTEQubGF6eUxvYWQgJiYgQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgIH1cbn07XG5jb25zdCBjb25uZWN0ZWRDYWxsYmFjayA9IChlbG0pID0+IHtcbiAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDApIHtcbiAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYoZWxtKTtcbiAgICAgICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgICAgICBjb25zdCBlbmRDb25uZWN0ZWQgPSBjcmVhdGVUaW1lKCdjb25uZWN0ZWRDYWxsYmFjaycsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lclRhcmdldFBhcmVudCkge1xuICAgICAgICAgICAgLy8gb25seSBydW4gaWYgd2UgaGF2ZSBsaXN0ZW5lcnMgYmVpbmcgYXR0YWNoZWQgdG8gYSBwYXJlbnRcbiAgICAgICAgICAgIGFkZEhvc3RFdmVudExpc3RlbmVycyhlbG0sIGhvc3RSZWYsIGNtcE1ldGEuJGxpc3RlbmVycyQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDEgLyogaGFzQ29ubmVjdGVkICovKSkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZSB0aGlzIGNvbXBvbmVudCBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMSAvKiBoYXNDb25uZWN0ZWQgKi87XG4gICAgICAgICAgICBsZXQgaG9zdElkO1xuICAgICAgICAgICAgaWYgKEJVSUxELmh5ZHJhdGVDbGllbnRTaWRlKSB7XG4gICAgICAgICAgICAgICAgaG9zdElkID0gZWxtLmdldEF0dHJpYnV0ZShIWURSQVRFX0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEb20gJiYgc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZUlkID0gQlVJTEQubW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEsIGVsbS5nZXRBdHRyaWJ1dGUoJ3MtbW9kZScpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkU3R5bGUoZWxtLnNoYWRvd1Jvb3QsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5yZW1vdmUoc2NvcGVJZCArICctaCcsIHNjb3BlSWQgKyAnLXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplQ2xpZW50SHlkcmF0ZShlbG0sIGNtcE1ldGEuJHRhZ05hbWUkLCBob3N0SWQsIGhvc3RSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zbG90UmVsb2NhdGlvbiAmJiAhaG9zdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdFVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzbG90IHBvbHlmaWxsIGlzIHJlcXVpcmVkIHdlJ2xsIG5lZWQgdG8gcHV0IHNvbWUgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBoZXJlIHRvIGFjdCBhcyBvcmlnaW5hbCBjb250ZW50IGFuY2hvcnMgYXMgd2UgbW92ZSBub2RlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAvLyBob3N0IGVsZW1lbnQgaGFzIGJlZW4gY29ubmVjdGVkIHRvIHRoZSBET01cbiAgICAgICAgICAgICAgICBpZiAoQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgKChCVUlMRC5zbG90IHx8IEJVSUxELnNoYWRvd0RvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcE1ldGEuJGZsYWdzJCAmICg0IC8qIGhhc1Nsb3RSZWxvY2F0aW9uICovIHwgOCAvKiBuZWVkc1NoYWRvd0RvbVNoaW0gKi8pKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50UmVmZXJlbmNlKGVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFzeW5jTG9hZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudCAoaWYgdGhlcmUgaXMgb25lKSBhbmQgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBhcyBvbmUgb2YgdGhlIGFjdGl2ZWx5IGxvYWRpbmcgY2hpbGQgY29tcG9uZW50cyBmb3IgaXRzIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgbGV0IGFuY2VzdG9yQ29tcG9uZW50ID0gZWxtO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYW5jZXN0b3JDb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudC5wYXJlbnROb2RlIHx8IGFuY2VzdG9yQ29tcG9uZW50Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaW1iIHVwIHRoZSBhbmNlc3RvcnMgbG9va2luZyBmb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCB0aGF0IGhhc24ndCBmaW5pc2hlZCBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JDb21wb25lbnQubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yQ29tcG9uZW50Lmhhc0F0dHJpYnV0ZSgncy1pZCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvckNvbXBvbmVudFsncy1wJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZvdW5kIHRoaXMgY29tcG9uZW50cyBmaXJzdCBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhpcyBjb21wb25lbnQncyBhbmNlc3RvciBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgKGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCA9IGFuY2VzdG9yQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExhenkgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy93ZWItY29tcG9uZW50cy9iZXN0LXByYWN0aWNlcyNsYXp5LXByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChCVUlMRC5wcm9wICYmICFCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSAmJiBjbXBNZXRhLiRtZW1iZXJzJCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKS5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyRmxhZ3MgJiAzMSAvKiBQcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5pbml0aWFsaXplTmV4dFRpY2spIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0ZWRDYWxsYmFjaywgdGFza1F1ZXVlLCBpbml0aWFsTG9hZFxuICAgICAgICAgICAgICAgIC8vIGFuZ3VsYXIgc2V0cyBhdHRyaWJ1dGUgQUZURVIgY29ubmVjdENhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg5MDlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTk0MFxuICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IGluaXRpYWxpemVDb21wb25lbnQoZWxtLCBob3N0UmVmLCBjbXBNZXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGZpcnN0IHRpbWUgdGhpcyBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyByZWF0dGFjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBob3N0XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IHdvdWxkIGhhdmUgYmVlbiByZW1vdmVkIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBmaXJlIG9mZiBjb25uZWN0ZWRDYWxsYmFjaygpIG9uIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAgICAgZmlyZUNvbm5lY3RlZENhbGxiYWNrKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpO1xuICAgICAgICB9XG4gICAgICAgIGVuZENvbm5lY3RlZCgpO1xuICAgIH1cbn07XG5jb25zdCBzZXRDb250ZW50UmVmZXJlbmNlID0gKGVsbSkgPT4ge1xuICAgIC8vIG9ubHkgcmVxdWlyZWQgd2hlbiB3ZSdyZSBOT1QgdXNpbmcgbmF0aXZlIHNoYWRvdyBkb20gKHNsb3QpXG4gICAgLy8gb3IgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBuYXRpdmUgc2hhZG93IGRvbVxuICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAvLyBsZXQncyBwaWNrIG91dCB0aGUgaW5uZXIgY29udGVudCBmb3Igc2xvdCBwcm9qZWN0aW9uXG4gICAgLy8gY3JlYXRlIGEgbm9kZSB0byByZXByZXNlbnQgd2hlcmUgdGhlIG9yaWdpbmFsXG4gICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICBjb25zdCBjb250ZW50UmVmRWxtID0gKGVsbVsncy1jciddID0gZG9jLmNyZWF0ZUNvbW1lbnQoQlVJTEQuaXNEZWJ1ZyA/IGBjb250ZW50LXJlZiAoaG9zdD0ke2VsbS5sb2NhbE5hbWV9KWAgOiAnJykpO1xuICAgIGNvbnRlbnRSZWZFbG1bJ3MtY24nXSA9IHRydWU7XG4gICAgZWxtLmluc2VydEJlZm9yZShjb250ZW50UmVmRWxtLCBlbG0uZmlyc3RDaGlsZCk7XG59O1xuY29uc3QgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gQlVJTEQubGF6eUxvYWQgPyBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDogZWxtO1xuICAgICAgICBpZiAoQlVJTEQuaG9zdExpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcCgocm1MaXN0ZW5lcikgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYXIgQ1NTIHZhci1zaGltIHRyYWNraW5nXG4gICAgICAgIGlmIChCVUlMRC5jc3NWYXJTaGltICYmIHBsdC4kY3NzU2hpbSQpIHtcbiAgICAgICAgICAgIHBsdC4kY3NzU2hpbSQucmVtb3ZlSG9zdChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5sYXp5TG9hZCAmJiBCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCVUlMRC5jbXBEaWRVbmxvYWQpIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkVW5sb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShjb21wYWN0TWV0YVsxXSwgcHJveHlDdXN0b21FbGVtZW50KENzdHIsIGNvbXBhY3RNZXRhKSk7XG59O1xuY29uc3QgcHJveHlDdXN0b21FbGVtZW50ID0gKENzdHIsIGNvbXBhY3RNZXRhKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgJGZsYWdzJDogY29tcGFjdE1ldGFbMF0sXG4gICAgICAgICR0YWdOYW1lJDogY29tcGFjdE1ldGFbMV0sXG4gICAgfTtcbiAgICBpZiAoQlVJTEQubWVtYmVyKSB7XG4gICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgfVxuICAgIGlmIChCVUlMRC5ob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgY21wTWV0YS4kbGlzdGVuZXJzJCA9IGNvbXBhY3RNZXRhWzNdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLiR3YXRjaGVycyQ7XG4gICAgfVxuICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgIGNtcE1ldGEuJGF0dHJzVG9SZWZsZWN0JCA9IFtdO1xuICAgIH1cbiAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmICFzdXBwb3J0c1NoYWRvdyAmJiBjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrID0gQ3N0ci5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjayA9IENzdHIucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIE9iamVjdC5hc3NpZ24oQ3N0ci5wcm90b3R5cGUsIHtcbiAgICAgICAgX19yZWdpc3Rlckhvc3QoKSB7XG4gICAgICAgICAgICByZWdpc3Rlckhvc3QodGhpcywgY21wTWV0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICBpZiAoQlVJTEQuY29ubmVjdGVkQ2FsbGJhY2sgJiYgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5kaXNjb25uZWN0ZWRDYWxsYmFjayAmJiBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfX2F0dGFjaFNoYWRvdygpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1NoYWRvdykge1xuICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zaGFkb3dEZWxlZ2F0ZXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZXNGb2N1czogISEoY21wTWV0YS4kZmxhZ3MkICYgMTYgLyogc2hhZG93RGVsZWdhdGVzRm9jdXMgKi8pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgQ3N0ci5pcyA9IGNtcE1ldGEuJHRhZ05hbWUkO1xuICAgIHJldHVybiBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovIHwgMiAvKiBwcm94eVN0YXRlICovKTtcbn07XG5jb25zdCBmb3JjZU1vZGVVcGRhdGUgPSAoZWxtKSA9PiB7XG4gICAgaWYgKEJVSUxELnN0eWxlICYmIEJVSUxELm1vZGUgJiYgIUJVSUxELmxhenlMb2FkKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBjb21wdXRlTW9kZShlbG0pO1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBpZiAoaG9zdFJlZi4kbW9kZU5hbWUkICE9PSBtb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gICAgICAgICAgICBjb25zdCBvbGRTY29wZUlkID0gZWxtWydzLXNjJ107XG4gICAgICAgICAgICBjb25zdCBzY29wZUlkID0gZ2V0U2NvcGVJZChjbXBNZXRhLCBtb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWxtLmNvbnN0cnVjdG9yLnN0eWxlW21vZGVdO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBjbXBNZXRhLiRmbGFncyQ7XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZShzY29wZUlkLCBzdHlsZSwgISEoZmxhZ3MgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kbW9kZU5hbWUkID0gbW9kZTtcbiAgICAgICAgICAgICAgICBlbG0uY2xhc3NMaXN0LnJlbW92ZShvbGRTY29wZUlkICsgJy1oJywgb2xkU2NvcGVJZCArICctcycpO1xuICAgICAgICAgICAgICAgIGF0dGFjaFN0eWxlcyhob3N0UmVmKTtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGhtclN0YXJ0ID0gKGVsbSwgY21wTWV0YSwgaG1yVmVyc2lvbklkKSA9PiB7XG4gICAgLy8gwq9cXF8o44OEKV8vwq9cbiAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgIC8vIHJlc2V0IHN0YXRlIGZsYWdzIHRvIG9ubHkgaGF2ZSBiZWVuIGNvbm5lY3RlZFxuICAgIGhvc3RSZWYuJGZsYWdzJCA9IDEgLyogaGFzQ29ubmVjdGVkICovO1xuICAgIC8vIFRPRE9cbiAgICAvLyBkZXRhdGNoIGFueSBldmVudCBsaXN0ZW5lcnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGFkZGVkXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSBub3QgcGFzc2luZyBhbiBleGFjdCBldmVudCBuYW1lIGl0J2xsXG4gICAgLy8gcmVtb3ZlIGFsbCBvZiB0aGlzIGVsZW1lbnQncyBldmVudCwgd2hpY2ggaXMgZ29vZFxuICAgIC8vIGNyZWF0ZSBhIGNhbGxiYWNrIGZvciB3aGVuIHRoaXMgY29tcG9uZW50IGZpbmlzaGVzIGhtclxuICAgIGVsbVsncy1obXItbG9hZCddID0gKCkgPT4ge1xuICAgICAgICAvLyBmaW5pc2hlZCBobXIgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICBkZWxldGUgZWxtWydzLWhtci1sb2FkJ107XG4gICAgfTtcbiAgICAvLyByZS1pbml0aWFsaXplIHRoZSBjb21wb25lbnRcbiAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSwgaG1yVmVyc2lvbklkKTtcbn07XG5jb25zdCBwYXRjaENsb25lTm9kZSA9IChIb3N0RWxlbWVudFByb3RvdHlwZSkgPT4ge1xuICAgIGNvbnN0IG9yZ0Nsb25lTm9kZSA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZTtcbiAgICBIb3N0RWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICBjb25zdCBzcmNOb2RlID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNTaGFkb3dEb20gPSBCVUlMRC5zaGFkb3dEb20gPyBzcmNOb2RlLnNoYWRvd1Jvb3QgJiYgc3VwcG9ydHNTaGFkb3cgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xvbmVkTm9kZSA9IG9yZ0Nsb25lTm9kZS5jYWxsKHNyY05vZGUsIGlzU2hhZG93RG9tID8gZGVlcCA6IGZhbHNlKTtcbiAgICAgICAgaWYgKEJVSUxELnNsb3QgJiYgIWlzU2hhZG93RG9tICYmIGRlZXApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGxldCBzbG90dGVkLCBub25TdGVuY2lsTm9kZTtcbiAgICAgICAgICAgIGxldCBzdGVuY2lsUHJpdmF0ZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3MtaWQnLFxuICAgICAgICAgICAgICAgICdzLWNyJyxcbiAgICAgICAgICAgICAgICAncy1scicsXG4gICAgICAgICAgICAgICAgJ3MtcmMnLFxuICAgICAgICAgICAgICAgICdzLXNjJyxcbiAgICAgICAgICAgICAgICAncy1wJyxcbiAgICAgICAgICAgICAgICAncy1jbicsXG4gICAgICAgICAgICAgICAgJ3Mtc3InLFxuICAgICAgICAgICAgICAgICdzLXNuJyxcbiAgICAgICAgICAgICAgICAncy1obicsXG4gICAgICAgICAgICAgICAgJ3Mtb2wnLFxuICAgICAgICAgICAgICAgICdzLW5yJyxcbiAgICAgICAgICAgICAgICAncy1zaScsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBzcmNOb2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzbG90dGVkID0gc3JjTm9kZS5jaGlsZE5vZGVzW2ldWydzLW5yJ107XG4gICAgICAgICAgICAgICAgbm9uU3RlbmNpbE5vZGUgPSBzdGVuY2lsUHJpdmF0ZXMuZXZlcnkoKHByaXZhdGVGaWVsZCkgPT4gIXNyY05vZGUuY2hpbGROb2Rlc1tpXVtwcml2YXRlRmllbGRdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuYXBwZW5kQ2hpbGRTbG90Rml4ICYmIGNsb25lZE5vZGUuX19hcHBlbmRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5fX2FwcGVuZENoaWxkKHNsb3R0ZWQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc2xvdHRlZC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub25TdGVuY2lsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHNyY05vZGUuY2hpbGROb2Rlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkTm9kZTtcbiAgICB9O1xufTtcbmNvbnN0IHBhdGNoU2xvdEFwcGVuZENoaWxkID0gKEhvc3RFbGVtZW50UHJvdG90eXBlKSA9PiB7XG4gICAgSG9zdEVsZW1lbnRQcm90b3R5cGUuX19hcHBlbmRDaGlsZCA9IEhvc3RFbGVtZW50UHJvdG90eXBlLmFwcGVuZENoaWxkO1xuICAgIEhvc3RFbGVtZW50UHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5ld0NoaWxkKSB7XG4gICAgICAgIGNvbnN0IHNsb3ROYW1lID0gKG5ld0NoaWxkWydzLXNuJ10gPSBnZXRTbG90TmFtZShuZXdDaGlsZCkpO1xuICAgICAgICBjb25zdCBzbG90Tm9kZSA9IGdldEhvc3RTbG90Tm9kZSh0aGlzLmNoaWxkTm9kZXMsIHNsb3ROYW1lKTtcbiAgICAgICAgaWYgKHNsb3ROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBzbG90Q2hpbGROb2RlcyA9IGdldEhvc3RTbG90Q2hpbGROb2RlcyhzbG90Tm9kZSwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYXBwZW5kQWZ0ZXIgPSBzbG90Q2hpbGROb2Rlc1tzbG90Q2hpbGROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmRBZnRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZCwgYXBwZW5kQWZ0ZXIubmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgIH07XG59O1xuLyoqXG4gKiBQYXRjaGVzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYW4gdW5uYW1lZCBzbG90dGVkIG5vZGUgaW5zaWRlIGEgc2NvcGVkIGNvbXBvbmVudFxuICogQHBhcmFtIGhvc3RFbGVtZW50UHJvdG90eXBlIHRoZSBgRWxlbWVudGAgdG8gYmUgcGF0Y2hlZFxuICogQHBhcmFtIGNtcE1ldGEgY29tcG9uZW50IHJ1bnRpbWUgbWV0YWRhdGEgdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgcGF0Y2hlZCBvciBub3RcbiAqL1xuY29uc3QgcGF0Y2hUZXh0Q29udGVudCA9IChob3N0RWxlbWVudFByb3RvdHlwZSwgY21wTWV0YSkgPT4ge1xuICAgIGlmIChCVUlMRC5zY29wZWQgJiYgY21wTWV0YS4kZmxhZ3MkICYgMiAvKiBzY29wZWRDc3NFbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3RFbGVtZW50UHJvdG90eXBlLCAnX190ZXh0Q29udGVudCcsIGRlc2NyaXB0b3IpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdEVsZW1lbnRQcm90b3R5cGUsICd0ZXh0Q29udGVudCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSAnZGVmYXVsdCBzbG90Jywgd2hpY2ggd291bGQgYmUgdGhlIGZpcnN0IHNsb3QgaW4gYSBzaGFkb3cgdHJlZSAoaWYgd2Ugd2VyZSB1c2luZyBvbmUpLCB3aG9zZSBuYW1lIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKHRoaXMuY2hpbGROb2RlcywgJycpO1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBzbG90IG5vZGUgaXMgZm91bmQsIHRoZSB0ZXh0Q29udGVudCBfbWF5XyBiZSBmb3VuZCBpbiB0aGUgbmV4dCBzaWJsaW5nICh0ZXh0KSBub2RlLCBkZXBlbmRpbmcgb24gaG93XG4gICAgICAgICAgICAgICAgLy8gbm9kZXMgd2VyZSByZW9yZGVyZWQgZHVyaW5nIHRoZSB2ZG9tIHJlbmRlci4gZmlyc3QgdHJ5IHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb20gdGhlIHNpYmxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBzbG90Tm9kZSA9PT0gbnVsbCB8fCBzbG90Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xvdE5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVHlwZSkgPT09IDMgLyogVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbG90Tm9kZS5uZXh0U2libGluZy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3ROb2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlICdkZWZhdWx0IHNsb3QnLCB3aGljaCB3b3VsZCBiZSB0aGUgZmlyc3Qgc2xvdCBpbiBhIHNoYWRvdyB0cmVlIChpZiB3ZSB3ZXJlIHVzaW5nIG9uZSksIHdob3NlIG5hbWUgaXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdE5vZGUgPSBnZXRIb3N0U2xvdE5vZGUodGhpcy5jaGlsZE5vZGVzLCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIHNsb3Qgbm9kZSBpcyBmb3VuZCwgdGhlIHRleHRDb250ZW50IF9tYXlfIG5lZWQgdG8gYmUgcGxhY2VkIGluIHRoZSBuZXh0IHNpYmxpbmcgKHRleHQpIG5vZGUsXG4gICAgICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGhvdyBub2RlcyB3ZXJlIHJlb3JkZXJlZCBkdXJpbmcgdGhlIHZkb20gcmVuZGVyLiBmaXJzdCB0cnkgdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb24gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2libGluZy5cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHNsb3ROb2RlID09PSBudWxsIHx8IHNsb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbG90Tm9kZS5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGVUeXBlKSA9PT0gMyAvKiBURVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkbid0IGZpbmQgYSBzbG90LCBidXQgdGhhdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGVyZSBpc24ndCBvbmUuIGlmIHRoaXMgY2hlY2sgcmFuIGJlZm9yZSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvYWRlZCwgd2UgY291bGQgaGF2ZSBtaXNzZWQgaXQuIGNoZWNrIGZvciBhIGNvbnRlbnQgcmVmZXJlbmNlIGVsZW1lbnQgb24gdGhlIHNjb3BlZCBjb21wb25lbnQgYW5kIGluc2VydFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudFJlZkVsbSA9IHRoaXNbJ3MtY3InXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRSZWZFbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNvbnRlbnRSZWZFbG0sIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGF0Y2hDaGlsZFNsb3ROb2RlcyA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjbGFzcyBGYWtlTm9kZUxpc3QgZXh0ZW5kcyBBcnJheSB7XG4gICAgICAgIGl0ZW0obikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNtcE1ldGEuJGZsYWdzJCAmIDggLyogbmVlZHNTaGFkb3dEb21TaGltICovKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXNGbiA9IGVsbS5fX2xvb2t1cEdldHRlcl9fKCdjaGlsZE5vZGVzJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZHJlbicsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLm1hcCgobikgPT4gbi5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsbSwgJ2NoaWxkRWxlbWVudENvdW50Jywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbG0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbG0sICdjaGlsZE5vZGVzJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzRm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoKHBsdC4kZmxhZ3MkICYgMSAvKiBpc1RtcERpc2Nvbm5lY3RlZCAqLykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0SG9zdFJlZih0aGlzKS4kZmxhZ3MkICYgMiAvKiBoYXNSZW5kZXJlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmFrZU5vZGVMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkTm9kZXNbaV1bJ3MtbnInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2xvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZha2VOb2RlTGlzdC5mcm9tKGNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGdldFNsb3ROYW1lID0gKG5vZGUpID0+IG5vZGVbJ3Mtc24nXSB8fCAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnc2xvdCcpKSB8fCAnJztcbi8qKlxuICogUmVjdXJzaXZlbHkgc2VhcmNoZXMgYSBzZXJpZXMgb2YgY2hpbGQgbm9kZXMgZm9yIGEgc2xvdCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lLlxuICogQHBhcmFtIGNoaWxkTm9kZXMgdGhlIG5vZGVzIHRvIHNlYXJjaCBmb3IgYSBzbG90IHdpdGggYSBzcGVjaWZpYyBuYW1lLlxuICogQHBhcmFtIHNsb3ROYW1lIHRoZSBuYW1lIG9mIHRoZSBzbG90IHRvIG1hdGNoIG9uLlxuICogQHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNsb3Qgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIG5hbWUsIGBudWxsYCBvdGhlcndpc2VcbiAqL1xuY29uc3QgZ2V0SG9zdFNsb3ROb2RlID0gKGNoaWxkTm9kZXMsIHNsb3ROYW1lKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjaGlsZE5vZGU7XG4gICAgZm9yICg7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmIChjaGlsZE5vZGVbJ3Mtc3InXSAmJiBjaGlsZE5vZGVbJ3Mtc24nXSA9PT0gc2xvdE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGROb2RlID0gZ2V0SG9zdFNsb3ROb2RlKGNoaWxkTm9kZS5jaGlsZE5vZGVzLCBzbG90TmFtZSk7XG4gICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0SG9zdFNsb3RDaGlsZE5vZGVzID0gKG4sIHNsb3ROYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IFtuXTtcbiAgICB3aGlsZSAoKG4gPSBuLm5leHRTaWJsaW5nKSAmJiBuWydzLXNuJ10gPT09IHNsb3ROYW1lKSB7XG4gICAgICAgIGNoaWxkTm9kZXMucHVzaChuKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkTm9kZXM7XG59O1xuY29uc3QgYm9vdHN0cmFwTGF6eSA9IChsYXp5QnVuZGxlcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgaWYgKEJVSUxELnByb2ZpbGUgJiYgcGVyZm9ybWFuY2UubWFyaykge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdzdDphcHA6c3RhcnQnKTtcbiAgICB9XG4gICAgaW5zdGFsbERldlRvb2xzKCk7XG4gICAgY29uc3QgZW5kQm9vdHN0cmFwID0gY3JlYXRlVGltZSgnYm9vdHN0cmFwTGF6eScpO1xuICAgIGNvbnN0IGNtcFRhZ3MgPSBbXTtcbiAgICBjb25zdCBleGNsdWRlID0gb3B0aW9ucy5leGNsdWRlIHx8IFtdO1xuICAgIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gd2luLmN1c3RvbUVsZW1lbnRzO1xuICAgIGNvbnN0IGhlYWQgPSBkb2MuaGVhZDtcbiAgICBjb25zdCBtZXRhQ2hhcnNldCA9IC8qQF9fUFVSRV9fKi8gaGVhZC5xdWVyeVNlbGVjdG9yKCdtZXRhW2NoYXJzZXRdJyk7XG4gICAgY29uc3QgdmlzaWJpbGl0eVN0eWxlID0gLypAX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjb25zdCBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlcyA9IC8qQF9fUFVSRV9fKi8gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoYFske0hZRFJBVEVEX1NUWUxFX0lEfV1gKTtcbiAgICBsZXQgYXBwTG9hZEZhbGxiYWNrO1xuICAgIGxldCBpc0Jvb3RzdHJhcHBpbmcgPSB0cnVlO1xuICAgIGxldCBpID0gMDtcbiAgICBPYmplY3QuYXNzaWduKHBsdCwgb3B0aW9ucyk7XG4gICAgcGx0LiRyZXNvdXJjZXNVcmwkID0gbmV3IFVSTChvcHRpb25zLnJlc291cmNlc1VybCB8fCAnLi8nLCBkb2MuYmFzZVVSSSkuaHJlZjtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zeW5jUXVldWUpIHtcbiAgICAgICAgICAgIHBsdC4kZmxhZ3MkIHw9IDQgLyogcXVldWVTeW5jICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSkge1xuICAgICAgICAvLyBJZiB0aGUgYXBwIGlzIGFscmVhZHkgaHlkcmF0ZWQgdGhlcmUgaXMgbm90IHBvaW50IHRvIGRpc2FibGUgdGhlXG4gICAgICAgIC8vIGFzeW5jIHF1ZXVlLiBUaGlzIHdpbGwgaW1wcm92ZSB0aGUgZmlyc3QgaW5wdXQgZGVsYXlcbiAgICAgICAgcGx0LiRmbGFncyQgfD0gMiAvKiBhcHBMb2FkZWQgKi87XG4gICAgfVxuICAgIGlmIChCVUlMRC5oeWRyYXRlQ2xpZW50U2lkZSAmJiBCVUlMRC5zaGFkb3dEb20pIHtcbiAgICAgICAgZm9yICg7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc3R5bGVzW2ldLmdldEF0dHJpYnV0ZShIWURSQVRFRF9TVFlMRV9JRCksIGNvbnZlcnRTY29wZWRUb1NoYWRvdyhzdHlsZXNbaV0uaW5uZXJIVE1MKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGF6eUJ1bmRsZXMubWFwKChsYXp5QnVuZGxlKSA9PiB7XG4gICAgICAgIGxhenlCdW5kbGVbMV0ubWFwKChjb21wYWN0TWV0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY21wTWV0YSA9IHtcbiAgICAgICAgICAgICAgICAkZmxhZ3MkOiBjb21wYWN0TWV0YVswXSxcbiAgICAgICAgICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgICAgICAgICAgICAgICRtZW1iZXJzJDogY29tcGFjdE1ldGFbMl0sXG4gICAgICAgICAgICAgICAgJGxpc3RlbmVycyQ6IGNvbXBhY3RNZXRhWzNdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5yZWZsZWN0KSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQud2F0Y2hDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELnNoYWRvd0RvbSAmJiAhc3VwcG9ydHNTaGFkb3cgJiYgY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgY21wTWV0YS4kZmxhZ3MkIHw9IDggLyogbmVlZHNTaGFkb3dEb21TaGltICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IEJVSUxELnRyYW5zZm9ybVRhZ05hbWUgJiYgb3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUoY21wTWV0YS4kdGFnTmFtZSQpXG4gICAgICAgICAgICAgICAgOiBjbXBNZXRhLiR0YWdOYW1lJDtcbiAgICAgICAgICAgIGNvbnN0IEhvc3RFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICAgICAgLy8gU3RlbmNpbExhenlIb3N0XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJIb3N0KHNlbGYsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RG9tICYmIGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogc2hhZG93RG9tRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgaXMgdXNpbmcgc2hhZG93IGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBzaGFkb3cgZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHJlYWQtb25seSBwcm9wZXJ0eSBcInNoYWRvd1Jvb3RcIiB0byB0aGUgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdGhlIHNoYWRvdyByb290IGJ1aWxkIGNvbmRpdGlvbmFscyB0byBtaW5pbWl6ZSBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQlVJTEQuc2hhZG93RGVsZWdhdGVzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIHNoYWRvd0RlbGVnYXRlc0ZvY3VzICovKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQlVJTEQuaHlkcmF0ZVNlcnZlclNpZGUgJiYgISgnc2hhZG93Um9vdCcgaW4gc2VsZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNoYWRvd1Jvb3QgPSBzZWxmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChCVUlMRC5zbG90Q2hpbGROb2Rlc0ZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hDaGlsZFNsb3ROb2RlcyhzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcExvYWRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFwcExvYWRGYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBMb2FkRmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb3RzdHJhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3RlZENhbGxiYWNrIHdpbGwgYmUgcHJvY2Vzc2VkIG9uY2UgYWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IGNvbm5lY3RlZENhbGxiYWNrKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBkaXNjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE9uUmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRIb3N0UmVmKHRoaXMpLiRvblJlYWR5UHJvbWlzZSQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChCVUlMRC5jbG9uZU5vZGVGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENsb25lTm9kZShIb3N0RWxlbWVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEJVSUxELmFwcGVuZENoaWxkU2xvdEZpeCkge1xuICAgICAgICAgICAgICAgIHBhdGNoU2xvdEFwcGVuZENoaWxkKEhvc3RFbGVtZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBIb3N0RWxlbWVudC5wcm90b3R5cGVbJ3MtaG1yJ10gPSBmdW5jdGlvbiAoaG1yVmVyc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhtclN0YXJ0KHRoaXMsIGNtcE1ldGEsIGhtclZlcnNpb25JZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChCVUlMRC5zY29wZWRTbG90VGV4dENvbnRlbnRGaXgpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFRleHRDb250ZW50KEhvc3RFbGVtZW50LnByb3RvdHlwZSwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbXBNZXRhLiRsYXp5QnVuZGxlSWQkID0gbGF6eUJ1bmRsZVswXTtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyh0YWdOYW1lKSAmJiAhY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgY21wVGFncy5wdXNoKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBwcm94eUNvbXBvbmVudChIb3N0RWxlbWVudCwgY21wTWV0YSwgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoQlVJTEQuaW52aXNpYmxlUHJlaHlkcmF0aW9uICYmIChCVUlMRC5oeWRyYXRlZENsYXNzIHx8IEJVSUxELmh5ZHJhdGVkQXR0cmlidXRlKSkge1xuICAgICAgICB2aXNpYmlsaXR5U3R5bGUuaW5uZXJIVE1MID0gY21wVGFncyArIEhZRFJBVEVEX0NTUztcbiAgICAgICAgdmlzaWJpbGl0eVN0eWxlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdHlsZXMnLCAnJyk7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHZpc2liaWxpdHlTdHlsZSwgbWV0YUNoYXJzZXQgPyBtZXRhQ2hhcnNldC5uZXh0U2libGluZyA6IGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZGVmZXJyZWQgY29ubmVjdGVkQ2FsbGJhY2tzIG5vdyBhbGwgY29tcG9uZW50cyBoYXZlIGJlZW4gcmVnaXN0ZXJlZFxuICAgIGlzQm9vdHN0cmFwcGluZyA9IGZhbHNlO1xuICAgIGlmIChkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MubWFwKChob3N0KSA9PiBob3N0LmNvbm5lY3RlZENhbGxiYWNrKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJVSUxELnByb2ZpbGUpIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzAsICd0aW1lb3V0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5qbXAoKCkgPT4gKGFwcExvYWRGYWxsYmFjayA9IHNldFRpbWVvdXQoYXBwRGlkTG9hZCwgMzApKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgYXBwTG9hZCBldmVudFxuICAgIGVuZEJvb3RzdHJhcCgpO1xufTtcbmNvbnN0IGdldEFzc2V0UGF0aCA9IChwYXRoKSA9PiB7XG4gICAgY29uc3QgYXNzZXRVcmwgPSBuZXcgVVJMKHBhdGgsIHBsdC4kcmVzb3VyY2VzVXJsJCk7XG4gICAgcmV0dXJuIGFzc2V0VXJsLm9yaWdpbiAhPT0gd2luLmxvY2F0aW9uLm9yaWdpbiA/IGFzc2V0VXJsLmhyZWYgOiBhc3NldFVybC5wYXRobmFtZTtcbn07XG5jb25zdCBzZXRBc3NldFBhdGggPSAocGF0aCkgPT4gKHBsdC4kcmVzb3VyY2VzVXJsJCA9IHBhdGgpO1xuY29uc3QgZ2V0Q29ubmVjdCA9IChfcmVmLCB0YWdOYW1lKSA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50T25SZWFkeSA9ICgpID0+IHtcbiAgICAgICAgbGV0IGVsbSA9IGRvYy5xdWVyeVNlbGVjdG9yKHRhZ05hbWUpO1xuICAgICAgICBpZiAoIWVsbSkge1xuICAgICAgICAgICAgZWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChlbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWxtLmNvbXBvbmVudE9uUmVhZHkgPT09ICdmdW5jdGlvbicgPyBlbG0uY29tcG9uZW50T25SZWFkeSgpIDogUHJvbWlzZS5yZXNvbHZlKGVsbSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50T25SZWFkeSgpLnRoZW4oKGVsKSA9PiBlbC5jcmVhdGUoLi4uYXJncykpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlLFxuICAgICAgICBjb21wb25lbnRPblJlYWR5LFxuICAgIH07XG59O1xuY29uc3QgZ2V0Q29udGV4dCA9IChfZWxtLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKGNvbnRleHQgaW4gQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gQ29udGV4dFtjb250ZXh0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgcmV0dXJuIHdpbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNTZXJ2ZXInIHx8IGNvbnRleHQgPT09ICdpc1ByZXJlbmRlcicpIHtcbiAgICAgICAgcmV0dXJuIEJVSUxELmh5ZHJhdGVTZXJ2ZXJTaWRlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaXNDbGllbnQnKSB7XG4gICAgICAgIHJldHVybiBCVUlMRC5oeWRyYXRlU2VydmVyU2lkZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3Jlc291cmNlc1VybCcgfHwgY29udGV4dCA9PT0gJ3B1YmxpY1BhdGgnKSB7XG4gICAgICAgIHJldHVybiBnZXRBc3NldFBhdGgoJy4nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCA9PT0gJ3F1ZXVlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JpdGU6IHdyaXRlVGFzayxcbiAgICAgICAgICAgIHJlYWQ6IHJlYWRUYXNrLFxuICAgICAgICAgICAgdGljazoge1xuICAgICAgICAgICAgICAgIHRoZW4oY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRUaWNrKGNiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5jb25zdCBpbnNlcnRWZG9tQW5ub3RhdGlvbnMgPSAoZG9jLCBzdGF0aWNDb21wb25lbnRzKSA9PiB7XG4gICAgaWYgKGRvYyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvY0RhdGEgPSB7XG4gICAgICAgICAgICBob3N0SWRzOiAwLFxuICAgICAgICAgICAgcm9vdExldmVsSWRzOiAwLFxuICAgICAgICAgICAgc3RhdGljQ29tcG9uZW50czogbmV3IFNldChzdGF0aWNDb21wb25lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICBwYXJzZVZOb2RlQW5ub3RhdGlvbnMoZG9jLCBkb2MuYm9keSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIG9yZ0xvY2F0aW9uTm9kZXMuZm9yRWFjaCgob3JnTG9jYXRpb25Ob2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAob3JnTG9jYXRpb25Ob2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVmID0gb3JnTG9jYXRpb25Ob2RlWydzLW5yJ107XG4gICAgICAgICAgICAgICAgbGV0IGhvc3RJZCA9IG5vZGVSZWZbJ3MtaG9zdC1pZCddO1xuICAgICAgICAgICAgICAgIGxldCBub2RlSWQgPSBub2RlUmVmWydzLW5vZGUtaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRJZCA9IGAke2hvc3RJZH0uJHtub2RlSWR9YDtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdElkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG9jRGF0YS5yb290TGV2ZWxJZHMrKztcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkID0gZG9jRGF0YS5yb290TGV2ZWxJZHM7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlUmVmLm5vZGVUeXBlID09PSAxIC8qIEVsZW1lbnROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUmVmLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBjaGlsZElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlUmVmLm5vZGVUeXBlID09PSAzIC8qIFRleHROb2RlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdElkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlUmVmLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VsZXNzIHdoaXRlc3BhY2Ugbm9kZSBhdCB0aGUgZG9jdW1lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmdMb2NhdGlvbk5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50QmVmb3JlVGV4dE5vZGUgPSBkb2MuY3JlYXRlQ29tbWVudChjaGlsZElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmVUZXh0Tm9kZS5ub2RlVmFsdWUgPSBgJHtURVhUX05PREVfSUR9LiR7Y2hpbGRJZH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjb21tZW50QmVmb3JlVGV4dE5vZGUsIG5vZGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBvcmdMb2NhdGlvbk5vZGVJZCA9IGAke09SR19MT0NBVElPTl9JRH0uJHtjaGlsZElkfWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnTG9jYXRpb25QYXJlbnROb2RlID0gb3JnTG9jYXRpb25Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0xvY2F0aW9uUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JnTG9jYXRpb25QYXJlbnROb2RlWydzLWVuJ10gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLlwiIG1lYW5zIHRoYXQgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGlzIG5vZGUncyBvcmlnaW5hbCBsb2NhdGlvbiBpcyBhIFNIQURPVyBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuYDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmdMb2NhdGlvblBhcmVudE5vZGVbJ3MtZW4nXSA9PT0gJ2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmRpbmcgd2l0aCBhIFwiLmNcIiBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhpcyBub2RlJ3Mgb3JpZ2luYWwgbG9jYXRpb24gaXMgYSBTQ09QRUQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoaXMgbm9kZSBpcyBhcGFydCBvZiB0aGUgcm9vdCBsZXZlbCBsaWdodCBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZ0xvY2F0aW9uTm9kZUlkICs9IGAuY2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JnTG9jYXRpb25Ob2RlLm5vZGVWYWx1ZSA9IG9yZ0xvY2F0aW9uTm9kZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGFyc2VWTm9kZUFubm90YXRpb25zID0gKGRvYywgbm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2RlcykgPT4ge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZVsncy1uciddICE9IG51bGwpIHtcbiAgICAgICAgb3JnTG9jYXRpb25Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFbGVtZW50Tm9kZSAqLykge1xuICAgICAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYgIT0gbnVsbCAmJiAhZG9jRGF0YS5zdGF0aWNDb21wb25lbnRzLmhhcyhjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbXBEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlSWRzOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5zZXJ0Vk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgaG9zdFJlZi4kdm5vZGUkLCBkb2NEYXRhLCBjbXBEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlVk5vZGVBbm5vdGF0aW9ucyhkb2MsIGNoaWxkTm9kZSwgZG9jRGF0YSwgb3JnTG9jYXRpb25Ob2Rlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBpbnNlcnRWTm9kZUFubm90YXRpb25zID0gKGRvYywgaG9zdEVsbSwgdm5vZGUsIGRvY0RhdGEsIGNtcERhdGEpID0+IHtcbiAgICBpZiAodm5vZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBob3N0SWQgPSArK2RvY0RhdGEuaG9zdElkcztcbiAgICAgICAgaG9zdEVsbS5zZXRBdHRyaWJ1dGUoSFlEUkFURV9JRCwgaG9zdElkKTtcbiAgICAgICAgaWYgKGhvc3RFbG1bJ3MtY3InXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBob3N0RWxtWydzLWNyJ10ubm9kZVZhbHVlID0gYCR7Q09OVEVOVF9SRUZfSUR9LiR7aG9zdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLiRjaGlsZHJlbiQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVwdGggPSAwO1xuICAgICAgICAgICAgdm5vZGUuJGNoaWxkcmVuJC5mb3JFYWNoKCh2bm9kZUNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGluc2VydENoaWxkVk5vZGVBbm5vdGF0aW9ucyhkb2MsIHZub2RlQ2hpbGQsIGNtcERhdGEsIGhvc3RJZCwgZGVwdGgsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0RWxtICYmIHZub2RlICYmIHZub2RlLiRlbG0kICYmICFob3N0RWxtLmhhc0F0dHJpYnV0ZSgnYy1pZCcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBob3N0RWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q2hpbGROb2RlcyA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBwYXJlbnRDaGlsZE5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8gJiYgbm9kZVsncy1zciddKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudENoaWxkTm9kZXMuaW5kZXhPZihob3N0RWxtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLiRlbG0kLnNldEF0dHJpYnV0ZShIWURSQVRFX0NISUxEX0lELCBgJHtjb21tZW50WydzLWhvc3QtaWQnXX0uJHtjb21tZW50WydzLW5vZGUtaWQnXX0uMC4ke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpbnNlcnRDaGlsZFZOb2RlQW5ub3RhdGlvbnMgPSAoZG9jLCB2bm9kZUNoaWxkLCBjbXBEYXRhLCBob3N0SWQsIGRlcHRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkRWxtID0gdm5vZGVDaGlsZC4kZWxtJDtcbiAgICBpZiAoY2hpbGRFbG0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVJZCA9IGNtcERhdGEubm9kZUlkcysrO1xuICAgIGNvbnN0IGNoaWxkSWQgPSBgJHtob3N0SWR9LiR7bm9kZUlkfS4ke2RlcHRofS4ke2luZGV4fWA7XG4gICAgY2hpbGRFbG1bJ3MtaG9zdC1pZCddID0gaG9zdElkO1xuICAgIGNoaWxkRWxtWydzLW5vZGUtaWQnXSA9IG5vZGVJZDtcbiAgICBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDEgLyogRWxlbWVudE5vZGUgKi8pIHtcbiAgICAgICAgY2hpbGRFbG0uc2V0QXR0cmlidXRlKEhZRFJBVEVfQ0hJTERfSUQsIGNoaWxkSWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZEVsbS5ub2RlVHlwZSA9PT0gMyAvKiBUZXh0Tm9kZSAqLykge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gY2hpbGRFbG0ucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAobm9kZU5hbWUgIT09ICdTVFlMRScgJiYgbm9kZU5hbWUgIT09ICdTQ1JJUFQnKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZUlkID0gYCR7VEVYVF9OT0RFX0lEfS4ke2NoaWxkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRCZWZvcmVUZXh0Tm9kZSA9IGRvYy5jcmVhdGVDb21tZW50KHRleHROb2RlSWQpO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29tbWVudEJlZm9yZVRleHROb2RlLCBjaGlsZEVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRFbG0ubm9kZVR5cGUgPT09IDggLyogQ29tbWVudE5vZGUgKi8pIHtcbiAgICAgICAgaWYgKGNoaWxkRWxtWydzLXNyJ10pIHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROYW1lID0gY2hpbGRFbG1bJ3Mtc24nXSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNsb3ROb2RlSWQgPSBgJHtTTE9UX05PREVfSUR9LiR7Y2hpbGRJZH0uJHtzbG90TmFtZX1gO1xuICAgICAgICAgICAgY2hpbGRFbG0ubm9kZVZhbHVlID0gc2xvdE5vZGVJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGVDaGlsZC4kY2hpbGRyZW4kICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hpbGREZXB0aCA9IGRlcHRoICsgMTtcbiAgICAgICAgdm5vZGVDaGlsZC4kY2hpbGRyZW4kLmZvckVhY2goKHZub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaW5zZXJ0Q2hpbGRWTm9kZUFubm90YXRpb25zKGRvYywgdm5vZGUsIGNtcERhdGEsIGhvc3RJZCwgY2hpbGREZXB0aCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3Qgc2V0UGxhdGZvcm1PcHRpb25zID0gKG9wdHMpID0+IE9iamVjdC5hc3NpZ24ocGx0LCBvcHRzKTtcbmNvbnN0IEZyYWdtZW50ID0gKF8sIGNoaWxkcmVuKSA9PiBjaGlsZHJlbjtcbmNvbnN0IGhvc3RSZWZzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEhvc3RSZWYgPSAocmVmKSA9PiBob3N0UmVmcy5nZXQocmVmKTtcbmNvbnN0IHJlZ2lzdGVySW5zdGFuY2UgPSAobGF6eUluc3RhbmNlLCBob3N0UmVmKSA9PiBob3N0UmVmcy5zZXQoKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgPSBsYXp5SW5zdGFuY2UpLCBob3N0UmVmKTtcbmNvbnN0IHJlZ2lzdGVySG9zdCA9IChlbG0sIGNtcE1ldGEpID0+IHtcbiAgICBjb25zdCBob3N0UmVmID0ge1xuICAgICAgICAkZmxhZ3MkOiAwLFxuICAgICAgICAkaG9zdEVsZW1lbnQkOiBlbG0sXG4gICAgICAgICRjbXBNZXRhJDogY21wTWV0YSxcbiAgICAgICAgJGluc3RhbmNlVmFsdWVzJDogbmV3IE1hcCgpLFxuICAgIH07XG4gICAgaWYgKEJVSUxELmlzRGV2KSB7XG4gICAgICAgIGhvc3RSZWYuJHJlbmRlckNvdW50JCA9IDA7XG4gICAgfVxuICAgIGlmIChCVUlMRC5tZXRob2QgJiYgQlVJTEQubGF6eUxvYWQpIHtcbiAgICAgICAgaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQgPSByKSk7XG4gICAgfVxuICAgIGlmIChCVUlMRC5hc3luY0xvYWRpbmcpIHtcbiAgICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKSk7XG4gICAgICAgIGVsbVsncy1wJ10gPSBbXTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSBbXTtcbiAgICB9XG4gICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCwgZmFsc2UpO1xuICAgIHJldHVybiBob3N0UmVmcy5zZXQoZWxtLCBob3N0UmVmKTtcbn07XG5jb25zdCBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xuY29uc3QgY29uc29sZUVycm9yID0gKGUsIGVsKSA9PiAoY3VzdG9tRXJyb3IgfHwgY29uc29sZS5lcnJvcikoZSwgZWwpO1xuY29uc3QgU1RFTkNJTF9ERVZfTU9ERSA9IEJVSUxELmlzVGVzdGluZ1xuICAgID8gWydTVEVOQ0lMOiddIC8vIEUyRSB0ZXN0aW5nXG4gICAgOiBbXG4gICAgICAgICclY3N0ZW5jaWwnLFxuICAgICAgICAnY29sb3I6IHdoaXRlO2JhY2tncm91bmQ6IzRjNDdmZjtmb250LXdlaWdodDogYm9sZDsgZm9udC1zaXplOjEwcHg7IHBhZGRpbmc6MnB4IDZweDsgYm9yZGVyLXJhZGl1czogNXB4JyxcbiAgICBdO1xuY29uc3QgY29uc29sZURldkVycm9yID0gKC4uLm0pID0+IGNvbnNvbGUuZXJyb3IoLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2V2FybiA9ICguLi5tKSA9PiBjb25zb2xlLndhcm4oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBjb25zb2xlRGV2SW5mbyA9ICguLi5tKSA9PiBjb25zb2xlLmluZm8oLi4uU1RFTkNJTF9ERVZfTU9ERSwgLi4ubSk7XG5jb25zdCBzZXRFcnJvckhhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGN1c3RvbUVycm9yID0gaGFuZGxlcik7XG5jb25zdCBjbXBNb2R1bGVzID0gLypAX19QVVJFX18qLyBuZXcgTWFwKCk7XG5jb25zdCBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIGxvYWRNb2R1bGVJbXBvcnRcbiAgICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgICBpZiAoQlVJTEQuaXNEZXYgJiYgdHlwZW9mIGJ1bmRsZUlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlRGV2RXJyb3IoYFRyeWluZyB0byBsYXppbHkgbG9hZCBjb21wb25lbnQgPCR7Y21wTWV0YS4kdGFnTmFtZSR9PiB3aXRoIHN0eWxlIG1vZGUgXCIke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiwgYnV0IGl0IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGUgPSAhQlVJTEQuaG90TW9kdWxlUmVwbGFjZW1lbnQgPyBjbXBNb2R1bGVzLmdldChidW5kbGVJZCkgOiBmYWxzZTtcbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnQoXG4gICAgLyogd2VicGFja0luY2x1ZGU6IC9cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrRXhjbHVkZTogL1xcLnN5c3RlbVxcLmVudHJ5XFwuanMkLyAqL1xuICAgIC8qIHdlYnBhY2tNb2RlOiBcImxhenlcIiAqL1xuICAgIGAuLyR7YnVuZGxlSWR9LmVudHJ5LmpzJHtCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCAmJiBobXJWZXJzaW9uSWQgPyAnP3MtaG1yPScgKyBobXJWZXJzaW9uSWQgOiAnJ31gKS50aGVuKChpbXBvcnRlZE1vZHVsZSkgPT4ge1xuICAgICAgICBpZiAoIUJVSUxELmhvdE1vZHVsZVJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjbXBNb2R1bGVzLnNldChidW5kbGVJZCwgaW1wb3J0ZWRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRlZE1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9LCBjb25zb2xlRXJyb3IpO1xufTtcbmNvbnN0IHN0eWxlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IG1vZGVSZXNvbHV0aW9uQ2hhaW4gPSBbXTtcbmNvbnN0IHF1ZXVlRG9tUmVhZHMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzID0gW107XG5jb25zdCBxdWV1ZURvbVdyaXRlc0xvdyA9IFtdO1xuY29uc3QgcXVldWVUYXNrID0gKHF1ZXVlLCB3cml0ZSkgPT4gKGNiKSA9PiB7XG4gICAgcXVldWUucHVzaChjYik7XG4gICAgaWYgKCFxdWV1ZVBlbmRpbmcpIHtcbiAgICAgICAgcXVldWVQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHdyaXRlICYmIHBsdC4kZmxhZ3MkICYgNCAvKiBxdWV1ZVN5bmMgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNvbnN1bWUgPSAocXVldWUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBxdWV1ZVtpXShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xufTtcbmNvbnN0IGNvbnN1bWVUaW1lb3V0ID0gKHF1ZXVlLCB0aW1lb3V0KSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB0cyA9IDA7XG4gICAgd2hpbGUgKGkgPCBxdWV1ZS5sZW5ndGggJiYgKHRzID0gcGVyZm9ybWFuY2Uubm93KCkpIDwgdGltZW91dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVldWVbaSsrXSh0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKDAsIGkpO1xuICAgIH1cbn07XG5jb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoQlVJTEQuYXN5bmNRdWV1ZSkge1xuICAgICAgICBxdWV1ZUNvbmdlc3Rpb24rKztcbiAgICB9XG4gICAgLy8gYWx3YXlzIGZvcmNlIGEgYnVuY2ggb2YgbWVkaXVtIGNhbGxiYWNrcyB0byBydW4sIGJ1dCBzdGlsbCBoYXZlXG4gICAgLy8gYSB0aHJvdHRsZSBvbiBob3cgbWFueSBjYW4gcnVuIGluIGEgY2VydGFpbiB0aW1lXG4gICAgLy8gRE9NIFJFQURTISEhXG4gICAgY29uc3VtZShxdWV1ZURvbVJlYWRzKTtcbiAgICAvLyBET00gV1JJVEVTISEhXG4gICAgaWYgKEJVSUxELmFzeW5jUXVldWUpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChwbHQuJGZsYWdzJCAmIDYgLyogcXVldWVNYXNrICovKSA9PT0gMiAvKiBhcHBMb2FkZWQgKi9cbiAgICAgICAgICAgID8gcGVyZm9ybWFuY2Uubm93KCkgKyAxNCAqIE1hdGguY2VpbChxdWV1ZUNvbmdlc3Rpb24gKiAoMS4wIC8gMTAuMCkpXG4gICAgICAgICAgICA6IEluZmluaXR5O1xuICAgICAgICBjb25zdW1lVGltZW91dChxdWV1ZURvbVdyaXRlcywgdGltZW91dCk7XG4gICAgICAgIGNvbnN1bWVUaW1lb3V0KHF1ZXVlRG9tV3JpdGVzTG93LCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHF1ZXVlRG9tV3JpdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXVlRG9tV3JpdGVzTG93LnB1c2goLi4ucXVldWVEb21Xcml0ZXMpO1xuICAgICAgICAgICAgcXVldWVEb21Xcml0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXMubGVuZ3RoICsgcXVldWVEb21Xcml0ZXNMb3cubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIHN0aWxsIG1vcmUgdG8gZG8geWV0LCBidXQgd2UndmUgcnVuIG91dCBvZiB0aW1lXG4gICAgICAgICAgICAvLyBsZXQncyBsZXQgdGhpcyB0aGluZyBjb29sIG9mZiBhbmQgdHJ5IGFnYWluIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWVDb25nZXN0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3VtZShxdWV1ZURvbVdyaXRlcyk7XG4gICAgICAgIGlmICgocXVldWVQZW5kaW5nID0gcXVldWVEb21SZWFkcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gc3RpbGwgbW9yZSB0byBkbyB5ZXQsIGJ1dCB3ZSd2ZSBydW4gb3V0IG9mIHRpbWVcbiAgICAgICAgICAgIC8vIGxldCdzIGxldCB0aGlzIHRoaW5nIGNvb2wgb2ZmIGFuZCB0cnkgYWdhaW4gaW4gdGhlIG5leHQgdGlja1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgbmV4dFRpY2sgPSAvKkBfX1BVUkVfXyovIChjYikgPT4gcHJvbWlzZVJlc29sdmUoKS50aGVuKGNiKTtcbmNvbnN0IHJlYWRUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21SZWFkcywgZmFsc2UpO1xuY29uc3Qgd3JpdGVUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21Xcml0ZXMsIHRydWUpO1xuY29uc3QgQnVpbGQgPSB7XG4gICAgaXNEZXY6IEJVSUxELmlzRGV2ID8gdHJ1ZSA6IGZhbHNlLFxuICAgIGlzQnJvd3NlcjogdHJ1ZSxcbiAgICBpc1NlcnZlcjogZmFsc2UsXG4gICAgaXNUZXN0aW5nOiBCVUlMRC5pc1Rlc3RpbmcgPyB0cnVlIDogZmFsc2UsXG59O1xuZXhwb3J0IHsgQlVJTEQsIEVudiwgTkFNRVNQQUNFIH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9hcHAtZGF0YSc7XG5leHBvcnQgeyBCdWlsZCwgQ1NTLCBDb250ZXh0LCBGcmFnbWVudCwgSCwgSCBhcyBIVE1MRWxlbWVudCwgSG9zdCwgU1RFTkNJTF9ERVZfTU9ERSwgYWRkSG9zdEV2ZW50TGlzdGVuZXJzLCBib290c3RyYXBMYXp5LCBjbXBNb2R1bGVzLCBjb25uZWN0ZWRDYWxsYmFjaywgY29uc29sZURldkVycm9yLCBjb25zb2xlRGV2SW5mbywgY29uc29sZURldldhcm4sIGNvbnNvbGVFcnJvciwgY3JlYXRlRXZlbnQsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRpc2Nvbm5lY3RlZENhbGxiYWNrLCBkb2MsIGZvcmNlTW9kZVVwZGF0ZSwgZm9yY2VVcGRhdGUsIGdldEFzc2V0UGF0aCwgZ2V0Q29ubmVjdCwgZ2V0Q29udGV4dCwgZ2V0RWxlbWVudCwgZ2V0SG9zdFJlZiwgZ2V0TW9kZSwgZ2V0UmVuZGVyaW5nUmVmLCBnZXRWYWx1ZSwgaCwgaW5zZXJ0VmRvbUFubm90YXRpb25zLCBpc01lbWJlckluRWxlbWVudCwgbG9hZE1vZHVsZSwgbW9kZVJlc29sdXRpb25DaGFpbiwgbmV4dFRpY2ssIHBhcnNlUHJvcGVydHlWYWx1ZSwgcGx0LCBwb3N0VXBkYXRlQ29tcG9uZW50LCBwcm9taXNlUmVzb2x2ZSwgcHJveHlDb21wb25lbnQsIHByb3h5Q3VzdG9tRWxlbWVudCwgcmVhZFRhc2ssIHJlZ2lzdGVySG9zdCwgcmVnaXN0ZXJJbnN0YW5jZSwgcmVuZGVyVmRvbSwgc2V0QXNzZXRQYXRoLCBzZXRFcnJvckhhbmRsZXIsIHNldE1vZGUsIHNldFBsYXRmb3JtSGVscGVycywgc2V0UGxhdGZvcm1PcHRpb25zLCBzZXRWYWx1ZSwgc3R5bGVzLCBzdXBwb3J0c0NvbnN0cnVjdGlibGVTdHlsZXNoZWV0cywgc3VwcG9ydHNMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzU2hhZG93LCB3aW4sIHdyaXRlVGFzayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7210\n")},655:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ZT": () => (/* binding */ __extends),\n/* harmony export */   "_T": () => (/* binding */ __rest),\n/* harmony export */   "mG": () => (/* binding */ __awaiter),\n/* harmony export */   "Jh": () => (/* binding */ __generator),\n/* harmony export */   "ev": () => (/* binding */ __spreadArray)\n/* harmony export */ });\n/* unused harmony exports __assign, __decorate, __param, __metadata, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///655\n')}}]);