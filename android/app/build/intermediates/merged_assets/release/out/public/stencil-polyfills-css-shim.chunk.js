(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[4952],{68533:()=>{eval("/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n/** @unrestricted */\nvar StyleNode = /** @class */ (function () {\n    function StyleNode() {\n        this.start = 0;\n        this.end = 0;\n        this.previous = null;\n        this.parent = null;\n        this.rules = null;\n        this.parsedCssText = '';\n        this.cssText = '';\n        this.atRule = false;\n        this.type = 0;\n        this.keyframesName = '';\n        this.selector = '';\n        this.parsedSelector = '';\n    }\n    return StyleNode;\n}());\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parse(text) {\n    text = clean(text);\n    return parseCss(lex(text), text);\n}\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n    return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n    var root = new StyleNode();\n    root['start'] = 0;\n    root['end'] = text.length;\n    var n = root;\n    for (var i = 0, l = text.length; i < l; i++) {\n        if (text[i] === OPEN_BRACE) {\n            if (!n['rules']) {\n                n['rules'] = [];\n            }\n            var p = n;\n            var previous = p['rules'][p['rules'].length - 1] || null;\n            n = new StyleNode();\n            n['start'] = i + 1;\n            n['parent'] = p;\n            n['previous'] = previous;\n            p['rules'].push(n);\n        }\n        else if (text[i] === CLOSE_BRACE) {\n            n['end'] = i + 1;\n            n = n['parent'] || root;\n        }\n    }\n    return root;\n}\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n    var t = text.substring(node['start'], node['end'] - 1);\n    node['parsedCssText'] = node['cssText'] = t.trim();\n    if (node.parent) {\n        var ss = node.previous ? node.previous['end'] : node.parent['start'];\n        t = text.substring(ss, node['start'] - 1);\n        t = _expandUnicodeEscapes(t);\n        t = t.replace(RX.multipleSpaces, ' ');\n        // TODO(sorvell): ad hoc; make selector include only after last ;\n        // helps with mixin syntax\n        t = t.substring(t.lastIndexOf(';') + 1);\n        var s = node['parsedSelector'] = node['selector'] = t.trim();\n        node['atRule'] = (s.indexOf(AT_START) === 0);\n        // note, support a subset of rule types...\n        if (node['atRule']) {\n            if (s.indexOf(MEDIA_START) === 0) {\n                node['type'] = types.MEDIA_RULE;\n            }\n            else if (s.match(RX.keyframesRule)) {\n                node['type'] = types.KEYFRAMES_RULE;\n                node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n            }\n        }\n        else {\n            if (s.indexOf(VAR_START) === 0) {\n                node['type'] = types.MIXIN_RULE;\n            }\n            else {\n                node['type'] = types.STYLE_RULE;\n            }\n        }\n    }\n    var r$ = node['rules'];\n    if (r$) {\n        for (var i = 0, l = r$.length, r = void 0; (i < l) && (r = r$[i]); i++) {\n            parseCss(r, text);\n        }\n    }\n    return node;\n}\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n    return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n        var code = arguments[1], repeat = 6 - code.length;\n        while (repeat--) {\n            code = '0' + code;\n        }\n        return '\\\\' + code;\n    });\n}\n/** @enum {number} */\nvar types = {\n    STYLE_RULE: 1,\n    KEYFRAMES_RULE: 7,\n    MEDIA_RULE: 4,\n    MIXIN_RULE: 1000\n};\nvar OPEN_BRACE = '{';\nvar CLOSE_BRACE = '}';\n// helper regexp's\nvar RX = {\n    comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n    port: /@import[^;]*;/gim,\n    customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n    mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n    mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n    varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n    keyframesRule: /^@[^\\s]*keyframes/,\n    multipleSpaces: /\\s+/g\n};\nvar VAR_START = '--';\nvar MEDIA_START = '@media';\nvar AT_START = '@';\nfunction findRegex(regex, cssText, offset) {\n    regex['lastIndex'] = 0;\n    var r = cssText.substring(offset).match(regex);\n    if (r) {\n        var start = offset + r['index'];\n        return {\n            start: start,\n            end: start + r[0].length\n        };\n    }\n    return null;\n}\nvar VAR_USAGE_START = /\\bvar\\(/;\nvar VAR_ASSIGN_START = /\\B--[\\w-]+\\s*:/;\nvar COMMENTS = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim;\nvar TRAILING_LINES = /^[\\t ]+\\n/gm;\nfunction resolveVar(props, prop, fallback) {\n    if (props[prop]) {\n        return props[prop];\n    }\n    if (fallback) {\n        return executeTemplate(fallback, props);\n    }\n    return '';\n}\nfunction findVarEndIndex(cssText, offset) {\n    var count = 0;\n    var i = offset;\n    for (; i < cssText.length; i++) {\n        var c = cssText[i];\n        if (c === '(') {\n            count++;\n        }\n        else if (c === ')') {\n            count--;\n            if (count <= 0) {\n                return i + 1;\n            }\n        }\n    }\n    return i;\n}\nfunction parseVar(cssText, offset) {\n    var varPos = findRegex(VAR_USAGE_START, cssText, offset);\n    if (!varPos) {\n        return null;\n    }\n    var endVar = findVarEndIndex(cssText, varPos.start);\n    var varContent = cssText.substring(varPos.end, endVar - 1);\n    var _a = varContent.split(','), propName = _a[0], fallback = _a.slice(1);\n    return {\n        start: varPos.start,\n        end: endVar,\n        propName: propName.trim(),\n        fallback: fallback.length > 0 ? fallback.join(',').trim() : undefined\n    };\n}\nfunction compileVar(cssText, template, offset) {\n    var varMeta = parseVar(cssText, offset);\n    if (!varMeta) {\n        template.push(cssText.substring(offset, cssText.length));\n        return cssText.length;\n    }\n    var propName = varMeta.propName;\n    var fallback = varMeta.fallback != null ? compileTemplate(varMeta.fallback) : undefined;\n    template.push(cssText.substring(offset, varMeta.start), function (params) { return resolveVar(params, propName, fallback); });\n    return varMeta.end;\n}\nfunction executeTemplate(template, props) {\n    var final = '';\n    for (var i = 0; i < template.length; i++) {\n        var s = template[i];\n        final += (typeof s === 'string')\n            ? s\n            : s(props);\n    }\n    return final;\n}\nfunction findEndValue(cssText, offset) {\n    var onStr = false;\n    var double = false;\n    var i = offset;\n    for (; i < cssText.length; i++) {\n        var c = cssText[i];\n        if (onStr) {\n            if (double && c === '\"') {\n                onStr = false;\n            }\n            if (!double && c === '\\'') {\n                onStr = false;\n            }\n        }\n        else {\n            if (c === '\"') {\n                onStr = true;\n                double = true;\n            }\n            else if (c === '\\'') {\n                onStr = true;\n                double = false;\n            }\n            else if (c === ';') {\n                return i + 1;\n            }\n            else if (c === '}') {\n                return i;\n            }\n        }\n    }\n    return i;\n}\nfunction removeCustomAssigns(cssText) {\n    var final = '';\n    var offset = 0;\n    while (true) {\n        var assignPos = findRegex(VAR_ASSIGN_START, cssText, offset);\n        var start = assignPos ? assignPos.start : cssText.length;\n        final += cssText.substring(offset, start);\n        if (assignPos) {\n            offset = findEndValue(cssText, start);\n        }\n        else {\n            break;\n        }\n    }\n    return final;\n}\nfunction compileTemplate(cssText) {\n    var index = 0;\n    cssText = cssText.replace(COMMENTS, '');\n    cssText = removeCustomAssigns(cssText)\n        .replace(TRAILING_LINES, '');\n    var segments = [];\n    while (index < cssText.length) {\n        index = compileVar(cssText, segments, index);\n    }\n    return segments;\n}\nfunction resolveValues(selectors) {\n    var props = {};\n    selectors.forEach(function (selector) {\n        selector.declarations.forEach(function (dec) {\n            props[dec.prop] = dec.value;\n        });\n    });\n    var propsValues = {};\n    var entries = Object.entries(props);\n    var _loop_1 = function (i) {\n        var dirty = false;\n        entries.forEach(function (_a) {\n            var key = _a[0], value = _a[1];\n            var propValue = executeTemplate(value, propsValues);\n            if (propValue !== propsValues[key]) {\n                propsValues[key] = propValue;\n                dirty = true;\n            }\n        });\n        if (!dirty) {\n            return \"break\";\n        }\n    };\n    for (var i = 0; i < 10; i++) {\n        var state_1 = _loop_1();\n        if (state_1 === \"break\")\n            break;\n    }\n    return propsValues;\n}\nfunction getSelectors(root, index) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (!root.rules) {\n        return [];\n    }\n    var selectors = [];\n    root.rules\n        .filter(function (rule) { return rule.type === types.STYLE_RULE; })\n        .forEach(function (rule) {\n        var declarations = getDeclarations(rule.cssText);\n        if (declarations.length > 0) {\n            rule.parsedSelector.split(',').forEach(function (selector) {\n                selector = selector.trim();\n                selectors.push({\n                    selector: selector,\n                    declarations: declarations,\n                    specificity: computeSpecificity(),\n                    nu: index\n                });\n            });\n        }\n        index++;\n    });\n    return selectors;\n}\nfunction computeSpecificity(_selector) {\n    return 1;\n}\nvar IMPORTANT = '!important';\nvar FIND_DECLARATIONS = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gm;\nfunction getDeclarations(cssText) {\n    var declarations = [];\n    var xArray;\n    while (xArray = FIND_DECLARATIONS.exec(cssText.trim())) {\n        var _a = normalizeValue(xArray[2]), value = _a.value, important = _a.important;\n        declarations.push({\n            prop: xArray[1].trim(),\n            value: compileTemplate(value),\n            important: important,\n        });\n    }\n    return declarations;\n}\nfunction normalizeValue(value) {\n    var regex = /\\s+/gim;\n    value = value.replace(regex, ' ').trim();\n    var important = value.endsWith(IMPORTANT);\n    if (important) {\n        value = value.substr(0, value.length - IMPORTANT.length).trim();\n    }\n    return {\n        value: value,\n        important: important\n    };\n}\nfunction getActiveSelectors(hostEl, hostScopeMap, globalScopes) {\n    // computes the css scopes that might affect this particular element\n    // avoiding using spread arrays to avoid ts helper fns when in es5\n    var scopes = [];\n    var scopesForElement = getScopesForElement(hostScopeMap, hostEl);\n    // globalScopes are always took into account\n    globalScopes.forEach(function (s) { return scopes.push(s); });\n    // the parent scopes are computed by walking parent dom until <html> is reached\n    scopesForElement.forEach(function (s) { return scopes.push(s); });\n    // each scope might have an array of associated selectors\n    // let's flatten the complete array of selectors from all the scopes\n    var selectorSet = getSelectorsForScopes(scopes);\n    // we filter to only the selectors that matches the hostEl\n    var activeSelectors = selectorSet.filter(function (selector) { return matches(hostEl, selector.selector); });\n    // sort selectors by specifity\n    return sortSelectors(activeSelectors);\n}\nfunction getScopesForElement(hostTemplateMap, node) {\n    var scopes = [];\n    while (node) {\n        var scope = hostTemplateMap.get(node);\n        if (scope) {\n            scopes.push(scope);\n        }\n        node = node.parentElement;\n    }\n    return scopes;\n}\nfunction getSelectorsForScopes(scopes) {\n    var selectors = [];\n    scopes.forEach(function (scope) {\n        selectors.push.apply(selectors, scope.selectors);\n    });\n    return selectors;\n}\nfunction sortSelectors(selectors) {\n    selectors.sort(function (a, b) {\n        if (a.specificity === b.specificity) {\n            return a.nu - b.nu;\n        }\n        return a.specificity - b.specificity;\n    });\n    return selectors;\n}\nfunction matches(el, selector) {\n    return selector === ':root' || selector === 'html' || el.matches(selector);\n}\nfunction parseCSS(original) {\n    var ast = parse(original);\n    var template = compileTemplate(original);\n    var selectors = getSelectors(ast);\n    return {\n        original: original,\n        template: template,\n        selectors: selectors,\n        usesCssVars: template.length > 1\n    };\n}\nfunction addGlobalStyle(globalScopes, styleEl) {\n    if (globalScopes.some(function (css) { return css.styleEl === styleEl; })) {\n        return false;\n    }\n    var css = parseCSS(styleEl.textContent);\n    css.styleEl = styleEl;\n    globalScopes.push(css);\n    return true;\n}\nfunction updateGlobalScopes(scopes) {\n    var selectors = getSelectorsForScopes(scopes);\n    var props = resolveValues(selectors);\n    scopes.forEach(function (scope) {\n        if (scope.usesCssVars) {\n            scope.styleEl.textContent = executeTemplate(scope.template, props);\n        }\n    });\n}\nfunction reScope(scope, scopeId) {\n    var template = scope.template.map(function (segment) {\n        return (typeof segment === 'string')\n            ? replaceScope(segment, scope.scopeId, scopeId)\n            : segment;\n    });\n    var selectors = scope.selectors.map(function (sel) {\n        return Object.assign(Object.assign({}, sel), { selector: replaceScope(sel.selector, scope.scopeId, scopeId) });\n    });\n    return Object.assign(Object.assign({}, scope), { template: template,\n        selectors: selectors,\n        scopeId: scopeId });\n}\nfunction replaceScope(original, oldScopeId, newScopeId) {\n    original = replaceAll(original, \"\\\\.\" + oldScopeId, \".\" + newScopeId);\n    return original;\n}\nfunction replaceAll(input, find, replace) {\n    return input.replace(new RegExp(find, 'g'), replace);\n}\nfunction loadDocument(doc, globalScopes) {\n    loadDocumentStyles(doc, globalScopes);\n    return loadDocumentLinks(doc, globalScopes).then(function () {\n        updateGlobalScopes(globalScopes);\n    });\n}\nfunction startWatcher(doc, globalScopes) {\n    var mutation = new MutationObserver(function () {\n        if (loadDocumentStyles(doc, globalScopes)) {\n            updateGlobalScopes(globalScopes);\n        }\n    });\n    mutation.observe(document.head, { childList: true });\n}\nfunction loadDocumentLinks(doc, globalScopes) {\n    var promises = [];\n    var linkElms = doc.querySelectorAll('link[rel=\"stylesheet\"][href]:not([data-no-shim])');\n    for (var i = 0; i < linkElms.length; i++) {\n        promises.push(addGlobalLink(doc, globalScopes, linkElms[i]));\n    }\n    return Promise.all(promises);\n}\nfunction loadDocumentStyles(doc, globalScopes) {\n    var styleElms = Array.from(doc.querySelectorAll('style:not([data-styles]):not([data-no-shim])'));\n    return styleElms\n        .map(function (style) { return addGlobalStyle(globalScopes, style); })\n        .some(Boolean);\n}\nfunction addGlobalLink(doc, globalScopes, linkElm) {\n    var url = linkElm.href;\n    return fetch(url).then(function (rsp) { return rsp.text(); }).then(function (text) {\n        if (hasCssVariables(text) && linkElm.parentNode) {\n            if (hasRelativeUrls(text)) {\n                text = fixRelativeUrls(text, url);\n            }\n            var styleEl = doc.createElement('style');\n            styleEl.setAttribute('data-styles', '');\n            styleEl.textContent = text;\n            addGlobalStyle(globalScopes, styleEl);\n            linkElm.parentNode.insertBefore(styleEl, linkElm);\n            linkElm.remove();\n        }\n    }).catch(function (err) {\n        console.error(err);\n    });\n}\n// This regexp tries to determine when a variable is declared, for example:\n//\n// .my-el { --highlight-color: green; }\n//\n// but we don't want to trigger when a classname uses \"--\" or a pseudo-class is\n// used. We assume that the only characters that can preceed a variable\n// declaration are \"{\", from an opening block, \";\" from a preceeding rule, or a\n// space. This prevents the regexp from matching a word in a selector, since\n// they would need to start with a \".\" or \"#\". (We assume element names don't\n// start with \"--\").\nvar CSS_VARIABLE_REGEXP = /[\\s;{]--[-a-zA-Z0-9]+\\s*:/m;\nfunction hasCssVariables(css) {\n    return css.indexOf('var(') > -1 || CSS_VARIABLE_REGEXP.test(css);\n}\n// This regexp find all url() usages with relative urls\nvar CSS_URL_REGEXP = /url[\\s]*\\([\\s]*['\"]?(?!(?:https?|data)\\:|\\/)([^\\'\\\"\\)]*)[\\s]*['\"]?\\)[\\s]*/gim;\nfunction hasRelativeUrls(css) {\n    CSS_URL_REGEXP.lastIndex = 0;\n    return CSS_URL_REGEXP.test(css);\n}\nfunction fixRelativeUrls(css, originalUrl) {\n    // get the basepath from the original import url\n    var basePath = originalUrl.replace(/[^/]*$/, '');\n    // replace the relative url, with the new relative url\n    return css.replace(CSS_URL_REGEXP, function (fullMatch, url) {\n        // rhe new relative path is the base path + uri\n        // TODO: normalize relative URL\n        var relativeUrl = basePath + url;\n        return fullMatch.replace(url, relativeUrl);\n    });\n}\nvar CustomStyle = /** @class */ (function () {\n    function CustomStyle(win, doc) {\n        this.win = win;\n        this.doc = doc;\n        this.count = 0;\n        this.hostStyleMap = new WeakMap();\n        this.hostScopeMap = new WeakMap();\n        this.globalScopes = [];\n        this.scopesMap = new Map();\n        this.didInit = false;\n    }\n    CustomStyle.prototype.i = function () {\n        var _this = this;\n        if (this.didInit || !this.win.requestAnimationFrame) {\n            return Promise.resolve();\n        }\n        else {\n            this.didInit = true;\n            return new Promise(function (resolve) {\n                _this.win.requestAnimationFrame(function () {\n                    startWatcher(_this.doc, _this.globalScopes);\n                    loadDocument(_this.doc, _this.globalScopes).then(function () { return resolve(); });\n                });\n            });\n        }\n    };\n    CustomStyle.prototype.addLink = function (linkEl) {\n        var _this = this;\n        return addGlobalLink(this.doc, this.globalScopes, linkEl).then(function () {\n            _this.updateGlobal();\n        });\n    };\n    CustomStyle.prototype.addGlobalStyle = function (styleEl) {\n        if (addGlobalStyle(this.globalScopes, styleEl)) {\n            this.updateGlobal();\n        }\n    };\n    CustomStyle.prototype.createHostStyle = function (hostEl, cssScopeId, cssText, isScoped) {\n        if (this.hostScopeMap.has(hostEl)) {\n            throw new Error('host style already created');\n        }\n        var baseScope = this.registerHostTemplate(cssText, cssScopeId, isScoped);\n        var styleEl = this.doc.createElement('style');\n        styleEl.setAttribute('data-no-shim', '');\n        if (!baseScope.usesCssVars) {\n            // This component does not use (read) css variables\n            styleEl.textContent = cssText;\n        }\n        else if (isScoped) {\n            // This component is dynamic: uses css var and is scoped\n            styleEl['s-sc'] = cssScopeId = baseScope.scopeId + \"-\" + this.count;\n            styleEl.textContent = '/*needs update*/';\n            this.hostStyleMap.set(hostEl, styleEl);\n            this.hostScopeMap.set(hostEl, reScope(baseScope, cssScopeId));\n            this.count++;\n        }\n        else {\n            // This component uses css vars, but it's no-encapsulation (global static)\n            baseScope.styleEl = styleEl;\n            if (!baseScope.usesCssVars) {\n                styleEl.textContent = executeTemplate(baseScope.template, {});\n            }\n            this.globalScopes.push(baseScope);\n            this.updateGlobal();\n            this.hostScopeMap.set(hostEl, baseScope);\n        }\n        return styleEl;\n    };\n    CustomStyle.prototype.removeHost = function (hostEl) {\n        var css = this.hostStyleMap.get(hostEl);\n        if (css) {\n            css.remove();\n        }\n        this.hostStyleMap.delete(hostEl);\n        this.hostScopeMap.delete(hostEl);\n    };\n    CustomStyle.prototype.updateHost = function (hostEl) {\n        var scope = this.hostScopeMap.get(hostEl);\n        if (scope && scope.usesCssVars && scope.isScoped) {\n            var styleEl = this.hostStyleMap.get(hostEl);\n            if (styleEl) {\n                var selectors = getActiveSelectors(hostEl, this.hostScopeMap, this.globalScopes);\n                var props = resolveValues(selectors);\n                styleEl.textContent = executeTemplate(scope.template, props);\n            }\n        }\n    };\n    CustomStyle.prototype.updateGlobal = function () {\n        updateGlobalScopes(this.globalScopes);\n    };\n    CustomStyle.prototype.registerHostTemplate = function (cssText, scopeId, isScoped) {\n        var scope = this.scopesMap.get(scopeId);\n        if (!scope) {\n            scope = parseCSS(cssText);\n            scope.scopeId = scopeId;\n            scope.isScoped = isScoped;\n            this.scopesMap.set(scopeId, scope);\n        }\n        return scope;\n    };\n    return CustomStyle;\n}());\n(function (win) {\n    if (win && !win.__cssshim && (!(win.CSS && win.CSS.supports && win.CSS.supports('color', 'var(--c)')))) {\n        win.__cssshim = new CustomStyle(win, win.document);\n    }\n})(typeof window !== 'undefined' && window);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1CQUFtQjtBQUN0RyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL3B3YS1lbGVtZW50cy9kaXN0L2VzbS1lczUvY3NzLXNoaW0tODc3NWQ5YWQtNTU2ZjBjYzIuanM/NGNkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuRXh0cmVtZWx5IHNpbXBsZSBjc3MgcGFyc2VyLiBJbnRlbmRlZCB0byBiZSBub3QgbW9yZSB0aGFuIHdoYXQgd2UgbmVlZFxuYW5kIGRlZmluaXRlbHkgbm90IG5lY2Vzc2FyaWx5IGNvcnJlY3QgPSkuXG4qL1xuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbnZhciBTdHlsZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVOb2RlKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5lbmQgPSAwO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJzZWRDc3NUZXh0ID0gJyc7XG4gICAgICAgIHRoaXMuY3NzVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLmF0UnVsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSAwO1xuICAgICAgICB0aGlzLmtleWZyYW1lc05hbWUgPSAnJztcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLnBhcnNlZFNlbGVjdG9yID0gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZU5vZGU7XG59KCkpO1xuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICB0ZXh0ID0gY2xlYW4odGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG4vLyByZW1vdmUgc3R1ZmYgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGF0IG1heSBoaW5kZXIgcGFyc2luZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjbGVhbihjc3NUZXh0KSB7XG4gICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuLy8gc3VwZXIgc2ltcGxlIHsuLi59IGxleGVyIHRoYXQgcmV0dXJucyBhIG5vZGUgdHJlZVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIHZhciByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICAgIHJvb3RbJ3N0YXJ0J10gPSAwO1xuICAgIHJvb3RbJ2VuZCddID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIG4gPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHRbaV0gPT09IE9QRU5fQlJBQ0UpIHtcbiAgICAgICAgICAgIGlmICghblsncnVsZXMnXSkge1xuICAgICAgICAgICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwID0gbjtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgICAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgICAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgICAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgICAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0W2ldID09PSBDTE9TRV9CUkFDRSkge1xuICAgICAgICAgICAgblsnZW5kJ10gPSBpICsgMTtcbiAgICAgICAgICAgIG4gPSBuWydwYXJlbnQnXSB8fCByb290O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuLy8gYWRkIHNlbGVjdG9ycy9jc3NUZXh0IHRvIG5vZGUgdHJlZVxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VDc3Mobm9kZSwgdGV4dCkge1xuICAgIHZhciB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgICBub2RlWydwYXJzZWRDc3NUZXh0J10gPSBub2RlWydjc3NUZXh0J10gPSB0LnRyaW0oKTtcbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgdmFyIHNzID0gbm9kZS5wcmV2aW91cyA/IG5vZGUucHJldmlvdXNbJ2VuZCddIDogbm9kZS5wYXJlbnRbJ3N0YXJ0J107XG4gICAgICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgICAgICB0ID0gX2V4cGFuZFVuaWNvZGVFc2NhcGVzKHQpO1xuICAgICAgICB0ID0gdC5yZXBsYWNlKFJYLm11bHRpcGxlU3BhY2VzLCAnICcpO1xuICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgICAgICAvLyBoZWxwcyB3aXRoIG1peGluIHN5bnRheFxuICAgICAgICB0ID0gdC5zdWJzdHJpbmcodC5sYXN0SW5kZXhPZignOycpICsgMSk7XG4gICAgICAgIHZhciBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICAgICAgbm9kZVsnYXRSdWxlJ10gPSAocy5pbmRleE9mKEFUX1NUQVJUKSA9PT0gMCk7XG4gICAgICAgIC8vIG5vdGUsIHN1cHBvcnQgYSBzdWJzZXQgb2YgcnVsZSB0eXBlcy4uLlxuICAgICAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgICAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuTUVESUFfUlVMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5LRVlGUkFNRVNfUlVMRTtcbiAgICAgICAgICAgICAgICBub2RlWydrZXlmcmFtZXNOYW1lJ10gPSBub2RlWydzZWxlY3RvciddLnNwbGl0KFJYLm11bHRpcGxlU3BhY2VzKS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1JWElOX1JVTEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5TVFlMRV9SVUxFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByJCA9IG5vZGVbJ3J1bGVzJ107XG4gICAgaWYgKHIkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gciQubGVuZ3RoLCByID0gdm9pZCAwOyAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBhcmd1bWVudHNbMV0sIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlcGVhdC0tKSB7XG4gICAgICAgICAgICBjb2RlID0gJzAnICsgY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgICB9KTtcbn1cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xudmFyIHR5cGVzID0ge1xuICAgIFNUWUxFX1JVTEU6IDEsXG4gICAgS0VZRlJBTUVTX1JVTEU6IDcsXG4gICAgTUVESUFfUlVMRTogNCxcbiAgICBNSVhJTl9SVUxFOiAxMDAwXG59O1xudmFyIE9QRU5fQlJBQ0UgPSAneyc7XG52YXIgQ0xPU0VfQlJBQ0UgPSAnfSc7XG4vLyBoZWxwZXIgcmVnZXhwJ3NcbnZhciBSWCA9IHtcbiAgICBjb21tZW50czogL1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxcbiAgICBwb3J0OiAvQGltcG9ydFteO10qOy9naW0sXG4gICAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICAgIG1peGluUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj97W159XSo/fSg/Ols7XFxuXXwkKT8vZ2ltLFxuICAgIG1peGluQXBwbHk6IC9AYXBwbHlcXHMqXFwoP1teKTtdKlxcKT9cXHMqKD86WztcXG5dfCQpPy9naW0sXG4gICAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gICAga2V5ZnJhbWVzUnVsZTogL15AW15cXHNdKmtleWZyYW1lcy8sXG4gICAgbXVsdGlwbGVTcGFjZXM6IC9cXHMrL2dcbn07XG52YXIgVkFSX1NUQVJUID0gJy0tJztcbnZhciBNRURJQV9TVEFSVCA9ICdAbWVkaWEnO1xudmFyIEFUX1NUQVJUID0gJ0AnO1xuZnVuY3Rpb24gZmluZFJlZ2V4KHJlZ2V4LCBjc3NUZXh0LCBvZmZzZXQpIHtcbiAgICByZWdleFsnbGFzdEluZGV4J10gPSAwO1xuICAgIHZhciByID0gY3NzVGV4dC5zdWJzdHJpbmcob2Zmc2V0KS5tYXRjaChyZWdleCk7XG4gICAgaWYgKHIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0ICsgclsnaW5kZXgnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQgKyByWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBWQVJfVVNBR0VfU1RBUlQgPSAvXFxidmFyXFwoLztcbnZhciBWQVJfQVNTSUdOX1NUQVJUID0gL1xcQi0tW1xcdy1dK1xccyo6LztcbnZhciBDT01NRU5UUyA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW07XG52YXIgVFJBSUxJTkdfTElORVMgPSAvXltcXHQgXStcXG4vZ207XG5mdW5jdGlvbiByZXNvbHZlVmFyKHByb3BzLCBwcm9wLCBmYWxsYmFjaykge1xuICAgIGlmIChwcm9wc1twcm9wXSkge1xuICAgICAgICByZXR1cm4gcHJvcHNbcHJvcF07XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZXhlY3V0ZVRlbXBsYXRlKGZhbGxiYWNrLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGZpbmRWYXJFbmRJbmRleChjc3NUZXh0LCBvZmZzZXQpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBpID0gb2Zmc2V0O1xuICAgIGZvciAoOyBpIDwgY3NzVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNzc1RleHRbaV07XG4gICAgICAgIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBwYXJzZVZhcihjc3NUZXh0LCBvZmZzZXQpIHtcbiAgICB2YXIgdmFyUG9zID0gZmluZFJlZ2V4KFZBUl9VU0FHRV9TVEFSVCwgY3NzVGV4dCwgb2Zmc2V0KTtcbiAgICBpZiAoIXZhclBvcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVuZFZhciA9IGZpbmRWYXJFbmRJbmRleChjc3NUZXh0LCB2YXJQb3Muc3RhcnQpO1xuICAgIHZhciB2YXJDb250ZW50ID0gY3NzVGV4dC5zdWJzdHJpbmcodmFyUG9zLmVuZCwgZW5kVmFyIC0gMSk7XG4gICAgdmFyIF9hID0gdmFyQ29udGVudC5zcGxpdCgnLCcpLCBwcm9wTmFtZSA9IF9hWzBdLCBmYWxsYmFjayA9IF9hLnNsaWNlKDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB2YXJQb3Muc3RhcnQsXG4gICAgICAgIGVuZDogZW5kVmFyLFxuICAgICAgICBwcm9wTmFtZTogcHJvcE5hbWUudHJpbSgpLFxuICAgICAgICBmYWxsYmFjazogZmFsbGJhY2subGVuZ3RoID4gMCA/IGZhbGxiYWNrLmpvaW4oJywnKS50cmltKCkgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVZhcihjc3NUZXh0LCB0ZW1wbGF0ZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhck1ldGEgPSBwYXJzZVZhcihjc3NUZXh0LCBvZmZzZXQpO1xuICAgIGlmICghdmFyTWV0YSkge1xuICAgICAgICB0ZW1wbGF0ZS5wdXNoKGNzc1RleHQuc3Vic3RyaW5nKG9mZnNldCwgY3NzVGV4dC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcHJvcE5hbWUgPSB2YXJNZXRhLnByb3BOYW1lO1xuICAgIHZhciBmYWxsYmFjayA9IHZhck1ldGEuZmFsbGJhY2sgIT0gbnVsbCA/IGNvbXBpbGVUZW1wbGF0ZSh2YXJNZXRhLmZhbGxiYWNrKSA6IHVuZGVmaW5lZDtcbiAgICB0ZW1wbGF0ZS5wdXNoKGNzc1RleHQuc3Vic3RyaW5nKG9mZnNldCwgdmFyTWV0YS5zdGFydCksIGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIHJlc29sdmVWYXIocGFyYW1zLCBwcm9wTmFtZSwgZmFsbGJhY2spOyB9KTtcbiAgICByZXR1cm4gdmFyTWV0YS5lbmQ7XG59XG5mdW5jdGlvbiBleGVjdXRlVGVtcGxhdGUodGVtcGxhdGUsIHByb3BzKSB7XG4gICAgdmFyIGZpbmFsID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcyA9IHRlbXBsYXRlW2ldO1xuICAgICAgICBmaW5hbCArPSAodHlwZW9mIHMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgPyBzXG4gICAgICAgICAgICA6IHMocHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWw7XG59XG5mdW5jdGlvbiBmaW5kRW5kVmFsdWUoY3NzVGV4dCwgb2Zmc2V0KSB7XG4gICAgdmFyIG9uU3RyID0gZmFsc2U7XG4gICAgdmFyIGRvdWJsZSA9IGZhbHNlO1xuICAgIHZhciBpID0gb2Zmc2V0O1xuICAgIGZvciAoOyBpIDwgY3NzVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNzc1RleHRbaV07XG4gICAgICAgIGlmIChvblN0cikge1xuICAgICAgICAgICAgaWYgKGRvdWJsZSAmJiBjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgb25TdHIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG91YmxlICYmIGMgPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgb25TdHIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgb25TdHIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRvdWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXFwnJykge1xuICAgICAgICAgICAgICAgIG9uU3RyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb3VibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tQXNzaWducyhjc3NUZXh0KSB7XG4gICAgdmFyIGZpbmFsID0gJyc7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGFzc2lnblBvcyA9IGZpbmRSZWdleChWQVJfQVNTSUdOX1NUQVJULCBjc3NUZXh0LCBvZmZzZXQpO1xuICAgICAgICB2YXIgc3RhcnQgPSBhc3NpZ25Qb3MgPyBhc3NpZ25Qb3Muc3RhcnQgOiBjc3NUZXh0Lmxlbmd0aDtcbiAgICAgICAgZmluYWwgKz0gY3NzVGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBzdGFydCk7XG4gICAgICAgIGlmIChhc3NpZ25Qb3MpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGZpbmRFbmRWYWx1ZShjc3NUZXh0LCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWw7XG59XG5mdW5jdGlvbiBjb21waWxlVGVtcGxhdGUoY3NzVGV4dCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShDT01NRU5UUywgJycpO1xuICAgIGNzc1RleHQgPSByZW1vdmVDdXN0b21Bc3NpZ25zKGNzc1RleHQpXG4gICAgICAgIC5yZXBsYWNlKFRSQUlMSU5HX0xJTkVTLCAnJyk7XG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgd2hpbGUgKGluZGV4IDwgY3NzVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSBjb21waWxlVmFyKGNzc1RleHQsIHNlZ21lbnRzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYWx1ZXMoc2VsZWN0b3JzKSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWMpIHtcbiAgICAgICAgICAgIHByb3BzW2RlYy5wcm9wXSA9IGRlYy52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHByb3BzVmFsdWVzID0ge307XG4gICAgdmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wcyk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZGlydHkgPSBmYWxzZTtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGV4ZWN1dGVUZW1wbGF0ZSh2YWx1ZSwgcHJvcHNWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHByb3BWYWx1ZSAhPT0gcHJvcHNWYWx1ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHByb3BzVmFsdWVzW2tleV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkaXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwcm9wc1ZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9ycyhyb290LCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gICAgaWYgKCFyb290LnJ1bGVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuICAgIHJvb3QucnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocnVsZSkgeyByZXR1cm4gcnVsZS50eXBlID09PSB0eXBlcy5TVFlMRV9SVUxFOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gZ2V0RGVjbGFyYXRpb25zKHJ1bGUuY3NzVGV4dCk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcnVsZS5wYXJzZWRTZWxlY3Rvci5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzcGVjaWZpY2l0eTogY29tcHV0ZVNwZWNpZmljaXR5KCksXG4gICAgICAgICAgICAgICAgICAgIG51OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZWN0b3JzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNwZWNpZmljaXR5KF9zZWxlY3Rvcikge1xuICAgIHJldHVybiAxO1xufVxudmFyIElNUE9SVEFOVCA9ICchaW1wb3J0YW50JztcbnZhciBGSU5EX0RFQ0xBUkFUSU9OUyA9IC8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07e10pKyl8XFx7KFtefV0qKVxcfSg/Oig/PVs7XFxzfV0pfCQpKS9nbTtcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9ucyhjc3NUZXh0KSB7XG4gICAgdmFyIGRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIHZhciB4QXJyYXk7XG4gICAgd2hpbGUgKHhBcnJheSA9IEZJTkRfREVDTEFSQVRJT05TLmV4ZWMoY3NzVGV4dC50cmltKCkpKSB7XG4gICAgICAgIHZhciBfYSA9IG5vcm1hbGl6ZVZhbHVlKHhBcnJheVsyXSksIHZhbHVlID0gX2EudmFsdWUsIGltcG9ydGFudCA9IF9hLmltcG9ydGFudDtcbiAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgcHJvcDogeEFycmF5WzFdLnRyaW0oKSxcbiAgICAgICAgICAgIHZhbHVlOiBjb21waWxlVGVtcGxhdGUodmFsdWUpLFxuICAgICAgICAgICAgaW1wb3J0YW50OiBpbXBvcnRhbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjbGFyYXRpb25zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgcmVnZXggPSAvXFxzKy9naW07XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCAnICcpLnRyaW0oKTtcbiAgICB2YXIgaW1wb3J0YW50ID0gdmFsdWUuZW5kc1dpdGgoSU1QT1JUQU5UKTtcbiAgICBpZiAoaW1wb3J0YW50KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIHZhbHVlLmxlbmd0aCAtIElNUE9SVEFOVC5sZW5ndGgpLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbXBvcnRhbnQ6IGltcG9ydGFudFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVTZWxlY3RvcnMoaG9zdEVsLCBob3N0U2NvcGVNYXAsIGdsb2JhbFNjb3Blcykge1xuICAgIC8vIGNvbXB1dGVzIHRoZSBjc3Mgc2NvcGVzIHRoYXQgbWlnaHQgYWZmZWN0IHRoaXMgcGFydGljdWxhciBlbGVtZW50XG4gICAgLy8gYXZvaWRpbmcgdXNpbmcgc3ByZWFkIGFycmF5cyB0byBhdm9pZCB0cyBoZWxwZXIgZm5zIHdoZW4gaW4gZXM1XG4gICAgdmFyIHNjb3BlcyA9IFtdO1xuICAgIHZhciBzY29wZXNGb3JFbGVtZW50ID0gZ2V0U2NvcGVzRm9yRWxlbWVudChob3N0U2NvcGVNYXAsIGhvc3RFbCk7XG4gICAgLy8gZ2xvYmFsU2NvcGVzIGFyZSBhbHdheXMgdG9vayBpbnRvIGFjY291bnRcbiAgICBnbG9iYWxTY29wZXMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gc2NvcGVzLnB1c2gocyk7IH0pO1xuICAgIC8vIHRoZSBwYXJlbnQgc2NvcGVzIGFyZSBjb21wdXRlZCBieSB3YWxraW5nIHBhcmVudCBkb20gdW50aWwgPGh0bWw+IGlzIHJlYWNoZWRcbiAgICBzY29wZXNGb3JFbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHNjb3Blcy5wdXNoKHMpOyB9KTtcbiAgICAvLyBlYWNoIHNjb3BlIG1pZ2h0IGhhdmUgYW4gYXJyYXkgb2YgYXNzb2NpYXRlZCBzZWxlY3RvcnNcbiAgICAvLyBsZXQncyBmbGF0dGVuIHRoZSBjb21wbGV0ZSBhcnJheSBvZiBzZWxlY3RvcnMgZnJvbSBhbGwgdGhlIHNjb3Blc1xuICAgIHZhciBzZWxlY3RvclNldCA9IGdldFNlbGVjdG9yc0ZvclNjb3BlcyhzY29wZXMpO1xuICAgIC8vIHdlIGZpbHRlciB0byBvbmx5IHRoZSBzZWxlY3RvcnMgdGhhdCBtYXRjaGVzIHRoZSBob3N0RWxcbiAgICB2YXIgYWN0aXZlU2VsZWN0b3JzID0gc2VsZWN0b3JTZXQuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gbWF0Y2hlcyhob3N0RWwsIHNlbGVjdG9yLnNlbGVjdG9yKTsgfSk7XG4gICAgLy8gc29ydCBzZWxlY3RvcnMgYnkgc3BlY2lmaXR5XG4gICAgcmV0dXJuIHNvcnRTZWxlY3RvcnMoYWN0aXZlU2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIGdldFNjb3Blc0ZvckVsZW1lbnQoaG9zdFRlbXBsYXRlTWFwLCBub2RlKSB7XG4gICAgdmFyIHNjb3BlcyA9IFtdO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGhvc3RUZW1wbGF0ZU1hcC5nZXQobm9kZSk7XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBzY29wZXM7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvcnNGb3JTY29wZXMoc2NvcGVzKSB7XG4gICAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuICAgIHNjb3Blcy5mb3JFYWNoKGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICBzZWxlY3RvcnMucHVzaC5hcHBseShzZWxlY3RvcnMsIHNjb3BlLnNlbGVjdG9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9ycztcbn1cbmZ1bmN0aW9uIHNvcnRTZWxlY3RvcnMoc2VsZWN0b3JzKSB7XG4gICAgc2VsZWN0b3JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuc3BlY2lmaWNpdHkgPT09IGIuc3BlY2lmaWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBhLm51IC0gYi5udTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5zcGVjaWZpY2l0eSAtIGIuc3BlY2lmaWNpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdG9ycztcbn1cbmZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID09PSAnOnJvb3QnIHx8IHNlbGVjdG9yID09PSAnaHRtbCcgfHwgZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBwYXJzZUNTUyhvcmlnaW5hbCkge1xuICAgIHZhciBhc3QgPSBwYXJzZShvcmlnaW5hbCk7XG4gICAgdmFyIHRlbXBsYXRlID0gY29tcGlsZVRlbXBsYXRlKG9yaWdpbmFsKTtcbiAgICB2YXIgc2VsZWN0b3JzID0gZ2V0U2VsZWN0b3JzKGFzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgICAgICB1c2VzQ3NzVmFyczogdGVtcGxhdGUubGVuZ3RoID4gMVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRHbG9iYWxTdHlsZShnbG9iYWxTY29wZXMsIHN0eWxlRWwpIHtcbiAgICBpZiAoZ2xvYmFsU2NvcGVzLnNvbWUoZnVuY3Rpb24gKGNzcykgeyByZXR1cm4gY3NzLnN0eWxlRWwgPT09IHN0eWxlRWw7IH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNzcyA9IHBhcnNlQ1NTKHN0eWxlRWwudGV4dENvbnRlbnQpO1xuICAgIGNzcy5zdHlsZUVsID0gc3R5bGVFbDtcbiAgICBnbG9iYWxTY29wZXMucHVzaChjc3MpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlR2xvYmFsU2NvcGVzKHNjb3Blcykge1xuICAgIHZhciBzZWxlY3RvcnMgPSBnZXRTZWxlY3RvcnNGb3JTY29wZXMoc2NvcGVzKTtcbiAgICB2YXIgcHJvcHMgPSByZXNvbHZlVmFsdWVzKHNlbGVjdG9ycyk7XG4gICAgc2NvcGVzLmZvckVhY2goZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgIGlmIChzY29wZS51c2VzQ3NzVmFycykge1xuICAgICAgICAgICAgc2NvcGUuc3R5bGVFbC50ZXh0Q29udGVudCA9IGV4ZWN1dGVUZW1wbGF0ZShzY29wZS50ZW1wbGF0ZSwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZVNjb3BlKHNjb3BlLCBzY29wZUlkKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gc2NvcGUudGVtcGxhdGUubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgPyByZXBsYWNlU2NvcGUoc2VnbWVudCwgc2NvcGUuc2NvcGVJZCwgc2NvcGVJZClcbiAgICAgICAgICAgIDogc2VnbWVudDtcbiAgICB9KTtcbiAgICB2YXIgc2VsZWN0b3JzID0gc2NvcGUuc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlbCksIHsgc2VsZWN0b3I6IHJlcGxhY2VTY29wZShzZWwuc2VsZWN0b3IsIHNjb3BlLnNjb3BlSWQsIHNjb3BlSWQpIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNjb3BlKSwgeyB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgICAgICBzY29wZUlkOiBzY29wZUlkIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZVNjb3BlKG9yaWdpbmFsLCBvbGRTY29wZUlkLCBuZXdTY29wZUlkKSB7XG4gICAgb3JpZ2luYWwgPSByZXBsYWNlQWxsKG9yaWdpbmFsLCBcIlxcXFwuXCIgKyBvbGRTY29wZUlkLCBcIi5cIiArIG5ld1Njb3BlSWQpO1xuICAgIHJldHVybiBvcmlnaW5hbDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoaW5wdXQsIGZpbmQsIHJlcGxhY2UpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShuZXcgUmVnRXhwKGZpbmQsICdnJyksIHJlcGxhY2UpO1xufVxuZnVuY3Rpb24gbG9hZERvY3VtZW50KGRvYywgZ2xvYmFsU2NvcGVzKSB7XG4gICAgbG9hZERvY3VtZW50U3R5bGVzKGRvYywgZ2xvYmFsU2NvcGVzKTtcbiAgICByZXR1cm4gbG9hZERvY3VtZW50TGlua3MoZG9jLCBnbG9iYWxTY29wZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGRhdGVHbG9iYWxTY29wZXMoZ2xvYmFsU2NvcGVzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hlcihkb2MsIGdsb2JhbFNjb3Blcykge1xuICAgIHZhciBtdXRhdGlvbiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvYWREb2N1bWVudFN0eWxlcyhkb2MsIGdsb2JhbFNjb3BlcykpIHtcbiAgICAgICAgICAgIHVwZGF0ZUdsb2JhbFNjb3BlcyhnbG9iYWxTY29wZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbXV0YXRpb24ub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGxvYWREb2N1bWVudExpbmtzKGRvYywgZ2xvYmFsU2NvcGVzKSB7XG4gICAgdmFyIHByb21pc2VzID0gW107XG4gICAgdmFyIGxpbmtFbG1zID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXVtocmVmXTpub3QoW2RhdGEtbm8tc2hpbV0pJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rRWxtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGFkZEdsb2JhbExpbmsoZG9jLCBnbG9iYWxTY29wZXMsIGxpbmtFbG1zW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59XG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRTdHlsZXMoZG9jLCBnbG9iYWxTY29wZXMpIHtcbiAgICB2YXIgc3R5bGVFbG1zID0gQXJyYXkuZnJvbShkb2MucXVlcnlTZWxlY3RvckFsbCgnc3R5bGU6bm90KFtkYXRhLXN0eWxlc10pOm5vdChbZGF0YS1uby1zaGltXSknKSk7XG4gICAgcmV0dXJuIHN0eWxlRWxtc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChzdHlsZSkgeyByZXR1cm4gYWRkR2xvYmFsU3R5bGUoZ2xvYmFsU2NvcGVzLCBzdHlsZSk7IH0pXG4gICAgICAgIC5zb21lKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gYWRkR2xvYmFsTGluayhkb2MsIGdsb2JhbFNjb3BlcywgbGlua0VsbSkge1xuICAgIHZhciB1cmwgPSBsaW5rRWxtLmhyZWY7XG4gICAgcmV0dXJuIGZldGNoKHVybCkudGhlbihmdW5jdGlvbiAocnNwKSB7IHJldHVybiByc3AudGV4dCgpOyB9KS50aGVuKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIGlmIChoYXNDc3NWYXJpYWJsZXModGV4dCkgJiYgbGlua0VsbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUmVsYXRpdmVVcmxzKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGZpeFJlbGF0aXZlVXJscyh0ZXh0LCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0eWxlcycsICcnKTtcbiAgICAgICAgICAgIHN0eWxlRWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgYWRkR2xvYmFsU3R5bGUoZ2xvYmFsU2NvcGVzLCBzdHlsZUVsKTtcbiAgICAgICAgICAgIGxpbmtFbG0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbCwgbGlua0VsbSk7XG4gICAgICAgICAgICBsaW5rRWxtLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSk7XG59XG4vLyBUaGlzIHJlZ2V4cCB0cmllcyB0byBkZXRlcm1pbmUgd2hlbiBhIHZhcmlhYmxlIGlzIGRlY2xhcmVkLCBmb3IgZXhhbXBsZTpcbi8vXG4vLyAubXktZWwgeyAtLWhpZ2hsaWdodC1jb2xvcjogZ3JlZW47IH1cbi8vXG4vLyBidXQgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHdoZW4gYSBjbGFzc25hbWUgdXNlcyBcIi0tXCIgb3IgYSBwc2V1ZG8tY2xhc3MgaXNcbi8vIHVzZWQuIFdlIGFzc3VtZSB0aGF0IHRoZSBvbmx5IGNoYXJhY3RlcnMgdGhhdCBjYW4gcHJlY2VlZCBhIHZhcmlhYmxlXG4vLyBkZWNsYXJhdGlvbiBhcmUgXCJ7XCIsIGZyb20gYW4gb3BlbmluZyBibG9jaywgXCI7XCIgZnJvbSBhIHByZWNlZWRpbmcgcnVsZSwgb3IgYVxuLy8gc3BhY2UuIFRoaXMgcHJldmVudHMgdGhlIHJlZ2V4cCBmcm9tIG1hdGNoaW5nIGEgd29yZCBpbiBhIHNlbGVjdG9yLCBzaW5jZVxuLy8gdGhleSB3b3VsZCBuZWVkIHRvIHN0YXJ0IHdpdGggYSBcIi5cIiBvciBcIiNcIi4gKFdlIGFzc3VtZSBlbGVtZW50IG5hbWVzIGRvbid0XG4vLyBzdGFydCB3aXRoIFwiLS1cIikuXG52YXIgQ1NTX1ZBUklBQkxFX1JFR0VYUCA9IC9bXFxzO3tdLS1bLWEtekEtWjAtOV0rXFxzKjovbTtcbmZ1bmN0aW9uIGhhc0Nzc1ZhcmlhYmxlcyhjc3MpIHtcbiAgICByZXR1cm4gY3NzLmluZGV4T2YoJ3ZhcignKSA+IC0xIHx8IENTU19WQVJJQUJMRV9SRUdFWFAudGVzdChjc3MpO1xufVxuLy8gVGhpcyByZWdleHAgZmluZCBhbGwgdXJsKCkgdXNhZ2VzIHdpdGggcmVsYXRpdmUgdXJsc1xudmFyIENTU19VUkxfUkVHRVhQID0gL3VybFtcXHNdKlxcKFtcXHNdKlsnXCJdPyg/ISg/Omh0dHBzP3xkYXRhKVxcOnxcXC8pKFteXFwnXFxcIlxcKV0qKVtcXHNdKlsnXCJdP1xcKVtcXHNdKi9naW07XG5mdW5jdGlvbiBoYXNSZWxhdGl2ZVVybHMoY3NzKSB7XG4gICAgQ1NTX1VSTF9SRUdFWFAubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQ1NTX1VSTF9SRUdFWFAudGVzdChjc3MpO1xufVxuZnVuY3Rpb24gZml4UmVsYXRpdmVVcmxzKGNzcywgb3JpZ2luYWxVcmwpIHtcbiAgICAvLyBnZXQgdGhlIGJhc2VwYXRoIGZyb20gdGhlIG9yaWdpbmFsIGltcG9ydCB1cmxcbiAgICB2YXIgYmFzZVBhdGggPSBvcmlnaW5hbFVybC5yZXBsYWNlKC9bXi9dKiQvLCAnJyk7XG4gICAgLy8gcmVwbGFjZSB0aGUgcmVsYXRpdmUgdXJsLCB3aXRoIHRoZSBuZXcgcmVsYXRpdmUgdXJsXG4gICAgcmV0dXJuIGNzcy5yZXBsYWNlKENTU19VUkxfUkVHRVhQLCBmdW5jdGlvbiAoZnVsbE1hdGNoLCB1cmwpIHtcbiAgICAgICAgLy8gcmhlIG5ldyByZWxhdGl2ZSBwYXRoIGlzIHRoZSBiYXNlIHBhdGggKyB1cmlcbiAgICAgICAgLy8gVE9ETzogbm9ybWFsaXplIHJlbGF0aXZlIFVSTFxuICAgICAgICB2YXIgcmVsYXRpdmVVcmwgPSBiYXNlUGF0aCArIHVybDtcbiAgICAgICAgcmV0dXJuIGZ1bGxNYXRjaC5yZXBsYWNlKHVybCwgcmVsYXRpdmVVcmwpO1xuICAgIH0pO1xufVxudmFyIEN1c3RvbVN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1c3RvbVN0eWxlKHdpbiwgZG9jKSB7XG4gICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaG9zdFN0eWxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5ob3N0U2NvcGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLmdsb2JhbFNjb3BlcyA9IFtdO1xuICAgICAgICB0aGlzLnNjb3Blc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kaWRJbml0ID0gZmFsc2U7XG4gICAgfVxuICAgIEN1c3RvbVN0eWxlLnByb3RvdHlwZS5pID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kaWRJbml0IHx8ICF0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlkSW5pdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRXYXRjaGVyKF90aGlzLmRvYywgX3RoaXMuZ2xvYmFsU2NvcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZERvY3VtZW50KF90aGlzLmRvYywgX3RoaXMuZ2xvYmFsU2NvcGVzKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3VzdG9tU3R5bGUucHJvdG90eXBlLmFkZExpbmsgPSBmdW5jdGlvbiAobGlua0VsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhZGRHbG9iYWxMaW5rKHRoaXMuZG9jLCB0aGlzLmdsb2JhbFNjb3BlcywgbGlua0VsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUdsb2JhbCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEN1c3RvbVN0eWxlLnByb3RvdHlwZS5hZGRHbG9iYWxTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZUVsKSB7XG4gICAgICAgIGlmIChhZGRHbG9iYWxTdHlsZSh0aGlzLmdsb2JhbFNjb3Blcywgc3R5bGVFbCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2xvYmFsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbVN0eWxlLnByb3RvdHlwZS5jcmVhdGVIb3N0U3R5bGUgPSBmdW5jdGlvbiAoaG9zdEVsLCBjc3NTY29wZUlkLCBjc3NUZXh0LCBpc1Njb3BlZCkge1xuICAgICAgICBpZiAodGhpcy5ob3N0U2NvcGVNYXAuaGFzKGhvc3RFbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaG9zdCBzdHlsZSBhbHJlYWR5IGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVNjb3BlID0gdGhpcy5yZWdpc3Rlckhvc3RUZW1wbGF0ZShjc3NUZXh0LCBjc3NTY29wZUlkLCBpc1Njb3BlZCk7XG4gICAgICAgIHZhciBzdHlsZUVsID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbm8tc2hpbScsICcnKTtcbiAgICAgICAgaWYgKCFiYXNlU2NvcGUudXNlc0Nzc1ZhcnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IHVzZSAocmVhZCkgY3NzIHZhcmlhYmxlc1xuICAgICAgICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY29wZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIGR5bmFtaWM6IHVzZXMgY3NzIHZhciBhbmQgaXMgc2NvcGVkXG4gICAgICAgICAgICBzdHlsZUVsWydzLXNjJ10gPSBjc3NTY29wZUlkID0gYmFzZVNjb3BlLnNjb3BlSWQgKyBcIi1cIiArIHRoaXMuY291bnQ7XG4gICAgICAgICAgICBzdHlsZUVsLnRleHRDb250ZW50ID0gJy8qbmVlZHMgdXBkYXRlKi8nO1xuICAgICAgICAgICAgdGhpcy5ob3N0U3R5bGVNYXAuc2V0KGhvc3RFbCwgc3R5bGVFbCk7XG4gICAgICAgICAgICB0aGlzLmhvc3RTY29wZU1hcC5zZXQoaG9zdEVsLCByZVNjb3BlKGJhc2VTY29wZSwgY3NzU2NvcGVJZCkpO1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgdXNlcyBjc3MgdmFycywgYnV0IGl0J3Mgbm8tZW5jYXBzdWxhdGlvbiAoZ2xvYmFsIHN0YXRpYylcbiAgICAgICAgICAgIGJhc2VTY29wZS5zdHlsZUVsID0gc3R5bGVFbDtcbiAgICAgICAgICAgIGlmICghYmFzZVNjb3BlLnVzZXNDc3NWYXJzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IGV4ZWN1dGVUZW1wbGF0ZShiYXNlU2NvcGUudGVtcGxhdGUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsU2NvcGVzLnB1c2goYmFzZVNjb3BlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR2xvYmFsKCk7XG4gICAgICAgICAgICB0aGlzLmhvc3RTY29wZU1hcC5zZXQoaG9zdEVsLCBiYXNlU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZUVsO1xuICAgIH07XG4gICAgQ3VzdG9tU3R5bGUucHJvdG90eXBlLnJlbW92ZUhvc3QgPSBmdW5jdGlvbiAoaG9zdEVsKSB7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLmhvc3RTdHlsZU1hcC5nZXQoaG9zdEVsKTtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgY3NzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG9zdFN0eWxlTWFwLmRlbGV0ZShob3N0RWwpO1xuICAgICAgICB0aGlzLmhvc3RTY29wZU1hcC5kZWxldGUoaG9zdEVsKTtcbiAgICB9O1xuICAgIEN1c3RvbVN0eWxlLnByb3RvdHlwZS51cGRhdGVIb3N0ID0gZnVuY3Rpb24gKGhvc3RFbCkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmhvc3RTY29wZU1hcC5nZXQoaG9zdEVsKTtcbiAgICAgICAgaWYgKHNjb3BlICYmIHNjb3BlLnVzZXNDc3NWYXJzICYmIHNjb3BlLmlzU2NvcGVkKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVFbCA9IHRoaXMuaG9zdFN0eWxlTWFwLmdldChob3N0RWwpO1xuICAgICAgICAgICAgaWYgKHN0eWxlRWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gZ2V0QWN0aXZlU2VsZWN0b3JzKGhvc3RFbCwgdGhpcy5ob3N0U2NvcGVNYXAsIHRoaXMuZ2xvYmFsU2NvcGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSByZXNvbHZlVmFsdWVzKHNlbGVjdG9ycyk7XG4gICAgICAgICAgICAgICAgc3R5bGVFbC50ZXh0Q29udGVudCA9IGV4ZWN1dGVUZW1wbGF0ZShzY29wZS50ZW1wbGF0ZSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21TdHlsZS5wcm90b3R5cGUudXBkYXRlR2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGRhdGVHbG9iYWxTY29wZXModGhpcy5nbG9iYWxTY29wZXMpO1xuICAgIH07XG4gICAgQ3VzdG9tU3R5bGUucHJvdG90eXBlLnJlZ2lzdGVySG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlSWQsIGlzU2NvcGVkKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVzTWFwLmdldChzY29wZUlkKTtcbiAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUgPSBwYXJzZUNTUyhjc3NUZXh0KTtcbiAgICAgICAgICAgIHNjb3BlLnNjb3BlSWQgPSBzY29wZUlkO1xuICAgICAgICAgICAgc2NvcGUuaXNTY29wZWQgPSBpc1Njb3BlZDtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzTWFwLnNldChzY29wZUlkLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbVN0eWxlO1xufSgpKTtcbihmdW5jdGlvbiAod2luKSB7XG4gICAgaWYgKHdpbiAmJiAhd2luLl9fY3Nzc2hpbSAmJiAoISh3aW4uQ1NTICYmIHdpbi5DU1Muc3VwcG9ydHMgJiYgd2luLkNTUy5zdXBwb3J0cygnY29sb3InLCAndmFyKC0tYyknKSkpKSB7XG4gICAgICAgIHdpbi5fX2Nzc3NoaW0gPSBuZXcgQ3VzdG9tU3R5bGUod2luLCB3aW4uZG9jdW1lbnQpO1xuICAgIH1cbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68533\n")}}]);