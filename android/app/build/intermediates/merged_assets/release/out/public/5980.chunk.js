"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[5980],{35980:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": () => (/* binding */ createAnimation)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nlet animationPrefix;\n/**\n * Web Animations requires hyphenated CSS properties\n * to be written in camelCase when animating\n */\nconst processKeyframes = (keyframes) => {\n  keyframes.forEach(keyframe => {\n    for (const key in keyframe) {\n      if (keyframe.hasOwnProperty(key)) {\n        const value = keyframe[key];\n        if (key === 'easing') {\n          const newKey = 'animation-timing-function';\n          keyframe[newKey] = value;\n          delete keyframe[key];\n        }\n        else {\n          const newKey = convertCamelCaseToHypen(key);\n          if (newKey !== key) {\n            keyframe[newKey] = value;\n            delete keyframe[key];\n          }\n        }\n      }\n    }\n  });\n  return keyframes;\n};\nconst convertCamelCaseToHypen = (str) => {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n};\nconst getAnimationPrefix = (el) => {\n  if (animationPrefix === undefined) {\n    const supportsUnprefixed = el.style.animationName !== undefined;\n    const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\n    animationPrefix = (!supportsUnprefixed && supportsWebkitPrefix) ? '-webkit-' : '';\n  }\n  return animationPrefix;\n};\nconst setStyleProperty = (element, propertyName, value) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.setProperty(prefix + propertyName, value);\n};\nconst removeStyleProperty = (element, propertyName) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.removeProperty(prefix + propertyName);\n};\nconst animationEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = { passive: true };\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n    el.addEventListener('animationend', onTransitionEnd, opts);\n    unRegTrans = () => {\n      el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n      el.removeEventListener('animationend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\nconst generateKeyframeRules = (keyframes = []) => {\n  return keyframes.map(keyframe => {\n    const offset = keyframe.offset;\n    const frameString = [];\n    for (const property in keyframe) {\n      if (keyframe.hasOwnProperty(property) && property !== 'offset') {\n        frameString.push(`${property}: ${keyframe[property]};`);\n      }\n    }\n    return `${offset * 100}% { ${frameString.join(' ')} }`;\n  }).join(' ');\n};\nconst keyframeIds = [];\nconst generateKeyframeName = (keyframeRules) => {\n  let index = keyframeIds.indexOf(keyframeRules);\n  if (index < 0) {\n    index = (keyframeIds.push(keyframeRules) - 1);\n  }\n  return `ion-animation-${index}`;\n};\nconst getStyleContainer = (element) => {\n  const rootNode = element.getRootNode();\n  return (rootNode.head || rootNode);\n};\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\n  const styleContainer = getStyleContainer(element);\n  const keyframePrefix = getAnimationPrefix(element);\n  const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\n  if (existingStylesheet) {\n    return existingStylesheet;\n  }\n  const stylesheet = (element.ownerDocument || document).createElement('style');\n  stylesheet.id = keyframeName;\n  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\n  styleContainer.appendChild(stylesheet);\n  return stylesheet;\n};\nconst addClassToArray = (classes = [], className) => {\n  if (className !== undefined) {\n    const classNameToAppend = (Array.isArray(className)) ? className : [className];\n    return [...classes, ...classNameToAppend];\n  }\n  return classes;\n};\n\nconst createAnimation = (animationId) => {\n  let _delay;\n  let _duration;\n  let _easing;\n  let _iterations;\n  let _fill;\n  let _direction;\n  let _keyframes = [];\n  let beforeAddClasses = [];\n  let beforeRemoveClasses = [];\n  let initialized = false;\n  let parentAnimation;\n  let beforeStylesValue = {};\n  let afterAddClasses = [];\n  let afterRemoveClasses = [];\n  let afterStylesValue = {};\n  let numAnimationsRunning = 0;\n  let shouldForceLinearEasing = false;\n  let shouldForceSyncPlayback = false;\n  let cssAnimationsTimerFallback;\n  let forceDirectionValue;\n  let forceDurationValue;\n  let forceDelayValue;\n  let willComplete = true;\n  let finished = false;\n  let shouldCalculateNumAnimations = true;\n  let keyframeName;\n  let ani;\n  const id = animationId;\n  const onFinishCallbacks = [];\n  const onFinishOneTimeCallbacks = [];\n  const elements = [];\n  const childAnimations = [];\n  const stylesheets = [];\n  const _beforeAddReadFunctions = [];\n  const _beforeAddWriteFunctions = [];\n  const _afterAddReadFunctions = [];\n  const _afterAddWriteFunctions = [];\n  const webAnimations = [];\n  const supportsAnimationEffect = (typeof AnimationEffect === 'function' || typeof window.AnimationEffect === 'function');\n  const supportsWebAnimations = (typeof Element === 'function') && (typeof Element.prototype.animate === 'function') && supportsAnimationEffect;\n  const ANIMATION_END_FALLBACK_PADDING_MS = 100;\n  const getWebAnimations = () => {\n    return webAnimations;\n  };\n  const destroy = (clearStyleSheets) => {\n    childAnimations.forEach(childAnimation => {\n      childAnimation.destroy(clearStyleSheets);\n    });\n    cleanUp(clearStyleSheets);\n    elements.length = 0;\n    childAnimations.length = 0;\n    _keyframes.length = 0;\n    clearOnFinish();\n    initialized = false;\n    shouldCalculateNumAnimations = true;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations, removes\n   * any animation properties from the\n   * animation's elements, and removes the\n   * animation's stylesheets from the DOM.\n   */\n  const cleanUp = (clearStyleSheets) => {\n    cleanUpElements();\n    if (clearStyleSheets) {\n      cleanUpStyleSheets();\n    }\n  };\n  const resetFlags = () => {\n    shouldForceLinearEasing = false;\n    shouldForceSyncPlayback = false;\n    shouldCalculateNumAnimations = true;\n    forceDirectionValue = undefined;\n    forceDurationValue = undefined;\n    forceDelayValue = undefined;\n    numAnimationsRunning = 0;\n    finished = false;\n    willComplete = true;\n  };\n  const onFinish = (callback, opts) => {\n    const callbacks = (opts && opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\n    callbacks.push({ c: callback, o: opts });\n    return ani;\n  };\n  const clearOnFinish = () => {\n    onFinishCallbacks.length = 0;\n    onFinishOneTimeCallbacks.length = 0;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations and removes\n   * any animation properties from the\n   * the animation's elements.\n   */\n  const cleanUpElements = () => {\n    if (supportsWebAnimations) {\n      webAnimations.forEach(animation => {\n        animation.cancel();\n      });\n      webAnimations.length = 0;\n    }\n    else {\n      const elementsArray = elements.slice();\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n        elementsArray.forEach(element => {\n          removeStyleProperty(element, 'animation-name');\n          removeStyleProperty(element, 'animation-duration');\n          removeStyleProperty(element, 'animation-timing-function');\n          removeStyleProperty(element, 'animation-iteration-count');\n          removeStyleProperty(element, 'animation-delay');\n          removeStyleProperty(element, 'animation-play-state');\n          removeStyleProperty(element, 'animation-fill-mode');\n          removeStyleProperty(element, 'animation-direction');\n        });\n      });\n    }\n  };\n  /**\n   * Removes the animation's stylesheets\n   * from the DOM.\n   */\n  const cleanUpStyleSheets = () => {\n    stylesheets.forEach(stylesheet => {\n      /**\n       * When sharing stylesheets, it's possible\n       * for another animation to have already\n       * cleaned up a particular stylesheet\n       */\n      if (stylesheet && stylesheet.parentNode) {\n        stylesheet.parentNode.removeChild(stylesheet);\n      }\n    });\n    stylesheets.length = 0;\n  };\n  const beforeAddRead = (readFn) => {\n    _beforeAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const beforeAddWrite = (writeFn) => {\n    _beforeAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const afterAddRead = (readFn) => {\n    _afterAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const afterAddWrite = (writeFn) => {\n    _afterAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const beforeAddClass = (className) => {\n    beforeAddClasses = addClassToArray(beforeAddClasses, className);\n    return ani;\n  };\n  const beforeRemoveClass = (className) => {\n    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\n    return ani;\n  };\n  /**\n   * Set CSS inline styles to the animation's\n   * elements before the animation begins.\n   */\n  const beforeStyles = (styles = {}) => {\n    beforeStylesValue = styles;\n    return ani;\n  };\n  /**\n   * Clear CSS inline styles from the animation's\n   * elements before the animation begins.\n   */\n  const beforeClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      beforeStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const afterAddClass = (className) => {\n    afterAddClasses = addClassToArray(afterAddClasses, className);\n    return ani;\n  };\n  const afterRemoveClass = (className) => {\n    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\n    return ani;\n  };\n  const afterStyles = (styles = {}) => {\n    afterStylesValue = styles;\n    return ani;\n  };\n  const afterClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      afterStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const getFill = () => {\n    if (_fill !== undefined) {\n      return _fill;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getFill();\n    }\n    return 'both';\n  };\n  const getDirection = () => {\n    if (forceDirectionValue !== undefined) {\n      return forceDirectionValue;\n    }\n    if (_direction !== undefined) {\n      return _direction;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDirection();\n    }\n    return 'normal';\n  };\n  const getEasing = () => {\n    if (shouldForceLinearEasing) {\n      return 'linear';\n    }\n    if (_easing !== undefined) {\n      return _easing;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getEasing();\n    }\n    return 'linear';\n  };\n  const getDuration = () => {\n    if (shouldForceSyncPlayback) {\n      return 0;\n    }\n    if (forceDurationValue !== undefined) {\n      return forceDurationValue;\n    }\n    if (_duration !== undefined) {\n      return _duration;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDuration();\n    }\n    return 0;\n  };\n  const getIterations = () => {\n    if (_iterations !== undefined) {\n      return _iterations;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getIterations();\n    }\n    return 1;\n  };\n  const getDelay = () => {\n    if (forceDelayValue !== undefined) {\n      return forceDelayValue;\n    }\n    if (_delay !== undefined) {\n      return _delay;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDelay();\n    }\n    return 0;\n  };\n  const getKeyframes = () => {\n    return _keyframes;\n  };\n  const direction = (animationDirection) => {\n    _direction = animationDirection;\n    update(true);\n    return ani;\n  };\n  const fill = (animationFill) => {\n    _fill = animationFill;\n    update(true);\n    return ani;\n  };\n  const delay = (animationDelay) => {\n    _delay = animationDelay;\n    update(true);\n    return ani;\n  };\n  const easing = (animationEasing) => {\n    _easing = animationEasing;\n    update(true);\n    return ani;\n  };\n  const duration = (animationDuration) => {\n    /**\n     * CSS Animation Durations of 0ms work fine on Chrome\n     * but do not run on Safari, so force it to 1ms to\n     * get it to run on both platforms.\n     */\n    if (!supportsWebAnimations && animationDuration === 0) {\n      animationDuration = 1;\n    }\n    _duration = animationDuration;\n    update(true);\n    return ani;\n  };\n  const iterations = (animationIterations) => {\n    _iterations = animationIterations;\n    update(true);\n    return ani;\n  };\n  const parent = (animation) => {\n    parentAnimation = animation;\n    return ani;\n  };\n  const addElement = (el) => {\n    if (el != null) {\n      if (el.nodeType === 1) {\n        elements.push(el);\n      }\n      else if (el.length >= 0) {\n        for (let i = 0; i < el.length; i++) {\n          elements.push(el[i]);\n        }\n      }\n      else {\n        console.error('Invalid addElement value');\n      }\n    }\n    return ani;\n  };\n  const addAnimation = (animationToAdd) => {\n    if (animationToAdd != null) {\n      if (Array.isArray(animationToAdd)) {\n        for (const animation of animationToAdd) {\n          animation.parent(ani);\n          childAnimations.push(animation);\n        }\n      }\n      else {\n        animationToAdd.parent(ani);\n        childAnimations.push(animationToAdd);\n      }\n    }\n    return ani;\n  };\n  const keyframes = (keyframeValues) => {\n    const different = _keyframes !== keyframeValues;\n    _keyframes = keyframeValues;\n    if (different) {\n      updateKeyframes(_keyframes);\n    }\n    return ani;\n  };\n  const updateKeyframes = (keyframeValues) => {\n    if (supportsWebAnimations) {\n      getWebAnimations().forEach(animation => {\n        if (animation.effect.setKeyframes) {\n          animation.effect.setKeyframes(keyframeValues);\n        }\n        else {\n          const newEffect = new KeyframeEffect(animation.effect.target, keyframeValues, animation.effect.getTiming());\n          animation.effect = newEffect;\n        }\n      });\n    }\n    else {\n      initializeCSSAnimation();\n    }\n  };\n  /**\n   * Run all \"before\" animation hooks.\n   */\n  const beforeAnimation = () => {\n    // Runs all before read callbacks\n    _beforeAddReadFunctions.forEach(callback => callback());\n    // Runs all before write callbacks\n    _beforeAddWriteFunctions.forEach(callback => callback());\n    // Updates styles and classes before animation runs\n    const addClasses = beforeAddClasses;\n    const removeClasses = beforeRemoveClasses;\n    const styles = beforeStylesValue;\n    elements.forEach(el => {\n      const elementClassList = el.classList;\n      addClasses.forEach(c => elementClassList.add(c));\n      removeClasses.forEach(c => elementClassList.remove(c));\n      for (const property in styles) {\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n  };\n  /**\n   * Run all \"after\" animation hooks.\n   */\n  const afterAnimation = () => {\n    clearCSSAnimationsTimeout();\n    // Runs all after read callbacks\n    _afterAddReadFunctions.forEach(callback => callback());\n    // Runs all after write callbacks\n    _afterAddWriteFunctions.forEach(callback => callback());\n    // Updates styles and classes before animation ends\n    const currentStep = willComplete ? 1 : 0;\n    const addClasses = afterAddClasses;\n    const removeClasses = afterRemoveClasses;\n    const styles = afterStylesValue;\n    elements.forEach(el => {\n      const elementClassList = el.classList;\n      addClasses.forEach(c => elementClassList.add(c));\n      removeClasses.forEach(c => elementClassList.remove(c));\n      for (const property in styles) {\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n    onFinishCallbacks.forEach(onFinishCallback => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.forEach(onFinishCallback => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.length = 0;\n    shouldCalculateNumAnimations = true;\n    if (willComplete) {\n      finished = true;\n    }\n    willComplete = true;\n  };\n  const animationFinish = () => {\n    if (numAnimationsRunning === 0) {\n      return;\n    }\n    numAnimationsRunning--;\n    if (numAnimationsRunning === 0) {\n      afterAnimation();\n      if (parentAnimation) {\n        parentAnimation.animationFinish();\n      }\n    }\n  };\n  const initializeCSSAnimation = (toggleAnimationName = true) => {\n    cleanUpStyleSheets();\n    const processedKeyframes = processKeyframes(_keyframes);\n    elements.forEach(element => {\n      if (processedKeyframes.length > 0) {\n        const keyframeRules = generateKeyframeRules(processedKeyframes);\n        keyframeName = (animationId !== undefined) ? animationId : generateKeyframeName(keyframeRules);\n        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\n        stylesheets.push(stylesheet);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill());\n        setStyleProperty(element, 'animation-direction', getDirection());\n        const iterationsCount = (getIterations() === Infinity)\n          ? 'infinite'\n          : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        setStyleProperty(element, 'animation-play-state', 'paused');\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\n        }\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          setStyleProperty(element, 'animation-name', stylesheet.id || null);\n        });\n      }\n    });\n  };\n  const initializeWebAnimation = () => {\n    elements.forEach(element => {\n      const animation = element.animate(_keyframes, {\n        id,\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection()\n      });\n      animation.pause();\n      webAnimations.push(animation);\n    });\n    if (webAnimations.length > 0) {\n      webAnimations[0].onfinish = () => {\n        animationFinish();\n      };\n    }\n  };\n  const initializeAnimation = (toggleAnimationName = true) => {\n    beforeAnimation();\n    if (_keyframes.length > 0) {\n      if (supportsWebAnimations) {\n        initializeWebAnimation();\n      }\n      else {\n        initializeCSSAnimation(toggleAnimationName);\n      }\n    }\n    initialized = true;\n  };\n  const setAnimationStep = (step) => {\n    step = Math.min(Math.max(step, 0), 0.9999);\n    if (supportsWebAnimations) {\n      webAnimations.forEach(animation => {\n        animation.currentTime = animation.effect.getComputedTiming().delay + (getDuration() * step);\n        animation.pause();\n      });\n    }\n    else {\n      const animationDuration = `-${getDuration() * step}ms`;\n      elements.forEach(element => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-delay', animationDuration);\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        }\n      });\n    }\n  };\n  const updateWebAnimation = (step) => {\n    webAnimations.forEach(animation => {\n      animation.effect.updateTiming({\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection()\n      });\n    });\n    if (step !== undefined) {\n      setAnimationStep(step);\n    }\n  };\n  const updateCSSAnimation = (toggleAnimationName = true, step) => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n      elements.forEach(element => {\n        setStyleProperty(element, 'animation-name', keyframeName || null);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', (step !== undefined) ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill() || null);\n        setStyleProperty(element, 'animation-direction', getDirection() || null);\n        const iterationsCount = (getIterations() === Infinity)\n          ? 'infinite'\n          : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\n        }\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          setStyleProperty(element, 'animation-name', keyframeName || null);\n        });\n      });\n    });\n  };\n  const update = (deep = false, toggleAnimationName = true, step) => {\n    if (deep) {\n      childAnimations.forEach(animation => {\n        animation.update(deep, toggleAnimationName, step);\n      });\n    }\n    if (supportsWebAnimations) {\n      updateWebAnimation(step);\n    }\n    else {\n      updateCSSAnimation(toggleAnimationName, step);\n    }\n    return ani;\n  };\n  const progressStart = (forceLinearEasing = false, step) => {\n    childAnimations.forEach(animation => {\n      animation.progressStart(forceLinearEasing, step);\n    });\n    pauseAnimation();\n    shouldForceLinearEasing = forceLinearEasing;\n    if (!initialized) {\n      initializeAnimation();\n    }\n    update(false, true, step);\n    return ani;\n  };\n  const progressStep = (step) => {\n    childAnimations.forEach(animation => {\n      animation.progressStep(step);\n    });\n    setAnimationStep(step);\n    return ani;\n  };\n  const progressEnd = (playTo, step, dur) => {\n    shouldForceLinearEasing = false;\n    childAnimations.forEach(animation => {\n      animation.progressEnd(playTo, step, dur);\n    });\n    if (dur !== undefined) {\n      forceDurationValue = dur;\n    }\n    finished = false;\n    // tslint:disable-next-line: strict-boolean-conditions\n    willComplete = true;\n    if (playTo === 0) {\n      forceDirectionValue = (getDirection() === 'reverse') ? 'normal' : 'reverse';\n      if (forceDirectionValue === 'reverse') {\n        willComplete = false;\n      }\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(1 - step);\n      }\n      else {\n        forceDelayValue = ((1 - step) * getDuration()) * -1;\n        update(false, false);\n      }\n    }\n    else if (playTo === 1) {\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(step);\n      }\n      else {\n        forceDelayValue = (step * getDuration()) * -1;\n        update(false, false);\n      }\n    }\n    if (playTo !== undefined) {\n      onFinish(() => {\n        forceDurationValue = undefined;\n        forceDirectionValue = undefined;\n        forceDelayValue = undefined;\n      }, {\n        oneTimeCallback: true\n      });\n      if (!parentAnimation) {\n        play();\n      }\n    }\n    return ani;\n  };\n  const pauseAnimation = () => {\n    if (initialized) {\n      if (supportsWebAnimations) {\n        webAnimations.forEach(animation => {\n          animation.pause();\n        });\n      }\n      else {\n        elements.forEach(element => {\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        });\n      }\n    }\n  };\n  const pause = () => {\n    childAnimations.forEach(animation => {\n      animation.pause();\n    });\n    pauseAnimation();\n    return ani;\n  };\n  const onAnimationEndFallback = () => {\n    cssAnimationsTimerFallback = undefined;\n    animationFinish();\n  };\n  const clearCSSAnimationsTimeout = () => {\n    if (cssAnimationsTimerFallback) {\n      clearTimeout(cssAnimationsTimerFallback);\n    }\n  };\n  const playCSSAnimations = () => {\n    clearCSSAnimationsTimeout();\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n      elements.forEach(element => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-play-state', 'running');\n        }\n      });\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n    else {\n      /**\n       * This is a catchall in the event that a CSS Animation did not finish.\n       * The Web Animations API has mechanisms in place for preventing this.\n       * CSS Animations will not fire an `animationend` event\n       * for elements with `display: none`. The Web Animations API\n       * accounts for this, but using raw CSS Animations requires\n       * this workaround.\n       */\n      const animationDelay = getDelay() || 0;\n      const animationDuration = getDuration() || 0;\n      const animationIterations = getIterations() || 1;\n      // No need to set a timeout when animation has infinite iterations\n      if (isFinite(animationIterations)) {\n        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + (animationDuration * animationIterations) + ANIMATION_END_FALLBACK_PADDING_MS);\n      }\n      animationEnd(elements[0], () => {\n        clearCSSAnimationsTimeout();\n        /**\n         * Ensure that clean up\n         * is always done a frame\n         * before the onFinish handlers\n         * are fired. Otherwise, there\n         * may be flickering if a new\n         * animation is started on the same\n         * element too quickly\n         *\n         * TODO: Is there a cleaner way to do this?\n         */\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          clearCSSAnimationPlayState();\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(animationFinish);\n        });\n      });\n    }\n  };\n  const clearCSSAnimationPlayState = () => {\n    elements.forEach(element => {\n      removeStyleProperty(element, 'animation-duration');\n      removeStyleProperty(element, 'animation-delay');\n      removeStyleProperty(element, 'animation-play-state');\n    });\n  };\n  const playWebAnimations = () => {\n    webAnimations.forEach(animation => {\n      animation.play();\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n  };\n  const resetAnimation = () => {\n    if (supportsWebAnimations) {\n      setAnimationStep(0);\n      updateWebAnimation();\n    }\n    else {\n      updateCSSAnimation();\n    }\n  };\n  const play = (opts) => {\n    return new Promise(resolve => {\n      if (opts && opts.sync) {\n        shouldForceSyncPlayback = true;\n        onFinish(() => shouldForceSyncPlayback = false, { oneTimeCallback: true });\n      }\n      if (!initialized) {\n        initializeAnimation();\n      }\n      if (finished) {\n        resetAnimation();\n        finished = false;\n      }\n      if (shouldCalculateNumAnimations) {\n        numAnimationsRunning = childAnimations.length + 1;\n        shouldCalculateNumAnimations = false;\n      }\n      onFinish(() => resolve(), { oneTimeCallback: true });\n      childAnimations.forEach(animation => {\n        animation.play();\n      });\n      if (supportsWebAnimations) {\n        playWebAnimations();\n      }\n      else {\n        playCSSAnimations();\n      }\n    });\n  };\n  const stop = () => {\n    childAnimations.forEach(animation => {\n      animation.stop();\n    });\n    if (initialized) {\n      cleanUpElements();\n      initialized = false;\n    }\n    resetFlags();\n  };\n  const from = (property, value) => {\n    const firstFrame = _keyframes[0];\n    if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\n      firstFrame[property] = value;\n    }\n    else {\n      _keyframes = [\n        { offset: 0, [property]: value },\n        ..._keyframes\n      ];\n    }\n    return ani;\n  };\n  const to = (property, value) => {\n    const lastFrame = _keyframes[_keyframes.length - 1];\n    if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\n      lastFrame[property] = value;\n    }\n    else {\n      _keyframes = [\n        ..._keyframes,\n        { offset: 1, [property]: value }\n      ];\n    }\n    return ani;\n  };\n  const fromTo = (property, fromValue, toValue) => {\n    return from(property, fromValue).to(property, toValue);\n  };\n  return ani = {\n    parentAnimation,\n    elements,\n    childAnimations,\n    id,\n    animationFinish,\n    from,\n    to,\n    fromTo,\n    parent,\n    play,\n    pause,\n    stop,\n    destroy,\n    keyframes,\n    addAnimation,\n    addElement,\n    update,\n    fill,\n    direction,\n    iterations,\n    duration,\n    easing,\n    delay,\n    getWebAnimations,\n    getKeyframes,\n    getFill,\n    getDirection,\n    getDelay,\n    getIterations,\n    getEasing,\n    getDuration,\n    afterAddRead,\n    afterAddWrite,\n    afterClearStyles,\n    afterStyles,\n    afterRemoveClass,\n    afterAddClass,\n    beforeAddRead,\n    beforeAddWrite,\n    beforeClearStyles,\n    beforeStyles,\n    beforeRemoveClass,\n    beforeAddClass,\n    onFinish,\n    progressStart,\n    progressStep,\n    progressEnd\n  };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5ODAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUN3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsSUFBSSxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBLGNBQWMsYUFBYSxJQUFJLEVBQUUsd0JBQXdCO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZSxZQUFZLGdCQUFnQixFQUFFLGlCQUFpQixHQUFHLGVBQWUsWUFBWSxhQUFhLE9BQU8sRUFBRSxnQkFBZ0I7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2FuaW1hdGlvbi5qcz8xZjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJhZiB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmxldCBhbmltYXRpb25QcmVmaXg7XG4vKipcbiAqIFdlYiBBbmltYXRpb25zIHJlcXVpcmVzIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnRpZXNcbiAqIHRvIGJlIHdyaXR0ZW4gaW4gY2FtZWxDYXNlIHdoZW4gYW5pbWF0aW5nXG4gKi9cbmNvbnN0IHByb2Nlc3NLZXlmcmFtZXMgPSAoa2V5ZnJhbWVzKSA9PiB7XG4gIGtleWZyYW1lcy5mb3JFYWNoKGtleWZyYW1lID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBrZXlmcmFtZSkge1xuICAgICAgaWYgKGtleWZyYW1lLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBrZXlmcmFtZVtrZXldO1xuICAgICAgICBpZiAoa2V5ID09PSAnZWFzaW5nJykge1xuICAgICAgICAgIGNvbnN0IG5ld0tleSA9ICdhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJztcbiAgICAgICAgICBrZXlmcmFtZVtuZXdLZXldID0gdmFsdWU7XG4gICAgICAgICAgZGVsZXRlIGtleWZyYW1lW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3S2V5ID0gY29udmVydENhbWVsQ2FzZVRvSHlwZW4oa2V5KTtcbiAgICAgICAgICBpZiAobmV3S2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgIGtleWZyYW1lW25ld0tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBrZXlmcmFtZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBrZXlmcmFtZXM7XG59O1xuY29uc3QgY29udmVydENhbWVsQ2FzZVRvSHlwZW4gPSAoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn07XG5jb25zdCBnZXRBbmltYXRpb25QcmVmaXggPSAoZWwpID0+IHtcbiAgaWYgKGFuaW1hdGlvblByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3VwcG9ydHNVbnByZWZpeGVkID0gZWwuc3R5bGUuYW5pbWF0aW9uTmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN1cHBvcnRzV2Via2l0UHJlZml4ID0gZWwuc3R5bGUud2Via2l0QW5pbWF0aW9uTmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgIGFuaW1hdGlvblByZWZpeCA9ICghc3VwcG9ydHNVbnByZWZpeGVkICYmIHN1cHBvcnRzV2Via2l0UHJlZml4KSA/ICctd2Via2l0LScgOiAnJztcbiAgfVxuICByZXR1cm4gYW5pbWF0aW9uUHJlZml4O1xufTtcbmNvbnN0IHNldFN0eWxlUHJvcGVydHkgPSAoZWxlbWVudCwgcHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBwcmVmaXggPSBwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aCgnYW5pbWF0aW9uJykgPyBnZXRBbmltYXRpb25QcmVmaXgoZWxlbWVudCkgOiAnJztcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcmVmaXggKyBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbn07XG5jb25zdCByZW1vdmVTdHlsZVByb3BlcnR5ID0gKGVsZW1lbnQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICBjb25zdCBwcmVmaXggPSBwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aCgnYW5pbWF0aW9uJykgPyBnZXRBbmltYXRpb25QcmVmaXgoZWxlbWVudCkgOiAnJztcbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcmVmaXggKyBwcm9wZXJ0eU5hbWUpO1xufTtcbmNvbnN0IGFuaW1hdGlvbkVuZCA9IChlbCwgY2FsbGJhY2spID0+IHtcbiAgbGV0IHVuUmVnVHJhbnM7XG4gIGNvbnN0IG9wdHMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgY29uc3QgdW5yZWdpc3RlciA9ICgpID0+IHtcbiAgICBpZiAodW5SZWdUcmFucykge1xuICAgICAgdW5SZWdUcmFucygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKGV2KSA9PiB7XG4gICAgaWYgKGVsID09PSBldi50YXJnZXQpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICAgIGNhbGxiYWNrKGV2KTtcbiAgICB9XG4gIH07XG4gIGlmIChlbCkge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdEFuaW1hdGlvbkVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICB1blJlZ1RyYW5zID0gKCkgPT4ge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0QW5pbWF0aW9uRW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5yZWdpc3Rlcjtcbn07XG5jb25zdCBnZW5lcmF0ZUtleWZyYW1lUnVsZXMgPSAoa2V5ZnJhbWVzID0gW10pID0+IHtcbiAgcmV0dXJuIGtleWZyYW1lcy5tYXAoa2V5ZnJhbWUgPT4ge1xuICAgIGNvbnN0IG9mZnNldCA9IGtleWZyYW1lLm9mZnNldDtcbiAgICBjb25zdCBmcmFtZVN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4ga2V5ZnJhbWUpIHtcbiAgICAgIGlmIChrZXlmcmFtZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgcHJvcGVydHkgIT09ICdvZmZzZXQnKSB7XG4gICAgICAgIGZyYW1lU3RyaW5nLnB1c2goYCR7cHJvcGVydHl9OiAke2tleWZyYW1lW3Byb3BlcnR5XX07YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgJHtvZmZzZXQgKiAxMDB9JSB7ICR7ZnJhbWVTdHJpbmcuam9pbignICcpfSB9YDtcbiAgfSkuam9pbignICcpO1xufTtcbmNvbnN0IGtleWZyYW1lSWRzID0gW107XG5jb25zdCBnZW5lcmF0ZUtleWZyYW1lTmFtZSA9IChrZXlmcmFtZVJ1bGVzKSA9PiB7XG4gIGxldCBpbmRleCA9IGtleWZyYW1lSWRzLmluZGV4T2Yoa2V5ZnJhbWVSdWxlcyk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IChrZXlmcmFtZUlkcy5wdXNoKGtleWZyYW1lUnVsZXMpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGBpb24tYW5pbWF0aW9uLSR7aW5kZXh9YDtcbn07XG5jb25zdCBnZXRTdHlsZUNvbnRhaW5lciA9IChlbGVtZW50KSA9PiB7XG4gIGNvbnN0IHJvb3ROb2RlID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICByZXR1cm4gKHJvb3ROb2RlLmhlYWQgfHwgcm9vdE5vZGUpO1xufTtcbmNvbnN0IGNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldCA9IChrZXlmcmFtZU5hbWUsIGtleWZyYW1lUnVsZXMsIGVsZW1lbnQpID0+IHtcbiAgY29uc3Qgc3R5bGVDb250YWluZXIgPSBnZXRTdHlsZUNvbnRhaW5lcihlbGVtZW50KTtcbiAgY29uc3Qga2V5ZnJhbWVQcmVmaXggPSBnZXRBbmltYXRpb25QcmVmaXgoZWxlbWVudCk7XG4gIGNvbnN0IGV4aXN0aW5nU3R5bGVzaGVldCA9IHN0eWxlQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyMnICsga2V5ZnJhbWVOYW1lKTtcbiAgaWYgKGV4aXN0aW5nU3R5bGVzaGVldCkge1xuICAgIHJldHVybiBleGlzdGluZ1N0eWxlc2hlZXQ7XG4gIH1cbiAgY29uc3Qgc3R5bGVzaGVldCA9IChlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlc2hlZXQuaWQgPSBrZXlmcmFtZU5hbWU7XG4gIHN0eWxlc2hlZXQudGV4dENvbnRlbnQgPSBgQCR7a2V5ZnJhbWVQcmVmaXh9a2V5ZnJhbWVzICR7a2V5ZnJhbWVOYW1lfSB7ICR7a2V5ZnJhbWVSdWxlc30gfSBAJHtrZXlmcmFtZVByZWZpeH1rZXlmcmFtZXMgJHtrZXlmcmFtZU5hbWV9LWFsdCB7ICR7a2V5ZnJhbWVSdWxlc30gfWA7XG4gIHN0eWxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0eWxlc2hlZXQpO1xuICByZXR1cm4gc3R5bGVzaGVldDtcbn07XG5jb25zdCBhZGRDbGFzc1RvQXJyYXkgPSAoY2xhc3NlcyA9IFtdLCBjbGFzc05hbWUpID0+IHtcbiAgaWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lVG9BcHBlbmQgPSAoQXJyYXkuaXNBcnJheShjbGFzc05hbWUpKSA/IGNsYXNzTmFtZSA6IFtjbGFzc05hbWVdO1xuICAgIHJldHVybiBbLi4uY2xhc3NlcywgLi4uY2xhc3NOYW1lVG9BcHBlbmRdO1xuICB9XG4gIHJldHVybiBjbGFzc2VzO1xufTtcblxuY29uc3QgY3JlYXRlQW5pbWF0aW9uID0gKGFuaW1hdGlvbklkKSA9PiB7XG4gIGxldCBfZGVsYXk7XG4gIGxldCBfZHVyYXRpb247XG4gIGxldCBfZWFzaW5nO1xuICBsZXQgX2l0ZXJhdGlvbnM7XG4gIGxldCBfZmlsbDtcbiAgbGV0IF9kaXJlY3Rpb247XG4gIGxldCBfa2V5ZnJhbWVzID0gW107XG4gIGxldCBiZWZvcmVBZGRDbGFzc2VzID0gW107XG4gIGxldCBiZWZvcmVSZW1vdmVDbGFzc2VzID0gW107XG4gIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBsZXQgcGFyZW50QW5pbWF0aW9uO1xuICBsZXQgYmVmb3JlU3R5bGVzVmFsdWUgPSB7fTtcbiAgbGV0IGFmdGVyQWRkQ2xhc3NlcyA9IFtdO1xuICBsZXQgYWZ0ZXJSZW1vdmVDbGFzc2VzID0gW107XG4gIGxldCBhZnRlclN0eWxlc1ZhbHVlID0ge307XG4gIGxldCBudW1BbmltYXRpb25zUnVubmluZyA9IDA7XG4gIGxldCBzaG91bGRGb3JjZUxpbmVhckVhc2luZyA9IGZhbHNlO1xuICBsZXQgc2hvdWxkRm9yY2VTeW5jUGxheWJhY2sgPSBmYWxzZTtcbiAgbGV0IGNzc0FuaW1hdGlvbnNUaW1lckZhbGxiYWNrO1xuICBsZXQgZm9yY2VEaXJlY3Rpb25WYWx1ZTtcbiAgbGV0IGZvcmNlRHVyYXRpb25WYWx1ZTtcbiAgbGV0IGZvcmNlRGVsYXlWYWx1ZTtcbiAgbGV0IHdpbGxDb21wbGV0ZSA9IHRydWU7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICBsZXQgc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucyA9IHRydWU7XG4gIGxldCBrZXlmcmFtZU5hbWU7XG4gIGxldCBhbmk7XG4gIGNvbnN0IGlkID0gYW5pbWF0aW9uSWQ7XG4gIGNvbnN0IG9uRmluaXNoQ2FsbGJhY2tzID0gW107XG4gIGNvbnN0IG9uRmluaXNoT25lVGltZUNhbGxiYWNrcyA9IFtdO1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBjb25zdCBjaGlsZEFuaW1hdGlvbnMgPSBbXTtcbiAgY29uc3Qgc3R5bGVzaGVldHMgPSBbXTtcbiAgY29uc3QgX2JlZm9yZUFkZFJlYWRGdW5jdGlvbnMgPSBbXTtcbiAgY29uc3QgX2JlZm9yZUFkZFdyaXRlRnVuY3Rpb25zID0gW107XG4gIGNvbnN0IF9hZnRlckFkZFJlYWRGdW5jdGlvbnMgPSBbXTtcbiAgY29uc3QgX2FmdGVyQWRkV3JpdGVGdW5jdGlvbnMgPSBbXTtcbiAgY29uc3Qgd2ViQW5pbWF0aW9ucyA9IFtdO1xuICBjb25zdCBzdXBwb3J0c0FuaW1hdGlvbkVmZmVjdCA9ICh0eXBlb2YgQW5pbWF0aW9uRWZmZWN0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB3aW5kb3cuQW5pbWF0aW9uRWZmZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgY29uc3Qgc3VwcG9ydHNXZWJBbmltYXRpb25zID0gKHR5cGVvZiBFbGVtZW50ID09PSAnZnVuY3Rpb24nKSAmJiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGUgPT09ICdmdW5jdGlvbicpICYmIHN1cHBvcnRzQW5pbWF0aW9uRWZmZWN0O1xuICBjb25zdCBBTklNQVRJT05fRU5EX0ZBTExCQUNLX1BBRERJTkdfTVMgPSAxMDA7XG4gIGNvbnN0IGdldFdlYkFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHdlYkFuaW1hdGlvbnM7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoY2xlYXJTdHlsZVNoZWV0cykgPT4ge1xuICAgIGNoaWxkQW5pbWF0aW9ucy5mb3JFYWNoKGNoaWxkQW5pbWF0aW9uID0+IHtcbiAgICAgIGNoaWxkQW5pbWF0aW9uLmRlc3Ryb3koY2xlYXJTdHlsZVNoZWV0cyk7XG4gICAgfSk7XG4gICAgY2xlYW5VcChjbGVhclN0eWxlU2hlZXRzKTtcbiAgICBlbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIGNoaWxkQW5pbWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIF9rZXlmcmFtZXMubGVuZ3RoID0gMDtcbiAgICBjbGVhck9uRmluaXNoKCk7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBzaG91bGRDYWxjdWxhdGVOdW1BbmltYXRpb25zID0gdHJ1ZTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICAvKipcbiAgICogQ2FuY2VscyBhbnkgV2ViIEFuaW1hdGlvbnMsIHJlbW92ZXNcbiAgICogYW55IGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGZyb20gdGhlXG4gICAqIGFuaW1hdGlvbidzIGVsZW1lbnRzLCBhbmQgcmVtb3ZlcyB0aGVcbiAgICogYW5pbWF0aW9uJ3Mgc3R5bGVzaGVldHMgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgY29uc3QgY2xlYW5VcCA9IChjbGVhclN0eWxlU2hlZXRzKSA9PiB7XG4gICAgY2xlYW5VcEVsZW1lbnRzKCk7XG4gICAgaWYgKGNsZWFyU3R5bGVTaGVldHMpIHtcbiAgICAgIGNsZWFuVXBTdHlsZVNoZWV0cygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzZXRGbGFncyA9ICgpID0+IHtcbiAgICBzaG91bGRGb3JjZUxpbmVhckVhc2luZyA9IGZhbHNlO1xuICAgIHNob3VsZEZvcmNlU3luY1BsYXliYWNrID0gZmFsc2U7XG4gICAgc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgZm9yY2VEaXJlY3Rpb25WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZUR1cmF0aW9uVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2VEZWxheVZhbHVlID0gdW5kZWZpbmVkO1xuICAgIG51bUFuaW1hdGlvbnNSdW5uaW5nID0gMDtcbiAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHdpbGxDb21wbGV0ZSA9IHRydWU7XG4gIH07XG4gIGNvbnN0IG9uRmluaXNoID0gKGNhbGxiYWNrLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gKG9wdHMgJiYgb3B0cy5vbmVUaW1lQ2FsbGJhY2spID8gb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzIDogb25GaW5pc2hDYWxsYmFja3M7XG4gICAgY2FsbGJhY2tzLnB1c2goeyBjOiBjYWxsYmFjaywgbzogb3B0cyB9KTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBjbGVhck9uRmluaXNoID0gKCkgPT4ge1xuICAgIG9uRmluaXNoQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IFdlYiBBbmltYXRpb25zIGFuZCByZW1vdmVzXG4gICAqIGFueSBhbmltYXRpb24gcHJvcGVydGllcyBmcm9tIHRoZVxuICAgKiB0aGUgYW5pbWF0aW9uJ3MgZWxlbWVudHMuXG4gICAqL1xuICBjb25zdCBjbGVhblVwRWxlbWVudHMgPSAoKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB7XG4gICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgd2ViQW5pbWF0aW9ucy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzQXJyYXkgPSBlbGVtZW50cy5zbGljZSgpO1xuICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgZWxlbWVudHNBcnJheS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1uYW1lJyk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWR1cmF0aW9uJyk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbicpO1xuICAgICAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnKTtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZGVsYXknKTtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScpO1xuICAgICAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1maWxsLW1vZGUnKTtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZGlyZWN0aW9uJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgYW5pbWF0aW9uJ3Mgc3R5bGVzaGVldHNcbiAgICogZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgY29uc3QgY2xlYW5VcFN0eWxlU2hlZXRzID0gKCkgPT4ge1xuICAgIHN0eWxlc2hlZXRzLmZvckVhY2goc3R5bGVzaGVldCA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gc2hhcmluZyBzdHlsZXNoZWV0cywgaXQncyBwb3NzaWJsZVxuICAgICAgICogZm9yIGFub3RoZXIgYW5pbWF0aW9uIHRvIGhhdmUgYWxyZWFkeVxuICAgICAgICogY2xlYW5lZCB1cCBhIHBhcnRpY3VsYXIgc3R5bGVzaGVldFxuICAgICAgICovXG4gICAgICBpZiAoc3R5bGVzaGVldCAmJiBzdHlsZXNoZWV0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3R5bGVzaGVldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlc2hlZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN0eWxlc2hlZXRzLmxlbmd0aCA9IDA7XG4gIH07XG4gIGNvbnN0IGJlZm9yZUFkZFJlYWQgPSAocmVhZEZuKSA9PiB7XG4gICAgX2JlZm9yZUFkZFJlYWRGdW5jdGlvbnMucHVzaChyZWFkRm4pO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGJlZm9yZUFkZFdyaXRlID0gKHdyaXRlRm4pID0+IHtcbiAgICBfYmVmb3JlQWRkV3JpdGVGdW5jdGlvbnMucHVzaCh3cml0ZUZuKTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckFkZFJlYWQgPSAocmVhZEZuKSA9PiB7XG4gICAgX2FmdGVyQWRkUmVhZEZ1bmN0aW9ucy5wdXNoKHJlYWRGbik7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYWZ0ZXJBZGRXcml0ZSA9ICh3cml0ZUZuKSA9PiB7XG4gICAgX2FmdGVyQWRkV3JpdGVGdW5jdGlvbnMucHVzaCh3cml0ZUZuKTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBiZWZvcmVBZGRDbGFzcyA9IChjbGFzc05hbWUpID0+IHtcbiAgICBiZWZvcmVBZGRDbGFzc2VzID0gYWRkQ2xhc3NUb0FycmF5KGJlZm9yZUFkZENsYXNzZXMsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlUmVtb3ZlQ2xhc3MgPSAoY2xhc3NOYW1lKSA9PiB7XG4gICAgYmVmb3JlUmVtb3ZlQ2xhc3NlcyA9IGFkZENsYXNzVG9BcnJheShiZWZvcmVSZW1vdmVDbGFzc2VzLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgQ1NTIGlubGluZSBzdHlsZXMgdG8gdGhlIGFuaW1hdGlvbidzXG4gICAqIGVsZW1lbnRzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGJlZ2lucy5cbiAgICovXG4gIGNvbnN0IGJlZm9yZVN0eWxlcyA9IChzdHlsZXMgPSB7fSkgPT4ge1xuICAgIGJlZm9yZVN0eWxlc1ZhbHVlID0gc3R5bGVzO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBDU1MgaW5saW5lIHN0eWxlcyBmcm9tIHRoZSBhbmltYXRpb24nc1xuICAgKiBlbGVtZW50cyBiZWZvcmUgdGhlIGFuaW1hdGlvbiBiZWdpbnMuXG4gICAqL1xuICBjb25zdCBiZWZvcmVDbGVhclN0eWxlcyA9IChwcm9wZXJ0eU5hbWVzID0gW10pID0+IHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgIGJlZm9yZVN0eWxlc1ZhbHVlW3Byb3BlcnR5XSA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckFkZENsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgIGFmdGVyQWRkQ2xhc3NlcyA9IGFkZENsYXNzVG9BcnJheShhZnRlckFkZENsYXNzZXMsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYWZ0ZXJSZW1vdmVDbGFzcyA9IChjbGFzc05hbWUpID0+IHtcbiAgICBhZnRlclJlbW92ZUNsYXNzZXMgPSBhZGRDbGFzc1RvQXJyYXkoYWZ0ZXJSZW1vdmVDbGFzc2VzLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGFmdGVyU3R5bGVzID0gKHN0eWxlcyA9IHt9KSA9PiB7XG4gICAgYWZ0ZXJTdHlsZXNWYWx1ZSA9IHN0eWxlcztcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckNsZWFyU3R5bGVzID0gKHByb3BlcnR5TmFtZXMgPSBbXSkgPT4ge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydHlOYW1lcykge1xuICAgICAgYWZ0ZXJTdHlsZXNWYWx1ZVtwcm9wZXJ0eV0gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZ2V0RmlsbCA9ICgpID0+IHtcbiAgICBpZiAoX2ZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9maWxsO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldEZpbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuICdib3RoJztcbiAgfTtcbiAgY29uc3QgZ2V0RGlyZWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChmb3JjZURpcmVjdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmb3JjZURpcmVjdGlvblZhbHVlO1xuICAgIH1cbiAgICBpZiAoX2RpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2RpcmVjdGlvbjtcbiAgICB9XG4gICAgaWYgKHBhcmVudEFuaW1hdGlvbikge1xuICAgICAgcmV0dXJuIHBhcmVudEFuaW1hdGlvbi5nZXREaXJlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuICdub3JtYWwnO1xuICB9O1xuICBjb25zdCBnZXRFYXNpbmcgPSAoKSA9PiB7XG4gICAgaWYgKHNob3VsZEZvcmNlTGluZWFyRWFzaW5nKSB7XG4gICAgICByZXR1cm4gJ2xpbmVhcic7XG4gICAgfVxuICAgIGlmIChfZWFzaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfZWFzaW5nO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldEVhc2luZygpO1xuICAgIH1cbiAgICByZXR1cm4gJ2xpbmVhcic7XG4gIH07XG4gIGNvbnN0IGdldER1cmF0aW9uID0gKCkgPT4ge1xuICAgIGlmIChzaG91bGRGb3JjZVN5bmNQbGF5YmFjaykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChmb3JjZUR1cmF0aW9uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZvcmNlRHVyYXRpb25WYWx1ZTtcbiAgICB9XG4gICAgaWYgKF9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2R1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldER1cmF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICBjb25zdCBnZXRJdGVyYXRpb25zID0gKCkgPT4ge1xuICAgIGlmIChfaXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2l0ZXJhdGlvbnM7XG4gICAgfVxuICAgIGlmIChwYXJlbnRBbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBwYXJlbnRBbmltYXRpb24uZ2V0SXRlcmF0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfTtcbiAgY29uc3QgZ2V0RGVsYXkgPSAoKSA9PiB7XG4gICAgaWYgKGZvcmNlRGVsYXlWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZm9yY2VEZWxheVZhbHVlO1xuICAgIH1cbiAgICBpZiAoX2RlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfZGVsYXk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRBbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBwYXJlbnRBbmltYXRpb24uZ2V0RGVsYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IGdldEtleWZyYW1lcyA9ICgpID0+IHtcbiAgICByZXR1cm4gX2tleWZyYW1lcztcbiAgfTtcbiAgY29uc3QgZGlyZWN0aW9uID0gKGFuaW1hdGlvbkRpcmVjdGlvbikgPT4ge1xuICAgIF9kaXJlY3Rpb24gPSBhbmltYXRpb25EaXJlY3Rpb247XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGZpbGwgPSAoYW5pbWF0aW9uRmlsbCkgPT4ge1xuICAgIF9maWxsID0gYW5pbWF0aW9uRmlsbDtcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZGVsYXkgPSAoYW5pbWF0aW9uRGVsYXkpID0+IHtcbiAgICBfZGVsYXkgPSBhbmltYXRpb25EZWxheTtcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZWFzaW5nID0gKGFuaW1hdGlvbkVhc2luZykgPT4ge1xuICAgIF9lYXNpbmcgPSBhbmltYXRpb25FYXNpbmc7XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGR1cmF0aW9uID0gKGFuaW1hdGlvbkR1cmF0aW9uKSA9PiB7XG4gICAgLyoqXG4gICAgICogQ1NTIEFuaW1hdGlvbiBEdXJhdGlvbnMgb2YgMG1zIHdvcmsgZmluZSBvbiBDaHJvbWVcbiAgICAgKiBidXQgZG8gbm90IHJ1biBvbiBTYWZhcmksIHNvIGZvcmNlIGl0IHRvIDFtcyB0b1xuICAgICAqIGdldCBpdCB0byBydW4gb24gYm90aCBwbGF0Zm9ybXMuXG4gICAgICovXG4gICAgaWYgKCFzdXBwb3J0c1dlYkFuaW1hdGlvbnMgJiYgYW5pbWF0aW9uRHVyYXRpb24gPT09IDApIHtcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gMTtcbiAgICB9XG4gICAgX2R1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb247XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGl0ZXJhdGlvbnMgPSAoYW5pbWF0aW9uSXRlcmF0aW9ucykgPT4ge1xuICAgIF9pdGVyYXRpb25zID0gYW5pbWF0aW9uSXRlcmF0aW9ucztcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcGFyZW50ID0gKGFuaW1hdGlvbikgPT4ge1xuICAgIHBhcmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZGRFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgaWYgKGVsICE9IG51bGwpIHtcbiAgICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgYWRkRWxlbWVudCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZGRBbmltYXRpb24gPSAoYW5pbWF0aW9uVG9BZGQpID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uVG9BZGQgIT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5pbWF0aW9uVG9BZGQpKSB7XG4gICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGFuaW1hdGlvblRvQWRkKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnBhcmVudChhbmkpO1xuICAgICAgICAgIGNoaWxkQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhbmltYXRpb25Ub0FkZC5wYXJlbnQoYW5pKTtcbiAgICAgICAgY2hpbGRBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uVG9BZGQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBrZXlmcmFtZXMgPSAoa2V5ZnJhbWVWYWx1ZXMpID0+IHtcbiAgICBjb25zdCBkaWZmZXJlbnQgPSBfa2V5ZnJhbWVzICE9PSBrZXlmcmFtZVZhbHVlcztcbiAgICBfa2V5ZnJhbWVzID0ga2V5ZnJhbWVWYWx1ZXM7XG4gICAgaWYgKGRpZmZlcmVudCkge1xuICAgICAgdXBkYXRlS2V5ZnJhbWVzKF9rZXlmcmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCB1cGRhdGVLZXlmcmFtZXMgPSAoa2V5ZnJhbWVWYWx1ZXMpID0+IHtcbiAgICBpZiAoc3VwcG9ydHNXZWJBbmltYXRpb25zKSB7XG4gICAgICBnZXRXZWJBbmltYXRpb25zKCkuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uLmVmZmVjdC5zZXRLZXlmcmFtZXMpIHtcbiAgICAgICAgICBhbmltYXRpb24uZWZmZWN0LnNldEtleWZyYW1lcyhrZXlmcmFtZVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3RWZmZWN0ID0gbmV3IEtleWZyYW1lRWZmZWN0KGFuaW1hdGlvbi5lZmZlY3QudGFyZ2V0LCBrZXlmcmFtZVZhbHVlcywgYW5pbWF0aW9uLmVmZmVjdC5nZXRUaW1pbmcoKSk7XG4gICAgICAgICAgYW5pbWF0aW9uLmVmZmVjdCA9IG5ld0VmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZUNTU0FuaW1hdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJ1biBhbGwgXCJiZWZvcmVcIiBhbmltYXRpb24gaG9va3MuXG4gICAqL1xuICBjb25zdCBiZWZvcmVBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgLy8gUnVucyBhbGwgYmVmb3JlIHJlYWQgY2FsbGJhY2tzXG4gICAgX2JlZm9yZUFkZFJlYWRGdW5jdGlvbnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAvLyBSdW5zIGFsbCBiZWZvcmUgd3JpdGUgY2FsbGJhY2tzXG4gICAgX2JlZm9yZUFkZFdyaXRlRnVuY3Rpb25zLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gICAgLy8gVXBkYXRlcyBzdHlsZXMgYW5kIGNsYXNzZXMgYmVmb3JlIGFuaW1hdGlvbiBydW5zXG4gICAgY29uc3QgYWRkQ2xhc3NlcyA9IGJlZm9yZUFkZENsYXNzZXM7XG4gICAgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IGJlZm9yZVJlbW92ZUNsYXNzZXM7XG4gICAgY29uc3Qgc3R5bGVzID0gYmVmb3JlU3R5bGVzVmFsdWU7XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50Q2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgYWRkQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWxlbWVudENsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgcmVtb3ZlQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWxlbWVudENsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsLCBwcm9wZXJ0eSwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFJ1biBhbGwgXCJhZnRlclwiIGFuaW1hdGlvbiBob29rcy5cbiAgICovXG4gIGNvbnN0IGFmdGVyQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgIGNsZWFyQ1NTQW5pbWF0aW9uc1RpbWVvdXQoKTtcbiAgICAvLyBSdW5zIGFsbCBhZnRlciByZWFkIGNhbGxiYWNrc1xuICAgIF9hZnRlckFkZFJlYWRGdW5jdGlvbnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAvLyBSdW5zIGFsbCBhZnRlciB3cml0ZSBjYWxsYmFja3NcbiAgICBfYWZ0ZXJBZGRXcml0ZUZ1bmN0aW9ucy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xuICAgIC8vIFVwZGF0ZXMgc3R5bGVzIGFuZCBjbGFzc2VzIGJlZm9yZSBhbmltYXRpb24gZW5kc1xuICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gd2lsbENvbXBsZXRlID8gMSA6IDA7XG4gICAgY29uc3QgYWRkQ2xhc3NlcyA9IGFmdGVyQWRkQ2xhc3NlcztcbiAgICBjb25zdCByZW1vdmVDbGFzc2VzID0gYWZ0ZXJSZW1vdmVDbGFzc2VzO1xuICAgIGNvbnN0IHN0eWxlcyA9IGFmdGVyU3R5bGVzVmFsdWU7XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50Q2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgYWRkQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWxlbWVudENsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgcmVtb3ZlQ2xhc3Nlcy5mb3JFYWNoKGMgPT4gZWxlbWVudENsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsLCBwcm9wZXJ0eSwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvbkZpbmlzaENhbGxiYWNrcy5mb3JFYWNoKG9uRmluaXNoQ2FsbGJhY2sgPT4ge1xuICAgICAgcmV0dXJuIG9uRmluaXNoQ2FsbGJhY2suYyhjdXJyZW50U3RlcCwgYW5pKTtcbiAgICB9KTtcbiAgICBvbkZpbmlzaE9uZVRpbWVDYWxsYmFja3MuZm9yRWFjaChvbkZpbmlzaENhbGxiYWNrID0+IHtcbiAgICAgIHJldHVybiBvbkZpbmlzaENhbGxiYWNrLmMoY3VycmVudFN0ZXAsIGFuaSk7XG4gICAgfSk7XG4gICAgb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgaWYgKHdpbGxDb21wbGV0ZSkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB3aWxsQ29tcGxldGUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBhbmltYXRpb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgaWYgKG51bUFuaW1hdGlvbnNSdW5uaW5nID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG51bUFuaW1hdGlvbnNSdW5uaW5nLS07XG4gICAgaWYgKG51bUFuaW1hdGlvbnNSdW5uaW5nID09PSAwKSB7XG4gICAgICBhZnRlckFuaW1hdGlvbigpO1xuICAgICAgaWYgKHBhcmVudEFuaW1hdGlvbikge1xuICAgICAgICBwYXJlbnRBbmltYXRpb24uYW5pbWF0aW9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBpbml0aWFsaXplQ1NTQW5pbWF0aW9uID0gKHRvZ2dsZUFuaW1hdGlvbk5hbWUgPSB0cnVlKSA9PiB7XG4gICAgY2xlYW5VcFN0eWxlU2hlZXRzKCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkS2V5ZnJhbWVzID0gcHJvY2Vzc0tleWZyYW1lcyhfa2V5ZnJhbWVzKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKHByb2Nlc3NlZEtleWZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleWZyYW1lUnVsZXMgPSBnZW5lcmF0ZUtleWZyYW1lUnVsZXMocHJvY2Vzc2VkS2V5ZnJhbWVzKTtcbiAgICAgICAga2V5ZnJhbWVOYW1lID0gKGFuaW1hdGlvbklkICE9PSB1bmRlZmluZWQpID8gYW5pbWF0aW9uSWQgOiBnZW5lcmF0ZUtleWZyYW1lTmFtZShrZXlmcmFtZVJ1bGVzKTtcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IGNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldChrZXlmcmFtZU5hbWUsIGtleWZyYW1lUnVsZXMsIGVsZW1lbnQpO1xuICAgICAgICBzdHlsZXNoZWV0cy5wdXNoKHN0eWxlc2hlZXQpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZHVyYXRpb24nLCBgJHtnZXREdXJhdGlvbigpfW1zYCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nLCBnZXRFYXNpbmcoKSk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kZWxheScsIGAke2dldERlbGF5KCl9bXNgKTtcbiAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWZpbGwtbW9kZScsIGdldEZpbGwoKSk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kaXJlY3Rpb24nLCBnZXREaXJlY3Rpb24oKSk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbnNDb3VudCA9IChnZXRJdGVyYXRpb25zKCkgPT09IEluZmluaXR5KVxuICAgICAgICAgID8gJ2luZmluaXRlJ1xuICAgICAgICAgIDogZ2V0SXRlcmF0aW9ucygpLnRvU3RyaW5nKCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnLCBpdGVyYXRpb25zQ291bnQpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScsICdwYXVzZWQnKTtcbiAgICAgICAgaWYgKHRvZ2dsZUFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScsIGAke3N0eWxlc2hlZXQuaWR9LWFsdGApO1xuICAgICAgICB9XG4gICAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLW5hbWUnLCBzdHlsZXNoZWV0LmlkIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgaW5pdGlhbGl6ZVdlYkFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKF9rZXlmcmFtZXMsIHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGF5OiBnZXREZWxheSgpLFxuICAgICAgICBkdXJhdGlvbjogZ2V0RHVyYXRpb24oKSxcbiAgICAgICAgZWFzaW5nOiBnZXRFYXNpbmcoKSxcbiAgICAgICAgaXRlcmF0aW9uczogZ2V0SXRlcmF0aW9ucygpLFxuICAgICAgICBmaWxsOiBnZXRGaWxsKCksXG4gICAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uKClcbiAgICAgIH0pO1xuICAgICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICB3ZWJBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9KTtcbiAgICBpZiAod2ViQW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB3ZWJBbmltYXRpb25zWzBdLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICBhbmltYXRpb25GaW5pc2goKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBjb25zdCBpbml0aWFsaXplQW5pbWF0aW9uID0gKHRvZ2dsZUFuaW1hdGlvbk5hbWUgPSB0cnVlKSA9PiB7XG4gICAgYmVmb3JlQW5pbWF0aW9uKCk7XG4gICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgICBpbml0aWFsaXplV2ViQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZUNTU0FuaW1hdGlvbih0b2dnbGVBbmltYXRpb25OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzZXRBbmltYXRpb25TdGVwID0gKHN0ZXApID0+IHtcbiAgICBzdGVwID0gTWF0aC5taW4oTWF0aC5tYXgoc3RlcCwgMCksIDAuOTk5OSk7XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB7XG4gICAgICAgIGFuaW1hdGlvbi5jdXJyZW50VGltZSA9IGFuaW1hdGlvbi5lZmZlY3QuZ2V0Q29tcHV0ZWRUaW1pbmcoKS5kZWxheSArIChnZXREdXJhdGlvbigpICogc3RlcCk7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSBgLSR7Z2V0RHVyYXRpb24oKSAqIHN0ZXB9bXNgO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kZWxheScsIGFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScsICdwYXVzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVXZWJBbmltYXRpb24gPSAoc3RlcCkgPT4ge1xuICAgIHdlYkFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgYW5pbWF0aW9uLmVmZmVjdC51cGRhdGVUaW1pbmcoe1xuICAgICAgICBkZWxheTogZ2V0RGVsYXkoKSxcbiAgICAgICAgZHVyYXRpb246IGdldER1cmF0aW9uKCksXG4gICAgICAgIGVhc2luZzogZ2V0RWFzaW5nKCksXG4gICAgICAgIGl0ZXJhdGlvbnM6IGdldEl0ZXJhdGlvbnMoKSxcbiAgICAgICAgZmlsbDogZ2V0RmlsbCgpLFxuICAgICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbigpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXRBbmltYXRpb25TdGVwKHN0ZXApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlQ1NTQW5pbWF0aW9uID0gKHRvZ2dsZUFuaW1hdGlvbk5hbWUgPSB0cnVlLCBzdGVwKSA9PiB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1uYW1lJywga2V5ZnJhbWVOYW1lIHx8IG51bGwpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZHVyYXRpb24nLCBgJHtnZXREdXJhdGlvbigpfW1zYCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nLCBnZXRFYXNpbmcoKSk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kZWxheScsIChzdGVwICE9PSB1bmRlZmluZWQpID8gYC0ke3N0ZXAgKiBnZXREdXJhdGlvbigpfW1zYCA6IGAke2dldERlbGF5KCl9bXNgKTtcbiAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWZpbGwtbW9kZScsIGdldEZpbGwoKSB8fCBudWxsKTtcbiAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWRpcmVjdGlvbicsIGdldERpcmVjdGlvbigpIHx8IG51bGwpO1xuICAgICAgICBjb25zdCBpdGVyYXRpb25zQ291bnQgPSAoZ2V0SXRlcmF0aW9ucygpID09PSBJbmZpbml0eSlcbiAgICAgICAgICA/ICdpbmZpbml0ZSdcbiAgICAgICAgICA6IGdldEl0ZXJhdGlvbnMoKS50b1N0cmluZygpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JywgaXRlcmF0aW9uc0NvdW50KTtcbiAgICAgICAgaWYgKHRvZ2dsZUFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScsIGAke2tleWZyYW1lTmFtZX0tYWx0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScsIGtleWZyYW1lTmFtZSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlID0gKGRlZXAgPSBmYWxzZSwgdG9nZ2xlQW5pbWF0aW9uTmFtZSA9IHRydWUsIHN0ZXApID0+IHtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShkZWVwLCB0b2dnbGVBbmltYXRpb25OYW1lLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNXZWJBbmltYXRpb25zKSB7XG4gICAgICB1cGRhdGVXZWJBbmltYXRpb24oc3RlcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXBkYXRlQ1NTQW5pbWF0aW9uKHRvZ2dsZUFuaW1hdGlvbk5hbWUsIHN0ZXApO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBwcm9ncmVzc1N0YXJ0ID0gKGZvcmNlTGluZWFyRWFzaW5nID0gZmFsc2UsIHN0ZXApID0+IHtcbiAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RhcnQoZm9yY2VMaW5lYXJFYXNpbmcsIHN0ZXApO1xuICAgIH0pO1xuICAgIHBhdXNlQW5pbWF0aW9uKCk7XG4gICAgc2hvdWxkRm9yY2VMaW5lYXJFYXNpbmcgPSBmb3JjZUxpbmVhckVhc2luZztcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBpbml0aWFsaXplQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZShmYWxzZSwgdHJ1ZSwgc3RlcCk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcHJvZ3Jlc3NTdGVwID0gKHN0ZXApID0+IHtcbiAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RlcChzdGVwKTtcbiAgICB9KTtcbiAgICBzZXRBbmltYXRpb25TdGVwKHN0ZXApO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IHByb2dyZXNzRW5kID0gKHBsYXlUbywgc3RlcCwgZHVyKSA9PiB7XG4gICAgc2hvdWxkRm9yY2VMaW5lYXJFYXNpbmcgPSBmYWxzZTtcbiAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgYW5pbWF0aW9uLnByb2dyZXNzRW5kKHBsYXlUbywgc3RlcCwgZHVyKTtcbiAgICB9KTtcbiAgICBpZiAoZHVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcmNlRHVyYXRpb25WYWx1ZSA9IGR1cjtcbiAgICB9XG4gICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHN0cmljdC1ib29sZWFuLWNvbmRpdGlvbnNcbiAgICB3aWxsQ29tcGxldGUgPSB0cnVlO1xuICAgIGlmIChwbGF5VG8gPT09IDApIHtcbiAgICAgIGZvcmNlRGlyZWN0aW9uVmFsdWUgPSAoZ2V0RGlyZWN0aW9uKCkgPT09ICdyZXZlcnNlJykgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICAgIGlmIChmb3JjZURpcmVjdGlvblZhbHVlID09PSAncmV2ZXJzZScpIHtcbiAgICAgICAgd2lsbENvbXBsZXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNXZWJBbmltYXRpb25zKSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICBzZXRBbmltYXRpb25TdGVwKDEgLSBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3JjZURlbGF5VmFsdWUgPSAoKDEgLSBzdGVwKSAqIGdldER1cmF0aW9uKCkpICogLTE7XG4gICAgICAgIHVwZGF0ZShmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwbGF5VG8gPT09IDEpIHtcbiAgICAgIGlmIChzdXBwb3J0c1dlYkFuaW1hdGlvbnMpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIHNldEFuaW1hdGlvblN0ZXAoc3RlcCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yY2VEZWxheVZhbHVlID0gKHN0ZXAgKiBnZXREdXJhdGlvbigpKSAqIC0xO1xuICAgICAgICB1cGRhdGUoZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYXlUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvbkZpbmlzaCgoKSA9PiB7XG4gICAgICAgIGZvcmNlRHVyYXRpb25WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yY2VEaXJlY3Rpb25WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yY2VEZWxheVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgfSwge1xuICAgICAgICBvbmVUaW1lQ2FsbGJhY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwYXJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgcGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBwYXVzZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmIChzdXBwb3J0c1dlYkFuaW1hdGlvbnMpIHtcbiAgICAgICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB7XG4gICAgICAgICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLXBsYXktc3RhdGUnLCAncGF1c2VkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF1c2UgPSAoKSA9PiB7XG4gICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH0pO1xuICAgIHBhdXNlQW5pbWF0aW9uKCk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3Qgb25BbmltYXRpb25FbmRGYWxsYmFjayA9ICgpID0+IHtcbiAgICBjc3NBbmltYXRpb25zVGltZXJGYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBhbmltYXRpb25GaW5pc2goKTtcbiAgfTtcbiAgY29uc3QgY2xlYXJDU1NBbmltYXRpb25zVGltZW91dCA9ICgpID0+IHtcbiAgICBpZiAoY3NzQW5pbWF0aW9uc1RpbWVyRmFsbGJhY2spIHtcbiAgICAgIGNsZWFyVGltZW91dChjc3NBbmltYXRpb25zVGltZXJGYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwbGF5Q1NTQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgICBjbGVhckNTU0FuaW1hdGlvbnNUaW1lb3V0KCk7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChfa2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScsICdydW5uaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChfa2V5ZnJhbWVzLmxlbmd0aCA9PT0gMCB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFuaW1hdGlvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyBhIGNhdGNoYWxsIGluIHRoZSBldmVudCB0aGF0IGEgQ1NTIEFuaW1hdGlvbiBkaWQgbm90IGZpbmlzaC5cbiAgICAgICAqIFRoZSBXZWIgQW5pbWF0aW9ucyBBUEkgaGFzIG1lY2hhbmlzbXMgaW4gcGxhY2UgZm9yIHByZXZlbnRpbmcgdGhpcy5cbiAgICAgICAqIENTUyBBbmltYXRpb25zIHdpbGwgbm90IGZpcmUgYW4gYGFuaW1hdGlvbmVuZGAgZXZlbnRcbiAgICAgICAqIGZvciBlbGVtZW50cyB3aXRoIGBkaXNwbGF5OiBub25lYC4gVGhlIFdlYiBBbmltYXRpb25zIEFQSVxuICAgICAgICogYWNjb3VudHMgZm9yIHRoaXMsIGJ1dCB1c2luZyByYXcgQ1NTIEFuaW1hdGlvbnMgcmVxdWlyZXNcbiAgICAgICAqIHRoaXMgd29ya2Fyb3VuZC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgYW5pbWF0aW9uRGVsYXkgPSBnZXREZWxheSgpIHx8IDA7XG4gICAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IGdldER1cmF0aW9uKCkgfHwgMDtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbkl0ZXJhdGlvbnMgPSBnZXRJdGVyYXRpb25zKCkgfHwgMTtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGEgdGltZW91dCB3aGVuIGFuaW1hdGlvbiBoYXMgaW5maW5pdGUgaXRlcmF0aW9uc1xuICAgICAgaWYgKGlzRmluaXRlKGFuaW1hdGlvbkl0ZXJhdGlvbnMpKSB7XG4gICAgICAgIGNzc0FuaW1hdGlvbnNUaW1lckZhbGxiYWNrID0gc2V0VGltZW91dChvbkFuaW1hdGlvbkVuZEZhbGxiYWNrLCBhbmltYXRpb25EZWxheSArIChhbmltYXRpb25EdXJhdGlvbiAqIGFuaW1hdGlvbkl0ZXJhdGlvbnMpICsgQU5JTUFUSU9OX0VORF9GQUxMQkFDS19QQURESU5HX01TKTtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbkVuZChlbGVtZW50c1swXSwgKCkgPT4ge1xuICAgICAgICBjbGVhckNTU0FuaW1hdGlvbnNUaW1lb3V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgdGhhdCBjbGVhbiB1cFxuICAgICAgICAgKiBpcyBhbHdheXMgZG9uZSBhIGZyYW1lXG4gICAgICAgICAqIGJlZm9yZSB0aGUgb25GaW5pc2ggaGFuZGxlcnNcbiAgICAgICAgICogYXJlIGZpcmVkLiBPdGhlcndpc2UsIHRoZXJlXG4gICAgICAgICAqIG1heSBiZSBmbGlja2VyaW5nIGlmIGEgbmV3XG4gICAgICAgICAqIGFuaW1hdGlvbiBpcyBzdGFydGVkIG9uIHRoZSBzYW1lXG4gICAgICAgICAqIGVsZW1lbnQgdG9vIHF1aWNrbHlcbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogSXMgdGhlcmUgYSBjbGVhbmVyIHdheSB0byBkbyB0aGlzP1xuICAgICAgICAgKi9cbiAgICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgICBjbGVhckNTU0FuaW1hdGlvblBsYXlTdGF0ZSgpO1xuICAgICAgICAgIHJhZihhbmltYXRpb25GaW5pc2gpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJDU1NBbmltYXRpb25QbGF5U3RhdGUgPSAoKSA9PiB7XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kdXJhdGlvbicpO1xuICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWRlbGF5Jyk7XG4gICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBwbGF5V2ViQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgICB3ZWJBbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfSk7XG4gICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID09PSAwIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYW5pbWF0aW9uRmluaXNoKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXNldEFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoc3VwcG9ydHNXZWJBbmltYXRpb25zKSB7XG4gICAgICBzZXRBbmltYXRpb25TdGVwKDApO1xuICAgICAgdXBkYXRlV2ViQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXBkYXRlQ1NTQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwbGF5ID0gKG9wdHMpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnN5bmMpIHtcbiAgICAgICAgc2hvdWxkRm9yY2VTeW5jUGxheWJhY2sgPSB0cnVlO1xuICAgICAgICBvbkZpbmlzaCgoKSA9PiBzaG91bGRGb3JjZVN5bmNQbGF5YmFjayA9IGZhbHNlLCB7IG9uZVRpbWVDYWxsYmFjazogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaW5pdGlhbGl6ZUFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgIHJlc2V0QW5pbWF0aW9uKCk7XG4gICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucykge1xuICAgICAgICBudW1BbmltYXRpb25zUnVubmluZyA9IGNoaWxkQW5pbWF0aW9ucy5sZW5ndGggKyAxO1xuICAgICAgICBzaG91bGRDYWxjdWxhdGVOdW1BbmltYXRpb25zID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvbkZpbmlzaCgoKSA9PiByZXNvbHZlKCksIHsgb25lVGltZUNhbGxiYWNrOiB0cnVlIH0pO1xuICAgICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgICBwbGF5V2ViQW5pbWF0aW9ucygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBsYXlDU1NBbmltYXRpb25zKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgfSk7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICBjbGVhblVwRWxlbWVudHMoKTtcbiAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJlc2V0RmxhZ3MoKTtcbiAgfTtcbiAgY29uc3QgZnJvbSA9IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBmaXJzdEZyYW1lID0gX2tleWZyYW1lc1swXTtcbiAgICBpZiAoZmlyc3RGcmFtZSAhPT0gdW5kZWZpbmVkICYmIChmaXJzdEZyYW1lLm9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGZpcnN0RnJhbWUub2Zmc2V0ID09PSAwKSkge1xuICAgICAgZmlyc3RGcmFtZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfa2V5ZnJhbWVzID0gW1xuICAgICAgICB7IG9mZnNldDogMCwgW3Byb3BlcnR5XTogdmFsdWUgfSxcbiAgICAgICAgLi4uX2tleWZyYW1lc1xuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgdG8gPSAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbGFzdEZyYW1lID0gX2tleWZyYW1lc1tfa2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0RnJhbWUgIT09IHVuZGVmaW5lZCAmJiAobGFzdEZyYW1lLm9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGxhc3RGcmFtZS5vZmZzZXQgPT09IDEpKSB7XG4gICAgICBsYXN0RnJhbWVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX2tleWZyYW1lcyA9IFtcbiAgICAgICAgLi4uX2tleWZyYW1lcyxcbiAgICAgICAgeyBvZmZzZXQ6IDEsIFtwcm9wZXJ0eV06IHZhbHVlIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGZyb21UbyA9IChwcm9wZXJ0eSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGZyb20ocHJvcGVydHksIGZyb21WYWx1ZSkudG8ocHJvcGVydHksIHRvVmFsdWUpO1xuICB9O1xuICByZXR1cm4gYW5pID0ge1xuICAgIHBhcmVudEFuaW1hdGlvbixcbiAgICBlbGVtZW50cyxcbiAgICBjaGlsZEFuaW1hdGlvbnMsXG4gICAgaWQsXG4gICAgYW5pbWF0aW9uRmluaXNoLFxuICAgIGZyb20sXG4gICAgdG8sXG4gICAgZnJvbVRvLFxuICAgIHBhcmVudCxcbiAgICBwbGF5LFxuICAgIHBhdXNlLFxuICAgIHN0b3AsXG4gICAgZGVzdHJveSxcbiAgICBrZXlmcmFtZXMsXG4gICAgYWRkQW5pbWF0aW9uLFxuICAgIGFkZEVsZW1lbnQsXG4gICAgdXBkYXRlLFxuICAgIGZpbGwsXG4gICAgZGlyZWN0aW9uLFxuICAgIGl0ZXJhdGlvbnMsXG4gICAgZHVyYXRpb24sXG4gICAgZWFzaW5nLFxuICAgIGRlbGF5LFxuICAgIGdldFdlYkFuaW1hdGlvbnMsXG4gICAgZ2V0S2V5ZnJhbWVzLFxuICAgIGdldEZpbGwsXG4gICAgZ2V0RGlyZWN0aW9uLFxuICAgIGdldERlbGF5LFxuICAgIGdldEl0ZXJhdGlvbnMsXG4gICAgZ2V0RWFzaW5nLFxuICAgIGdldER1cmF0aW9uLFxuICAgIGFmdGVyQWRkUmVhZCxcbiAgICBhZnRlckFkZFdyaXRlLFxuICAgIGFmdGVyQ2xlYXJTdHlsZXMsXG4gICAgYWZ0ZXJTdHlsZXMsXG4gICAgYWZ0ZXJSZW1vdmVDbGFzcyxcbiAgICBhZnRlckFkZENsYXNzLFxuICAgIGJlZm9yZUFkZFJlYWQsXG4gICAgYmVmb3JlQWRkV3JpdGUsXG4gICAgYmVmb3JlQ2xlYXJTdHlsZXMsXG4gICAgYmVmb3JlU3R5bGVzLFxuICAgIGJlZm9yZVJlbW92ZUNsYXNzLFxuICAgIGJlZm9yZUFkZENsYXNzLFxuICAgIG9uRmluaXNoLFxuICAgIHByb2dyZXNzU3RhcnQsXG4gICAgcHJvZ3Jlc3NTdGVwLFxuICAgIHByb2dyZXNzRW5kXG4gIH07XG59O1xuXG5leHBvcnQgeyBjcmVhdGVBbmltYXRpb24gYXMgYyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35980\n")}}]);