"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[5980],{35980:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": () => (/* binding */ createAnimation)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96587);\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\nlet animationPrefix;\n/**\n * Web Animations requires hyphenated CSS properties\n * to be written in camelCase when animating\n */\nconst processKeyframes = (keyframes) => {\n  keyframes.forEach((keyframe) => {\n    for (const key in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(key)) {\n        const value = keyframe[key];\n        if (key === 'easing') {\n          const newKey = 'animation-timing-function';\n          keyframe[newKey] = value;\n          delete keyframe[key];\n        }\n        else {\n          const newKey = convertCamelCaseToHypen(key);\n          if (newKey !== key) {\n            keyframe[newKey] = value;\n            delete keyframe[key];\n          }\n        }\n      }\n    }\n  });\n  return keyframes;\n};\nconst convertCamelCaseToHypen = (str) => {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n};\nconst getAnimationPrefix = (el) => {\n  if (animationPrefix === undefined) {\n    const supportsUnprefixed = el.style.animationName !== undefined;\n    const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\n    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';\n  }\n  return animationPrefix;\n};\nconst setStyleProperty = (element, propertyName, value) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.setProperty(prefix + propertyName, value);\n};\nconst removeStyleProperty = (element, propertyName) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.removeProperty(prefix + propertyName);\n};\nconst animationEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = { passive: true };\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n    el.addEventListener('animationend', onTransitionEnd, opts);\n    unRegTrans = () => {\n      el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n      el.removeEventListener('animationend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\nconst generateKeyframeRules = (keyframes = []) => {\n  return keyframes\n    .map((keyframe) => {\n    const offset = keyframe.offset;\n    const frameString = [];\n    for (const property in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(property) && property !== 'offset') {\n        frameString.push(`${property}: ${keyframe[property]};`);\n      }\n    }\n    return `${offset * 100}% { ${frameString.join(' ')} }`;\n  })\n    .join(' ');\n};\nconst keyframeIds = [];\nconst generateKeyframeName = (keyframeRules) => {\n  let index = keyframeIds.indexOf(keyframeRules);\n  if (index < 0) {\n    index = keyframeIds.push(keyframeRules) - 1;\n  }\n  return `ion-animation-${index}`;\n};\nconst getStyleContainer = (element) => {\n  const rootNode = element.getRootNode();\n  return rootNode.head || rootNode;\n};\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\n  const styleContainer = getStyleContainer(element);\n  const keyframePrefix = getAnimationPrefix(element);\n  const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\n  if (existingStylesheet) {\n    return existingStylesheet;\n  }\n  const stylesheet = (element.ownerDocument || document).createElement('style');\n  stylesheet.id = keyframeName;\n  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\n  styleContainer.appendChild(stylesheet);\n  return stylesheet;\n};\nconst addClassToArray = (classes = [], className) => {\n  if (className !== undefined) {\n    const classNameToAppend = Array.isArray(className) ? className : [className];\n    return [...classes, ...classNameToAppend];\n  }\n  return classes;\n};\n\nconst createAnimation = (animationId) => {\n  let _delay;\n  let _duration;\n  let _easing;\n  let _iterations;\n  let _fill;\n  let _direction;\n  let _keyframes = [];\n  let beforeAddClasses = [];\n  let beforeRemoveClasses = [];\n  let initialized = false;\n  let parentAnimation;\n  let beforeStylesValue = {};\n  let afterAddClasses = [];\n  let afterRemoveClasses = [];\n  let afterStylesValue = {};\n  let numAnimationsRunning = 0;\n  let shouldForceLinearEasing = false;\n  let shouldForceSyncPlayback = false;\n  let cssAnimationsTimerFallback;\n  let forceDirectionValue;\n  let forceDurationValue;\n  let forceDelayValue;\n  let willComplete = true;\n  let finished = false;\n  let shouldCalculateNumAnimations = true;\n  let keyframeName;\n  let ani;\n  let paused = false;\n  const id = animationId;\n  const onFinishCallbacks = [];\n  const onFinishOneTimeCallbacks = [];\n  const elements = [];\n  const childAnimations = [];\n  const stylesheets = [];\n  const _beforeAddReadFunctions = [];\n  const _beforeAddWriteFunctions = [];\n  const _afterAddReadFunctions = [];\n  const _afterAddWriteFunctions = [];\n  const webAnimations = [];\n  const supportsAnimationEffect = typeof AnimationEffect === 'function' || typeof window.AnimationEffect === 'function';\n  const supportsWebAnimations = typeof Element === 'function' &&\n    typeof Element.prototype.animate === 'function' &&\n    supportsAnimationEffect;\n  const ANIMATION_END_FALLBACK_PADDING_MS = 100;\n  const getWebAnimations = () => {\n    return webAnimations;\n  };\n  const destroy = (clearStyleSheets) => {\n    childAnimations.forEach((childAnimation) => {\n      childAnimation.destroy(clearStyleSheets);\n    });\n    cleanUp(clearStyleSheets);\n    elements.length = 0;\n    childAnimations.length = 0;\n    _keyframes.length = 0;\n    clearOnFinish();\n    initialized = false;\n    shouldCalculateNumAnimations = true;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations, removes\n   * any animation properties from the\n   * animation's elements, and removes the\n   * animation's stylesheets from the DOM.\n   */\n  const cleanUp = (clearStyleSheets) => {\n    cleanUpElements();\n    if (clearStyleSheets) {\n      cleanUpStyleSheets();\n    }\n  };\n  const resetFlags = () => {\n    shouldForceLinearEasing = false;\n    shouldForceSyncPlayback = false;\n    shouldCalculateNumAnimations = true;\n    forceDirectionValue = undefined;\n    forceDurationValue = undefined;\n    forceDelayValue = undefined;\n    numAnimationsRunning = 0;\n    finished = false;\n    willComplete = true;\n    paused = false;\n  };\n  const isRunning = () => {\n    return numAnimationsRunning !== 0 && !paused;\n  };\n  const onFinish = (callback, opts) => {\n    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\n    callbacks.push({ c: callback, o: opts });\n    return ani;\n  };\n  const clearOnFinish = () => {\n    onFinishCallbacks.length = 0;\n    onFinishOneTimeCallbacks.length = 0;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations and removes\n   * any animation properties from the\n   * the animation's elements.\n   */\n  const cleanUpElements = () => {\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        animation.cancel();\n      });\n      webAnimations.length = 0;\n    }\n    else {\n      const elementsArray = elements.slice();\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n        elementsArray.forEach((element) => {\n          removeStyleProperty(element, 'animation-name');\n          removeStyleProperty(element, 'animation-duration');\n          removeStyleProperty(element, 'animation-timing-function');\n          removeStyleProperty(element, 'animation-iteration-count');\n          removeStyleProperty(element, 'animation-delay');\n          removeStyleProperty(element, 'animation-play-state');\n          removeStyleProperty(element, 'animation-fill-mode');\n          removeStyleProperty(element, 'animation-direction');\n        });\n      });\n    }\n  };\n  /**\n   * Removes the animation's stylesheets\n   * from the DOM.\n   */\n  const cleanUpStyleSheets = () => {\n    stylesheets.forEach((stylesheet) => {\n      /**\n       * When sharing stylesheets, it's possible\n       * for another animation to have already\n       * cleaned up a particular stylesheet\n       */\n      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {\n        stylesheet.parentNode.removeChild(stylesheet);\n      }\n    });\n    stylesheets.length = 0;\n  };\n  const beforeAddRead = (readFn) => {\n    _beforeAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const beforeAddWrite = (writeFn) => {\n    _beforeAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const afterAddRead = (readFn) => {\n    _afterAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const afterAddWrite = (writeFn) => {\n    _afterAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const beforeAddClass = (className) => {\n    beforeAddClasses = addClassToArray(beforeAddClasses, className);\n    return ani;\n  };\n  const beforeRemoveClass = (className) => {\n    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\n    return ani;\n  };\n  /**\n   * Set CSS inline styles to the animation's\n   * elements before the animation begins.\n   */\n  const beforeStyles = (styles = {}) => {\n    beforeStylesValue = styles;\n    return ani;\n  };\n  /**\n   * Clear CSS inline styles from the animation's\n   * elements before the animation begins.\n   */\n  const beforeClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      beforeStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const afterAddClass = (className) => {\n    afterAddClasses = addClassToArray(afterAddClasses, className);\n    return ani;\n  };\n  const afterRemoveClass = (className) => {\n    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\n    return ani;\n  };\n  const afterStyles = (styles = {}) => {\n    afterStylesValue = styles;\n    return ani;\n  };\n  const afterClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      afterStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const getFill = () => {\n    if (_fill !== undefined) {\n      return _fill;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getFill();\n    }\n    return 'both';\n  };\n  const getDirection = () => {\n    if (forceDirectionValue !== undefined) {\n      return forceDirectionValue;\n    }\n    if (_direction !== undefined) {\n      return _direction;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDirection();\n    }\n    return 'normal';\n  };\n  const getEasing = () => {\n    if (shouldForceLinearEasing) {\n      return 'linear';\n    }\n    if (_easing !== undefined) {\n      return _easing;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getEasing();\n    }\n    return 'linear';\n  };\n  const getDuration = () => {\n    if (shouldForceSyncPlayback) {\n      return 0;\n    }\n    if (forceDurationValue !== undefined) {\n      return forceDurationValue;\n    }\n    if (_duration !== undefined) {\n      return _duration;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDuration();\n    }\n    return 0;\n  };\n  const getIterations = () => {\n    if (_iterations !== undefined) {\n      return _iterations;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getIterations();\n    }\n    return 1;\n  };\n  const getDelay = () => {\n    if (forceDelayValue !== undefined) {\n      return forceDelayValue;\n    }\n    if (_delay !== undefined) {\n      return _delay;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDelay();\n    }\n    return 0;\n  };\n  const getKeyframes = () => {\n    return _keyframes;\n  };\n  const direction = (animationDirection) => {\n    _direction = animationDirection;\n    update(true);\n    return ani;\n  };\n  const fill = (animationFill) => {\n    _fill = animationFill;\n    update(true);\n    return ani;\n  };\n  const delay = (animationDelay) => {\n    _delay = animationDelay;\n    update(true);\n    return ani;\n  };\n  const easing = (animationEasing) => {\n    _easing = animationEasing;\n    update(true);\n    return ani;\n  };\n  const duration = (animationDuration) => {\n    /**\n     * CSS Animation Durations of 0ms work fine on Chrome\n     * but do not run on Safari, so force it to 1ms to\n     * get it to run on both platforms.\n     */\n    if (!supportsWebAnimations && animationDuration === 0) {\n      animationDuration = 1;\n    }\n    _duration = animationDuration;\n    update(true);\n    return ani;\n  };\n  const iterations = (animationIterations) => {\n    _iterations = animationIterations;\n    update(true);\n    return ani;\n  };\n  const parent = (animation) => {\n    parentAnimation = animation;\n    return ani;\n  };\n  const addElement = (el) => {\n    if (el != null) {\n      if (el.nodeType === 1) {\n        elements.push(el);\n      }\n      else if (el.length >= 0) {\n        for (let i = 0; i < el.length; i++) {\n          elements.push(el[i]);\n        }\n      }\n      else {\n        console.error('Invalid addElement value');\n      }\n    }\n    return ani;\n  };\n  const addAnimation = (animationToAdd) => {\n    if (animationToAdd != null) {\n      if (Array.isArray(animationToAdd)) {\n        for (const animation of animationToAdd) {\n          animation.parent(ani);\n          childAnimations.push(animation);\n        }\n      }\n      else {\n        animationToAdd.parent(ani);\n        childAnimations.push(animationToAdd);\n      }\n    }\n    return ani;\n  };\n  const keyframes = (keyframeValues) => {\n    const different = _keyframes !== keyframeValues;\n    _keyframes = keyframeValues;\n    if (different) {\n      updateKeyframes(_keyframes);\n    }\n    return ani;\n  };\n  const updateKeyframes = (keyframeValues) => {\n    if (supportsWebAnimations) {\n      getWebAnimations().forEach((animation) => {\n        if (animation.effect.setKeyframes) {\n          animation.effect.setKeyframes(keyframeValues);\n        }\n        else {\n          const newEffect = new KeyframeEffect(animation.effect.target, keyframeValues, animation.effect.getTiming());\n          animation.effect = newEffect;\n        }\n      });\n    }\n    else {\n      initializeCSSAnimation();\n    }\n  };\n  /**\n   * Run all \"before\" animation hooks.\n   */\n  const beforeAnimation = () => {\n    // Runs all before read callbacks\n    _beforeAddReadFunctions.forEach((callback) => callback());\n    // Runs all before write callbacks\n    _beforeAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation runs\n    const addClasses = beforeAddClasses;\n    const removeClasses = beforeRemoveClasses;\n    const styles = beforeStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n  };\n  /**\n   * Run all \"after\" animation hooks.\n   */\n  const afterAnimation = () => {\n    clearCSSAnimationsTimeout();\n    // Runs all after read callbacks\n    _afterAddReadFunctions.forEach((callback) => callback());\n    // Runs all after write callbacks\n    _afterAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation ends\n    const currentStep = willComplete ? 1 : 0;\n    const addClasses = afterAddClasses;\n    const removeClasses = afterRemoveClasses;\n    const styles = afterStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n    onFinishCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.length = 0;\n    shouldCalculateNumAnimations = true;\n    if (willComplete) {\n      finished = true;\n    }\n    willComplete = true;\n  };\n  const animationFinish = () => {\n    if (numAnimationsRunning === 0) {\n      return;\n    }\n    numAnimationsRunning--;\n    if (numAnimationsRunning === 0) {\n      afterAnimation();\n      if (parentAnimation) {\n        parentAnimation.animationFinish();\n      }\n    }\n  };\n  const initializeCSSAnimation = (toggleAnimationName = true) => {\n    cleanUpStyleSheets();\n    const processedKeyframes = processKeyframes(_keyframes);\n    elements.forEach((element) => {\n      if (processedKeyframes.length > 0) {\n        const keyframeRules = generateKeyframeRules(processedKeyframes);\n        keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);\n        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\n        stylesheets.push(stylesheet);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill());\n        setStyleProperty(element, 'animation-direction', getDirection());\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        setStyleProperty(element, 'animation-play-state', 'paused');\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\n        }\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          setStyleProperty(element, 'animation-name', stylesheet.id || null);\n        });\n      }\n    });\n  };\n  const initializeWebAnimation = () => {\n    elements.forEach((element) => {\n      const animation = element.animate(_keyframes, {\n        id,\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n      animation.pause();\n      webAnimations.push(animation);\n    });\n    if (webAnimations.length > 0) {\n      webAnimations[0].onfinish = () => {\n        animationFinish();\n      };\n    }\n  };\n  const initializeAnimation = (toggleAnimationName = true) => {\n    beforeAnimation();\n    if (_keyframes.length > 0) {\n      if (supportsWebAnimations) {\n        initializeWebAnimation();\n      }\n      else {\n        initializeCSSAnimation(toggleAnimationName);\n      }\n    }\n    initialized = true;\n  };\n  const setAnimationStep = (step) => {\n    step = Math.min(Math.max(step, 0), 0.9999);\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;\n        animation.pause();\n      });\n    }\n    else {\n      const animationDuration = `-${getDuration() * step}ms`;\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-delay', animationDuration);\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        }\n      });\n    }\n  };\n  const updateWebAnimation = (step) => {\n    webAnimations.forEach((animation) => {\n      animation.effect.updateTiming({\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n    });\n    if (step !== undefined) {\n      setAnimationStep(step);\n    }\n  };\n  const updateCSSAnimation = (toggleAnimationName = true, step) => {\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n      elements.forEach((element) => {\n        setStyleProperty(element, 'animation-name', keyframeName || null);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill() || null);\n        setStyleProperty(element, 'animation-direction', getDirection() || null);\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\n        }\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          setStyleProperty(element, 'animation-name', keyframeName || null);\n        });\n      });\n    });\n  };\n  const update = (deep = false, toggleAnimationName = true, step) => {\n    if (deep) {\n      childAnimations.forEach((animation) => {\n        animation.update(deep, toggleAnimationName, step);\n      });\n    }\n    if (supportsWebAnimations) {\n      updateWebAnimation(step);\n    }\n    else {\n      updateCSSAnimation(toggleAnimationName, step);\n    }\n    return ani;\n  };\n  const progressStart = (forceLinearEasing = false, step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStart(forceLinearEasing, step);\n    });\n    pauseAnimation();\n    shouldForceLinearEasing = forceLinearEasing;\n    if (!initialized) {\n      initializeAnimation();\n    }\n    update(false, true, step);\n    return ani;\n  };\n  const progressStep = (step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStep(step);\n    });\n    setAnimationStep(step);\n    return ani;\n  };\n  const progressEnd = (playTo, step, dur) => {\n    shouldForceLinearEasing = false;\n    childAnimations.forEach((animation) => {\n      animation.progressEnd(playTo, step, dur);\n    });\n    if (dur !== undefined) {\n      forceDurationValue = dur;\n    }\n    finished = false;\n    willComplete = true;\n    if (playTo === 0) {\n      forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';\n      if (forceDirectionValue === 'reverse') {\n        willComplete = false;\n      }\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(1 - step);\n      }\n      else {\n        forceDelayValue = (1 - step) * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    else if (playTo === 1) {\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(step);\n      }\n      else {\n        forceDelayValue = step * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    if (playTo !== undefined) {\n      onFinish(() => {\n        forceDurationValue = undefined;\n        forceDirectionValue = undefined;\n        forceDelayValue = undefined;\n      }, {\n        oneTimeCallback: true,\n      });\n      if (!parentAnimation) {\n        play();\n      }\n    }\n    return ani;\n  };\n  const pauseAnimation = () => {\n    if (initialized) {\n      if (supportsWebAnimations) {\n        webAnimations.forEach((animation) => {\n          animation.pause();\n        });\n      }\n      else {\n        elements.forEach((element) => {\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        });\n      }\n      paused = true;\n    }\n  };\n  const pause = () => {\n    childAnimations.forEach((animation) => {\n      animation.pause();\n    });\n    pauseAnimation();\n    return ani;\n  };\n  const onAnimationEndFallback = () => {\n    cssAnimationsTimerFallback = undefined;\n    animationFinish();\n  };\n  const clearCSSAnimationsTimeout = () => {\n    if (cssAnimationsTimerFallback) {\n      clearTimeout(cssAnimationsTimerFallback);\n    }\n  };\n  const playCSSAnimations = () => {\n    clearCSSAnimationsTimeout();\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-play-state', 'running');\n        }\n      });\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n    else {\n      /**\n       * This is a catchall in the event that a CSS Animation did not finish.\n       * The Web Animations API has mechanisms in place for preventing this.\n       * CSS Animations will not fire an `animationend` event\n       * for elements with `display: none`. The Web Animations API\n       * accounts for this, but using raw CSS Animations requires\n       * this workaround.\n       */\n      const animationDelay = getDelay() || 0;\n      const animationDuration = getDuration() || 0;\n      const animationIterations = getIterations() || 1;\n      // No need to set a timeout when animation has infinite iterations\n      if (isFinite(animationIterations)) {\n        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);\n      }\n      animationEnd(elements[0], () => {\n        clearCSSAnimationsTimeout();\n        /**\n         * Ensure that clean up\n         * is always done a frame\n         * before the onFinish handlers\n         * are fired. Otherwise, there\n         * may be flickering if a new\n         * animation is started on the same\n         * element too quickly\n         *\n         * TODO: Is there a cleaner way to do this?\n         */\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => {\n          clearCSSAnimationPlayState();\n          (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(animationFinish);\n        });\n      });\n    }\n  };\n  const clearCSSAnimationPlayState = () => {\n    elements.forEach((element) => {\n      removeStyleProperty(element, 'animation-duration');\n      removeStyleProperty(element, 'animation-delay');\n      removeStyleProperty(element, 'animation-play-state');\n    });\n  };\n  const playWebAnimations = () => {\n    webAnimations.forEach((animation) => {\n      animation.play();\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n  };\n  const resetAnimation = () => {\n    if (supportsWebAnimations) {\n      setAnimationStep(0);\n      updateWebAnimation();\n    }\n    else {\n      updateCSSAnimation();\n    }\n  };\n  const play = (opts) => {\n    return new Promise((resolve) => {\n      if (opts === null || opts === void 0 ? void 0 : opts.sync) {\n        shouldForceSyncPlayback = true;\n        onFinish(() => (shouldForceSyncPlayback = false), { oneTimeCallback: true });\n      }\n      if (!initialized) {\n        initializeAnimation();\n      }\n      if (finished) {\n        resetAnimation();\n        finished = false;\n      }\n      if (shouldCalculateNumAnimations) {\n        numAnimationsRunning = childAnimations.length + 1;\n        shouldCalculateNumAnimations = false;\n      }\n      onFinish(() => resolve(), { oneTimeCallback: true });\n      childAnimations.forEach((animation) => {\n        animation.play();\n      });\n      if (supportsWebAnimations) {\n        playWebAnimations();\n      }\n      else {\n        playCSSAnimations();\n      }\n      paused = false;\n    });\n  };\n  const stop = () => {\n    childAnimations.forEach((animation) => {\n      animation.stop();\n    });\n    if (initialized) {\n      cleanUpElements();\n      initialized = false;\n    }\n    resetFlags();\n  };\n  const from = (property, value) => {\n    const firstFrame = _keyframes[0];\n    if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\n      firstFrame[property] = value;\n    }\n    else {\n      _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];\n    }\n    return ani;\n  };\n  const to = (property, value) => {\n    const lastFrame = _keyframes[_keyframes.length - 1];\n    if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\n      lastFrame[property] = value;\n    }\n    else {\n      _keyframes = [..._keyframes, { offset: 1, [property]: value }];\n    }\n    return ani;\n  };\n  const fromTo = (property, fromValue, toValue) => {\n    return from(property, fromValue).to(property, toValue);\n  };\n  return (ani = {\n    parentAnimation,\n    elements,\n    childAnimations,\n    id,\n    animationFinish,\n    from,\n    to,\n    fromTo,\n    parent,\n    play,\n    pause,\n    stop,\n    destroy,\n    keyframes,\n    addAnimation,\n    addElement,\n    update,\n    fill,\n    direction,\n    iterations,\n    duration,\n    easing,\n    delay,\n    getWebAnimations,\n    getKeyframes,\n    getFill,\n    getDirection,\n    getDelay,\n    getIterations,\n    getEasing,\n    getDuration,\n    afterAddRead,\n    afterAddWrite,\n    afterClearStyles,\n    afterStyles,\n    afterRemoveClass,\n    afterAddClass,\n    beforeAddRead,\n    beforeAddWrite,\n    beforeClearStyles,\n    beforeStyles,\n    beforeRemoveClass,\n    beforeAddClass,\n    onFinish,\n    isRunning,\n    progressStart,\n    progressStep,\n    progressEnd,\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU5ODAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUN3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsSUFBSSxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBLGNBQWMsYUFBYSxJQUFJLEVBQUUsd0JBQXdCO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlLFlBQVksZ0JBQWdCLEVBQUUsaUJBQWlCLEdBQUcsZUFBZSxZQUFZLGFBQWEsT0FBTyxFQUFFLGdCQUFnQjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhDQUFHO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2FuaW1hdGlvbi5qcz8xZjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJhZiB9IGZyb20gJy4vaGVscGVycy5qcyc7XG5cbmxldCBhbmltYXRpb25QcmVmaXg7XG4vKipcbiAqIFdlYiBBbmltYXRpb25zIHJlcXVpcmVzIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnRpZXNcbiAqIHRvIGJlIHdyaXR0ZW4gaW4gY2FtZWxDYXNlIHdoZW4gYW5pbWF0aW5nXG4gKi9cbmNvbnN0IHByb2Nlc3NLZXlmcmFtZXMgPSAoa2V5ZnJhbWVzKSA9PiB7XG4gIGtleWZyYW1lcy5mb3JFYWNoKChrZXlmcmFtZSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGtleWZyYW1lKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICBpZiAoa2V5ZnJhbWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGtleWZyYW1lW2tleV07XG4gICAgICAgIGlmIChrZXkgPT09ICdlYXNpbmcnKSB7XG4gICAgICAgICAgY29uc3QgbmV3S2V5ID0gJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nO1xuICAgICAgICAgIGtleWZyYW1lW25ld0tleV0gPSB2YWx1ZTtcbiAgICAgICAgICBkZWxldGUga2V5ZnJhbWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdLZXkgPSBjb252ZXJ0Q2FtZWxDYXNlVG9IeXBlbihrZXkpO1xuICAgICAgICAgIGlmIChuZXdLZXkgIT09IGtleSkge1xuICAgICAgICAgICAga2V5ZnJhbWVbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIGtleWZyYW1lW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGtleWZyYW1lcztcbn07XG5jb25zdCBjb252ZXJ0Q2FtZWxDYXNlVG9IeXBlbiA9IChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufTtcbmNvbnN0IGdldEFuaW1hdGlvblByZWZpeCA9IChlbCkgPT4ge1xuICBpZiAoYW5pbWF0aW9uUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzdXBwb3J0c1VucHJlZml4ZWQgPSBlbC5zdHlsZS5hbmltYXRpb25OYW1lICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3VwcG9ydHNXZWJraXRQcmVmaXggPSBlbC5zdHlsZS53ZWJraXRBbmltYXRpb25OYW1lICE9PSB1bmRlZmluZWQ7XG4gICAgYW5pbWF0aW9uUHJlZml4ID0gIXN1cHBvcnRzVW5wcmVmaXhlZCAmJiBzdXBwb3J0c1dlYmtpdFByZWZpeCA/ICctd2Via2l0LScgOiAnJztcbiAgfVxuICByZXR1cm4gYW5pbWF0aW9uUHJlZml4O1xufTtcbmNvbnN0IHNldFN0eWxlUHJvcGVydHkgPSAoZWxlbWVudCwgcHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBwcmVmaXggPSBwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aCgnYW5pbWF0aW9uJykgPyBnZXRBbmltYXRpb25QcmVmaXgoZWxlbWVudCkgOiAnJztcbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcmVmaXggKyBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbn07XG5jb25zdCByZW1vdmVTdHlsZVByb3BlcnR5ID0gKGVsZW1lbnQsIHByb3BlcnR5TmFtZSkgPT4ge1xuICBjb25zdCBwcmVmaXggPSBwcm9wZXJ0eU5hbWUuc3RhcnRzV2l0aCgnYW5pbWF0aW9uJykgPyBnZXRBbmltYXRpb25QcmVmaXgoZWxlbWVudCkgOiAnJztcbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcmVmaXggKyBwcm9wZXJ0eU5hbWUpO1xufTtcbmNvbnN0IGFuaW1hdGlvbkVuZCA9IChlbCwgY2FsbGJhY2spID0+IHtcbiAgbGV0IHVuUmVnVHJhbnM7XG4gIGNvbnN0IG9wdHMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgY29uc3QgdW5yZWdpc3RlciA9ICgpID0+IHtcbiAgICBpZiAodW5SZWdUcmFucykge1xuICAgICAgdW5SZWdUcmFucygpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKGV2KSA9PiB7XG4gICAgaWYgKGVsID09PSBldi50YXJnZXQpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICAgIGNhbGxiYWNrKGV2KTtcbiAgICB9XG4gIH07XG4gIGlmIChlbCkge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdEFuaW1hdGlvbkVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICB1blJlZ1RyYW5zID0gKCkgPT4ge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0QW5pbWF0aW9uRW5kJywgb25UcmFuc2l0aW9uRW5kLCBvcHRzKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCwgb3B0cyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5yZWdpc3Rlcjtcbn07XG5jb25zdCBnZW5lcmF0ZUtleWZyYW1lUnVsZXMgPSAoa2V5ZnJhbWVzID0gW10pID0+IHtcbiAgcmV0dXJuIGtleWZyYW1lc1xuICAgIC5tYXAoKGtleWZyYW1lKSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0ID0ga2V5ZnJhbWUub2Zmc2V0O1xuICAgIGNvbnN0IGZyYW1lU3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBrZXlmcmFtZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgaWYgKGtleWZyYW1lLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBwcm9wZXJ0eSAhPT0gJ29mZnNldCcpIHtcbiAgICAgICAgZnJhbWVTdHJpbmcucHVzaChgJHtwcm9wZXJ0eX06ICR7a2V5ZnJhbWVbcHJvcGVydHldfTtgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke29mZnNldCAqIDEwMH0lIHsgJHtmcmFtZVN0cmluZy5qb2luKCcgJyl9IH1gO1xuICB9KVxuICAgIC5qb2luKCcgJyk7XG59O1xuY29uc3Qga2V5ZnJhbWVJZHMgPSBbXTtcbmNvbnN0IGdlbmVyYXRlS2V5ZnJhbWVOYW1lID0gKGtleWZyYW1lUnVsZXMpID0+IHtcbiAgbGV0IGluZGV4ID0ga2V5ZnJhbWVJZHMuaW5kZXhPZihrZXlmcmFtZVJ1bGVzKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0ga2V5ZnJhbWVJZHMucHVzaChrZXlmcmFtZVJ1bGVzKSAtIDE7XG4gIH1cbiAgcmV0dXJuIGBpb24tYW5pbWF0aW9uLSR7aW5kZXh9YDtcbn07XG5jb25zdCBnZXRTdHlsZUNvbnRhaW5lciA9IChlbGVtZW50KSA9PiB7XG4gIGNvbnN0IHJvb3ROb2RlID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICByZXR1cm4gcm9vdE5vZGUuaGVhZCB8fCByb290Tm9kZTtcbn07XG5jb25zdCBjcmVhdGVLZXlmcmFtZVN0eWxlc2hlZXQgPSAoa2V5ZnJhbWVOYW1lLCBrZXlmcmFtZVJ1bGVzLCBlbGVtZW50KSA9PiB7XG4gIGNvbnN0IHN0eWxlQ29udGFpbmVyID0gZ2V0U3R5bGVDb250YWluZXIoZWxlbWVudCk7XG4gIGNvbnN0IGtleWZyYW1lUHJlZml4ID0gZ2V0QW5pbWF0aW9uUHJlZml4KGVsZW1lbnQpO1xuICBjb25zdCBleGlzdGluZ1N0eWxlc2hlZXQgPSBzdHlsZUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjJyArIGtleWZyYW1lTmFtZSk7XG4gIGlmIChleGlzdGluZ1N0eWxlc2hlZXQpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdTdHlsZXNoZWV0O1xuICB9XG4gIGNvbnN0IHN0eWxlc2hlZXQgPSAoZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZXNoZWV0LmlkID0ga2V5ZnJhbWVOYW1lO1xuICBzdHlsZXNoZWV0LnRleHRDb250ZW50ID0gYEAke2tleWZyYW1lUHJlZml4fWtleWZyYW1lcyAke2tleWZyYW1lTmFtZX0geyAke2tleWZyYW1lUnVsZXN9IH0gQCR7a2V5ZnJhbWVQcmVmaXh9a2V5ZnJhbWVzICR7a2V5ZnJhbWVOYW1lfS1hbHQgeyAke2tleWZyYW1lUnVsZXN9IH1gO1xuICBzdHlsZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHlsZXNoZWV0KTtcbiAgcmV0dXJuIHN0eWxlc2hlZXQ7XG59O1xuY29uc3QgYWRkQ2xhc3NUb0FycmF5ID0gKGNsYXNzZXMgPSBbXSwgY2xhc3NOYW1lKSA9PiB7XG4gIGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZVRvQXBwZW5kID0gQXJyYXkuaXNBcnJheShjbGFzc05hbWUpID8gY2xhc3NOYW1lIDogW2NsYXNzTmFtZV07XG4gICAgcmV0dXJuIFsuLi5jbGFzc2VzLCAuLi5jbGFzc05hbWVUb0FwcGVuZF07XG4gIH1cbiAgcmV0dXJuIGNsYXNzZXM7XG59O1xuXG5jb25zdCBjcmVhdGVBbmltYXRpb24gPSAoYW5pbWF0aW9uSWQpID0+IHtcbiAgbGV0IF9kZWxheTtcbiAgbGV0IF9kdXJhdGlvbjtcbiAgbGV0IF9lYXNpbmc7XG4gIGxldCBfaXRlcmF0aW9ucztcbiAgbGV0IF9maWxsO1xuICBsZXQgX2RpcmVjdGlvbjtcbiAgbGV0IF9rZXlmcmFtZXMgPSBbXTtcbiAgbGV0IGJlZm9yZUFkZENsYXNzZXMgPSBbXTtcbiAgbGV0IGJlZm9yZVJlbW92ZUNsYXNzZXMgPSBbXTtcbiAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG4gIGxldCBwYXJlbnRBbmltYXRpb247XG4gIGxldCBiZWZvcmVTdHlsZXNWYWx1ZSA9IHt9O1xuICBsZXQgYWZ0ZXJBZGRDbGFzc2VzID0gW107XG4gIGxldCBhZnRlclJlbW92ZUNsYXNzZXMgPSBbXTtcbiAgbGV0IGFmdGVyU3R5bGVzVmFsdWUgPSB7fTtcbiAgbGV0IG51bUFuaW1hdGlvbnNSdW5uaW5nID0gMDtcbiAgbGV0IHNob3VsZEZvcmNlTGluZWFyRWFzaW5nID0gZmFsc2U7XG4gIGxldCBzaG91bGRGb3JjZVN5bmNQbGF5YmFjayA9IGZhbHNlO1xuICBsZXQgY3NzQW5pbWF0aW9uc1RpbWVyRmFsbGJhY2s7XG4gIGxldCBmb3JjZURpcmVjdGlvblZhbHVlO1xuICBsZXQgZm9yY2VEdXJhdGlvblZhbHVlO1xuICBsZXQgZm9yY2VEZWxheVZhbHVlO1xuICBsZXQgd2lsbENvbXBsZXRlID0gdHJ1ZTtcbiAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG4gIGxldCBzaG91bGRDYWxjdWxhdGVOdW1BbmltYXRpb25zID0gdHJ1ZTtcbiAgbGV0IGtleWZyYW1lTmFtZTtcbiAgbGV0IGFuaTtcbiAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICBjb25zdCBpZCA9IGFuaW1hdGlvbklkO1xuICBjb25zdCBvbkZpbmlzaENhbGxiYWNrcyA9IFtdO1xuICBjb25zdCBvbkZpbmlzaE9uZVRpbWVDYWxsYmFja3MgPSBbXTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgY29uc3QgY2hpbGRBbmltYXRpb25zID0gW107XG4gIGNvbnN0IHN0eWxlc2hlZXRzID0gW107XG4gIGNvbnN0IF9iZWZvcmVBZGRSZWFkRnVuY3Rpb25zID0gW107XG4gIGNvbnN0IF9iZWZvcmVBZGRXcml0ZUZ1bmN0aW9ucyA9IFtdO1xuICBjb25zdCBfYWZ0ZXJBZGRSZWFkRnVuY3Rpb25zID0gW107XG4gIGNvbnN0IF9hZnRlckFkZFdyaXRlRnVuY3Rpb25zID0gW107XG4gIGNvbnN0IHdlYkFuaW1hdGlvbnMgPSBbXTtcbiAgY29uc3Qgc3VwcG9ydHNBbmltYXRpb25FZmZlY3QgPSB0eXBlb2YgQW5pbWF0aW9uRWZmZWN0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB3aW5kb3cuQW5pbWF0aW9uRWZmZWN0ID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBzdXBwb3J0c1dlYkFuaW1hdGlvbnMgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5hbmltYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgc3VwcG9ydHNBbmltYXRpb25FZmZlY3Q7XG4gIGNvbnN0IEFOSU1BVElPTl9FTkRfRkFMTEJBQ0tfUEFERElOR19NUyA9IDEwMDtcbiAgY29uc3QgZ2V0V2ViQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgICByZXR1cm4gd2ViQW5pbWF0aW9ucztcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9IChjbGVhclN0eWxlU2hlZXRzKSA9PiB7XG4gICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goKGNoaWxkQW5pbWF0aW9uKSA9PiB7XG4gICAgICBjaGlsZEFuaW1hdGlvbi5kZXN0cm95KGNsZWFyU3R5bGVTaGVldHMpO1xuICAgIH0pO1xuICAgIGNsZWFuVXAoY2xlYXJTdHlsZVNoZWV0cyk7XG4gICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICBjaGlsZEFuaW1hdGlvbnMubGVuZ3RoID0gMDtcbiAgICBfa2V5ZnJhbWVzLmxlbmd0aCA9IDA7XG4gICAgY2xlYXJPbkZpbmlzaCgpO1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IFdlYiBBbmltYXRpb25zLCByZW1vdmVzXG4gICAqIGFueSBhbmltYXRpb24gcHJvcGVydGllcyBmcm9tIHRoZVxuICAgKiBhbmltYXRpb24ncyBlbGVtZW50cywgYW5kIHJlbW92ZXMgdGhlXG4gICAqIGFuaW1hdGlvbidzIHN0eWxlc2hlZXRzIGZyb20gdGhlIERPTS5cbiAgICovXG4gIGNvbnN0IGNsZWFuVXAgPSAoY2xlYXJTdHlsZVNoZWV0cykgPT4ge1xuICAgIGNsZWFuVXBFbGVtZW50cygpO1xuICAgIGlmIChjbGVhclN0eWxlU2hlZXRzKSB7XG4gICAgICBjbGVhblVwU3R5bGVTaGVldHMoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlc2V0RmxhZ3MgPSAoKSA9PiB7XG4gICAgc2hvdWxkRm9yY2VMaW5lYXJFYXNpbmcgPSBmYWxzZTtcbiAgICBzaG91bGRGb3JjZVN5bmNQbGF5YmFjayA9IGZhbHNlO1xuICAgIHNob3VsZENhbGN1bGF0ZU51bUFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIGZvcmNlRGlyZWN0aW9uVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2VEdXJhdGlvblZhbHVlID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlRGVsYXlWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBudW1BbmltYXRpb25zUnVubmluZyA9IDA7XG4gICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICB3aWxsQ29tcGxldGUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICB9O1xuICBjb25zdCBpc1J1bm5pbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG51bUFuaW1hdGlvbnNSdW5uaW5nICE9PSAwICYmICFwYXVzZWQ7XG4gIH07XG4gIGNvbnN0IG9uRmluaXNoID0gKGNhbGxiYWNrLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5vbmVUaW1lQ2FsbGJhY2spID8gb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzIDogb25GaW5pc2hDYWxsYmFja3M7XG4gICAgY2FsbGJhY2tzLnB1c2goeyBjOiBjYWxsYmFjaywgbzogb3B0cyB9KTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBjbGVhck9uRmluaXNoID0gKCkgPT4ge1xuICAgIG9uRmluaXNoQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IFdlYiBBbmltYXRpb25zIGFuZCByZW1vdmVzXG4gICAqIGFueSBhbmltYXRpb24gcHJvcGVydGllcyBmcm9tIHRoZVxuICAgKiB0aGUgYW5pbWF0aW9uJ3MgZWxlbWVudHMuXG4gICAqL1xuICBjb25zdCBjbGVhblVwRWxlbWVudHMgPSAoKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICB3ZWJBbmltYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZWxlbWVudHNBcnJheSA9IGVsZW1lbnRzLnNsaWNlKCk7XG4gICAgICByYWYoKCkgPT4ge1xuICAgICAgICBlbGVtZW50c0FycmF5LmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScpO1xuICAgICAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kdXJhdGlvbicpO1xuICAgICAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nKTtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24taXRlcmF0aW9uLWNvdW50Jyk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWRlbGF5Jyk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLXBsYXktc3RhdGUnKTtcbiAgICAgICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZmlsbC1tb2RlJyk7XG4gICAgICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWRpcmVjdGlvbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGFuaW1hdGlvbidzIHN0eWxlc2hlZXRzXG4gICAqIGZyb20gdGhlIERPTS5cbiAgICovXG4gIGNvbnN0IGNsZWFuVXBTdHlsZVNoZWV0cyA9ICgpID0+IHtcbiAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0KSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gc2hhcmluZyBzdHlsZXNoZWV0cywgaXQncyBwb3NzaWJsZVxuICAgICAgICogZm9yIGFub3RoZXIgYW5pbWF0aW9uIHRvIGhhdmUgYWxyZWFkeVxuICAgICAgICogY2xlYW5lZCB1cCBhIHBhcnRpY3VsYXIgc3R5bGVzaGVldFxuICAgICAgICovXG4gICAgICBpZiAoc3R5bGVzaGVldCA9PT0gbnVsbCB8fCBzdHlsZXNoZWV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZXNoZWV0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3R5bGVzaGVldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlc2hlZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN0eWxlc2hlZXRzLmxlbmd0aCA9IDA7XG4gIH07XG4gIGNvbnN0IGJlZm9yZUFkZFJlYWQgPSAocmVhZEZuKSA9PiB7XG4gICAgX2JlZm9yZUFkZFJlYWRGdW5jdGlvbnMucHVzaChyZWFkRm4pO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGJlZm9yZUFkZFdyaXRlID0gKHdyaXRlRm4pID0+IHtcbiAgICBfYmVmb3JlQWRkV3JpdGVGdW5jdGlvbnMucHVzaCh3cml0ZUZuKTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckFkZFJlYWQgPSAocmVhZEZuKSA9PiB7XG4gICAgX2FmdGVyQWRkUmVhZEZ1bmN0aW9ucy5wdXNoKHJlYWRGbik7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYWZ0ZXJBZGRXcml0ZSA9ICh3cml0ZUZuKSA9PiB7XG4gICAgX2FmdGVyQWRkV3JpdGVGdW5jdGlvbnMucHVzaCh3cml0ZUZuKTtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBiZWZvcmVBZGRDbGFzcyA9IChjbGFzc05hbWUpID0+IHtcbiAgICBiZWZvcmVBZGRDbGFzc2VzID0gYWRkQ2xhc3NUb0FycmF5KGJlZm9yZUFkZENsYXNzZXMsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlUmVtb3ZlQ2xhc3MgPSAoY2xhc3NOYW1lKSA9PiB7XG4gICAgYmVmb3JlUmVtb3ZlQ2xhc3NlcyA9IGFkZENsYXNzVG9BcnJheShiZWZvcmVSZW1vdmVDbGFzc2VzLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgQ1NTIGlubGluZSBzdHlsZXMgdG8gdGhlIGFuaW1hdGlvbidzXG4gICAqIGVsZW1lbnRzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGJlZ2lucy5cbiAgICovXG4gIGNvbnN0IGJlZm9yZVN0eWxlcyA9IChzdHlsZXMgPSB7fSkgPT4ge1xuICAgIGJlZm9yZVN0eWxlc1ZhbHVlID0gc3R5bGVzO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhciBDU1MgaW5saW5lIHN0eWxlcyBmcm9tIHRoZSBhbmltYXRpb24nc1xuICAgKiBlbGVtZW50cyBiZWZvcmUgdGhlIGFuaW1hdGlvbiBiZWdpbnMuXG4gICAqL1xuICBjb25zdCBiZWZvcmVDbGVhclN0eWxlcyA9IChwcm9wZXJ0eU5hbWVzID0gW10pID0+IHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgIGJlZm9yZVN0eWxlc1ZhbHVlW3Byb3BlcnR5XSA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckFkZENsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgIGFmdGVyQWRkQ2xhc3NlcyA9IGFkZENsYXNzVG9BcnJheShhZnRlckFkZENsYXNzZXMsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgYWZ0ZXJSZW1vdmVDbGFzcyA9IChjbGFzc05hbWUpID0+IHtcbiAgICBhZnRlclJlbW92ZUNsYXNzZXMgPSBhZGRDbGFzc1RvQXJyYXkoYWZ0ZXJSZW1vdmVDbGFzc2VzLCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGFmdGVyU3R5bGVzID0gKHN0eWxlcyA9IHt9KSA9PiB7XG4gICAgYWZ0ZXJTdHlsZXNWYWx1ZSA9IHN0eWxlcztcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZnRlckNsZWFyU3R5bGVzID0gKHByb3BlcnR5TmFtZXMgPSBbXSkgPT4ge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydHlOYW1lcykge1xuICAgICAgYWZ0ZXJTdHlsZXNWYWx1ZVtwcm9wZXJ0eV0gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZ2V0RmlsbCA9ICgpID0+IHtcbiAgICBpZiAoX2ZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9maWxsO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldEZpbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuICdib3RoJztcbiAgfTtcbiAgY29uc3QgZ2V0RGlyZWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChmb3JjZURpcmVjdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmb3JjZURpcmVjdGlvblZhbHVlO1xuICAgIH1cbiAgICBpZiAoX2RpcmVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2RpcmVjdGlvbjtcbiAgICB9XG4gICAgaWYgKHBhcmVudEFuaW1hdGlvbikge1xuICAgICAgcmV0dXJuIHBhcmVudEFuaW1hdGlvbi5nZXREaXJlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuICdub3JtYWwnO1xuICB9O1xuICBjb25zdCBnZXRFYXNpbmcgPSAoKSA9PiB7XG4gICAgaWYgKHNob3VsZEZvcmNlTGluZWFyRWFzaW5nKSB7XG4gICAgICByZXR1cm4gJ2xpbmVhcic7XG4gICAgfVxuICAgIGlmIChfZWFzaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfZWFzaW5nO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldEVhc2luZygpO1xuICAgIH1cbiAgICByZXR1cm4gJ2xpbmVhcic7XG4gIH07XG4gIGNvbnN0IGdldER1cmF0aW9uID0gKCkgPT4ge1xuICAgIGlmIChzaG91bGRGb3JjZVN5bmNQbGF5YmFjaykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChmb3JjZUR1cmF0aW9uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZvcmNlRHVyYXRpb25WYWx1ZTtcbiAgICB9XG4gICAgaWYgKF9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2R1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAocGFyZW50QW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gcGFyZW50QW5pbWF0aW9uLmdldER1cmF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICBjb25zdCBnZXRJdGVyYXRpb25zID0gKCkgPT4ge1xuICAgIGlmIChfaXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX2l0ZXJhdGlvbnM7XG4gICAgfVxuICAgIGlmIChwYXJlbnRBbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBwYXJlbnRBbmltYXRpb24uZ2V0SXRlcmF0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfTtcbiAgY29uc3QgZ2V0RGVsYXkgPSAoKSA9PiB7XG4gICAgaWYgKGZvcmNlRGVsYXlWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZm9yY2VEZWxheVZhbHVlO1xuICAgIH1cbiAgICBpZiAoX2RlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfZGVsYXk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRBbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBwYXJlbnRBbmltYXRpb24uZ2V0RGVsYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGNvbnN0IGdldEtleWZyYW1lcyA9ICgpID0+IHtcbiAgICByZXR1cm4gX2tleWZyYW1lcztcbiAgfTtcbiAgY29uc3QgZGlyZWN0aW9uID0gKGFuaW1hdGlvbkRpcmVjdGlvbikgPT4ge1xuICAgIF9kaXJlY3Rpb24gPSBhbmltYXRpb25EaXJlY3Rpb247XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGZpbGwgPSAoYW5pbWF0aW9uRmlsbCkgPT4ge1xuICAgIF9maWxsID0gYW5pbWF0aW9uRmlsbDtcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZGVsYXkgPSAoYW5pbWF0aW9uRGVsYXkpID0+IHtcbiAgICBfZGVsYXkgPSBhbmltYXRpb25EZWxheTtcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZWFzaW5nID0gKGFuaW1hdGlvbkVhc2luZykgPT4ge1xuICAgIF9lYXNpbmcgPSBhbmltYXRpb25FYXNpbmc7XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGR1cmF0aW9uID0gKGFuaW1hdGlvbkR1cmF0aW9uKSA9PiB7XG4gICAgLyoqXG4gICAgICogQ1NTIEFuaW1hdGlvbiBEdXJhdGlvbnMgb2YgMG1zIHdvcmsgZmluZSBvbiBDaHJvbWVcbiAgICAgKiBidXQgZG8gbm90IHJ1biBvbiBTYWZhcmksIHNvIGZvcmNlIGl0IHRvIDFtcyB0b1xuICAgICAqIGdldCBpdCB0byBydW4gb24gYm90aCBwbGF0Zm9ybXMuXG4gICAgICovXG4gICAgaWYgKCFzdXBwb3J0c1dlYkFuaW1hdGlvbnMgJiYgYW5pbWF0aW9uRHVyYXRpb24gPT09IDApIHtcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gMTtcbiAgICB9XG4gICAgX2R1cmF0aW9uID0gYW5pbWF0aW9uRHVyYXRpb247XG4gICAgdXBkYXRlKHRydWUpO1xuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IGl0ZXJhdGlvbnMgPSAoYW5pbWF0aW9uSXRlcmF0aW9ucykgPT4ge1xuICAgIF9pdGVyYXRpb25zID0gYW5pbWF0aW9uSXRlcmF0aW9ucztcbiAgICB1cGRhdGUodHJ1ZSk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcGFyZW50ID0gKGFuaW1hdGlvbikgPT4ge1xuICAgIHBhcmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZGRFbGVtZW50ID0gKGVsKSA9PiB7XG4gICAgaWYgKGVsICE9IG51bGwpIHtcbiAgICAgIGlmIChlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgYWRkRWxlbWVudCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBhZGRBbmltYXRpb24gPSAoYW5pbWF0aW9uVG9BZGQpID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uVG9BZGQgIT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5pbWF0aW9uVG9BZGQpKSB7XG4gICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGFuaW1hdGlvblRvQWRkKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnBhcmVudChhbmkpO1xuICAgICAgICAgIGNoaWxkQW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhbmltYXRpb25Ub0FkZC5wYXJlbnQoYW5pKTtcbiAgICAgICAgY2hpbGRBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uVG9BZGQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCBrZXlmcmFtZXMgPSAoa2V5ZnJhbWVWYWx1ZXMpID0+IHtcbiAgICBjb25zdCBkaWZmZXJlbnQgPSBfa2V5ZnJhbWVzICE9PSBrZXlmcmFtZVZhbHVlcztcbiAgICBfa2V5ZnJhbWVzID0ga2V5ZnJhbWVWYWx1ZXM7XG4gICAgaWYgKGRpZmZlcmVudCkge1xuICAgICAgdXBkYXRlS2V5ZnJhbWVzKF9rZXlmcmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCB1cGRhdGVLZXlmcmFtZXMgPSAoa2V5ZnJhbWVWYWx1ZXMpID0+IHtcbiAgICBpZiAoc3VwcG9ydHNXZWJBbmltYXRpb25zKSB7XG4gICAgICBnZXRXZWJBbmltYXRpb25zKCkuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChhbmltYXRpb24uZWZmZWN0LnNldEtleWZyYW1lcykge1xuICAgICAgICAgIGFuaW1hdGlvbi5lZmZlY3Quc2V0S2V5ZnJhbWVzKGtleWZyYW1lVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdFZmZlY3QgPSBuZXcgS2V5ZnJhbWVFZmZlY3QoYW5pbWF0aW9uLmVmZmVjdC50YXJnZXQsIGtleWZyYW1lVmFsdWVzLCBhbmltYXRpb24uZWZmZWN0LmdldFRpbWluZygpKTtcbiAgICAgICAgICBhbmltYXRpb24uZWZmZWN0ID0gbmV3RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbml0aWFsaXplQ1NTQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUnVuIGFsbCBcImJlZm9yZVwiIGFuaW1hdGlvbiBob29rcy5cbiAgICovXG4gIGNvbnN0IGJlZm9yZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAvLyBSdW5zIGFsbCBiZWZvcmUgcmVhZCBjYWxsYmFja3NcbiAgICBfYmVmb3JlQWRkUmVhZEZ1bmN0aW9ucy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgLy8gUnVucyBhbGwgYmVmb3JlIHdyaXRlIGNhbGxiYWNrc1xuICAgIF9iZWZvcmVBZGRXcml0ZUZ1bmN0aW9ucy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgLy8gVXBkYXRlcyBzdHlsZXMgYW5kIGNsYXNzZXMgYmVmb3JlIGFuaW1hdGlvbiBydW5zXG4gICAgY29uc3QgYWRkQ2xhc3NlcyA9IGJlZm9yZUFkZENsYXNzZXM7XG4gICAgY29uc3QgcmVtb3ZlQ2xhc3NlcyA9IGJlZm9yZVJlbW92ZUNsYXNzZXM7XG4gICAgY29uc3Qgc3R5bGVzID0gYmVmb3JlU3R5bGVzVmFsdWU7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBhZGRDbGFzc2VzLmZvckVhY2goKGMpID0+IGVsZW1lbnRDbGFzc0xpc3QuYWRkKGMpKTtcbiAgICAgIHJlbW92ZUNsYXNzZXMuZm9yRWFjaCgoYykgPT4gZWxlbWVudENsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWwsIHByb3BlcnR5LCBzdHlsZXNbcHJvcGVydHldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUnVuIGFsbCBcImFmdGVyXCIgYW5pbWF0aW9uIGhvb2tzLlxuICAgKi9cbiAgY29uc3QgYWZ0ZXJBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgY2xlYXJDU1NBbmltYXRpb25zVGltZW91dCgpO1xuICAgIC8vIFJ1bnMgYWxsIGFmdGVyIHJlYWQgY2FsbGJhY2tzXG4gICAgX2FmdGVyQWRkUmVhZEZ1bmN0aW9ucy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSk7XG4gICAgLy8gUnVucyBhbGwgYWZ0ZXIgd3JpdGUgY2FsbGJhY2tzXG4gICAgX2FmdGVyQWRkV3JpdGVGdW5jdGlvbnMuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgIC8vIFVwZGF0ZXMgc3R5bGVzIGFuZCBjbGFzc2VzIGJlZm9yZSBhbmltYXRpb24gZW5kc1xuICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gd2lsbENvbXBsZXRlID8gMSA6IDA7XG4gICAgY29uc3QgYWRkQ2xhc3NlcyA9IGFmdGVyQWRkQ2xhc3NlcztcbiAgICBjb25zdCByZW1vdmVDbGFzc2VzID0gYWZ0ZXJSZW1vdmVDbGFzc2VzO1xuICAgIGNvbnN0IHN0eWxlcyA9IGFmdGVyU3R5bGVzVmFsdWU7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBhZGRDbGFzc2VzLmZvckVhY2goKGMpID0+IGVsZW1lbnRDbGFzc0xpc3QuYWRkKGMpKTtcbiAgICAgIHJlbW92ZUNsYXNzZXMuZm9yRWFjaCgoYykgPT4gZWxlbWVudENsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWwsIHByb3BlcnR5LCBzdHlsZXNbcHJvcGVydHldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9uRmluaXNoQ2FsbGJhY2tzLmZvckVhY2goKG9uRmluaXNoQ2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiBvbkZpbmlzaENhbGxiYWNrLmMoY3VycmVudFN0ZXAsIGFuaSk7XG4gICAgfSk7XG4gICAgb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzLmZvckVhY2goKG9uRmluaXNoQ2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiBvbkZpbmlzaENhbGxiYWNrLmMoY3VycmVudFN0ZXAsIGFuaSk7XG4gICAgfSk7XG4gICAgb25GaW5pc2hPbmVUaW1lQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgc2hvdWxkQ2FsY3VsYXRlTnVtQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgaWYgKHdpbGxDb21wbGV0ZSkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB3aWxsQ29tcGxldGUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBhbmltYXRpb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgaWYgKG51bUFuaW1hdGlvbnNSdW5uaW5nID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG51bUFuaW1hdGlvbnNSdW5uaW5nLS07XG4gICAgaWYgKG51bUFuaW1hdGlvbnNSdW5uaW5nID09PSAwKSB7XG4gICAgICBhZnRlckFuaW1hdGlvbigpO1xuICAgICAgaWYgKHBhcmVudEFuaW1hdGlvbikge1xuICAgICAgICBwYXJlbnRBbmltYXRpb24uYW5pbWF0aW9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBpbml0aWFsaXplQ1NTQW5pbWF0aW9uID0gKHRvZ2dsZUFuaW1hdGlvbk5hbWUgPSB0cnVlKSA9PiB7XG4gICAgY2xlYW5VcFN0eWxlU2hlZXRzKCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkS2V5ZnJhbWVzID0gcHJvY2Vzc0tleWZyYW1lcyhfa2V5ZnJhbWVzKTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAocHJvY2Vzc2VkS2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWVSdWxlcyA9IGdlbmVyYXRlS2V5ZnJhbWVSdWxlcyhwcm9jZXNzZWRLZXlmcmFtZXMpO1xuICAgICAgICBrZXlmcmFtZU5hbWUgPSBhbmltYXRpb25JZCAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uSWQgOiBnZW5lcmF0ZUtleWZyYW1lTmFtZShrZXlmcmFtZVJ1bGVzKTtcbiAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IGNyZWF0ZUtleWZyYW1lU3R5bGVzaGVldChrZXlmcmFtZU5hbWUsIGtleWZyYW1lUnVsZXMsIGVsZW1lbnQpO1xuICAgICAgICBzdHlsZXNoZWV0cy5wdXNoKHN0eWxlc2hlZXQpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZHVyYXRpb24nLCBgJHtnZXREdXJhdGlvbigpfW1zYCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nLCBnZXRFYXNpbmcoKSk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kZWxheScsIGAke2dldERlbGF5KCl9bXNgKTtcbiAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWZpbGwtbW9kZScsIGdldEZpbGwoKSk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1kaXJlY3Rpb24nLCBnZXREaXJlY3Rpb24oKSk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbnNDb3VudCA9IGdldEl0ZXJhdGlvbnMoKSA9PT0gSW5maW5pdHkgPyAnaW5maW5pdGUnIDogZ2V0SXRlcmF0aW9ucygpLnRvU3RyaW5nKCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnLCBpdGVyYXRpb25zQ291bnQpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tcGxheS1zdGF0ZScsICdwYXVzZWQnKTtcbiAgICAgICAgaWYgKHRvZ2dsZUFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScsIGAke3N0eWxlc2hlZXQuaWR9LWFsdGApO1xuICAgICAgICB9XG4gICAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLW5hbWUnLCBzdHlsZXNoZWV0LmlkIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgaW5pdGlhbGl6ZVdlYkFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBlbGVtZW50LmFuaW1hdGUoX2tleWZyYW1lcywge1xuICAgICAgICBpZCxcbiAgICAgICAgZGVsYXk6IGdldERlbGF5KCksXG4gICAgICAgIGR1cmF0aW9uOiBnZXREdXJhdGlvbigpLFxuICAgICAgICBlYXNpbmc6IGdldEVhc2luZygpLFxuICAgICAgICBpdGVyYXRpb25zOiBnZXRJdGVyYXRpb25zKCksXG4gICAgICAgIGZpbGw6IGdldEZpbGwoKSxcbiAgICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24oKSxcbiAgICAgIH0pO1xuICAgICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgICB3ZWJBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9KTtcbiAgICBpZiAod2ViQW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB3ZWJBbmltYXRpb25zWzBdLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICBhbmltYXRpb25GaW5pc2goKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBjb25zdCBpbml0aWFsaXplQW5pbWF0aW9uID0gKHRvZ2dsZUFuaW1hdGlvbk5hbWUgPSB0cnVlKSA9PiB7XG4gICAgYmVmb3JlQW5pbWF0aW9uKCk7XG4gICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgICBpbml0aWFsaXplV2ViQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZUNTU0FuaW1hdGlvbih0b2dnbGVBbmltYXRpb25OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzZXRBbmltYXRpb25TdGVwID0gKHN0ZXApID0+IHtcbiAgICBzdGVwID0gTWF0aC5taW4oTWF0aC5tYXgoc3RlcCwgMCksIDAuOTk5OSk7XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcbiAgICAgICAgYW5pbWF0aW9uLmN1cnJlbnRUaW1lID0gYW5pbWF0aW9uLmVmZmVjdC5nZXRDb21wdXRlZFRpbWluZygpLmRlbGF5ICsgZ2V0RHVyYXRpb24oKSAqIHN0ZXA7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb24gPSBgLSR7Z2V0RHVyYXRpb24oKSAqIHN0ZXB9bXNgO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoX2tleWZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWRlbGF5JywgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1wbGF5LXN0YXRlJywgJ3BhdXNlZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZVdlYkFuaW1hdGlvbiA9IChzdGVwKSA9PiB7XG4gICAgd2ViQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcbiAgICAgIGFuaW1hdGlvbi5lZmZlY3QudXBkYXRlVGltaW5nKHtcbiAgICAgICAgZGVsYXk6IGdldERlbGF5KCksXG4gICAgICAgIGR1cmF0aW9uOiBnZXREdXJhdGlvbigpLFxuICAgICAgICBlYXNpbmc6IGdldEVhc2luZygpLFxuICAgICAgICBpdGVyYXRpb25zOiBnZXRJdGVyYXRpb25zKCksXG4gICAgICAgIGZpbGw6IGdldEZpbGwoKSxcbiAgICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24oKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldEFuaW1hdGlvblN0ZXAoc3RlcCk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVDU1NBbmltYXRpb24gPSAodG9nZ2xlQW5pbWF0aW9uTmFtZSA9IHRydWUsIHN0ZXApID0+IHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tbmFtZScsIGtleWZyYW1lTmFtZSB8fCBudWxsKTtcbiAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWR1cmF0aW9uJywgYCR7Z2V0RHVyYXRpb24oKX1tc2ApO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJywgZ2V0RWFzaW5nKCkpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZGVsYXknLCBzdGVwICE9PSB1bmRlZmluZWQgPyBgLSR7c3RlcCAqIGdldER1cmF0aW9uKCl9bXNgIDogYCR7Z2V0RGVsYXkoKX1tc2ApO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZmlsbC1tb2RlJywgZ2V0RmlsbCgpIHx8IG51bGwpO1xuICAgICAgICBzZXRTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZGlyZWN0aW9uJywgZ2V0RGlyZWN0aW9uKCkgfHwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbnNDb3VudCA9IGdldEl0ZXJhdGlvbnMoKSA9PT0gSW5maW5pdHkgPyAnaW5maW5pdGUnIDogZ2V0SXRlcmF0aW9ucygpLnRvU3RyaW5nKCk7XG4gICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQnLCBpdGVyYXRpb25zQ291bnQpO1xuICAgICAgICBpZiAodG9nZ2xlQW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1uYW1lJywgYCR7a2V5ZnJhbWVOYW1lfS1hbHRgKTtcbiAgICAgICAgfVxuICAgICAgICByYWYoKCkgPT4ge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1uYW1lJywga2V5ZnJhbWVOYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGUgPSAoZGVlcCA9IGZhbHNlLCB0b2dnbGVBbmltYXRpb25OYW1lID0gdHJ1ZSwgc3RlcCkgPT4ge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICAgIGFuaW1hdGlvbi51cGRhdGUoZGVlcCwgdG9nZ2xlQW5pbWF0aW9uTmFtZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgdXBkYXRlV2ViQW5pbWF0aW9uKHN0ZXApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHVwZGF0ZUNTU0FuaW1hdGlvbih0b2dnbGVBbmltYXRpb25OYW1lLCBzdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcHJvZ3Jlc3NTdGFydCA9IChmb3JjZUxpbmVhckVhc2luZyA9IGZhbHNlLCBzdGVwKSA9PiB7XG4gICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4ge1xuICAgICAgYW5pbWF0aW9uLnByb2dyZXNzU3RhcnQoZm9yY2VMaW5lYXJFYXNpbmcsIHN0ZXApO1xuICAgIH0pO1xuICAgIHBhdXNlQW5pbWF0aW9uKCk7XG4gICAgc2hvdWxkRm9yY2VMaW5lYXJFYXNpbmcgPSBmb3JjZUxpbmVhckVhc2luZztcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBpbml0aWFsaXplQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZShmYWxzZSwgdHJ1ZSwgc3RlcCk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcHJvZ3Jlc3NTdGVwID0gKHN0ZXApID0+IHtcbiAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICBhbmltYXRpb24ucHJvZ3Jlc3NTdGVwKHN0ZXApO1xuICAgIH0pO1xuICAgIHNldEFuaW1hdGlvblN0ZXAoc3RlcCk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgcHJvZ3Jlc3NFbmQgPSAocGxheVRvLCBzdGVwLCBkdXIpID0+IHtcbiAgICBzaG91bGRGb3JjZUxpbmVhckVhc2luZyA9IGZhbHNlO1xuICAgIGNoaWxkQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcbiAgICAgIGFuaW1hdGlvbi5wcm9ncmVzc0VuZChwbGF5VG8sIHN0ZXAsIGR1cik7XG4gICAgfSk7XG4gICAgaWYgKGR1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3JjZUR1cmF0aW9uVmFsdWUgPSBkdXI7XG4gICAgfVxuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgd2lsbENvbXBsZXRlID0gdHJ1ZTtcbiAgICBpZiAocGxheVRvID09PSAwKSB7XG4gICAgICBmb3JjZURpcmVjdGlvblZhbHVlID0gZ2V0RGlyZWN0aW9uKCkgPT09ICdyZXZlcnNlJyA/ICdub3JtYWwnIDogJ3JldmVyc2UnO1xuICAgICAgaWYgKGZvcmNlRGlyZWN0aW9uVmFsdWUgPT09ICdyZXZlcnNlJykge1xuICAgICAgICB3aWxsQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c1dlYkFuaW1hdGlvbnMpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIHNldEFuaW1hdGlvblN0ZXAoMSAtIHN0ZXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvcmNlRGVsYXlWYWx1ZSA9ICgxIC0gc3RlcCkgKiBnZXREdXJhdGlvbigpICogLTE7XG4gICAgICAgIHVwZGF0ZShmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwbGF5VG8gPT09IDEpIHtcbiAgICAgIGlmIChzdXBwb3J0c1dlYkFuaW1hdGlvbnMpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIHNldEFuaW1hdGlvblN0ZXAoc3RlcCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yY2VEZWxheVZhbHVlID0gc3RlcCAqIGdldER1cmF0aW9uKCkgKiAtMTtcbiAgICAgICAgdXBkYXRlKGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwbGF5VG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb25GaW5pc2goKCkgPT4ge1xuICAgICAgICBmb3JjZUR1cmF0aW9uVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvcmNlRGlyZWN0aW9uVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvcmNlRGVsYXlWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0sIHtcbiAgICAgICAgb25lVGltZUNhbGxiYWNrOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXBhcmVudEFuaW1hdGlvbikge1xuICAgICAgICBwbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmk7XG4gIH07XG4gIGNvbnN0IHBhdXNlQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgICB3ZWJBbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4ge1xuICAgICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLXBsYXktc3RhdGUnLCAncGF1c2VkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgIGNoaWxkQW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24pID0+IHtcbiAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH0pO1xuICAgIHBhdXNlQW5pbWF0aW9uKCk7XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3Qgb25BbmltYXRpb25FbmRGYWxsYmFjayA9ICgpID0+IHtcbiAgICBjc3NBbmltYXRpb25zVGltZXJGYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBhbmltYXRpb25GaW5pc2goKTtcbiAgfTtcbiAgY29uc3QgY2xlYXJDU1NBbmltYXRpb25zVGltZW91dCA9ICgpID0+IHtcbiAgICBpZiAoY3NzQW5pbWF0aW9uc1RpbWVyRmFsbGJhY2spIHtcbiAgICAgIGNsZWFyVGltZW91dChjc3NBbmltYXRpb25zVGltZXJGYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwbGF5Q1NTQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgICBjbGVhckNTU0FuaW1hdGlvbnNUaW1lb3V0KCk7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldFN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1wbGF5LXN0YXRlJywgJ3J1bm5pbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKF9rZXlmcmFtZXMubGVuZ3RoID09PSAwIHx8IGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYW5pbWF0aW9uRmluaXNoKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgY2F0Y2hhbGwgaW4gdGhlIGV2ZW50IHRoYXQgYSBDU1MgQW5pbWF0aW9uIGRpZCBub3QgZmluaXNoLlxuICAgICAgICogVGhlIFdlYiBBbmltYXRpb25zIEFQSSBoYXMgbWVjaGFuaXNtcyBpbiBwbGFjZSBmb3IgcHJldmVudGluZyB0aGlzLlxuICAgICAgICogQ1NTIEFuaW1hdGlvbnMgd2lsbCBub3QgZmlyZSBhbiBgYW5pbWF0aW9uZW5kYCBldmVudFxuICAgICAgICogZm9yIGVsZW1lbnRzIHdpdGggYGRpc3BsYXk6IG5vbmVgLiBUaGUgV2ViIEFuaW1hdGlvbnMgQVBJXG4gICAgICAgKiBhY2NvdW50cyBmb3IgdGhpcywgYnV0IHVzaW5nIHJhdyBDU1MgQW5pbWF0aW9ucyByZXF1aXJlc1xuICAgICAgICogdGhpcyB3b3JrYXJvdW5kLlxuICAgICAgICovXG4gICAgICBjb25zdCBhbmltYXRpb25EZWxheSA9IGdldERlbGF5KCkgfHwgMDtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9uID0gZ2V0RHVyYXRpb24oKSB8fCAwO1xuICAgICAgY29uc3QgYW5pbWF0aW9uSXRlcmF0aW9ucyA9IGdldEl0ZXJhdGlvbnMoKSB8fCAxO1xuICAgICAgLy8gTm8gbmVlZCB0byBzZXQgYSB0aW1lb3V0IHdoZW4gYW5pbWF0aW9uIGhhcyBpbmZpbml0ZSBpdGVyYXRpb25zXG4gICAgICBpZiAoaXNGaW5pdGUoYW5pbWF0aW9uSXRlcmF0aW9ucykpIHtcbiAgICAgICAgY3NzQW5pbWF0aW9uc1RpbWVyRmFsbGJhY2sgPSBzZXRUaW1lb3V0KG9uQW5pbWF0aW9uRW5kRmFsbGJhY2ssIGFuaW1hdGlvbkRlbGF5ICsgYW5pbWF0aW9uRHVyYXRpb24gKiBhbmltYXRpb25JdGVyYXRpb25zICsgQU5JTUFUSU9OX0VORF9GQUxMQkFDS19QQURESU5HX01TKTtcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbkVuZChlbGVtZW50c1swXSwgKCkgPT4ge1xuICAgICAgICBjbGVhckNTU0FuaW1hdGlvbnNUaW1lb3V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgdGhhdCBjbGVhbiB1cFxuICAgICAgICAgKiBpcyBhbHdheXMgZG9uZSBhIGZyYW1lXG4gICAgICAgICAqIGJlZm9yZSB0aGUgb25GaW5pc2ggaGFuZGxlcnNcbiAgICAgICAgICogYXJlIGZpcmVkLiBPdGhlcndpc2UsIHRoZXJlXG4gICAgICAgICAqIG1heSBiZSBmbGlja2VyaW5nIGlmIGEgbmV3XG4gICAgICAgICAqIGFuaW1hdGlvbiBpcyBzdGFydGVkIG9uIHRoZSBzYW1lXG4gICAgICAgICAqIGVsZW1lbnQgdG9vIHF1aWNrbHlcbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogSXMgdGhlcmUgYSBjbGVhbmVyIHdheSB0byBkbyB0aGlzP1xuICAgICAgICAgKi9cbiAgICAgICAgcmFmKCgpID0+IHtcbiAgICAgICAgICBjbGVhckNTU0FuaW1hdGlvblBsYXlTdGF0ZSgpO1xuICAgICAgICAgIHJhZihhbmltYXRpb25GaW5pc2gpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJDU1NBbmltYXRpb25QbGF5U3RhdGUgPSAoKSA9PiB7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgcmVtb3ZlU3R5bGVQcm9wZXJ0eShlbGVtZW50LCAnYW5pbWF0aW9uLWR1cmF0aW9uJyk7XG4gICAgICByZW1vdmVTdHlsZVByb3BlcnR5KGVsZW1lbnQsICdhbmltYXRpb24tZGVsYXknKTtcbiAgICAgIHJlbW92ZVN0eWxlUHJvcGVydHkoZWxlbWVudCwgJ2FuaW1hdGlvbi1wbGF5LXN0YXRlJyk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHBsYXlXZWJBbmltYXRpb25zID0gKCkgPT4ge1xuICAgIHdlYkFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH0pO1xuICAgIGlmIChfa2V5ZnJhbWVzLmxlbmd0aCA9PT0gMCB8fCBlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGFuaW1hdGlvbkZpbmlzaCgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzZXRBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHN1cHBvcnRzV2ViQW5pbWF0aW9ucykge1xuICAgICAgc2V0QW5pbWF0aW9uU3RlcCgwKTtcbiAgICAgIHVwZGF0ZVdlYkFuaW1hdGlvbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHVwZGF0ZUNTU0FuaW1hdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGxheSA9IChvcHRzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnN5bmMpIHtcbiAgICAgICAgc2hvdWxkRm9yY2VTeW5jUGxheWJhY2sgPSB0cnVlO1xuICAgICAgICBvbkZpbmlzaCgoKSA9PiAoc2hvdWxkRm9yY2VTeW5jUGxheWJhY2sgPSBmYWxzZSksIHsgb25lVGltZUNhbGxiYWNrOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICBpbml0aWFsaXplQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgcmVzZXRBbmltYXRpb24oKTtcbiAgICAgICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRDYWxjdWxhdGVOdW1BbmltYXRpb25zKSB7XG4gICAgICAgIG51bUFuaW1hdGlvbnNSdW5uaW5nID0gY2hpbGRBbmltYXRpb25zLmxlbmd0aCArIDE7XG4gICAgICAgIHNob3VsZENhbGN1bGF0ZU51bUFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9uRmluaXNoKCgpID0+IHJlc29sdmUoKSwgeyBvbmVUaW1lQ2FsbGJhY2s6IHRydWUgfSk7XG4gICAgICBjaGlsZEFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChzdXBwb3J0c1dlYkFuaW1hdGlvbnMpIHtcbiAgICAgICAgcGxheVdlYkFuaW1hdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwbGF5Q1NTQW5pbWF0aW9ucygpO1xuICAgICAgfVxuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgY2hpbGRBbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4ge1xuICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcbiAgICB9KTtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNsZWFuVXBFbGVtZW50cygpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmVzZXRGbGFncygpO1xuICB9O1xuICBjb25zdCBmcm9tID0gKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGZpcnN0RnJhbWUgPSBfa2V5ZnJhbWVzWzBdO1xuICAgIGlmIChmaXJzdEZyYW1lICE9PSB1bmRlZmluZWQgJiYgKGZpcnN0RnJhbWUub2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgZmlyc3RGcmFtZS5vZmZzZXQgPT09IDApKSB7XG4gICAgICBmaXJzdEZyYW1lW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9rZXlmcmFtZXMgPSBbeyBvZmZzZXQ6IDAsIFtwcm9wZXJ0eV06IHZhbHVlIH0sIC4uLl9rZXlmcmFtZXNdO1xuICAgIH1cbiAgICByZXR1cm4gYW5pO1xuICB9O1xuICBjb25zdCB0byA9IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBfa2V5ZnJhbWVzW19rZXlmcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RGcmFtZSAhPT0gdW5kZWZpbmVkICYmIChsYXN0RnJhbWUub2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgbGFzdEZyYW1lLm9mZnNldCA9PT0gMSkpIHtcbiAgICAgIGxhc3RGcmFtZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfa2V5ZnJhbWVzID0gWy4uLl9rZXlmcmFtZXMsIHsgb2Zmc2V0OiAxLCBbcHJvcGVydHldOiB2YWx1ZSB9XTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaTtcbiAgfTtcbiAgY29uc3QgZnJvbVRvID0gKHByb3BlcnR5LCBmcm9tVmFsdWUsIHRvVmFsdWUpID0+IHtcbiAgICByZXR1cm4gZnJvbShwcm9wZXJ0eSwgZnJvbVZhbHVlKS50byhwcm9wZXJ0eSwgdG9WYWx1ZSk7XG4gIH07XG4gIHJldHVybiAoYW5pID0ge1xuICAgIHBhcmVudEFuaW1hdGlvbixcbiAgICBlbGVtZW50cyxcbiAgICBjaGlsZEFuaW1hdGlvbnMsXG4gICAgaWQsXG4gICAgYW5pbWF0aW9uRmluaXNoLFxuICAgIGZyb20sXG4gICAgdG8sXG4gICAgZnJvbVRvLFxuICAgIHBhcmVudCxcbiAgICBwbGF5LFxuICAgIHBhdXNlLFxuICAgIHN0b3AsXG4gICAgZGVzdHJveSxcbiAgICBrZXlmcmFtZXMsXG4gICAgYWRkQW5pbWF0aW9uLFxuICAgIGFkZEVsZW1lbnQsXG4gICAgdXBkYXRlLFxuICAgIGZpbGwsXG4gICAgZGlyZWN0aW9uLFxuICAgIGl0ZXJhdGlvbnMsXG4gICAgZHVyYXRpb24sXG4gICAgZWFzaW5nLFxuICAgIGRlbGF5LFxuICAgIGdldFdlYkFuaW1hdGlvbnMsXG4gICAgZ2V0S2V5ZnJhbWVzLFxuICAgIGdldEZpbGwsXG4gICAgZ2V0RGlyZWN0aW9uLFxuICAgIGdldERlbGF5LFxuICAgIGdldEl0ZXJhdGlvbnMsXG4gICAgZ2V0RWFzaW5nLFxuICAgIGdldER1cmF0aW9uLFxuICAgIGFmdGVyQWRkUmVhZCxcbiAgICBhZnRlckFkZFdyaXRlLFxuICAgIGFmdGVyQ2xlYXJTdHlsZXMsXG4gICAgYWZ0ZXJTdHlsZXMsXG4gICAgYWZ0ZXJSZW1vdmVDbGFzcyxcbiAgICBhZnRlckFkZENsYXNzLFxuICAgIGJlZm9yZUFkZFJlYWQsXG4gICAgYmVmb3JlQWRkV3JpdGUsXG4gICAgYmVmb3JlQ2xlYXJTdHlsZXMsXG4gICAgYmVmb3JlU3R5bGVzLFxuICAgIGJlZm9yZVJlbW92ZUNsYXNzLFxuICAgIGJlZm9yZUFkZENsYXNzLFxuICAgIG9uRmluaXNoLFxuICAgIGlzUnVubmluZyxcbiAgICBwcm9ncmVzc1N0YXJ0LFxuICAgIHByb2dyZXNzU3RlcCxcbiAgICBwcm9ncmVzc0VuZCxcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVBbmltYXRpb24gYXMgYyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35980\n")}}]);