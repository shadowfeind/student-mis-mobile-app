"use strict";(self.webpackChunkstudent_mis_mobile_app=self.webpackChunkstudent_mis_mobile_app||[]).push([[6167],{86167:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"createSwipeBackGesture\": () => (/* binding */ createSwipeBackGesture)\n});\n\n// EXTERNAL MODULE: ./node_modules/@ionic/core/components/helpers.js\nvar helpers = __webpack_require__(96587);\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/dir.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = (hostEl) => {\n  if (hostEl) {\n    if (hostEl.dir !== '') {\n      return hostEl.dir.toLowerCase() === 'rtl';\n    }\n  }\n  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/gesture-controller.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nclass GestureController {\n  constructor() {\n    this.gestureId = 0;\n    this.requestedStart = new Map();\n    this.disabledGestures = new Map();\n    this.disabledScroll = new Set();\n  }\n  /**\n   * Creates a gesture delegate based on the GestureConfig passed\n   */\n  createGesture(config) {\n    return new GestureDelegate(this, this.newID(), config.name, config.priority || 0, !!config.disableScroll);\n  }\n  /**\n   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.\n   */\n  createBlocker(opts = {}) {\n    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);\n  }\n  start(gestureName, id, priority) {\n    if (!this.canStart(gestureName)) {\n      this.requestedStart.delete(id);\n      return false;\n    }\n    this.requestedStart.set(id, priority);\n    return true;\n  }\n  capture(gestureName, id, priority) {\n    if (!this.start(gestureName, id, priority)) {\n      return false;\n    }\n    const requestedStart = this.requestedStart;\n    let maxPriority = -10000;\n    requestedStart.forEach((value) => {\n      maxPriority = Math.max(maxPriority, value);\n    });\n    if (maxPriority === priority) {\n      this.capturedId = id;\n      requestedStart.clear();\n      const event = new CustomEvent('ionGestureCaptured', { detail: { gestureName } });\n      document.dispatchEvent(event);\n      return true;\n    }\n    requestedStart.delete(id);\n    return false;\n  }\n  release(id) {\n    this.requestedStart.delete(id);\n    if (this.capturedId === id) {\n      this.capturedId = undefined;\n    }\n  }\n  disableGesture(gestureName, id) {\n    let set = this.disabledGestures.get(gestureName);\n    if (set === undefined) {\n      set = new Set();\n      this.disabledGestures.set(gestureName, set);\n    }\n    set.add(id);\n  }\n  enableGesture(gestureName, id) {\n    const set = this.disabledGestures.get(gestureName);\n    if (set !== undefined) {\n      set.delete(id);\n    }\n  }\n  disableScroll(id) {\n    this.disabledScroll.add(id);\n    if (this.disabledScroll.size === 1) {\n      document.body.classList.add(BACKDROP_NO_SCROLL);\n    }\n  }\n  enableScroll(id) {\n    this.disabledScroll.delete(id);\n    if (this.disabledScroll.size === 0) {\n      document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n  }\n  canStart(gestureName) {\n    if (this.capturedId !== undefined) {\n      // a gesture already captured\n      return false;\n    }\n    if (this.isDisabled(gestureName)) {\n      return false;\n    }\n    return true;\n  }\n  isCaptured() {\n    return this.capturedId !== undefined;\n  }\n  isScrollDisabled() {\n    return this.disabledScroll.size > 0;\n  }\n  isDisabled(gestureName) {\n    const disabled = this.disabledGestures.get(gestureName);\n    if (disabled && disabled.size > 0) {\n      return true;\n    }\n    return false;\n  }\n  newID() {\n    this.gestureId++;\n    return this.gestureId;\n  }\n}\nclass GestureDelegate {\n  constructor(ctrl, id, name, priority, disableScroll) {\n    this.id = id;\n    this.name = name;\n    this.disableScroll = disableScroll;\n    this.priority = priority * 1000000 + id;\n    this.ctrl = ctrl;\n  }\n  canStart() {\n    if (!this.ctrl) {\n      return false;\n    }\n    return this.ctrl.canStart(this.name);\n  }\n  start() {\n    if (!this.ctrl) {\n      return false;\n    }\n    return this.ctrl.start(this.name, this.id, this.priority);\n  }\n  capture() {\n    if (!this.ctrl) {\n      return false;\n    }\n    const captured = this.ctrl.capture(this.name, this.id, this.priority);\n    if (captured && this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n    return captured;\n  }\n  release() {\n    if (this.ctrl) {\n      this.ctrl.release(this.id);\n      if (this.disableScroll) {\n        this.ctrl.enableScroll(this.id);\n      }\n    }\n  }\n  destroy() {\n    this.release();\n    this.ctrl = undefined;\n  }\n}\nclass BlockerDelegate {\n  constructor(ctrl, id, disable, disableScroll) {\n    this.id = id;\n    this.disable = disable;\n    this.disableScroll = disableScroll;\n    this.ctrl = ctrl;\n  }\n  block() {\n    if (!this.ctrl) {\n      return;\n    }\n    if (this.disable) {\n      for (const gesture of this.disable) {\n        this.ctrl.disableGesture(gesture, this.id);\n      }\n    }\n    if (this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n  }\n  unblock() {\n    if (!this.ctrl) {\n      return;\n    }\n    if (this.disable) {\n      for (const gesture of this.disable) {\n        this.ctrl.enableGesture(gesture, this.id);\n      }\n    }\n    if (this.disableScroll) {\n      this.ctrl.enableScroll(this.id);\n    }\n  }\n  destroy() {\n    this.unblock();\n    this.ctrl = undefined;\n  }\n}\nconst BACKDROP_NO_SCROLL = 'backdrop-no-scroll';\nconst GESTURE_CONTROLLER = new GestureController();\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/index2.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\nconst addEventListener = (el, eventName, callback, opts) => {\n  // use event listener options when supported\n  // otherwise it's just a boolean for the \"capture\" arg\n  const listenerOpts = supportsPassive(el)\n    ? {\n      capture: !!opts.capture,\n      passive: !!opts.passive,\n    }\n    : !!opts.capture;\n  let add;\n  let remove;\n  if (el['__zone_symbol__addEventListener']) {\n    add = '__zone_symbol__addEventListener';\n    remove = '__zone_symbol__removeEventListener';\n  }\n  else {\n    add = 'addEventListener';\n    remove = 'removeEventListener';\n  }\n  el[add](eventName, callback, listenerOpts);\n  return () => {\n    el[remove](eventName, callback, listenerOpts);\n  };\n};\nconst supportsPassive = (node) => {\n  if (_sPassive === undefined) {\n    try {\n      const opts = Object.defineProperty({}, 'passive', {\n        get: () => {\n          _sPassive = true;\n        },\n      });\n      node.addEventListener('optsTest', () => {\n        return;\n      }, opts);\n    }\n    catch (e) {\n      _sPassive = false;\n    }\n  }\n  return !!_sPassive;\n};\nlet _sPassive;\n\nconst MOUSE_WAIT = 2000;\nconst createPointerEvents = (el, pointerDown, pointerMove, pointerUp, options) => {\n  let rmTouchStart;\n  let rmTouchMove;\n  let rmTouchEnd;\n  let rmTouchCancel;\n  let rmMouseStart;\n  let rmMouseMove;\n  let rmMouseUp;\n  let lastTouchEvent = 0;\n  const handleTouchStart = (ev) => {\n    lastTouchEvent = Date.now() + MOUSE_WAIT;\n    if (!pointerDown(ev)) {\n      return;\n    }\n    if (!rmTouchMove && pointerMove) {\n      rmTouchMove = addEventListener(el, 'touchmove', pointerMove, options);\n    }\n    /**\n     * Events are dispatched on the element that is tapped and bubble up to\n     * the reference element in the gesture. In the event that the element this\n     * event was first dispatched on is removed from the DOM, the event will no\n     * longer bubble up to our reference element. This leaves the gesture in an\n     * unusable state. To account for this, the touchend and touchcancel listeners\n     * should be added to the event target so that they still fire even if the target\n     * is removed from the DOM.\n     */\n    if (!rmTouchEnd) {\n      rmTouchEnd = addEventListener(ev.target, 'touchend', handleTouchEnd, options);\n    }\n    if (!rmTouchCancel) {\n      rmTouchCancel = addEventListener(ev.target, 'touchcancel', handleTouchEnd, options);\n    }\n  };\n  const handleMouseDown = (ev) => {\n    if (lastTouchEvent > Date.now()) {\n      return;\n    }\n    if (!pointerDown(ev)) {\n      return;\n    }\n    if (!rmMouseMove && pointerMove) {\n      rmMouseMove = addEventListener(getDocument(el), 'mousemove', pointerMove, options);\n    }\n    if (!rmMouseUp) {\n      rmMouseUp = addEventListener(getDocument(el), 'mouseup', handleMouseUp, options);\n    }\n  };\n  const handleTouchEnd = (ev) => {\n    stopTouch();\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  };\n  const handleMouseUp = (ev) => {\n    stopMouse();\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  };\n  const stopTouch = () => {\n    if (rmTouchMove) {\n      rmTouchMove();\n    }\n    if (rmTouchEnd) {\n      rmTouchEnd();\n    }\n    if (rmTouchCancel) {\n      rmTouchCancel();\n    }\n    rmTouchMove = rmTouchEnd = rmTouchCancel = undefined;\n  };\n  const stopMouse = () => {\n    if (rmMouseMove) {\n      rmMouseMove();\n    }\n    if (rmMouseUp) {\n      rmMouseUp();\n    }\n    rmMouseMove = rmMouseUp = undefined;\n  };\n  const stop = () => {\n    stopTouch();\n    stopMouse();\n  };\n  const enable = (isEnabled = true) => {\n    if (!isEnabled) {\n      if (rmTouchStart) {\n        rmTouchStart();\n      }\n      if (rmMouseStart) {\n        rmMouseStart();\n      }\n      rmTouchStart = rmMouseStart = undefined;\n      stop();\n    }\n    else {\n      if (!rmTouchStart) {\n        rmTouchStart = addEventListener(el, 'touchstart', handleTouchStart, options);\n      }\n      if (!rmMouseStart) {\n        rmMouseStart = addEventListener(el, 'mousedown', handleMouseDown, options);\n      }\n    }\n  };\n  const destroy = () => {\n    enable(false);\n    pointerUp = pointerMove = pointerDown = undefined;\n  };\n  return {\n    enable,\n    stop,\n    destroy,\n  };\n};\nconst getDocument = (node) => {\n  return node instanceof Document ? node : node.ownerDocument;\n};\n\nconst createPanRecognizer = (direction, thresh, maxAngle) => {\n  const radians = maxAngle * (Math.PI / 180);\n  const isDirX = direction === 'x';\n  const maxCosine = Math.cos(radians);\n  const threshold = thresh * thresh;\n  let startX = 0;\n  let startY = 0;\n  let dirty = false;\n  let isPan = 0;\n  return {\n    start(x, y) {\n      startX = x;\n      startY = y;\n      isPan = 0;\n      dirty = true;\n    },\n    detect(x, y) {\n      if (!dirty) {\n        return false;\n      }\n      const deltaX = x - startX;\n      const deltaY = y - startY;\n      const distance = deltaX * deltaX + deltaY * deltaY;\n      if (distance < threshold) {\n        return false;\n      }\n      const hypotenuse = Math.sqrt(distance);\n      const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;\n      if (cosine > maxCosine) {\n        isPan = 1;\n      }\n      else if (cosine < -maxCosine) {\n        isPan = -1;\n      }\n      else {\n        isPan = 0;\n      }\n      dirty = false;\n      return true;\n    },\n    isGesture() {\n      return isPan !== 0;\n    },\n    getDirection() {\n      return isPan;\n    },\n  };\n};\n\nconst createGesture = (config) => {\n  let hasCapturedPan = false;\n  let hasStartedPan = false;\n  let hasFiredStart = true;\n  let isMoveQueued = false;\n  const finalConfig = Object.assign({ disableScroll: false, direction: 'x', gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, config);\n  const canStart = finalConfig.canStart;\n  const onWillStart = finalConfig.onWillStart;\n  const onStart = finalConfig.onStart;\n  const onEnd = finalConfig.onEnd;\n  const notCaptured = finalConfig.notCaptured;\n  const onMove = finalConfig.onMove;\n  const threshold = finalConfig.threshold;\n  const passive = finalConfig.passive;\n  const blurOnStart = finalConfig.blurOnStart;\n  const detail = {\n    type: 'pan',\n    startX: 0,\n    startY: 0,\n    startTime: 0,\n    currentX: 0,\n    currentY: 0,\n    velocityX: 0,\n    velocityY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    currentTime: 0,\n    event: undefined,\n    data: undefined,\n  };\n  const pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);\n  const gesture = GESTURE_CONTROLLER.createGesture({\n    name: config.gestureName,\n    priority: config.gesturePriority,\n    disableScroll: config.disableScroll,\n  });\n  const pointerDown = (ev) => {\n    const timeStamp = now(ev);\n    if (hasStartedPan || !hasFiredStart) {\n      return false;\n    }\n    updateDetail(ev, detail);\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTime = detail.currentTime = timeStamp;\n    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;\n    detail.event = ev;\n    // Check if gesture can start\n    if (canStart && canStart(detail) === false) {\n      return false;\n    }\n    // Release fallback\n    gesture.release();\n    // Start gesture\n    if (!gesture.start()) {\n      return false;\n    }\n    hasStartedPan = true;\n    if (threshold === 0) {\n      return tryToCapturePan();\n    }\n    pan.start(detail.startX, detail.startY);\n    return true;\n  };\n  const pointerMove = (ev) => {\n    // fast path, if gesture is currently captured\n    // do minimum job to get user-land even dispatched\n    if (hasCapturedPan) {\n      if (!isMoveQueued && hasFiredStart) {\n        isMoveQueued = true;\n        calcGestureData(detail, ev);\n        requestAnimationFrame(fireOnMove);\n      }\n      return;\n    }\n    // gesture is currently being detected\n    calcGestureData(detail, ev);\n    if (pan.detect(detail.currentX, detail.currentY)) {\n      if (!pan.isGesture() || !tryToCapturePan()) {\n        abortGesture();\n      }\n    }\n  };\n  const fireOnMove = () => {\n    // Since fireOnMove is called inside a RAF, onEnd() might be called,\n    // we must double check hasCapturedPan\n    if (!hasCapturedPan) {\n      return;\n    }\n    isMoveQueued = false;\n    if (onMove) {\n      onMove(detail);\n    }\n  };\n  const tryToCapturePan = () => {\n    if (gesture && !gesture.capture()) {\n      return false;\n    }\n    hasCapturedPan = true;\n    hasFiredStart = false;\n    // reset start position since the real user-land event starts here\n    // If the pan detector threshold is big, not resetting the start position\n    // will cause a jump in the animation equal to the detector threshold.\n    // the array of positions used to calculate the gesture velocity does not\n    // need to be cleaned, more points in the positions array always results in a\n    // more accurate value of the velocity.\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTime = detail.currentTime;\n    if (onWillStart) {\n      onWillStart(detail).then(fireOnStart);\n    }\n    else {\n      fireOnStart();\n    }\n    return true;\n  };\n  const blurActiveElement = () => {\n    if (typeof document !== 'undefined') {\n      const activeElement = document.activeElement;\n      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur) {\n        activeElement.blur();\n      }\n    }\n  };\n  const fireOnStart = () => {\n    if (blurOnStart) {\n      blurActiveElement();\n    }\n    if (onStart) {\n      onStart(detail);\n    }\n    hasFiredStart = true;\n  };\n  const reset = () => {\n    hasCapturedPan = false;\n    hasStartedPan = false;\n    isMoveQueued = false;\n    hasFiredStart = true;\n    gesture.release();\n  };\n  // END *************************\n  const pointerUp = (ev) => {\n    const tmpHasCaptured = hasCapturedPan;\n    const tmpHasFiredStart = hasFiredStart;\n    reset();\n    if (!tmpHasFiredStart) {\n      return;\n    }\n    calcGestureData(detail, ev);\n    // Try to capture press\n    if (tmpHasCaptured) {\n      if (onEnd) {\n        onEnd(detail);\n      }\n      return;\n    }\n    // Not captured any event\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  };\n  const pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {\n    capture: false,\n    passive,\n  });\n  const abortGesture = () => {\n    reset();\n    pointerEvents.stop();\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  };\n  return {\n    enable(enable = true) {\n      if (!enable) {\n        if (hasCapturedPan) {\n          pointerUp(undefined);\n        }\n        reset();\n      }\n      pointerEvents.enable(enable);\n    },\n    destroy() {\n      gesture.destroy();\n      pointerEvents.destroy();\n    },\n  };\n};\nconst calcGestureData = (detail, ev) => {\n  if (!ev) {\n    return;\n  }\n  const prevX = detail.currentX;\n  const prevY = detail.currentY;\n  const prevT = detail.currentTime;\n  updateDetail(ev, detail);\n  const currentX = detail.currentX;\n  const currentY = detail.currentY;\n  const timestamp = (detail.currentTime = now(ev));\n  const timeDelta = timestamp - prevT;\n  if (timeDelta > 0 && timeDelta < 100) {\n    const velocityX = (currentX - prevX) / timeDelta;\n    const velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  detail.event = ev;\n};\nconst updateDetail = (ev, detail) => {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  let x = 0;\n  let y = 0;\n  if (ev) {\n    const changedTouches = ev.changedTouches;\n    if (changedTouches && changedTouches.length > 0) {\n      const touch = changedTouches[0];\n      x = touch.clientX;\n      y = touch.clientY;\n    }\n    else if (ev.pageX !== undefined) {\n      x = ev.pageX;\n      y = ev.pageY;\n    }\n  }\n  detail.currentX = x;\n  detail.currentY = y;\n};\nconst now = (ev) => {\n  return ev.timeStamp || Date.now();\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@ionic/core/components/swipe-back.js\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n\n\n\n\nconst createSwipeBackGesture = (el, canStartHandler, onStartHandler, onMoveHandler, onEndHandler) => {\n  const win = el.ownerDocument.defaultView;\n  const rtl = isRTL(el);\n  /**\n   * Determine if a gesture is near the edge\n   * of the screen. If true, then the swipe\n   * to go back gesture should proceed.\n   */\n  const isAtEdge = (detail) => {\n    const threshold = 50;\n    const { startX } = detail;\n    if (rtl) {\n      return startX >= win.innerWidth - threshold;\n    }\n    return startX <= threshold;\n  };\n  const getDeltaX = (detail) => {\n    return rtl ? -detail.deltaX : detail.deltaX;\n  };\n  const getVelocityX = (detail) => {\n    return rtl ? -detail.velocityX : detail.velocityX;\n  };\n  const canStart = (detail) => {\n    return isAtEdge(detail) && canStartHandler();\n  };\n  const onMove = (detail) => {\n    // set the transition animation's progress\n    const delta = getDeltaX(detail);\n    const stepValue = delta / win.innerWidth;\n    onMoveHandler(stepValue);\n  };\n  const onEnd = (detail) => {\n    // the swipe back gesture has ended\n    const delta = getDeltaX(detail);\n    const width = win.innerWidth;\n    const stepValue = delta / width;\n    const velocity = getVelocityX(detail);\n    const z = width / 2.0;\n    const shouldComplete = velocity >= 0 && (velocity > 0.2 || delta > z);\n    const missing = shouldComplete ? 1 - stepValue : stepValue;\n    const missingDistance = missing * width;\n    let realDur = 0;\n    if (missingDistance > 5) {\n      const dur = missingDistance / Math.abs(velocity);\n      realDur = Math.min(dur, 540);\n    }\n    /**\n     * TODO: stepValue can sometimes return negative values\n     * or values greater than 1 which should not be possible.\n     * Need to investigate more to find where the issue is.\n     */\n    onEndHandler(shouldComplete, stepValue <= 0 ? 0.01 : (0,helpers.j)(0, stepValue, 0.9999), realDur);\n  };\n  return createGesture({\n    el,\n    gestureName: 'goback-swipe',\n    gesturePriority: 40,\n    threshold: 10,\n    canStart,\n    onStart: onStartHandler,\n    onMove,\n    onEnd,\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYxNjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0I7OztBQ2pCdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7OztBQ2pNbkM7QUFDQTtBQUNBO0FBQ2tFO0FBQ0E7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzR0FBc0c7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCOzs7QUNyY3pCO0FBQ0E7QUFDQTtBQUMwQztBQUNKO0FBQ007O0FBRTVDO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBSztBQUM5RDtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9kaXIuanM/NDQyZSIsIndlYnBhY2s6Ly9zdHVkZW50LW1pcy1tb2JpbGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvZ2VzdHVyZS1jb250cm9sbGVyLmpzPzYzZmMiLCJ3ZWJwYWNrOi8vc3R1ZGVudC1taXMtbW9iaWxlLWFwcC8uL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9jb21wb25lbnRzL2luZGV4Mi5qcz9lMzc5Iiwid2VicGFjazovL3N0dWRlbnQtbWlzLW1vYmlsZS1hcHAvLi9ub2RlX21vZHVsZXMvQGlvbmljL2NvcmUvY29tcG9uZW50cy9zd2lwZS1iYWNrLmpzPzhkMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRvY3VtZW50IG9yIGhvc3QgZWxlbWVudFxuICogaGFzIGEgYGRpcmAgc2V0IHRvIGBydGxgLiBUaGUgaG9zdCB2YWx1ZSB3aWxsIGFsd2F5c1xuICogdGFrZSBwcmlvcml0eSBvdmVyIHRoZSByb290IGRvY3VtZW50IHZhbHVlLlxuICovXG5jb25zdCBpc1JUTCA9IChob3N0RWwpID0+IHtcbiAgaWYgKGhvc3RFbCkge1xuICAgIGlmIChob3N0RWwuZGlyICE9PSAnJykge1xuICAgICAgcmV0dXJuIGhvc3RFbC5kaXIudG9Mb3dlckNhc2UoKSA9PT0gJ3J0bCc7XG4gICAgfVxuICB9XG4gIHJldHVybiAoZG9jdW1lbnQgPT09IG51bGwgfHwgZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50LmRpci50b0xvd2VyQ2FzZSgpKSA9PT0gJ3J0bCc7XG59O1xuXG5leHBvcnQgeyBpc1JUTCBhcyBpIH07XG4iLCIvKiFcbiAqIChDKSBJb25pYyBodHRwOi8vaW9uaWNmcmFtZXdvcmsuY29tIC0gTUlUIExpY2Vuc2VcbiAqL1xuY2xhc3MgR2VzdHVyZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdlc3R1cmVJZCA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTdGFydCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRpc2FibGVkR2VzdHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kaXNhYmxlZFNjcm9sbCA9IG5ldyBTZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdlc3R1cmUgZGVsZWdhdGUgYmFzZWQgb24gdGhlIEdlc3R1cmVDb25maWcgcGFzc2VkXG4gICAqL1xuICBjcmVhdGVHZXN0dXJlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgR2VzdHVyZURlbGVnYXRlKHRoaXMsIHRoaXMubmV3SUQoKSwgY29uZmlnLm5hbWUsIGNvbmZpZy5wcmlvcml0eSB8fCAwLCAhIWNvbmZpZy5kaXNhYmxlU2Nyb2xsKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJsb2NrZXIgdGhhdCB3aWxsIGJsb2NrIGFueSBvdGhlciBnZXN0dXJlIGV2ZW50cyBmcm9tIGZpcmluZy4gU2V0IGluIHRoZSBpb24tZ2VzdHVyZSBjb21wb25lbnQuXG4gICAqL1xuICBjcmVhdGVCbG9ja2VyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgQmxvY2tlckRlbGVnYXRlKHRoaXMsIHRoaXMubmV3SUQoKSwgb3B0cy5kaXNhYmxlLCAhIW9wdHMuZGlzYWJsZVNjcm9sbCk7XG4gIH1cbiAgc3RhcnQoZ2VzdHVyZU5hbWUsIGlkLCBwcmlvcml0eSkge1xuICAgIGlmICghdGhpcy5jYW5TdGFydChnZXN0dXJlTmFtZSkpIHtcbiAgICAgIHRoaXMucmVxdWVzdGVkU3RhcnQuZGVsZXRlKGlkKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0ZWRTdGFydC5zZXQoaWQsIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYXB0dXJlKGdlc3R1cmVOYW1lLCBpZCwgcHJpb3JpdHkpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnQoZ2VzdHVyZU5hbWUsIGlkLCBwcmlvcml0eSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdGVkU3RhcnQgPSB0aGlzLnJlcXVlc3RlZFN0YXJ0O1xuICAgIGxldCBtYXhQcmlvcml0eSA9IC0xMDAwMDtcbiAgICByZXF1ZXN0ZWRTdGFydC5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgbWF4UHJpb3JpdHkgPSBNYXRoLm1heChtYXhQcmlvcml0eSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIGlmIChtYXhQcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRJZCA9IGlkO1xuICAgICAgcmVxdWVzdGVkU3RhcnQuY2xlYXIoKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdpb25HZXN0dXJlQ2FwdHVyZWQnLCB7IGRldGFpbDogeyBnZXN0dXJlTmFtZSB9IH0pO1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVxdWVzdGVkU3RhcnQuZGVsZXRlKGlkKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVsZWFzZShpZCkge1xuICAgIHRoaXMucmVxdWVzdGVkU3RhcnQuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy5jYXB0dXJlZElkID09PSBpZCkge1xuICAgICAgdGhpcy5jYXB0dXJlZElkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlR2VzdHVyZShnZXN0dXJlTmFtZSwgaWQpIHtcbiAgICBsZXQgc2V0ID0gdGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldChnZXN0dXJlTmFtZSk7XG4gICAgaWYgKHNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmRpc2FibGVkR2VzdHVyZXMuc2V0KGdlc3R1cmVOYW1lLCBzZXQpO1xuICAgIH1cbiAgICBzZXQuYWRkKGlkKTtcbiAgfVxuICBlbmFibGVHZXN0dXJlKGdlc3R1cmVOYW1lLCBpZCkge1xuICAgIGNvbnN0IHNldCA9IHRoaXMuZGlzYWJsZWRHZXN0dXJlcy5nZXQoZ2VzdHVyZU5hbWUpO1xuICAgIGlmIChzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0LmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG4gIGRpc2FibGVTY3JvbGwoaWQpIHtcbiAgICB0aGlzLmRpc2FibGVkU2Nyb2xsLmFkZChpZCk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRTY3JvbGwuc2l6ZSA9PT0gMSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKEJBQ0tEUk9QX05PX1NDUk9MTCk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVNjcm9sbChpZCkge1xuICAgIHRoaXMuZGlzYWJsZWRTY3JvbGwuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZFNjcm9sbC5zaXplID09PSAwKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoQkFDS0RST1BfTk9fU0NST0xMKTtcbiAgICB9XG4gIH1cbiAgY2FuU3RhcnQoZ2VzdHVyZU5hbWUpIHtcbiAgICBpZiAodGhpcy5jYXB0dXJlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGEgZ2VzdHVyZSBhbHJlYWR5IGNhcHR1cmVkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoZ2VzdHVyZU5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzQ2FwdHVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwdHVyZWRJZCAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGlzU2Nyb2xsRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRTY3JvbGwuc2l6ZSA+IDA7XG4gIH1cbiAgaXNEaXNhYmxlZChnZXN0dXJlTmFtZSkge1xuICAgIGNvbnN0IGRpc2FibGVkID0gdGhpcy5kaXNhYmxlZEdlc3R1cmVzLmdldChnZXN0dXJlTmFtZSk7XG4gICAgaWYgKGRpc2FibGVkICYmIGRpc2FibGVkLnNpemUgPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG5ld0lEKCkge1xuICAgIHRoaXMuZ2VzdHVyZUlkKys7XG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZUlkO1xuICB9XG59XG5jbGFzcyBHZXN0dXJlRGVsZWdhdGUge1xuICBjb25zdHJ1Y3RvcihjdHJsLCBpZCwgbmFtZSwgcHJpb3JpdHksIGRpc2FibGVTY3JvbGwpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGwgPSBkaXNhYmxlU2Nyb2xsO1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eSAqIDEwMDAwMDAgKyBpZDtcbiAgICB0aGlzLmN0cmwgPSBjdHJsO1xuICB9XG4gIGNhblN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5jdHJsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN0cmwuY2FuU3RhcnQodGhpcy5uYW1lKTtcbiAgfVxuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuY3RybCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdHJsLnN0YXJ0KHRoaXMubmFtZSwgdGhpcy5pZCwgdGhpcy5wcmlvcml0eSk7XG4gIH1cbiAgY2FwdHVyZSgpIHtcbiAgICBpZiAoIXRoaXMuY3RybCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlZCA9IHRoaXMuY3RybC5jYXB0dXJlKHRoaXMubmFtZSwgdGhpcy5pZCwgdGhpcy5wcmlvcml0eSk7XG4gICAgaWYgKGNhcHR1cmVkICYmIHRoaXMuZGlzYWJsZVNjcm9sbCkge1xuICAgICAgdGhpcy5jdHJsLmRpc2FibGVTY3JvbGwodGhpcy5pZCk7XG4gICAgfVxuICAgIHJldHVybiBjYXB0dXJlZDtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLmN0cmwpIHtcbiAgICAgIHRoaXMuY3RybC5yZWxlYXNlKHRoaXMuaWQpO1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZVNjcm9sbCkge1xuICAgICAgICB0aGlzLmN0cmwuZW5hYmxlU2Nyb2xsKHRoaXMuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICAgIHRoaXMuY3RybCA9IHVuZGVmaW5lZDtcbiAgfVxufVxuY2xhc3MgQmxvY2tlckRlbGVnYXRlIHtcbiAgY29uc3RydWN0b3IoY3RybCwgaWQsIGRpc2FibGUsIGRpc2FibGVTY3JvbGwpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGwgPSBkaXNhYmxlU2Nyb2xsO1xuICAgIHRoaXMuY3RybCA9IGN0cmw7XG4gIH1cbiAgYmxvY2soKSB7XG4gICAgaWYgKCF0aGlzLmN0cmwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZSkge1xuICAgICAgZm9yIChjb25zdCBnZXN0dXJlIG9mIHRoaXMuZGlzYWJsZSkge1xuICAgICAgICB0aGlzLmN0cmwuZGlzYWJsZUdlc3R1cmUoZ2VzdHVyZSwgdGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc2FibGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuY3RybC5kaXNhYmxlU2Nyb2xsKHRoaXMuaWQpO1xuICAgIH1cbiAgfVxuICB1bmJsb2NrKCkge1xuICAgIGlmICghdGhpcy5jdHJsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc2FibGUpIHtcbiAgICAgIGZvciAoY29uc3QgZ2VzdHVyZSBvZiB0aGlzLmRpc2FibGUpIHtcbiAgICAgICAgdGhpcy5jdHJsLmVuYWJsZUdlc3R1cmUoZ2VzdHVyZSwgdGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmRpc2FibGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuY3RybC5lbmFibGVTY3JvbGwodGhpcy5pZCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bmJsb2NrKCk7XG4gICAgdGhpcy5jdHJsID0gdW5kZWZpbmVkO1xuICB9XG59XG5jb25zdCBCQUNLRFJPUF9OT19TQ1JPTEwgPSAnYmFja2Ryb3Atbm8tc2Nyb2xsJztcbmNvbnN0IEdFU1RVUkVfQ09OVFJPTExFUiA9IG5ldyBHZXN0dXJlQ29udHJvbGxlcigpO1xuXG5leHBvcnQgeyBHRVNUVVJFX0NPTlRST0xMRVIgYXMgRyB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IEcgYXMgR0VTVFVSRV9DT05UUk9MTEVSIH0gZnJvbSAnLi9nZXN0dXJlLWNvbnRyb2xsZXIuanMnO1xuZXhwb3J0IHsgRyBhcyBHRVNUVVJFX0NPTlRST0xMRVIgfSBmcm9tICcuL2dlc3R1cmUtY29udHJvbGxlci5qcyc7XG5cbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSAoZWwsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdHMpID0+IHtcbiAgLy8gdXNlIGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgd2hlbiBzdXBwb3J0ZWRcbiAgLy8gb3RoZXJ3aXNlIGl0J3MganVzdCBhIGJvb2xlYW4gZm9yIHRoZSBcImNhcHR1cmVcIiBhcmdcbiAgY29uc3QgbGlzdGVuZXJPcHRzID0gc3VwcG9ydHNQYXNzaXZlKGVsKVxuICAgID8ge1xuICAgICAgY2FwdHVyZTogISFvcHRzLmNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiAhIW9wdHMucGFzc2l2ZSxcbiAgICB9XG4gICAgOiAhIW9wdHMuY2FwdHVyZTtcbiAgbGV0IGFkZDtcbiAgbGV0IHJlbW92ZTtcbiAgaWYgKGVsWydfX3pvbmVfc3ltYm9sX19hZGRFdmVudExpc3RlbmVyJ10pIHtcbiAgICBhZGQgPSAnX196b25lX3N5bWJvbF9fYWRkRXZlbnRMaXN0ZW5lcic7XG4gICAgcmVtb3ZlID0gJ19fem9uZV9zeW1ib2xfX3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICB9XG4gIGVsc2Uge1xuICAgIGFkZCA9ICdhZGRFdmVudExpc3RlbmVyJztcbiAgICByZW1vdmUgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIH1cbiAgZWxbYWRkXShldmVudE5hbWUsIGNhbGxiYWNrLCBsaXN0ZW5lck9wdHMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsW3JlbW92ZV0oZXZlbnROYW1lLCBjYWxsYmFjaywgbGlzdGVuZXJPcHRzKTtcbiAgfTtcbn07XG5jb25zdCBzdXBwb3J0c1Bhc3NpdmUgPSAobm9kZSkgPT4ge1xuICBpZiAoX3NQYXNzaXZlID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIF9zUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignb3B0c1Rlc3QnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgX3NQYXNzaXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiAhIV9zUGFzc2l2ZTtcbn07XG5sZXQgX3NQYXNzaXZlO1xuXG5jb25zdCBNT1VTRV9XQUlUID0gMjAwMDtcbmNvbnN0IGNyZWF0ZVBvaW50ZXJFdmVudHMgPSAoZWwsIHBvaW50ZXJEb3duLCBwb2ludGVyTW92ZSwgcG9pbnRlclVwLCBvcHRpb25zKSA9PiB7XG4gIGxldCBybVRvdWNoU3RhcnQ7XG4gIGxldCBybVRvdWNoTW92ZTtcbiAgbGV0IHJtVG91Y2hFbmQ7XG4gIGxldCBybVRvdWNoQ2FuY2VsO1xuICBsZXQgcm1Nb3VzZVN0YXJ0O1xuICBsZXQgcm1Nb3VzZU1vdmU7XG4gIGxldCBybU1vdXNlVXA7XG4gIGxldCBsYXN0VG91Y2hFdmVudCA9IDA7XG4gIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSAoZXYpID0+IHtcbiAgICBsYXN0VG91Y2hFdmVudCA9IERhdGUubm93KCkgKyBNT1VTRV9XQUlUO1xuICAgIGlmICghcG9pbnRlckRvd24oZXYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcm1Ub3VjaE1vdmUgJiYgcG9pbnRlck1vdmUpIHtcbiAgICAgIHJtVG91Y2hNb3ZlID0gYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ3RvdWNobW92ZScsIHBvaW50ZXJNb3ZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZlbnRzIGFyZSBkaXNwYXRjaGVkIG9uIHRoZSBlbGVtZW50IHRoYXQgaXMgdGFwcGVkIGFuZCBidWJibGUgdXAgdG9cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaW4gdGhlIGdlc3R1cmUuIEluIHRoZSBldmVudCB0aGF0IHRoZSBlbGVtZW50IHRoaXNcbiAgICAgKiBldmVudCB3YXMgZmlyc3QgZGlzcGF0Y2hlZCBvbiBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgdGhlIGV2ZW50IHdpbGwgbm9cbiAgICAgKiBsb25nZXIgYnViYmxlIHVwIHRvIG91ciByZWZlcmVuY2UgZWxlbWVudC4gVGhpcyBsZWF2ZXMgdGhlIGdlc3R1cmUgaW4gYW5cbiAgICAgKiB1bnVzYWJsZSBzdGF0ZS4gVG8gYWNjb3VudCBmb3IgdGhpcywgdGhlIHRvdWNoZW5kIGFuZCB0b3VjaGNhbmNlbCBsaXN0ZW5lcnNcbiAgICAgKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGV2ZW50IHRhcmdldCBzbyB0aGF0IHRoZXkgc3RpbGwgZmlyZSBldmVuIGlmIHRoZSB0YXJnZXRcbiAgICAgKiBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgKi9cbiAgICBpZiAoIXJtVG91Y2hFbmQpIHtcbiAgICAgIHJtVG91Y2hFbmQgPSBhZGRFdmVudExpc3RlbmVyKGV2LnRhcmdldCwgJ3RvdWNoZW5kJywgaGFuZGxlVG91Y2hFbmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXJtVG91Y2hDYW5jZWwpIHtcbiAgICAgIHJtVG91Y2hDYW5jZWwgPSBhZGRFdmVudExpc3RlbmVyKGV2LnRhcmdldCwgJ3RvdWNoY2FuY2VsJywgaGFuZGxlVG91Y2hFbmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlTW91c2VEb3duID0gKGV2KSA9PiB7XG4gICAgaWYgKGxhc3RUb3VjaEV2ZW50ID4gRGF0ZS5ub3coKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBvaW50ZXJEb3duKGV2KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJtTW91c2VNb3ZlICYmIHBvaW50ZXJNb3ZlKSB7XG4gICAgICBybU1vdXNlTW92ZSA9IGFkZEV2ZW50TGlzdGVuZXIoZ2V0RG9jdW1lbnQoZWwpLCAnbW91c2Vtb3ZlJywgcG9pbnRlck1vdmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXJtTW91c2VVcCkge1xuICAgICAgcm1Nb3VzZVVwID0gYWRkRXZlbnRMaXN0ZW5lcihnZXREb2N1bWVudChlbCksICdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVUb3VjaEVuZCA9IChldikgPT4ge1xuICAgIHN0b3BUb3VjaCgpO1xuICAgIGlmIChwb2ludGVyVXApIHtcbiAgICAgIHBvaW50ZXJVcChldik7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gKGV2KSA9PiB7XG4gICAgc3RvcE1vdXNlKCk7XG4gICAgaWYgKHBvaW50ZXJVcCkge1xuICAgICAgcG9pbnRlclVwKGV2KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0b3BUb3VjaCA9ICgpID0+IHtcbiAgICBpZiAocm1Ub3VjaE1vdmUpIHtcbiAgICAgIHJtVG91Y2hNb3ZlKCk7XG4gICAgfVxuICAgIGlmIChybVRvdWNoRW5kKSB7XG4gICAgICBybVRvdWNoRW5kKCk7XG4gICAgfVxuICAgIGlmIChybVRvdWNoQ2FuY2VsKSB7XG4gICAgICBybVRvdWNoQ2FuY2VsKCk7XG4gICAgfVxuICAgIHJtVG91Y2hNb3ZlID0gcm1Ub3VjaEVuZCA9IHJtVG91Y2hDYW5jZWwgPSB1bmRlZmluZWQ7XG4gIH07XG4gIGNvbnN0IHN0b3BNb3VzZSA9ICgpID0+IHtcbiAgICBpZiAocm1Nb3VzZU1vdmUpIHtcbiAgICAgIHJtTW91c2VNb3ZlKCk7XG4gICAgfVxuICAgIGlmIChybU1vdXNlVXApIHtcbiAgICAgIHJtTW91c2VVcCgpO1xuICAgIH1cbiAgICBybU1vdXNlTW92ZSA9IHJtTW91c2VVcCA9IHVuZGVmaW5lZDtcbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBzdG9wVG91Y2goKTtcbiAgICBzdG9wTW91c2UoKTtcbiAgfTtcbiAgY29uc3QgZW5hYmxlID0gKGlzRW5hYmxlZCA9IHRydWUpID0+IHtcbiAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgaWYgKHJtVG91Y2hTdGFydCkge1xuICAgICAgICBybVRvdWNoU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChybU1vdXNlU3RhcnQpIHtcbiAgICAgICAgcm1Nb3VzZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBybVRvdWNoU3RhcnQgPSBybU1vdXNlU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCFybVRvdWNoU3RhcnQpIHtcbiAgICAgICAgcm1Ub3VjaFN0YXJ0ID0gYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ3RvdWNoc3RhcnQnLCBoYW5kbGVUb3VjaFN0YXJ0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghcm1Nb3VzZVN0YXJ0KSB7XG4gICAgICAgIHJtTW91c2VTdGFydCA9IGFkZEV2ZW50TGlzdGVuZXIoZWwsICdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBlbmFibGUoZmFsc2UpO1xuICAgIHBvaW50ZXJVcCA9IHBvaW50ZXJNb3ZlID0gcG9pbnRlckRvd24gPSB1bmRlZmluZWQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZW5hYmxlLFxuICAgIHN0b3AsXG4gICAgZGVzdHJveSxcbiAgfTtcbn07XG5jb25zdCBnZXREb2N1bWVudCA9IChub2RlKSA9PiB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50O1xufTtcblxuY29uc3QgY3JlYXRlUGFuUmVjb2duaXplciA9IChkaXJlY3Rpb24sIHRocmVzaCwgbWF4QW5nbGUpID0+IHtcbiAgY29uc3QgcmFkaWFucyA9IG1heEFuZ2xlICogKE1hdGguUEkgLyAxODApO1xuICBjb25zdCBpc0RpclggPSBkaXJlY3Rpb24gPT09ICd4JztcbiAgY29uc3QgbWF4Q29zaW5lID0gTWF0aC5jb3MocmFkaWFucyk7XG4gIGNvbnN0IHRocmVzaG9sZCA9IHRocmVzaCAqIHRocmVzaDtcbiAgbGV0IHN0YXJ0WCA9IDA7XG4gIGxldCBzdGFydFkgPSAwO1xuICBsZXQgZGlydHkgPSBmYWxzZTtcbiAgbGV0IGlzUGFuID0gMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydCh4LCB5KSB7XG4gICAgICBzdGFydFggPSB4O1xuICAgICAgc3RhcnRZID0geTtcbiAgICAgIGlzUGFuID0gMDtcbiAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuICAgIGRldGVjdCh4LCB5KSB7XG4gICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhWCA9IHggLSBzdGFydFg7XG4gICAgICBjb25zdCBkZWx0YVkgPSB5IC0gc3RhcnRZO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVk7XG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgaHlwb3RlbnVzZSA9IE1hdGguc3FydChkaXN0YW5jZSk7XG4gICAgICBjb25zdCBjb3NpbmUgPSAoaXNEaXJYID8gZGVsdGFYIDogZGVsdGFZKSAvIGh5cG90ZW51c2U7XG4gICAgICBpZiAoY29zaW5lID4gbWF4Q29zaW5lKSB7XG4gICAgICAgIGlzUGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvc2luZSA8IC1tYXhDb3NpbmUpIHtcbiAgICAgICAgaXNQYW4gPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpc1BhbiA9IDA7XG4gICAgICB9XG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc0dlc3R1cmUoKSB7XG4gICAgICByZXR1cm4gaXNQYW4gIT09IDA7XG4gICAgfSxcbiAgICBnZXREaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNQYW47XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdlc3R1cmUgPSAoY29uZmlnKSA9PiB7XG4gIGxldCBoYXNDYXB0dXJlZFBhbiA9IGZhbHNlO1xuICBsZXQgaGFzU3RhcnRlZFBhbiA9IGZhbHNlO1xuICBsZXQgaGFzRmlyZWRTdGFydCA9IHRydWU7XG4gIGxldCBpc01vdmVRdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgZmluYWxDb25maWcgPSBPYmplY3QuYXNzaWduKHsgZGlzYWJsZVNjcm9sbDogZmFsc2UsIGRpcmVjdGlvbjogJ3gnLCBnZXN0dXJlUHJpb3JpdHk6IDAsIHBhc3NpdmU6IHRydWUsIG1heEFuZ2xlOiA0MCwgdGhyZXNob2xkOiAxMCB9LCBjb25maWcpO1xuICBjb25zdCBjYW5TdGFydCA9IGZpbmFsQ29uZmlnLmNhblN0YXJ0O1xuICBjb25zdCBvbldpbGxTdGFydCA9IGZpbmFsQ29uZmlnLm9uV2lsbFN0YXJ0O1xuICBjb25zdCBvblN0YXJ0ID0gZmluYWxDb25maWcub25TdGFydDtcbiAgY29uc3Qgb25FbmQgPSBmaW5hbENvbmZpZy5vbkVuZDtcbiAgY29uc3Qgbm90Q2FwdHVyZWQgPSBmaW5hbENvbmZpZy5ub3RDYXB0dXJlZDtcbiAgY29uc3Qgb25Nb3ZlID0gZmluYWxDb25maWcub25Nb3ZlO1xuICBjb25zdCB0aHJlc2hvbGQgPSBmaW5hbENvbmZpZy50aHJlc2hvbGQ7XG4gIGNvbnN0IHBhc3NpdmUgPSBmaW5hbENvbmZpZy5wYXNzaXZlO1xuICBjb25zdCBibHVyT25TdGFydCA9IGZpbmFsQ29uZmlnLmJsdXJPblN0YXJ0O1xuICBjb25zdCBkZXRhaWwgPSB7XG4gICAgdHlwZTogJ3BhbicsXG4gICAgc3RhcnRYOiAwLFxuICAgIHN0YXJ0WTogMCxcbiAgICBzdGFydFRpbWU6IDAsXG4gICAgY3VycmVudFg6IDAsXG4gICAgY3VycmVudFk6IDAsXG4gICAgdmVsb2NpdHlYOiAwLFxuICAgIHZlbG9jaXR5WTogMCxcbiAgICBkZWx0YVg6IDAsXG4gICAgZGVsdGFZOiAwLFxuICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgIGV2ZW50OiB1bmRlZmluZWQsXG4gICAgZGF0YTogdW5kZWZpbmVkLFxuICB9O1xuICBjb25zdCBwYW4gPSBjcmVhdGVQYW5SZWNvZ25pemVyKGZpbmFsQ29uZmlnLmRpcmVjdGlvbiwgZmluYWxDb25maWcudGhyZXNob2xkLCBmaW5hbENvbmZpZy5tYXhBbmdsZSk7XG4gIGNvbnN0IGdlc3R1cmUgPSBHRVNUVVJFX0NPTlRST0xMRVIuY3JlYXRlR2VzdHVyZSh7XG4gICAgbmFtZTogY29uZmlnLmdlc3R1cmVOYW1lLFxuICAgIHByaW9yaXR5OiBjb25maWcuZ2VzdHVyZVByaW9yaXR5LFxuICAgIGRpc2FibGVTY3JvbGw6IGNvbmZpZy5kaXNhYmxlU2Nyb2xsLFxuICB9KTtcbiAgY29uc3QgcG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICBjb25zdCB0aW1lU3RhbXAgPSBub3coZXYpO1xuICAgIGlmIChoYXNTdGFydGVkUGFuIHx8ICFoYXNGaXJlZFN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZURldGFpbChldiwgZGV0YWlsKTtcbiAgICBkZXRhaWwuc3RhcnRYID0gZGV0YWlsLmN1cnJlbnRYO1xuICAgIGRldGFpbC5zdGFydFkgPSBkZXRhaWwuY3VycmVudFk7XG4gICAgZGV0YWlsLnN0YXJ0VGltZSA9IGRldGFpbC5jdXJyZW50VGltZSA9IHRpbWVTdGFtcDtcbiAgICBkZXRhaWwudmVsb2NpdHlYID0gZGV0YWlsLnZlbG9jaXR5WSA9IGRldGFpbC5kZWx0YVggPSBkZXRhaWwuZGVsdGFZID0gMDtcbiAgICBkZXRhaWwuZXZlbnQgPSBldjtcbiAgICAvLyBDaGVjayBpZiBnZXN0dXJlIGNhbiBzdGFydFxuICAgIGlmIChjYW5TdGFydCAmJiBjYW5TdGFydChkZXRhaWwpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBSZWxlYXNlIGZhbGxiYWNrXG4gICAgZ2VzdHVyZS5yZWxlYXNlKCk7XG4gICAgLy8gU3RhcnQgZ2VzdHVyZVxuICAgIGlmICghZ2VzdHVyZS5zdGFydCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc1N0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgIGlmICh0aHJlc2hvbGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnlUb0NhcHR1cmVQYW4oKTtcbiAgICB9XG4gICAgcGFuLnN0YXJ0KGRldGFpbC5zdGFydFgsIGRldGFpbC5zdGFydFkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBwb2ludGVyTW92ZSA9IChldikgPT4ge1xuICAgIC8vIGZhc3QgcGF0aCwgaWYgZ2VzdHVyZSBpcyBjdXJyZW50bHkgY2FwdHVyZWRcbiAgICAvLyBkbyBtaW5pbXVtIGpvYiB0byBnZXQgdXNlci1sYW5kIGV2ZW4gZGlzcGF0Y2hlZFxuICAgIGlmIChoYXNDYXB0dXJlZFBhbikge1xuICAgICAgaWYgKCFpc01vdmVRdWV1ZWQgJiYgaGFzRmlyZWRTdGFydCkge1xuICAgICAgICBpc01vdmVRdWV1ZWQgPSB0cnVlO1xuICAgICAgICBjYWxjR2VzdHVyZURhdGEoZGV0YWlsLCBldik7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmaXJlT25Nb3ZlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZ2VzdHVyZSBpcyBjdXJyZW50bHkgYmVpbmcgZGV0ZWN0ZWRcbiAgICBjYWxjR2VzdHVyZURhdGEoZGV0YWlsLCBldik7XG4gICAgaWYgKHBhbi5kZXRlY3QoZGV0YWlsLmN1cnJlbnRYLCBkZXRhaWwuY3VycmVudFkpKSB7XG4gICAgICBpZiAoIXBhbi5pc0dlc3R1cmUoKSB8fCAhdHJ5VG9DYXB0dXJlUGFuKCkpIHtcbiAgICAgICAgYWJvcnRHZXN0dXJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBmaXJlT25Nb3ZlID0gKCkgPT4ge1xuICAgIC8vIFNpbmNlIGZpcmVPbk1vdmUgaXMgY2FsbGVkIGluc2lkZSBhIFJBRiwgb25FbmQoKSBtaWdodCBiZSBjYWxsZWQsXG4gICAgLy8gd2UgbXVzdCBkb3VibGUgY2hlY2sgaGFzQ2FwdHVyZWRQYW5cbiAgICBpZiAoIWhhc0NhcHR1cmVkUGFuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzTW92ZVF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChvbk1vdmUpIHtcbiAgICAgIG9uTW92ZShkZXRhaWwpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJ5VG9DYXB0dXJlUGFuID0gKCkgPT4ge1xuICAgIGlmIChnZXN0dXJlICYmICFnZXN0dXJlLmNhcHR1cmUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNDYXB0dXJlZFBhbiA9IHRydWU7XG4gICAgaGFzRmlyZWRTdGFydCA9IGZhbHNlO1xuICAgIC8vIHJlc2V0IHN0YXJ0IHBvc2l0aW9uIHNpbmNlIHRoZSByZWFsIHVzZXItbGFuZCBldmVudCBzdGFydHMgaGVyZVxuICAgIC8vIElmIHRoZSBwYW4gZGV0ZWN0b3IgdGhyZXNob2xkIGlzIGJpZywgbm90IHJlc2V0dGluZyB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAvLyB3aWxsIGNhdXNlIGEganVtcCBpbiB0aGUgYW5pbWF0aW9uIGVxdWFsIHRvIHRoZSBkZXRlY3RvciB0aHJlc2hvbGQuXG4gICAgLy8gdGhlIGFycmF5IG9mIHBvc2l0aW9ucyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgZ2VzdHVyZSB2ZWxvY2l0eSBkb2VzIG5vdFxuICAgIC8vIG5lZWQgdG8gYmUgY2xlYW5lZCwgbW9yZSBwb2ludHMgaW4gdGhlIHBvc2l0aW9ucyBhcnJheSBhbHdheXMgcmVzdWx0cyBpbiBhXG4gICAgLy8gbW9yZSBhY2N1cmF0ZSB2YWx1ZSBvZiB0aGUgdmVsb2NpdHkuXG4gICAgZGV0YWlsLnN0YXJ0WCA9IGRldGFpbC5jdXJyZW50WDtcbiAgICBkZXRhaWwuc3RhcnRZID0gZGV0YWlsLmN1cnJlbnRZO1xuICAgIGRldGFpbC5zdGFydFRpbWUgPSBkZXRhaWwuY3VycmVudFRpbWU7XG4gICAgaWYgKG9uV2lsbFN0YXJ0KSB7XG4gICAgICBvbldpbGxTdGFydChkZXRhaWwpLnRoZW4oZmlyZU9uU3RhcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZpcmVPblN0YXJ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCBibHVyQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFbGVtZW50LmJsdXIpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBmaXJlT25TdGFydCA9ICgpID0+IHtcbiAgICBpZiAoYmx1ck9uU3RhcnQpIHtcbiAgICAgIGJsdXJBY3RpdmVFbGVtZW50KCk7XG4gICAgfVxuICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICBvblN0YXJ0KGRldGFpbCk7XG4gICAgfVxuICAgIGhhc0ZpcmVkU3RhcnQgPSB0cnVlO1xuICB9O1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBoYXNDYXB0dXJlZFBhbiA9IGZhbHNlO1xuICAgIGhhc1N0YXJ0ZWRQYW4gPSBmYWxzZTtcbiAgICBpc01vdmVRdWV1ZWQgPSBmYWxzZTtcbiAgICBoYXNGaXJlZFN0YXJ0ID0gdHJ1ZTtcbiAgICBnZXN0dXJlLnJlbGVhc2UoKTtcbiAgfTtcbiAgLy8gRU5EICoqKioqKioqKioqKioqKioqKioqKioqKipcbiAgY29uc3QgcG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgY29uc3QgdG1wSGFzQ2FwdHVyZWQgPSBoYXNDYXB0dXJlZFBhbjtcbiAgICBjb25zdCB0bXBIYXNGaXJlZFN0YXJ0ID0gaGFzRmlyZWRTdGFydDtcbiAgICByZXNldCgpO1xuICAgIGlmICghdG1wSGFzRmlyZWRTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxjR2VzdHVyZURhdGEoZGV0YWlsLCBldik7XG4gICAgLy8gVHJ5IHRvIGNhcHR1cmUgcHJlc3NcbiAgICBpZiAodG1wSGFzQ2FwdHVyZWQpIHtcbiAgICAgIGlmIChvbkVuZCkge1xuICAgICAgICBvbkVuZChkZXRhaWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOb3QgY2FwdHVyZWQgYW55IGV2ZW50XG4gICAgaWYgKG5vdENhcHR1cmVkKSB7XG4gICAgICBub3RDYXB0dXJlZChkZXRhaWwpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMoZmluYWxDb25maWcuZWwsIHBvaW50ZXJEb3duLCBwb2ludGVyTW92ZSwgcG9pbnRlclVwLCB7XG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgcGFzc2l2ZSxcbiAgfSk7XG4gIGNvbnN0IGFib3J0R2VzdHVyZSA9ICgpID0+IHtcbiAgICByZXNldCgpO1xuICAgIHBvaW50ZXJFdmVudHMuc3RvcCgpO1xuICAgIGlmIChub3RDYXB0dXJlZCkge1xuICAgICAgbm90Q2FwdHVyZWQoZGV0YWlsKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgZW5hYmxlKGVuYWJsZSA9IHRydWUpIHtcbiAgICAgIGlmICghZW5hYmxlKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZFBhbikge1xuICAgICAgICAgIHBvaW50ZXJVcCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICB9XG4gICAgICBwb2ludGVyRXZlbnRzLmVuYWJsZShlbmFibGUpO1xuICAgIH0sXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGdlc3R1cmUuZGVzdHJveSgpO1xuICAgICAgcG9pbnRlckV2ZW50cy5kZXN0cm95KCk7XG4gICAgfSxcbiAgfTtcbn07XG5jb25zdCBjYWxjR2VzdHVyZURhdGEgPSAoZGV0YWlsLCBldikgPT4ge1xuICBpZiAoIWV2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByZXZYID0gZGV0YWlsLmN1cnJlbnRYO1xuICBjb25zdCBwcmV2WSA9IGRldGFpbC5jdXJyZW50WTtcbiAgY29uc3QgcHJldlQgPSBkZXRhaWwuY3VycmVudFRpbWU7XG4gIHVwZGF0ZURldGFpbChldiwgZGV0YWlsKTtcbiAgY29uc3QgY3VycmVudFggPSBkZXRhaWwuY3VycmVudFg7XG4gIGNvbnN0IGN1cnJlbnRZID0gZGV0YWlsLmN1cnJlbnRZO1xuICBjb25zdCB0aW1lc3RhbXAgPSAoZGV0YWlsLmN1cnJlbnRUaW1lID0gbm93KGV2KSk7XG4gIGNvbnN0IHRpbWVEZWx0YSA9IHRpbWVzdGFtcCAtIHByZXZUO1xuICBpZiAodGltZURlbHRhID4gMCAmJiB0aW1lRGVsdGEgPCAxMDApIHtcbiAgICBjb25zdCB2ZWxvY2l0eVggPSAoY3VycmVudFggLSBwcmV2WCkgLyB0aW1lRGVsdGE7XG4gICAgY29uc3QgdmVsb2NpdHlZID0gKGN1cnJlbnRZIC0gcHJldlkpIC8gdGltZURlbHRhO1xuICAgIGRldGFpbC52ZWxvY2l0eVggPSB2ZWxvY2l0eVggKiAwLjcgKyBkZXRhaWwudmVsb2NpdHlYICogMC4zO1xuICAgIGRldGFpbC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVkgKiAwLjcgKyBkZXRhaWwudmVsb2NpdHlZICogMC4zO1xuICB9XG4gIGRldGFpbC5kZWx0YVggPSBjdXJyZW50WCAtIGRldGFpbC5zdGFydFg7XG4gIGRldGFpbC5kZWx0YVkgPSBjdXJyZW50WSAtIGRldGFpbC5zdGFydFk7XG4gIGRldGFpbC5ldmVudCA9IGV2O1xufTtcbmNvbnN0IHVwZGF0ZURldGFpbCA9IChldiwgZGV0YWlsKSA9PiB7XG4gIC8vIGdldCBYIGNvb3JkaW5hdGVzIGZvciBlaXRoZXIgYSBtb3VzZSBjbGlja1xuICAvLyBvciBhIHRvdWNoIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gZXZlbnRcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChldikge1xuICAgIGNvbnN0IGNoYW5nZWRUb3VjaGVzID0gZXYuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgIHkgPSB0b3VjaC5jbGllbnRZO1xuICAgIH1cbiAgICBlbHNlIGlmIChldi5wYWdlWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gZXYucGFnZVg7XG4gICAgICB5ID0gZXYucGFnZVk7XG4gICAgfVxuICB9XG4gIGRldGFpbC5jdXJyZW50WCA9IHg7XG4gIGRldGFpbC5jdXJyZW50WSA9IHk7XG59O1xuY29uc3Qgbm93ID0gKGV2KSA9PiB7XG4gIHJldHVybiBldi50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUdlc3R1cmUgfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyBqIGFzIGNsYW1wIH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGkgYXMgaXNSVEwgfSBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVHZXN0dXJlIH0gZnJvbSAnLi9pbmRleDIuanMnO1xuXG5jb25zdCBjcmVhdGVTd2lwZUJhY2tHZXN0dXJlID0gKGVsLCBjYW5TdGFydEhhbmRsZXIsIG9uU3RhcnRIYW5kbGVyLCBvbk1vdmVIYW5kbGVyLCBvbkVuZEhhbmRsZXIpID0+IHtcbiAgY29uc3Qgd2luID0gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY29uc3QgcnRsID0gaXNSVEwoZWwpO1xuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgZ2VzdHVyZSBpcyBuZWFyIHRoZSBlZGdlXG4gICAqIG9mIHRoZSBzY3JlZW4uIElmIHRydWUsIHRoZW4gdGhlIHN3aXBlXG4gICAqIHRvIGdvIGJhY2sgZ2VzdHVyZSBzaG91bGQgcHJvY2VlZC5cbiAgICovXG4gIGNvbnN0IGlzQXRFZGdlID0gKGRldGFpbCkgPT4ge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDUwO1xuICAgIGNvbnN0IHsgc3RhcnRYIH0gPSBkZXRhaWw7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgcmV0dXJuIHN0YXJ0WCA+PSB3aW4uaW5uZXJXaWR0aCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0WCA8PSB0aHJlc2hvbGQ7XG4gIH07XG4gIGNvbnN0IGdldERlbHRhWCA9IChkZXRhaWwpID0+IHtcbiAgICByZXR1cm4gcnRsID8gLWRldGFpbC5kZWx0YVggOiBkZXRhaWwuZGVsdGFYO1xuICB9O1xuICBjb25zdCBnZXRWZWxvY2l0eVggPSAoZGV0YWlsKSA9PiB7XG4gICAgcmV0dXJuIHJ0bCA/IC1kZXRhaWwudmVsb2NpdHlYIDogZGV0YWlsLnZlbG9jaXR5WDtcbiAgfTtcbiAgY29uc3QgY2FuU3RhcnQgPSAoZGV0YWlsKSA9PiB7XG4gICAgcmV0dXJuIGlzQXRFZGdlKGRldGFpbCkgJiYgY2FuU3RhcnRIYW5kbGVyKCk7XG4gIH07XG4gIGNvbnN0IG9uTW92ZSA9IChkZXRhaWwpID0+IHtcbiAgICAvLyBzZXQgdGhlIHRyYW5zaXRpb24gYW5pbWF0aW9uJ3MgcHJvZ3Jlc3NcbiAgICBjb25zdCBkZWx0YSA9IGdldERlbHRhWChkZXRhaWwpO1xuICAgIGNvbnN0IHN0ZXBWYWx1ZSA9IGRlbHRhIC8gd2luLmlubmVyV2lkdGg7XG4gICAgb25Nb3ZlSGFuZGxlcihzdGVwVmFsdWUpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChkZXRhaWwpID0+IHtcbiAgICAvLyB0aGUgc3dpcGUgYmFjayBnZXN0dXJlIGhhcyBlbmRlZFxuICAgIGNvbnN0IGRlbHRhID0gZ2V0RGVsdGFYKGRldGFpbCk7XG4gICAgY29uc3Qgd2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgICBjb25zdCBzdGVwVmFsdWUgPSBkZWx0YSAvIHdpZHRoO1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gZ2V0VmVsb2NpdHlYKGRldGFpbCk7XG4gICAgY29uc3QgeiA9IHdpZHRoIC8gMi4wO1xuICAgIGNvbnN0IHNob3VsZENvbXBsZXRlID0gdmVsb2NpdHkgPj0gMCAmJiAodmVsb2NpdHkgPiAwLjIgfHwgZGVsdGEgPiB6KTtcbiAgICBjb25zdCBtaXNzaW5nID0gc2hvdWxkQ29tcGxldGUgPyAxIC0gc3RlcFZhbHVlIDogc3RlcFZhbHVlO1xuICAgIGNvbnN0IG1pc3NpbmdEaXN0YW5jZSA9IG1pc3NpbmcgKiB3aWR0aDtcbiAgICBsZXQgcmVhbER1ciA9IDA7XG4gICAgaWYgKG1pc3NpbmdEaXN0YW5jZSA+IDUpIHtcbiAgICAgIGNvbnN0IGR1ciA9IG1pc3NpbmdEaXN0YW5jZSAvIE1hdGguYWJzKHZlbG9jaXR5KTtcbiAgICAgIHJlYWxEdXIgPSBNYXRoLm1pbihkdXIsIDU0MCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IHN0ZXBWYWx1ZSBjYW4gc29tZXRpbWVzIHJldHVybiBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiBvciB2YWx1ZXMgZ3JlYXRlciB0aGFuIDEgd2hpY2ggc2hvdWxkIG5vdCBiZSBwb3NzaWJsZS5cbiAgICAgKiBOZWVkIHRvIGludmVzdGlnYXRlIG1vcmUgdG8gZmluZCB3aGVyZSB0aGUgaXNzdWUgaXMuXG4gICAgICovXG4gICAgb25FbmRIYW5kbGVyKHNob3VsZENvbXBsZXRlLCBzdGVwVmFsdWUgPD0gMCA/IDAuMDEgOiBjbGFtcCgwLCBzdGVwVmFsdWUsIDAuOTk5OSksIHJlYWxEdXIpO1xuICB9O1xuICByZXR1cm4gY3JlYXRlR2VzdHVyZSh7XG4gICAgZWwsXG4gICAgZ2VzdHVyZU5hbWU6ICdnb2JhY2stc3dpcGUnLFxuICAgIGdlc3R1cmVQcmlvcml0eTogNDAsXG4gICAgdGhyZXNob2xkOiAxMCxcbiAgICBjYW5TdGFydCxcbiAgICBvblN0YXJ0OiBvblN0YXJ0SGFuZGxlcixcbiAgICBvbk1vdmUsXG4gICAgb25FbmQsXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3dpcGVCYWNrR2VzdHVyZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86167\n")}}]);